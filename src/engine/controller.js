
import { PubSub } from "../utils/pubSub.js";
import { engineStatus } from "../stores/common.js";
/**
 * The Controller is a singleton class that encapsulates signal engine (sema-engine)
 * and implements the dependency inversion principle
 * @class AudioEngine
 */
export default class Controller {
	/**
	 * @constructor
	 */
	constructor(engine) {
		if (Controller.instance) {
			return Controller.instance // Singleton pattern, only one instance in sema
		}
		Controller.instance = this

		// Constructor dependency injection of a sema-engine singleton instance
		this.engine = engine
    this.initializing = false
		this.samplesLoaded = false
    this.isStopped = false
	}

	/**
	 * Handler of the Pub/Sub message events
	 * whose topics are subscribed to in the audio engine constructor
	 * @onMessagingEventHandler
	 */
	onMessagingEventHandler(event) {
		if (event !== undefined) {
			// Receive notification from "model-output-data" topic
			console.log('DEBUG:AudioEngine:onMessagingEventHandler:')
			console.log(event)
			this.audioWorkletNode.port.postMessage(event)
		}
	}

	/**
	 * Handler of audio worklet processor events
	 * @onProcessorAsyncMessageHandler
	 * @param event
	 */
	onProcessorAsyncMessage(event) {
		if (event !== undefined && event.data !== undefined) {
			// console.log('DEBUG:AudioEngine:processorMessageHandler:');
			// console.log(event);
			// if (event.data.rq !== undefined && event.data.rq === "send") {
			// 	switch (event.data.ttype) {
			// 		case "ML":
			// 			// Stream generated by 'toJS' live code instruction — e.g. {10,0,{1}sin}toJS;
			// 			// publishes to model/JS editor, which posts to ml.worker
			// 			this.messaging.publish("model-input-data", {
			// 				type: "model-input-data",
			// 				value: event.data.value,
			// 				ch: event.data.ch,
			// 			});
			// 			break;
			// 		case "NET":
			// 			this.peerNet.send(
			// 				event.data.ch[0],
			// 				event.data.value,
			// 				event.data.ch[1]
			// 			);
			// 			break;
			// 	}
			// }
			//  else if (event.data.rq && event.data.rq === "buf") {
			// 	console.log("buf", event.data);
			// 	switch (event.data.ttype) {
			// 		case "ML":
			// 			this.messaging.publish("model-input-buffer", {
			// 				type: "model-input-buffer",
			// 				value: event.data.value,
			// 				channelID: event.data.channelID, //channel ID
			// 				blocksize: event.data.blocksize,
			// 			});
			// 			break;
			// 	}
			// }
			// else if (event.data.phase !== undefined) {
			// console.log('DEBUG:AudioEngine:phase:');
			// console.log(event.data.phase);
			// this.kuraClock.broadcastPhase(event.data.phase); // TODO Refactor p to phase
			// }
			// else if (event.data.rq != undefined && event.data.rq === 'receive') {
			//   switch (event.data.ttype) {
			//     case 'ML':
			//       // Stream generated by 'fromJS' live code instruction – e.g. {{10,1}fromJS}saw
			//       // publishes to model/JS editor, which posts to ml.worker
			//       this.messaging.publish('model-output-data-request', {
			//         type: 'model-output-data-request',
			//         value: event.data.value,
			//         channel: event.data.ch
			//       });
			//       break;
			//     case 'NET':
			//       break;
			//   }
			// }
		}
	}

	/**
	 * Initialises audio context and sets worklet processor code
	 * @init
	 * @param audioworletURL
	 * TODO removing numClockPeers, should be added to a specialised function
	 */
	async init(audioWorkletURL) {
		if (this.engine) {
			try {
        this.initializing = true;
				await this.engine.init(audioWorkletURL)

				// Subscribe async messages from the Audio Worklet Processor scope
				// this.engine.subscribeAsyncMessage(this.onProcessorAsyncMessage)
				// const channelId = 'mxy',
				// 	ttype = 'mouseXY',
				// 	blockSize = 2

				// // Create SharedArrayBuffer for mouse data
				// this.engine.createSharedBuffer(channelId, ttype, blockSize)

				// Lazy load all samples imported from assets

				// this.samplesLoaded = await this.importSamples()
				this.samplesLoaded = await this.importSamplesAsync()

				console.log('samples loaded')

				// Connect Analysers loaded from the store need to pass callbacks after they load
				// this.engine.connectAnalysers()

        this.initializing = false;
				// Change engine status on settings bar
				engineStatus.set('running')

			} catch (error) {
				console.error('Error initialising engine', error)
			}
		}
	}

	async stop() {
		if (this.engine && !this.engine.isHushed) {
			await this.engine.hush()
			engineStatus.set('paused')
		}
	}

	onAudioInputFail(error) {
		console.error(
			`Engine Controller: AudioInputFail – ${error.message} ${error.name}`
		)
	}

	/**
	 * Sets up an AudioIn WAAPI sub-graph
	 * @connectMediaStreamSourceInput
	 */
	async connectMediaStream() {
		const constraints = (window.constraints = {
			audio: true,
			video: false,
		})

		navigator.mediaDevices
			.getUserMedia(constraints)
			.then((s) => this.onAudioInputInit(s))
			.catch(this.onAudioInputFail)
	}

	/**
	 * ! Deprecated until I have time to make a Rollup plugin
	 * @returns list of all imports from a folder specified by context
	 */
	getSamplesNames() {
		const r = require.context('../../assets/samples', false, /\.wav$/)

		// return an array list of filenames (with extension)
		const importAll = (r) => r.keys().map((file) => file.match(/[^\/]+$/)[0])

		return importAll(r)
	}


	// async importSamples(){

	// 	await new Promise(async (resolve, reject) => {
	// 		// let sampleCounter = sampleList.length;
	// 		let sampleCounter = 11;
	// 		// await import(`../../assets/samples/909.wav`) // need to use the samples relative path to the src, not in public,
	// 			// .then((e) => {
	// 			try {
	// 				this.engine.loadSample('909', `909.wav`)
	// 				// if (--sampleCounter <= 0) resolve(true)
	// 				// console.log(`loading sample: ${e.default}`)
	// 			}
	// 			catch(err) {
	// 				console.error(`Error Engine lazy loading sample: ${err}`)
	// 				reject(err)
	// 			}

	// 	})
	// }

	async importSample(path){
		// e.g `../../assets/samples/909.wav`
		await import(path) // need to use he samples relative path to the src, not in public,
			.then((e) => {
				this.engine.loadSample(e.default, `./${e.default}`)
				if (--sampleCounter <= 0) resolve(true)
				console.log(`loading sample: ${e.default}`)
			})
			.catch((err) => {
				console.error(`Error Engine lazy loading sample: ${err}`)
				reject(err)
			})
  }

	/**
	 *
	 * @returns
	 */
	async importSamplesAsync(sampleList) {
		return await new Promise(async (resolve, reject) => {
			// let sampleCounter = sampleList.length;
			let sampleCounter = 11;

			await import(`../../assets/samples/909.wav`) // need to use the samples relative path to the src, not in public,
				.then((e) => {
					this.engine.loadSample(e.default, `./${e.default}`)
					if (--sampleCounter <= 0) resolve(true)
					console.log(`loading sample: ${e.default}`)
				})
				.catch((err) => {
					console.error(`Error Engine lazy loading sample: ${err}`)
					reject(err)
				})
			// sampleCounter++;

			await import(`../../assets/samples/909b.wav`) // need to use the samples relative path to the src, not in public,
				.then((e) => {
					this.engine.loadSample(e.default, `./${e.default}`)
					if (--sampleCounter <= 0) resolve(true)
					console.log(`loading sample: ${e.default}`)
				})
				.catch((err) => {
					console.error(`Error Engine lazy loading sample: ${err}`)
					reject(err)
				})
			// sampleCounter++;

			await import(`../../assets/samples/909closed.wav`) // need to use the samples relative path to the src, not in public,
				.then((e) => {
					this.engine.loadSample(e.default, `./${e.default}`)
					if (--sampleCounter <= 0) resolve(true)
					console.log(`loading sample: ${e.default}`)
				})
				.catch((err) => {
					console.error(`Error Engine lazy loading sample: ${err}`)
					reject(err)
				})
			// sampleCounter++;

			await import(`../../assets/samples/909open.wav`) // need to use the samples relative path to the src, not in public,
				.then((e) => {
					this.engine.loadSample(e.default, `./${e.default}`)
					if (--sampleCounter <= 0) resolve(true)
					console.log(`loading sample: ${e.default}`)
				})
				.catch((err) => {
					console.error(`Error Engine lazy loading sample: ${err}`)
					reject(err)
				})
			// sampleCounter++;

			await import(`../../assets/samples/click.wav`) // need to use the samples relative path to the src, not in public,
				.then((e) => {
					this.engine.loadSample(e.default, `./${e.default}`)
					if (--sampleCounter <= 0) resolve(true)
					console.log(`loading sample: ${e.default}`)
				})
				.catch((err) => {
					console.error(`Error Engine lazy loading sample: ${err}`)
					reject(err)
				})

			await import(`../../assets/samples/spade.wav`) // need to use the samples relative path to the src, not in public,
				.then((e) => {
					this.engine.loadSample(e.default, `./${e.default}`)
					if (--sampleCounter <= 0) resolve(true)
					console.log(`loading sample: ${e.default}`)
				})
				.catch((err) => {
					console.error(`Error Engine lazy loading sample: ${err}`)
					reject(err)
				})

			await import(`../../assets/samples/boom2.wav`) // need to use the samples relative path to the src, not in public,
				.then((e) => {
					this.engine.loadSample(e.default, `./${e.default}`)
					if (--sampleCounter <= 0) resolve(true)
					console.log(`loading sample: ${e.default}`)
				})
				.catch((err) => {
					console.error(`Error Engine lazy loading sample: ${err}`)
					reject(err)
				})

			await import(`../../assets/samples/boom.wav`) // need to use the samples relative path to the src, not in public,
				.then((e) => {
					this.engine.loadSample(e.default, `./${e.default}`)
					if (--sampleCounter <= 0) resolve(true)
					console.log(`loading sample: ${e.default}`)
				})
				.catch((err) => {
					console.error(`Error Engine lazy loading sample: ${err}`)
					reject(err)
				})

			await import(`../../assets/samples/machine.wav`) // need to use the samples relative path to the src, not in public,
				.then((e) => {
					this.engine.loadSample(e.default, `./${e.default}`)
					if (--sampleCounter <= 0) resolve(true)
					console.log(`loading sample: ${e.default}`)
				})
				.catch((err) => {
					console.error(`Error Engine lazy loading sample: ${err}`)
					reject(err)
				})

			await import(`../../assets/samples/patterndrone2.wav`) // need to use the samples relative path to the src, not in public,
				.then((e) => {
					this.engine.loadSample(e.default, `./${e.default}`)
					if (--sampleCounter <= 0) resolve(true)
					console.log(`loading sample: ${e.default}`)
				})
				.catch((err) => {
					console.error(`Error Engine lazy loading sample: ${err}`)
					reject(err)
				})

			await import(`../../assets/samples/convol5.wav`) // need to use the samples relative path to the src, not in public,
				.then((e) => {
					this.engine.loadSample(e.default, `./${e.default}`)
					if (--sampleCounter <= 0) resolve(true)
					console.log(`loading sample: ${e.default}`)
				})
				.catch((err) => {
					console.error(`Error Engine lazy loading sample: ${err}`)
					reject(err)
				})

			// sampleCounter++;
		})
	}
}
