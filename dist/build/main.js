
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; r.crossOrigin='anonymous'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
/**
 * mounts app to target element 
 *
 * @export
 * @param {object} Component Svelte component
 * @param {object} [options={ target: document.body }] Options for the Svelte component
 * @param {string} [id='hmr'] ID for the component container
 * @param {string} [eventName='app-loaded'] Name of the event that triggers replacement of previous component
 * @returns
 */
function HMR(Component, options = { target: document.body }, id = 'hmr', eventName = 'app-loaded') {
    const prerenderedHtmlElement = document.getElementById(id);

    // Create a hidden target element to contain our app
    const target = document.createElement("div");
    target.style.visibility = 'hidden';
    options.target.appendChild(target);

    if (!prerenderedHtmlElement)
        showApp();
    else
        // Wait for the app to load before replacing the prerendered HTML
        addEventListener(eventName, showApp);

    function showApp() {
        removeEventListener(eventName, showApp);
        if (prerenderedHtmlElement) prerenderedHtmlElement.remove();
        // Show our component and take over the ID of the old container
        target.style.visibility = null;
        target.setAttribute('id', id);
    }

    return new Component({ ...options, target });
}

function noop() { }
function assign(tar, src) {
    // @ts-ignore
    for (const k in src)
        tar[k] = src[k];
    return tar;
}
function is_promise(value) {
    return value && typeof value === 'object' && typeof value.then === 'function';
}
function run(fn) {
    return fn();
}
function blank_object() {
    return Object.create(null);
}
function run_all(fns) {
    fns.forEach(run);
}
function is_function(thing) {
    return typeof thing === 'function';
}
function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
}
function is_empty(obj) {
    return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
    if (store == null) {
        return noop;
    }
    const unsub = store.subscribe(...callbacks);
    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
    let value;
    subscribe(store, _ => value = _)();
    return value;
}
function component_subscribe(component, store, callback) {
    component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
    if (definition) {
        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
        return definition[0](slot_ctx);
    }
}
function get_slot_context(definition, ctx, $$scope, fn) {
    return definition[1] && fn
        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
        : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
    if (definition[2] && fn) {
        const lets = definition[2](fn(dirty));
        if ($$scope.dirty === undefined) {
            return lets;
        }
        if (typeof lets === 'object') {
            const merged = [];
            const len = Math.max($$scope.dirty.length, lets.length);
            for (let i = 0; i < len; i += 1) {
                merged[i] = $$scope.dirty[i] | lets[i];
            }
            return merged;
        }
        return $$scope.dirty | lets;
    }
    return $$scope.dirty;
}
function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
    if (slot_changes) {
        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
        slot.p(slot_context, slot_changes);
    }
}
function exclude_internal_props(props) {
    const result = {};
    for (const k in props)
        if (k[0] !== '$')
            result[k] = props[k];
    return result;
}
function null_to_empty(value) {
    return value == null ? '' : value;
}
function set_store_value(store, ret, value = ret) {
    store.set(value);
    return ret;
}
function action_destroyer(action_result) {
    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}

function append(target, node) {
    target.appendChild(node);
}
function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
}
function detach(node) {
    node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
    for (let i = 0; i < iterations.length; i += 1) {
        if (iterations[i])
            iterations[i].d(detaching);
    }
}
function element(name) {
    return document.createElement(name);
}
function svg_element(name) {
    return document.createElementNS('http://www.w3.org/2000/svg', name);
}
function text$1(data) {
    return document.createTextNode(data);
}
function space() {
    return text$1(' ');
}
function empty() {
    return text$1('');
}
function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
    return function (event) {
        event.preventDefault();
        // @ts-ignore
        return fn.call(this, event);
    };
}
function attr(node, attribute, value) {
    if (value == null)
        node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
        node.setAttribute(attribute, value);
}
function children(element) {
    return Array.from(element.childNodes);
}
function set_data(text, data) {
    data = '' + data;
    if (text.wholeText !== data)
        text.data = data;
}
function set_input_value(input, value) {
    input.value = value == null ? '' : value;
}
function set_style(node, key, value, important) {
    node.style.setProperty(key, value, important ? 'important' : '');
}
function select_option(select, value) {
    for (let i = 0; i < select.options.length; i += 1) {
        const option = select.options[i];
        if (option.__value === value) {
            option.selected = true;
            return;
        }
    }
}
function select_value(select) {
    const selected_option = select.querySelector(':checked') || select.options[0];
    return selected_option && selected_option.__value;
}
function toggle_class(element, name, toggle) {
    element.classList[toggle ? 'add' : 'remove'](name);
}
function custom_event(type, detail) {
    const e = document.createEvent('CustomEvent');
    e.initCustomEvent(type, false, false, detail);
    return e;
}

let current_component;
function set_current_component(component) {
    current_component = component;
}
function get_current_component() {
    if (!current_component)
        throw new Error('Function called outside component initialization');
    return current_component;
}
function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
}
function onDestroy(fn) {
    get_current_component().$$.on_destroy.push(fn);
}
function createEventDispatcher() {
    const component = get_current_component();
    return (type, detail) => {
        const callbacks = component.$$.callbacks[type];
        if (callbacks) {
            // TODO are there situations where events could be dispatched
            // in a server (non-DOM) environment?
            const event = custom_event(type, detail);
            callbacks.slice().forEach(fn => {
                fn.call(component, event);
            });
        }
    };
}
function setContext(key, context) {
    get_current_component().$$.context.set(key, context);
}
function getContext(key) {
    return get_current_component().$$.context.get(key);
}

const dirty_components = [];
const binding_callbacks = [];
const render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = Promise.resolve();
let update_scheduled = false;
function schedule_update() {
    if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
    }
}
function tick() {
    schedule_update();
    return resolved_promise;
}
function add_render_callback(fn) {
    render_callbacks.push(fn);
}
function add_flush_callback(fn) {
    flush_callbacks.push(fn);
}
let flushing = false;
const seen_callbacks = new Set();
function flush() {
    if (flushing)
        return;
    flushing = true;
    do {
        // first, call beforeUpdate functions
        // and update components
        for (let i = 0; i < dirty_components.length; i += 1) {
            const component = dirty_components[i];
            set_current_component(component);
            update(component.$$);
        }
        set_current_component(null);
        dirty_components.length = 0;
        while (binding_callbacks.length)
            binding_callbacks.pop()();
        // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...
        for (let i = 0; i < render_callbacks.length; i += 1) {
            const callback = render_callbacks[i];
            if (!seen_callbacks.has(callback)) {
                // ...so guard against infinite loops
                seen_callbacks.add(callback);
                callback();
            }
        }
        render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
        flush_callbacks.pop()();
    }
    update_scheduled = false;
    flushing = false;
    seen_callbacks.clear();
}
function update($$) {
    if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
    }
}
const outroing = new Set();
let outros;
function group_outros() {
    outros = {
        r: 0,
        c: [],
        p: outros // parent group
    };
}
function check_outros() {
    if (!outros.r) {
        run_all(outros.c);
    }
    outros = outros.p;
}
function transition_in(block, local) {
    if (block && block.i) {
        outroing.delete(block);
        block.i(local);
    }
}
function transition_out(block, local, detach, callback) {
    if (block && block.o) {
        if (outroing.has(block))
            return;
        outroing.add(block);
        outros.c.push(() => {
            outroing.delete(block);
            if (callback) {
                if (detach)
                    block.d(1);
                callback();
            }
        });
        block.o(local);
    }
}

function handle_promise(promise, info) {
    const token = info.token = {};
    function update(type, index, key, value) {
        if (info.token !== token)
            return;
        info.resolved = value;
        let child_ctx = info.ctx;
        if (key !== undefined) {
            child_ctx = child_ctx.slice();
            child_ctx[key] = value;
        }
        const block = type && (info.current = type)(child_ctx);
        let needs_flush = false;
        if (info.block) {
            if (info.blocks) {
                info.blocks.forEach((block, i) => {
                    if (i !== index && block) {
                        group_outros();
                        transition_out(block, 1, 1, () => {
                            info.blocks[i] = null;
                        });
                        check_outros();
                    }
                });
            }
            else {
                info.block.d(1);
            }
            block.c();
            transition_in(block, 1);
            block.m(info.mount(), info.anchor);
            needs_flush = true;
        }
        info.block = block;
        if (info.blocks)
            info.blocks[index] = block;
        if (needs_flush) {
            flush();
        }
    }
    if (is_promise(promise)) {
        const current_component = get_current_component();
        promise.then(value => {
            set_current_component(current_component);
            update(info.then, 1, info.value, value);
            set_current_component(null);
        }, error => {
            set_current_component(current_component);
            update(info.catch, 2, info.error, error);
            set_current_component(null);
            if (!info.hasCatch) {
                throw error;
            }
        });
        // if we previously had a then/catch block, destroy it
        if (info.current !== info.pending) {
            update(info.pending, 0);
            return true;
        }
    }
    else {
        if (info.current !== info.then) {
            update(info.then, 1, info.value, promise);
            return true;
        }
        info.resolved = promise;
    }
}

const globals = (typeof window !== 'undefined'
    ? window
    : typeof globalThis !== 'undefined'
        ? globalThis
        : global);

function destroy_block(block, lookup) {
    block.d(1);
    lookup.delete(block.key);
}
function outro_and_destroy_block(block, lookup) {
    transition_out(block, 1, 1, () => {
        lookup.delete(block.key);
    });
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
    let o = old_blocks.length;
    let n = list.length;
    let i = o;
    const old_indexes = {};
    while (i--)
        old_indexes[old_blocks[i].key] = i;
    const new_blocks = [];
    const new_lookup = new Map();
    const deltas = new Map();
    i = n;
    while (i--) {
        const child_ctx = get_context(ctx, list, i);
        const key = get_key(child_ctx);
        let block = lookup.get(key);
        if (!block) {
            block = create_each_block(key, child_ctx);
            block.c();
        }
        else if (dynamic) {
            block.p(child_ctx, dirty);
        }
        new_lookup.set(key, new_blocks[i] = block);
        if (key in old_indexes)
            deltas.set(key, Math.abs(i - old_indexes[key]));
    }
    const will_move = new Set();
    const did_move = new Set();
    function insert(block) {
        transition_in(block, 1);
        block.m(node, next);
        lookup.set(block.key, block);
        next = block.first;
        n--;
    }
    while (o && n) {
        const new_block = new_blocks[n - 1];
        const old_block = old_blocks[o - 1];
        const new_key = new_block.key;
        const old_key = old_block.key;
        if (new_block === old_block) {
            // do nothing
            next = new_block.first;
            o--;
            n--;
        }
        else if (!new_lookup.has(old_key)) {
            // remove old block
            destroy(old_block, lookup);
            o--;
        }
        else if (!lookup.has(new_key) || will_move.has(new_key)) {
            insert(new_block);
        }
        else if (did_move.has(old_key)) {
            o--;
        }
        else if (deltas.get(new_key) > deltas.get(old_key)) {
            did_move.add(new_key);
            insert(new_block);
        }
        else {
            will_move.add(old_key);
            o--;
        }
    }
    while (o--) {
        const old_block = old_blocks[o];
        if (!new_lookup.has(old_block.key))
            destroy(old_block, lookup);
    }
    while (n)
        insert(new_blocks[n - 1]);
    return new_blocks;
}

function get_spread_update(levels, updates) {
    const update = {};
    const to_null_out = {};
    const accounted_for = { $$scope: 1 };
    let i = levels.length;
    while (i--) {
        const o = levels[i];
        const n = updates[i];
        if (n) {
            for (const key in o) {
                if (!(key in n))
                    to_null_out[key] = 1;
            }
            for (const key in n) {
                if (!accounted_for[key]) {
                    update[key] = n[key];
                    accounted_for[key] = 1;
                }
            }
            levels[i] = n;
        }
        else {
            for (const key in o) {
                accounted_for[key] = 1;
            }
        }
    }
    for (const key in to_null_out) {
        if (!(key in update))
            update[key] = undefined;
    }
    return update;
}
function get_spread_object(spread_props) {
    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
}

function bind(component, name, callback) {
    const index = component.$$.props[name];
    if (index !== undefined) {
        component.$$.bound[index] = callback;
        callback(component.$$.ctx[index]);
    }
}
function create_component(block) {
    block && block.c();
}
function mount_component(component, target, anchor) {
    const { fragment, on_mount, on_destroy, after_update } = component.$$;
    fragment && fragment.m(target, anchor);
    // onMount happens before the initial afterUpdate
    add_render_callback(() => {
        const new_on_destroy = on_mount.map(run).filter(is_function);
        if (on_destroy) {
            on_destroy.push(...new_on_destroy);
        }
        else {
            // Edge case - component was destroyed immediately,
            // most likely as a result of a binding initialising
            run_all(new_on_destroy);
        }
        component.$$.on_mount = [];
    });
    after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
    }
}
function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
    }
    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
}
function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const prop_values = options.props || {};
    const $$ = component.$$ = {
        fragment: null,
        ctx: null,
        // state
        props,
        update: noop,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        before_update: [],
        after_update: [],
        context: new Map(parent_component ? parent_component.$$.context : []),
        // everything else
        callbacks: blank_object(),
        dirty,
        skip_bound: false
    };
    let ready = false;
    $$.ctx = instance
        ? instance(component, prop_values, (i, ret, ...rest) => {
            const value = rest.length ? rest[0] : ret;
            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                if (!$$.skip_bound && $$.bound[i])
                    $$.bound[i](value);
                if (ready)
                    make_dirty(component, i);
            }
            return ret;
        })
        : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    // `false` as a special case of no DOM component
    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
    if (options.target) {
        if (options.hydrate) {
            const nodes = children(options.target);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.l(nodes);
            nodes.forEach(detach);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.c();
        }
        if (options.intro)
            transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor);
        flush();
    }
    set_current_component(parent_component);
}
/**
 * Base class for Svelte components. Used when dev=false.
 */
class SvelteComponent {
    $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
    }
    $on(type, callback) {
        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
        callbacks.push(callback);
        return () => {
            const index = callbacks.indexOf(callback);
            if (index !== -1)
                callbacks.splice(index, 1);
        };
    }
    $set($$props) {
        if (this.$$set && !is_empty($$props)) {
            this.$$.skip_bound = true;
            this.$$set($$props);
            this.$$.skip_bound = false;
        }
    }
}

var defaultConfig = {
    queryHandler: {
        parse: search => fromEntries(new URLSearchParams(search)),
        stringify: params => '?' + (new URLSearchParams(params)).toString()
    },
    urlTransform: {
        apply: x => x,
        remove: x => x
    },
    useHash: false
};


function fromEntries(iterable) {
    return [...iterable].reduce((obj, [key, val]) => {
        obj[key] = val;
        return obj
    }, {})
}

const MATCH_PARAM = RegExp(/\:([^/()]+)/g);

function handleScroll(element, scrollToTop) {
  if (navigator.userAgent.includes('jsdom')) return false
  if (scrollToTop) scrollAncestorsToTop(element);
  handleHash();
}

function handleHash() {
  if (navigator.userAgent.includes('jsdom')) return false
  const { hash } = window.location;
  if (hash) {
    const validElementIdRegex = /^[A-Za-z]+[\w\-\:\.]*$/;
    if (validElementIdRegex.test(hash.substring(1))) {
      const el = document.querySelector(hash);
      if (el) el.scrollIntoView();
    }
  }
}

function scrollAncestorsToTop(element) {
  if (
    element &&
    element.scrollTo &&
    element.dataset.routify !== 'scroll-lock' &&
    element.dataset['routify-scroll'] !== 'lock'
  ) {
    element.style['scroll-behavior'] = 'auto';
    element.scrollTo({ top: 0, behavior: 'auto' });
    element.style['scroll-behavior'] = '';
    scrollAncestorsToTop(element.parentElement);
  }
}

const pathToRegex = (str, recursive) => {
  const suffix = recursive ? '' : '/?$'; //fallbacks should match recursively
  str = str.replace(/\/_fallback?$/, '(/|$)');
  str = str.replace(/\/index$/, '(/index)?'); //index files should be matched even if not present in url
  str = str.replace(MATCH_PARAM, '([^/]+)') + suffix;
  str = `^${str}`;
  return str
};

const pathToParamKeys = string => {
  const paramsKeys = [];
  let matches;
  while ((matches = MATCH_PARAM.exec(string))) paramsKeys.push(matches[1]);
  return paramsKeys
};

const pathToRank = ({ path }) => {
  return path
    .split('/')
    .filter(Boolean)
    .map(str => (str === '_fallback' ? 'A' : str.startsWith(':') ? 'B' : 'C'))
    .join('')
};

/** Supresses Routify caused logs and warnings for one tick */
function suppressComponentWarnings(ctx, tick) {
  suppressComponentWarnings._console = suppressComponentWarnings._console || { log: console.log, warn: console.warn };
  const { _console } = suppressComponentWarnings;

  const name = ctx.componentFile.name
    .replace(/Proxy<_?(.+)>/, '$1') //nollup wraps names in Proxy<...>
    .replace(/^Index$/, ctx.component.shortPath.split('/').pop()) //nollup names Index.svelte index. We want a real name
    .replace(/^./, s => s.toUpperCase()) //capitalize first letter
    .replace(/\:(.+)/, 'U5B$1u5D'); // :id => U5Bidu5D

  const ignores = [
    `<${name}> received an unexpected slot "default".`,
    `<${name}> was created with unknown prop 'scoped'`,
    `<${name}> was created with unknown prop 'scopedSync'`,
  ];
  for (const log of ['log', 'warn']) {
    console[log] = (...args) => {
      if (!ignores.includes(args[0]))
        _console[log](...args);
    };
    tick().then(() => {
      //after component has been created, we want to restore the console method (log or warn)
      console[log] = _console[log];
    });
  }
}

function currentLocation() {
  let dirtyFullpath = window.location.pathname + window.location.search + window.location.hash;
  const { url, options } = resolvePrefetch(dirtyFullpath);
  const parsedUrl = parseUrl(url);

  return { ...parsedUrl, options }
}

/**
 * converts /path/to__routify_url_options__1234abcde to
 * {options, url: '/path/to'}
 * @param {string} dirtyFullpath 
 */
function resolvePrefetch(dirtyFullpath) {
  const [url, _options] = dirtyFullpath.split('__[[routify_url_options]]__');

  const options = JSON.parse(decodeURIComponent(_options || '') || '{}');

  window.routify = window.routify || {};
  window.routify.prefetched = options.prefetch;

  return { url, options }
}

/**
 * 
 * @param {string} url 
 */
function parseUrl(url) {
  if (defaultConfig.useHash)
    url = url.replace(/.*#(.+)/, '$1');
  const origin = url.startsWith('/') ? window.location.origin : undefined;
  const _url = new URL(url, origin);
  const fullpath = _url.pathname + _url.search + _url.hash;
  return { url: _url, fullpath }
}


/**
 * populates parameters, applies urlTransform, prefixes hash
 * eg. /foo/:bar to /foo/something or #/foo/something
 * and applies config.urlTransform
 * @param {*} path 
 * @param {*} params 
 */
function resolveUrl(path, params, inheritedParams) {
  const hash = defaultConfig.useHash ? '#' : '';
  let url;
  url = populateUrl(path, params, inheritedParams);
  url = defaultConfig.urlTransform.apply(url);
  url = hash + url;
  return url
}


/**
 * populates an url path with parameters
 * populateUrl('/home/:foo', {foo: 'something', bar:'baz'})  to /foo/something?bar=baz
 * @param {*} path 
 * @param {*} params 
 */
function populateUrl(path, params, inheritedParams) {
  const allParams = Object.assign({}, inheritedParams, params);
  const queryString = getQueryString(path, params);

  for (const [key, value] of Object.entries(allParams))
    path = path.replace(`:${key}`, value);

  return `${path}${queryString}`
}


/**
 * 
 * @param {string} path 
 * @param {object} params 
 */
function getQueryString(path, params) {
  if (!defaultConfig.queryHandler) return ""
  const ignoredKeys = pathToParamKeys(path);
  const queryParams = {};
  if (params) Object.entries(params).forEach(([key, value]) => {
    if (!ignoredKeys.includes(key))
      queryParams[key] = value;
  });
  return defaultConfig.queryHandler.stringify(queryParams).replace(/\?$/, '')
}

/* node_modules/@roxi/routify/runtime/decorators/Noop.svelte generated by Svelte v3.31.0 */

function create_fragment(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[2].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[1], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { scoped = {} } = $$props;

	$$self.$$set = $$props => {
		if ("scoped" in $$props) $$invalidate(0, scoped = $$props.scoped);
		if ("$$scope" in $$props) $$invalidate(1, $$scope = $$props.$$scope);
	};

	return [scoped, $$scope, slots];
}

class Noop extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { scoped: 0 });
	}
}

const subscriber_queue = [];
/**
 * Creates a `Readable` store that allows reading by subscription.
 * @param value initial value
 * @param {StartStopNotifier}start start and stop notifications for subscriptions
 */
function readable(value, start) {
    return {
        subscribe: writable(value, start).subscribe
    };
}
/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 * @param {*=}value initial value
 * @param {StartStopNotifier=}start start and stop notifications for subscriptions
 */
function writable(value, start = noop) {
    let stop;
    const subscribers = [];
    function set(new_value) {
        if (safe_not_equal(value, new_value)) {
            value = new_value;
            if (stop) { // store is ready
                const run_queue = !subscriber_queue.length;
                for (let i = 0; i < subscribers.length; i += 1) {
                    const s = subscribers[i];
                    s[1]();
                    subscriber_queue.push(s, value);
                }
                if (run_queue) {
                    for (let i = 0; i < subscriber_queue.length; i += 2) {
                        subscriber_queue[i][0](subscriber_queue[i + 1]);
                    }
                    subscriber_queue.length = 0;
                }
            }
        }
    }
    function update(fn) {
        set(fn(value));
    }
    function subscribe(run, invalidate = noop) {
        const subscriber = [run, invalidate];
        subscribers.push(subscriber);
        if (subscribers.length === 1) {
            stop = start(set) || noop;
        }
        run(value);
        return () => {
            const index = subscribers.indexOf(subscriber);
            if (index !== -1) {
                subscribers.splice(index, 1);
            }
            if (subscribers.length === 0) {
                stop();
                stop = null;
            }
        };
    }
    return { set, update, subscribe };
}
function derived(stores, fn, initial_value) {
    const single = !Array.isArray(stores);
    const stores_array = single
        ? [stores]
        : stores;
    const auto = fn.length < 2;
    return readable(initial_value, (set) => {
        let inited = false;
        const values = [];
        let pending = 0;
        let cleanup = noop;
        const sync = () => {
            if (pending) {
                return;
            }
            cleanup();
            const result = fn(single ? values[0] : values, set);
            if (auto) {
                set(result);
            }
            else {
                cleanup = is_function(result) ? result : noop;
            }
        };
        const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
            values[i] = value;
            pending &= ~(1 << i);
            if (inited) {
                sync();
            }
        }, () => {
            pending |= (1 << i);
        }));
        inited = true;
        sync();
        return function stop() {
            run_all(unsubscribers);
            cleanup();
        };
    });
}

window.routify = window.routify || {};

/** @type {import('svelte/store').Writable<RouteNode>} */
const route = writable(null); // the actual route being rendered

/** @type {import('svelte/store').Writable<RouteNode[]>} */
const routes = writable([]); // all routes
routes.subscribe(routes => (window.routify.routes = routes));

let rootContext = writable({ component: { params: {} } });

/** @type {import('svelte/store').Writable<RouteNode>} */
const urlRoute = writable(null);  // the route matching the url

const isChangingPage = writable(true);

async function onPageLoaded({ page, metatags, afterPageLoad, parentNode }) {
    //scroll needs to run after page load
    const scrollToTop = page.last !== page;
    setTimeout(() => handleScroll(parentNode, scrollToTop));

    const { path } = page;
    const { options } = currentLocation();
    const prefetchId = options.prefetch;

    for (const hook of afterPageLoad._hooks) {
        // deleted/invalidated hooks are left as undefined
        if (hook) await hook(page.api);
    }

    metatags.update();

    dispatchEvent(new CustomEvent('app-loaded'));
    parent.postMessage({
        msg: 'app-loaded',
        prefetched: window.routify.prefetched,
        path,
        prefetchId
    }, "*");
    window['routify'].appLoaded = true;
    window['routify'].stopAutoReady = false;
}

/**
 * @param {string} url 
 * @return {ClientNode}
 */
function urlToRoute(url, clone = false) {
    url = defaultConfig.urlTransform.remove(url);
    let { pathname, search } = parseUrl(url).url;

    /** @type {RouteNode[]} */
    const routes$1 = get_store_value(routes);
    const matchingRoute =
        // find a route with a matching name
        routes$1.find(route => pathname === route.meta.name) ||
        // or a matching path
        routes$1.find(route => pathname.match(route.regex));

    if (!matchingRoute)
        throw new Error(`Route could not be found for "${pathname}".`)

    // we want to clone if we're only previewing an URL
    const _matchingRoute = clone ? Object.create(matchingRoute) : matchingRoute;

    const { route, redirectPath, rewritePath } = resolveRedirects(_matchingRoute, routes$1);

    if (rewritePath) {
        ({ pathname, search } = parseUrl(resolveUrl(rewritePath, route.params)).url);
        if (redirectPath)
            route.redirectTo = resolveUrl(redirectPath, route.params || {});
    }

    if (defaultConfig.queryHandler)
        route.params = Object.assign({}, defaultConfig.queryHandler.parse(search));

    assignParamsToRouteAndLayouts(route, pathname);

    route.leftover = url.replace(new RegExp(route.regex), '');
    return route
}

function assignParamsToRouteAndLayouts(route, pathname) {
    if (route.paramKeys) {
        const layouts = layoutByPos(route.layouts);
        const fragments = pathname.split('/').filter(Boolean);
        const routeProps = getRouteProps(route.path);

        routeProps.forEach((prop, i) => {
            if (prop) {
                route.params[prop] = fragments[i];
                if (layouts[i]) layouts[i].param = { [prop]: fragments[i] };
                else route.param = { [prop]: fragments[i] };
            }
        });
    }
}

/**
 * 
 * @param {RouteNode} route 
 * @param {RouteNode[]} routes 
 * @param {*} params 
 */
function resolveRedirects(route, routes, redirectPath, rewritePath) {
    const { redirect, rewrite } = route.meta;

    if (redirect || rewrite) {
        redirectPath = redirect ? redirect.path || redirect : redirectPath;
        rewritePath = rewrite ? rewrite.path || rewrite : redirectPath;
        const redirectParams = redirect && redirect.params;
        const rewriteParams = rewrite && rewrite.params;

        const newRoute = routes.find(r => r.path === rewritePath);
        if (newRoute === route) console.error(`${rewritePath} is redirecting to itself`);
        if (!newRoute) console.error(`${route.path} is redirecting to non-existent path: ${rewritePath}`);
        if (redirectParams || rewriteParams)
            newRoute.params = Object.assign({}, newRoute.params, redirectParams, rewriteParams);

        return resolveRedirects(newRoute, routes, redirectPath, rewritePath)
    }
    return { route, redirectPath, rewritePath }
}


/**
 * @param {array} layouts
 */
function layoutByPos(layouts) {
    const arr = [];
    layouts.forEach(layout => {
        arr[layout.path.split('/').filter(Boolean).length - 1] = layout;
    });
    return arr
}


/**
 * @param {string} url
 */
function getRouteProps(url) {
    return url
        .split('/')
        .filter(Boolean)
        .map(f => f.match(/\:(.+)/))
        .map(f => f && f[1])
}

/* node_modules/@roxi/routify/runtime/Prefetcher.svelte generated by Svelte v3.31.0 */

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[1] = list[i];
	return child_ctx;
}

// (80:2) {#each $actives as prefetch (prefetch.options.prefetch)}
function create_each_block(key_1, ctx) {
	let iframe;
	let iframe_src_value;

	return {
		key: key_1,
		first: null,
		c() {
			iframe = element("iframe");
			if (iframe.src !== (iframe_src_value = /*prefetch*/ ctx[1].url)) attr(iframe, "src", iframe_src_value);
			attr(iframe, "frameborder", "0");
			attr(iframe, "title", "routify prefetcher");
			this.first = iframe;
		},
		m(target, anchor) {
			insert(target, iframe, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*$actives*/ 1 && iframe.src !== (iframe_src_value = /*prefetch*/ ctx[1].url)) {
				attr(iframe, "src", iframe_src_value);
			}
		},
		d(detaching) {
			if (detaching) detach(iframe);
		}
	};
}

function create_fragment$1(ctx) {
	let div;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_value = /*$actives*/ ctx[0];
	const get_key = ctx => /*prefetch*/ ctx[1].options.prefetch;

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div, "id", "__routify_iframes");
			set_style(div, "display", "none");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*$actives*/ 1) {
				const each_value = /*$actives*/ ctx[0];
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, destroy_block, create_each_block, null, get_each_context);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};
}

const iframeNum = 2;

/** stores and subscriptions */
const queue = writable([]);

const actives = derived(queue, q => q.slice(0, iframeNum));

actives.subscribe(actives => actives.forEach(({ options }) => {
	setTimeout(() => removeFromQueue(options.prefetch), options.timeout);
}));

/**
 * @param {number|MessageEvent} idOrEvent
 */
function removeFromQueue(idOrEvent) {
	const id = idOrEvent.data ? idOrEvent.data.prefetchId : idOrEvent;
	if (!id) return null;
	const entry = get_store_value(queue).find(entry => entry && entry.options.prefetch == id);

	// removeFromQueue is called by both eventListener and timeout,
	// but we can only remove the item once
	if (entry) {
		const { gracePeriod } = entry.options;
		const gracePromise = new Promise(resolve => setTimeout(resolve, gracePeriod));

		const idlePromise = new Promise(resolve => {
				window.requestIdleCallback
				? window.requestIdleCallback(resolve)
				: setTimeout(resolve, gracePeriod + 1000);
			});

		Promise.all([gracePromise, idlePromise]).then(() => {
			queue.update(q => q.filter(q => q.options.prefetch != id));
		});
	}
}

// Listen to message from child window
addEventListener("message", removeFromQueue, false);

function instance$1($$self, $$props, $$invalidate) {
	let $actives;
	component_subscribe($$self, actives, $$value => $$invalidate(0, $actives = $$value));
	return [$actives];
}

class Prefetcher extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});
	}
}

/// <reference path="../typedef.js" />

/** @ts-check */
/**
 * @typedef {Object} RoutifyContext
 * @prop {ClientNode} component
 * @prop {ClientNode} layout
 * @prop {any} componentFile 
 * 
 *  @returns {import('svelte/store').Readable<RoutifyContext>} */
function getRoutifyContext() {
  return getContext('routify') || rootContext
}

/**
 * @typedef {function():void} ReadyHelper
 * @typedef {import('svelte/store').Readable<ReadyHelper>} ReadyHelperStore
 * @type {ReadyHelperStore}
*/
const ready = {
  subscribe(run) {
    window['routify'].stopAutoReady = true;
    async function ready() {
      await tick();
      await onPageLoaded({ page: get_store_value(route), metatags, afterPageLoad });
    }
    run(ready);
    return () => { }
  }
};

/**
 * @callback AfterPageLoadHelper
 * @param {function} callback
 * 
 * @typedef {import('svelte/store').Readable<AfterPageLoadHelper> & {_hooks:Array<function>}} AfterPageLoadHelperStore
 * @type {AfterPageLoadHelperStore}
 */
const afterPageLoad = {
  _hooks: [
    event => isChangingPage.set(false)
  ],
  subscribe: hookHandler
};

/** 
 * @callback BeforeUrlChangeHelper
 * @param {function} callback
 *
 * @typedef {import('svelte/store').Readable<BeforeUrlChangeHelper> & {_hooks:Array<function>}} BeforeUrlChangeHelperStore
 * @type {BeforeUrlChangeHelperStore}
 **/
const beforeUrlChange = {
  _hooks: [],
  subscribe: hookHandler
};

function hookHandler(listener) {
  const hooks = this._hooks;
  const index = hooks.length;
  listener(callback => { hooks[index] = callback; });
  return (...params) => {
    delete hooks[index];
    listener(...params);
  }
}

/**
 * We have to grab params and leftover from the context and not directly from the store.
 * Otherwise the context is updated before the component is destroyed. * 
 * @typedef {Object.<string, *>} ParamsHelper
 * @typedef {import('svelte/store').Readable<ParamsHelper>} ParamsHelperStore
 * @type {ParamsHelperStore}
 **/
const params = {
  subscribe(run) {
    const ctx = getRoutifyContext();
    return derived(ctx, ctx => ctx.route.params).subscribe(run)
  }
};

/**
 * @callback UrlHelper
 * @param {String=} path
 * @param {UrlParams=} params
 * @param {UrlOptions=} options
 * @return {String}
 *
 * @typedef {import('svelte/store').Readable<UrlHelper>} UrlHelperStore
 * @type {UrlHelperStore} 
 * */
const url = {
  subscribe(listener) {
    const ctx = getRoutifyContext();
    const { route, routes } = get_store_value(ctx);
    return derived(
      ctx,
      ctx => makeUrlHelper(ctx, route, routes)
    ).subscribe(
      listener
    )
  }
};

/** 
 * @param {{component: ClientNode}} $ctx 
 * @param {RouteNode} $currentRoute 
 * @param {RouteNode[]} $routes 
 * @returns {UrlHelper}
 */
function makeUrlHelper($ctx, $currentRoute, $routes) {
  return function url(path, params = {}, options) {
    const { component } = $ctx;
    const inheritedParams = Object.assign({}, $currentRoute.params, component.params);
    let el = path && path.nodeType && path;

    if (el)
      path = path.getAttribute('href');

    path = path ? resolvePath(path) : component.shortPath;

    // preload the route  
    const route = $routes.find(route => [route.shortPath || '/', route.path].includes(path));
    if (route && route.meta.preload === 'proximity' && window.requestIdleCallback) {
      const delay = routify.appLoaded ? 0 : 1500;
      setTimeout(() => {
        window.requestIdleCallback(() => route.api.preload());
      }, delay);
    }

    const strict = options && options.strict !== false;
    if (!strict) path = path.replace(/index$/, '');

    let url = resolveUrl(path, params, inheritedParams);

    if (el) {
      el.href = url;
      return {
        update(changedParams) { el.href = resolveUrl(path, changedParams, inheritedParams); }
      }
    }

    return url

    /**
     * converts relative, named and absolute paths to absolute paths
     * example: at `/foo/bar/baz`  the path  `../bar2/:something`  converts to   `/foo/bar2/:something`
     * @param {*} path 
     */
    function resolvePath(path) {
      if (path.match(/^\.\.?\//)) {
        //RELATIVE PATH
        let [, breadcrumbs, relativePath] = path.match(/^([\.\/]+)(.*)/);
        let dir = component.path.replace(/\/$/, '');
        const traverse = breadcrumbs.match(/\.\.\//g) || [];
        // if this is a page, we want to traverse one step back to its folder
        if (component.isPage) traverse.push(null);
        traverse.forEach(() => dir = dir.replace(/\/[^\/]+\/?$/, ''));
        path = `${dir}/${relativePath}`.replace(/\/$/, '');
        path = path || '/'; // empty means root
      } else if (path.match(/^\//)) ; else {
        // NAMED PATH
        const matchingRoute = $routes.find(route => route.meta.name === path);
        if (matchingRoute) path = matchingRoute.shortPath;
      }
      return path
    }



  }
}


/**
* @callback GotoHelper
* @param {String=} path
* @param {UrlParams=} params
* @param {GotoOptions=} options
*
* @typedef {import('svelte/store').Readable<GotoHelper>}  GotoHelperStore
* @type {GotoHelperStore} 
* */
const goto = {
  subscribe(listener) {
    const routifyUpdatePage = getContext('routifyupdatepage');
    return derived(url,
      url => function goto(path, params, _static, shallow) {
        const href = url(path, params);
        if (!_static) history.pushState({}, null, href);
        else routifyUpdatePage(href, shallow);
      }
    ).subscribe(
      listener
    )
  },
};

/**
 * @type {GotoHelperStore} 
 * */
const redirect = {
  subscribe(listener) {
    const routifyUpdatePage = getContext('routifyupdatepage');
    return derived(url,
      url => function redirect(path, params, _static, shallow) {
        const href = url(path, params);
        if (!_static) history.replaceState({}, null, href);
        else routifyUpdatePage(href, shallow);
      }
    ).subscribe(
      listener
    )
  },
};

/**
 * @callback IsActiveHelper
 * @param {String=} path
 * @param {UrlParams=} params
 * @param {UrlOptions=} options
 * @returns {Boolean}
 * 
 * @typedef {import('svelte/store').Readable<IsActiveHelper>} IsActiveHelperStore
 * @type {IsActiveHelperStore} 
 * */
const isActive = {
  subscribe(run) {
    return derived(
      [url, route],
      ([url, route]) => function isActive(path = "", params = {}, { strict } = { strict: true }) {
        path = url(path, params, { strict });
        const currentPath = url(route.path, null, { strict });
        const re = new RegExp('^' + path + '($|/)');
        return !!currentPath.match(re)
      }
    ).subscribe(run)
  },
};



const _metatags = {
  subscribe(listener) {
    this._origin = this.getOrigin();
    return listener(metatags)
  },
  props: {},
  templates: {},
  services: {
    plain: { propField: 'name', valueField: 'content' },
    twitter: { propField: 'name', valueField: 'content' },
    og: { propField: 'property', valueField: 'content' },
  },
  plugins: [
    {
      name: 'applyTemplate',
      condition: () => true,
      action: (prop, value) => {
        const template = _metatags.getLongest(_metatags.templates, prop) || (x => x);
        return [prop, template(value)]
      }
    },
    {
      name: 'createMeta',
      condition: () => true,
      action(prop, value) {
        _metatags.writeMeta(prop, value);
      }
    },
    {
      name: 'createOG',
      condition: prop => !prop.match(':'),
      action(prop, value) {
        _metatags.writeMeta(`og:${prop}`, value);
      }
    },
    {
      name: 'createTitle',
      condition: prop => prop === 'title',
      action(prop, value) {
        document.title = value;
      }
    }
  ],
  getLongest(repo, name) {
    const providers = repo[name];
    if (providers) {
      const currentPath = get_store_value(route).path;
      const allPaths = Object.keys(repo[name]);
      const matchingPaths = allPaths.filter(path => currentPath.includes(path));

      const longestKey = matchingPaths.sort((a, b) => b.length - a.length)[0];

      return providers[longestKey]
    }
  },
  writeMeta(prop, value) {
    const head = document.getElementsByTagName('head')[0];
    const match = prop.match(/(.+)\:/);
    const serviceName = match && match[1] || 'plain';
    const { propField, valueField } = metatags.services[serviceName] || metatags.services.plain;
    const oldElement = document.querySelector(`meta[${propField}='${prop}']`);
    if (oldElement) oldElement.remove();

    const newElement = document.createElement('meta');
    newElement.setAttribute(propField, prop);
    newElement.setAttribute(valueField, value);
    newElement.setAttribute('data-origin', 'routify');
    head.appendChild(newElement);
  },
  set(prop, value) {
    // we only want strings. If metatags is used as a store, svelte will try to assign an object to prop
    if (typeof prop === 'string') {
      _metatags.plugins.forEach(plugin => {
        if (plugin.condition(prop, value))
          [prop, value] = plugin.action(prop, value) || [prop, value];
      });
    }
  },
  clear() {
    const oldElement = document.querySelector(`meta`);
    if (oldElement) oldElement.remove();
  },
  template(name, fn) {
    const origin = _metatags.getOrigin;
    _metatags.templates[name] = _metatags.templates[name] || {};
    _metatags.templates[name][origin] = fn;
  },
  update() {
    Object.keys(_metatags.props).forEach((prop) => {
      let value = (_metatags.getLongest(_metatags.props, prop));
      _metatags.plugins.forEach(plugin => {
        if (plugin.condition(prop, value)) {
          [prop, value] = plugin.action(prop, value) || [prop, value];

        }
      });
    });
  },
  batchedUpdate() {
    if (!_metatags._pendingUpdate) {
      _metatags._pendingUpdate = true;
      setTimeout(() => {
        _metatags._pendingUpdate = false;
        this.update();
      });
    }
  },
  _updateQueued: false,
  _origin: false,
  getOrigin() {
    if (this._origin) return this._origin
    const routifyCtx = getRoutifyContext();
    return routifyCtx && get_store_value(routifyCtx).path || '/'
  },
  _pendingUpdate: false
};


/**
 * metatags
 * @prop {Object.<string, string>}
 */
const metatags = new Proxy(_metatags, {
  set(target, name, value, receiver) {
    const { props } = target;

    if (Reflect.has(target, name))
      Reflect.set(target, name, value, receiver);
    else {
      props[name] = props[name] || {};
      props[name][target.getOrigin()] = value;
    }

    if (window['routify'].appLoaded)
      target.batchedUpdate();
    return true
  }
});

/* node_modules/@roxi/routify/runtime/Route.svelte generated by Svelte v3.31.0 */

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[21] = list[i].component;
	child_ctx[22] = list[i].componentFile;
	child_ctx[2] = list[i].decorator;
	child_ctx[1] = list[i].nodes;
	return child_ctx;
}

// (109:0) {#if $context}
function create_if_block_1(ctx) {
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_1_anchor;
	let current;
	let each_value = [/*$context*/ ctx[4]];
	const get_key = ctx => /*id*/ ctx[7];

	for (let i = 0; i < 1; i += 1) {
		let child_ctx = get_each_context$1(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$1(key, child_ctx));
	}

	return {
		c() {
			for (let i = 0; i < 1; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < 1; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*$context, scoped, scopedSync, node, decorator, scopeToChild, id*/ 33554621) {
				const each_value = [/*$context*/ ctx[4]];
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$1, each_1_anchor, get_each_context$1);
				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < 1; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < 1; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			for (let i = 0; i < 1; i += 1) {
				each_blocks[i].d(detaching);
			}

			if (detaching) detach(each_1_anchor);
		}
	};
}

// (120:8) {#if component && nodes.length}
function create_if_block_2(ctx) {
	let route_1;
	let current;

	route_1 = new Route({
			props: {
				decorator: /*decorator*/ ctx[2],
				nodes: /*nodes*/ ctx[1],
				scoped: {
					.../*scoped*/ ctx[0],
					.../*scopeToChild*/ ctx[25]
				}
			}
		});

	return {
		c() {
			create_component(route_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(route_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const route_1_changes = {};
			if (dirty & /*decorator*/ 4) route_1_changes.decorator = /*decorator*/ ctx[2];
			if (dirty & /*$context*/ 16) route_1_changes.nodes = /*nodes*/ ctx[1];

			if (dirty & /*scoped, scopeToChild*/ 33554433) route_1_changes.scoped = {
				.../*scoped*/ ctx[0],
				.../*scopeToChild*/ ctx[25]
			};

			route_1.$set(route_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(route_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(route_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(route_1, detaching);
		}
	};
}

// (112:6) <svelte:component         this={componentFile}         let:scoped={scopeToChild}         let:decorator         {scoped}         {scopedSync}         {...node.param || {}}       >
function create_default_slot_1(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*component*/ ctx[21] && /*nodes*/ ctx[1].length && create_if_block_2(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*component*/ ctx[21] && /*nodes*/ ctx[1].length) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*$context*/ 16) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_2(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (111:4) <svelte:component this={decorator} {scoped}>
function create_default_slot(ctx) {
	let switch_instance;
	let t;
	let current;

	const switch_instance_spread_levels = [
		{ scoped: /*scoped*/ ctx[0] },
		{ scopedSync: /*scopedSync*/ ctx[5] },
		/*node*/ ctx[3].param || {}
	];

	var switch_value = /*componentFile*/ ctx[22];

	function switch_props(ctx) {
		let switch_instance_props = {
			$$slots: {
				default: [
					create_default_slot_1,
					({ scoped: scopeToChild, decorator }) => ({ 25: scopeToChild, 2: decorator }),
					({ scoped: scopeToChild, decorator }) => (scopeToChild ? 33554432 : 0) | (decorator ? 4 : 0)
				]
			},
			$$scope: { ctx }
		};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
	}

	return {
		c() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			t = space();
		},
		m(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert(target, t, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const switch_instance_changes = (dirty & /*scoped, scopedSync, node*/ 41)
			? get_spread_update(switch_instance_spread_levels, [
					dirty & /*scoped*/ 1 && { scoped: /*scoped*/ ctx[0] },
					dirty & /*scopedSync*/ 32 && { scopedSync: /*scopedSync*/ ctx[5] },
					dirty & /*node*/ 8 && get_spread_object(/*node*/ ctx[3].param || {})
				])
			: {};

			if (dirty & /*$$scope, decorator, $context, scoped, scopeToChild*/ 100663317) {
				switch_instance_changes.$$scope = { dirty, ctx };
			}

			if (switch_value !== (switch_value = /*componentFile*/ ctx[22])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, t.parentNode, t);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (switch_instance) destroy_component(switch_instance, detaching);
			if (detaching) detach(t);
		}
	};
}

// (110:2) {#each [$context] as { component, componentFile, decorator, nodes }
function create_each_block$1(key_1, ctx) {
	let first;
	let switch_instance;
	let switch_instance_anchor;
	let current;
	var switch_value = /*decorator*/ ctx[2];

	function switch_props(ctx) {
		return {
			props: {
				scoped: /*scoped*/ ctx[0],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
	}

	return {
		key: key_1,
		first: null,
		c() {
			first = empty();
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
			this.first = first;
		},
		m(target, anchor) {
			insert(target, first, anchor);

			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const switch_instance_changes = {};
			if (dirty & /*scoped*/ 1) switch_instance_changes.scoped = /*scoped*/ ctx[0];

			if (dirty & /*$$scope, $context, scoped, scopedSync, node, decorator*/ 67108925) {
				switch_instance_changes.$$scope = { dirty, ctx };
			}

			if (switch_value !== (switch_value = /*decorator*/ ctx[2])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(first);
			if (detaching) detach(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

// (133:0) {#if !parentNode}
function create_if_block(ctx) {
	let div;
	let setParentNode_action;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			set_style(div, "display", "contents");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (!mounted) {
				dispose = action_destroyer(setParentNode_action = /*setParentNode*/ ctx[10].call(null, div));
				mounted = true;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$2(ctx) {
	let t;
	let if_block1_anchor;
	let current;
	let if_block0 = /*$context*/ ctx[4] && create_if_block_1(ctx);
	let if_block1 = !/*parentNode*/ ctx[6] && create_if_block(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*$context*/ ctx[4]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*$context*/ 16) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t.parentNode, t);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (!/*parentNode*/ ctx[6]) {
				if (if_block1) ; else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let $context;
	let $parentContext;
	let $route;
	let $routes;
	component_subscribe($$self, route, $$value => $$invalidate(15, $route = $$value));
	component_subscribe($$self, routes, $$value => $$invalidate(16, $routes = $$value));
	let { nodes = [] } = $$props;
	let { scoped = {} } = $$props;
	let { decorator = undefined } = $$props;

	/** @type {LayoutOrDecorator} */
	let node = null;

	let remainingNodes = null;
	let scopedSync = {};
	let parentNode;
	let invalidate = 1;
	const context = writable(null);
	component_subscribe($$self, context, value => $$invalidate(4, $context = value));

	/** @type {import("svelte/store").Writable<Context>} */
	const parentContext = getContext("routify") || rootContext;

	component_subscribe($$self, parentContext, value => $$invalidate(14, $parentContext = value));
	const setParentNode = el => $$invalidate(6, parentNode = el.parentNode);
	setContext("routify", context);
	let lastNodes = [];

	/**  @param {LayoutOrDecorator} node */
	function setComponent(node) {
		let PendingComponent = node.component();
		if (PendingComponent instanceof Promise) PendingComponent.then(onComponentLoaded); else onComponentLoaded(PendingComponent);
	}

	/** @param {SvelteComponent} componentFile */
	function onComponentLoaded(componentFile) {
		$$invalidate(5, scopedSync = { ...scoped });

		// we have to proxy remaining nodes through ctx (instead of props) or route changes get propagated
		// to leaf layouts of to-be-destroyed-layouts
		const ctx = {
			//we need to keep any possible context.child or the layout will be childless until the new child has been rendered
			...$context,
			nodes: remainingNodes,
			decorator: decorator || Noop,
			layout: node.isLayout ? node : $parentContext.layout,
			component: node,
			route: $route,
			routes: $routes,
			componentFile,
			parentNode: parentNode || $parentContext.parentNode
		};

		context.set(ctx);
		set_store_value(parentContext, $parentContext.child = node, $parentContext);
		if (remainingNodes.length === 0) onLastComponentLoaded();
	}

	async function onLastComponentLoaded() {
		await new Promise(resolve => setTimeout(resolve));
		const isOnCurrentRoute = $context.component.path === $route.path; //maybe we're getting redirected

		// Let everyone know the last child has rendered
		if (!window["routify"].stopAutoReady && isOnCurrentRoute) onPageLoaded({
			page: $context.component,
			metatags,
			afterPageLoad,
			parentNode
		});
	}

	/**  @param {ClientNode} layout */
	function getID({ meta, path, param, params }) {
		return JSON.stringify({
			path,
			invalidate,
			param: (meta["param-is-page"] || meta["slug-is-page"]) && param,
			queryParams: meta["query-params-is-page"] && params
		});
	}

	$$self.$$set = $$props => {
		if ("nodes" in $$props) $$invalidate(1, nodes = $$props.nodes);
		if ("scoped" in $$props) $$invalidate(0, scoped = $$props.scoped);
		if ("decorator" in $$props) $$invalidate(2, decorator = $$props.decorator);
	};

	let id;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*lastNodes, nodes, invalidate*/ 6146) {
			 if (lastNodes !== nodes) {
				$$invalidate(12, lastNodes = nodes);
				$$invalidate(3, [node, ...remainingNodes] = [...nodes], node);
				$$invalidate(3, node.api.reset = () => $$invalidate(11, invalidate++, invalidate), node);
			}
		}

		if ($$self.$$.dirty & /*node*/ 8) {
			 setComponent(node);
		}

		if ($$self.$$.dirty & /*$context, invalidate*/ 2064) {
			 $$invalidate(7, id = $context && invalidate && getID($context.component));
		}

		if ($$self.$$.dirty & /*$context*/ 16) {
			 $context && suppressComponentWarnings($context, tick);
		}
	};

	return [
		scoped,
		nodes,
		decorator,
		node,
		$context,
		scopedSync,
		parentNode,
		id,
		context,
		parentContext,
		setParentNode,
		invalidate,
		lastNodes
	];
}

class Route extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { nodes: 1, scoped: 0, decorator: 2 });
	}
}

function init$1(routes, callback) {
  /** @type { ClientNode | false } */
  let lastRoute = false;

  function updatePage(proxyToUrl, shallow) {
    const url = proxyToUrl || currentLocation().fullpath;
    const route$1 = urlToRoute(url);
    if (route$1.redirectTo) {
      history.replaceStateNative({}, null, route$1.redirectTo);
      delete route$1.redirectTo;
    }

    const currentRoute = shallow && urlToRoute(currentLocation().fullpath, routes);
    const contextRoute = currentRoute || route$1;
    const nodes = [...contextRoute.layouts, route$1];
    if (lastRoute) delete lastRoute.last; //todo is a page component the right place for the previous route?
    route$1.last = lastRoute;
    lastRoute = route$1;

    //set the route in the store
    if (!proxyToUrl)
      urlRoute.set(route$1);
    route.set(route$1);

    //preload components in parallel
    route$1.api.preload().then(() => {
      //run callback in Router.svelte    
      isChangingPage.set(true);
      callback(nodes);
    });
  }

  const destroy = createEventListeners(updatePage);

  return { updatePage, destroy }
}

/**
 * svelte:window events doesn't work on refresh
 * @param {Function} updatePage
 */
function createEventListeners(updatePage) {
['pushState', 'replaceState'].forEach(eventName => {
    if (!history[eventName + 'Native'])
      history[eventName + 'Native'] = history[eventName];
    history[eventName] = async function (state = {}, title, url) {
      // do nothing if we're navigating to the current page
      const currentUrl = location.pathname + location.search + location.hash;
      if (url === currentUrl) return false

      const { id, path, params } = get_store_value(route);
      state = { id, path, params, ...state };
      const event = new Event(eventName.toLowerCase());
      Object.assign(event, { state, title, url });

      const route$1 = await runHooksBeforeUrlChange(event, url);
      if (route$1) {
        history[eventName + 'Native'].apply(this, [state, title, url]);
        return dispatchEvent(event)
      }
    };
  });

  let _ignoreNextPop = false;

  const listeners = {
    click: handleClick,
    pushstate: () => updatePage(),
    replacestate: () => updatePage(),
    popstate: async event => {
      if (_ignoreNextPop)
        _ignoreNextPop = false;
      else {
        if (await runHooksBeforeUrlChange(event, currentLocation().fullpath)) {
          updatePage();
        } else {
          _ignoreNextPop = true;
          event.preventDefault();
          history.go(1);
        }
      }
    },
  };

  Object.entries(listeners).forEach(args => addEventListener(...args));

  const unregister = () => {
    Object.entries(listeners).forEach(args => removeEventListener(...args));
  };

  return unregister
}

function handleClick(event) {
  const el = event.target.closest('a');
  const href = el && el.href;

  if (
    event.ctrlKey ||
    event.metaKey ||
    event.altKey ||
    event.shiftKey ||
    event.button ||
    event.defaultPrevented
  )
    return
  if (!href || el.target || el.host !== location.host) return

  const url = new URL(href);
  const relativeUrl = url.pathname + url.search + url.hash;

  event.preventDefault();
  history.pushState({}, '', relativeUrl);
}

async function runHooksBeforeUrlChange(event, url) {
  const route = urlToRoute(url).api;
  for (const hook of beforeUrlChange._hooks.filter(Boolean)) {
    // return false if the hook returns false
    const result = await hook(event, route, { url });
    if (!result) return false
  }
  return true
}

/* node_modules/@roxi/routify/runtime/Router.svelte generated by Svelte v3.31.0 */

function create_if_block$1(ctx) {
	let route_1;
	let current;
	route_1 = new Route({ props: { nodes: /*nodes*/ ctx[0] } });

	return {
		c() {
			create_component(route_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(route_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const route_1_changes = {};
			if (dirty & /*nodes*/ 1) route_1_changes.nodes = /*nodes*/ ctx[0];
			route_1.$set(route_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(route_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(route_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(route_1, detaching);
		}
	};
}

function create_fragment$3(ctx) {
	let t;
	let prefetcher;
	let current;
	let if_block = /*nodes*/ ctx[0] && /*$route*/ ctx[1] !== null && create_if_block$1(ctx);
	prefetcher = new Prefetcher({});

	return {
		c() {
			if (if_block) if_block.c();
			t = space();
			create_component(prefetcher.$$.fragment);
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t, anchor);
			mount_component(prefetcher, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*nodes*/ ctx[0] && /*$route*/ ctx[1] !== null) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*nodes, $route*/ 3) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(prefetcher.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(prefetcher.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t);
			destroy_component(prefetcher, detaching);
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	let $route;
	component_subscribe($$self, route, $$value => $$invalidate(1, $route = $$value));
	let { routes: routes$1 } = $$props;
	let { config = {} } = $$props;
	let nodes;
	let navigator;
	window.routify = window.routify || {};
	window.routify.inBrowser = !window.navigator.userAgent.match("jsdom");
	Object.assign(defaultConfig, config);
	const updatePage = (...args) => navigator && navigator.updatePage(...args);
	setContext("routifyupdatepage", updatePage);
	const callback = res => $$invalidate(0, nodes = res);

	const cleanup = () => {
		if (!navigator) return;
		navigator.destroy();
		navigator = null;
	};

	let initTimeout = null;

	// init is async to prevent a horrible bug that completely disable reactivity
	// in the host component -- something like the component's update function is
	// called before its fragment is created, and since the component is then seen
	// as already dirty, it is never scheduled for update again, and remains dirty
	// forever... I failed to isolate the precise conditions for the bug, but the
	// faulty update is triggered by a change in the route store, and so offseting
	// store initialization by one tick gives the host component some time to
	// create its fragment. The root cause it probably a bug in Svelte with deeply
	// intertwinned store and reactivity.
	const doInit = () => {
		clearTimeout(initTimeout);

		initTimeout = setTimeout(() => {
			cleanup();
			navigator = init$1(routes$1, callback);
			routes.set(routes$1);
			navigator.updatePage();
		});
	};

	onDestroy(cleanup);

	$$self.$$set = $$props => {
		if ("routes" in $$props) $$invalidate(2, routes$1 = $$props.routes);
		if ("config" in $$props) $$invalidate(3, config = $$props.config);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*routes*/ 4) {
			 if (routes$1) doInit();
		}
	};

	return [nodes, $route, routes$1, config];
}

class Router extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { routes: 2, config: 3 });
	}
}

/** 
 * Node payload
 * @typedef {Object} NodePayload
 * @property {RouteNode=} file current node
 * @property {RouteNode=} parent parent of the current node
 * @property {StateObject=} state state shared by every node in the walker
 * @property {Object=} scope scope inherited by descendants in the scope
 *
 * State Object
 * @typedef {Object} StateObject
 * @prop {TreePayload=} treePayload payload from the tree
 * 
 * Node walker proxy
 * @callback NodeWalkerProxy
 * @param {NodePayload} NodePayload
 */


/**
 * Node middleware
 * @description Walks through the nodes of a tree
 * @example middleware = createNodeMiddleware(payload => {payload.file.name = 'hello'})(treePayload))
 * @param {NodeWalkerProxy} fn 
 */
function createNodeMiddleware(fn) {

    /**    
     * NodeMiddleware payload receiver
     * @param {TreePayload} payload
     */
    const inner = async function execute(payload) {
        return await nodeMiddleware(fn, {
            file: payload.tree,
            state: { treePayload: payload },
            scope: {}
        })
    };

    /**    
     * NodeMiddleware sync payload receiver
     * @param {TreePayload} payload
     */
    inner.sync = function executeSync(payload) {
        return nodeMiddlewareSync(fn, {
            file: payload.tree,
            state: { treePayload: payload },
            scope: {}
        })
    };

    return inner
}

/**
 * Node walker
 * @param {NodeWalkerProxy} fn function to be called for each file
 * @param {NodePayload=} payload 
 */
async function nodeMiddleware(fn, payload) {
    const _file = await fn(payload);
    if (_file === false) return false
    const file = _file || payload.file;

    if (file.children) {
        const children = await Promise.all(file.children.map(async _file => nodeMiddleware(fn, {
            state: payload.state,
            scope: clone(payload.scope || {}),
            parent: payload.file,
            file: await _file
        })));
        file.children = children.filter(Boolean);
    }

    return file
}

/**
 * Node walker (sync version)
 * @param {NodeWalkerProxy} fn function to be called for each file
 * @param {NodePayload=} payload 
 */
function nodeMiddlewareSync(fn, payload) {
    const _file = fn(payload);
    if (_file === false) return false

    const file = _file || payload.file;

    if (file.children) {
        const children = file.children.map(_file => nodeMiddlewareSync(fn, {
            state: payload.state,
            scope: clone(payload.scope || {}),
            parent: payload.file,
            file: _file
        }));
        file.children = children.filter(Boolean);
    }

    return file
}


/**
 * Clone with JSON
 * @param {T} obj 
 * @returns {T} JSON cloned object
 * @template T
 */
function clone(obj) { return JSON.parse(JSON.stringify(obj)) }

const setRegex = createNodeMiddleware(({ file }) => {
    if (file.isPage || file.isFallback)
        file.regex = pathToRegex(file.path, file.isFallback);
});
const setParamKeys = createNodeMiddleware(({ file }) => {
    file.paramKeys = pathToParamKeys(file.path);
});

const setShortPath = createNodeMiddleware(({ file }) => {
    if (file.isFallback || file.isIndex)
        file.shortPath = file.path.replace(/\/[^/]+$/, '');
    else file.shortPath = file.path;
});
const setRank = createNodeMiddleware(({ file }) => {
    file.ranking = pathToRank(file);
});


// todo delete?
const addMetaChildren = createNodeMiddleware(({ file }) => {
    const node = file;
    const metaChildren = file.meta && file.meta.children || [];
    if (metaChildren.length) {
        node.children = node.children || [];
        node.children.push(...metaChildren.map(meta => ({ isMeta: true, ...meta, meta })));
    }
});

const setIsIndexable = createNodeMiddleware(payload => {
    const { file } = payload;
    const { isFallback, meta } = file;
    const isDynamic = file.path.split('/').pop().startsWith(':');
    const isIndex = file.path.endsWith('/index');
    const isIndexed = meta.index || meta.index === 0;
    const isHidden = meta.index === false;

    file.isIndexable = isIndexed || (!isFallback && !isDynamic && !isIndex && !isHidden);
    file.isNonIndexable = !file.isIndexable;
});

const assignRelations = createNodeMiddleware(({ file, parent }) => {
    Object.defineProperty(file, 'parent', { get: () => parent });
    Object.defineProperty(file, 'nextSibling', { get: () => _getSibling(file, 1) });
    Object.defineProperty(file, 'prevSibling', { get: () => _getSibling(file, -1) });
    Object.defineProperty(file, 'lineage', { get: () => _getLineage(parent) });
});

function _getLineage(node, lineage = []) {
    if (node) {
        lineage.unshift(node);
        _getLineage(node.parent, lineage);
    }
    return lineage
}

/**
 * 
 * @param {RouteNode} file 
 * @param {Number} direction 
 */
function _getSibling(file, direction) {
    if (!file.root) {
        const siblings = file.parent.children.filter(c => c.isIndexable);
        const index = siblings.indexOf(file);
        return siblings[index + direction]
    }
}

const assignIndex = createNodeMiddleware(({ file, parent }) => {
    if (file.isIndex) Object.defineProperty(parent, 'index', { get: () => file });
});

const assignLayout = createNodeMiddleware(({ file, scope }) => {
    // create a layouts getter
    Object.defineProperty(file, 'layouts', { get: () => getLayouts(file) });

    /**
     * returns a list of layouts by recursively traversing the AST ancestry
     * @param {RouteNode} file 
     * @returns {RouteNode[]}
     */
    function getLayouts(file) {
        // if this isn't a layout and it's reset, return an empty array
        if (!file.isLayout && file.meta.reset) return []

        const { parent } = file;
        const layout = parent && parent.component && parent;
        const isReset = layout && (layout.isReset || layout.meta.reset);
        const layouts = (parent && !isReset && getLayouts(parent)) || [];
        if (layout) layouts.push(layout);
        return layouts
    }
});


const createFlatList = treePayload => {
    createNodeMiddleware(payload => {
        if (payload.file.isPage || payload.file.isFallback)
            payload.state.treePayload.routes.push(payload.file);
    }).sync(treePayload);
    treePayload.routes.sort((c, p) => (c.ranking >= p.ranking ? -1 : 1));
};

const setPrototype = createNodeMiddleware(({ file }) => {
    const Prototype = file.root
        ? Root
        : file.children
            ? file.isPage ? PageDir : Dir
            : file.isReset
                ? Reset
                : file.isLayout
                    ? Layout
                    : file.isFallback
                        ? Fallback
                        : Page;
    Object.setPrototypeOf(file, Prototype.prototype);

    function Layout() { }
    function Dir() { }
    function Fallback() { }
    function Page() { }
    function PageDir() { }
    function Reset() { }
    function Root() { }
});

var miscPlugins = /*#__PURE__*/Object.freeze({
    __proto__: null,
    setRegex: setRegex,
    setParamKeys: setParamKeys,
    setShortPath: setShortPath,
    setRank: setRank,
    addMetaChildren: addMetaChildren,
    setIsIndexable: setIsIndexable,
    assignRelations: assignRelations,
    assignIndex: assignIndex,
    assignLayout: assignLayout,
    createFlatList: createFlatList,
    setPrototype: setPrototype
});

const defaultNode = {
    "isDir": false,
    "ext": "svelte",
    "isLayout": false,
    "isReset": false,
    "isIndex": false,
    "isFallback": false,
    "isPage": false,
    "ownMeta": {},
    "meta": {
        "recursive": true,
        "preload": false,
        "prerender": true
    },
    "id": "__fallback",
};

function restoreDefaults(node) {
    Object.entries(defaultNode).forEach(([key, value]) => {
        if (typeof node[key] === 'undefined')
            node[key] = value;
    });
    
    if(node.children)
        node.children = node.children.map(restoreDefaults);

    return node
}

const assignAPI = createNodeMiddleware(({ file }) => {
    file.api = new ClientApi(file);
});

class ClientApi {
    constructor(file) {
        this.__file = file;
        Object.defineProperty(this, '__file', { enumerable: false });
        this.isMeta = !!file.isMeta;
        this.path = file.path;
        this.title = _prettyName(file);
        this.meta = file.meta;
    }

    get parent() { return !this.__file.root && this.__file.parent.api }
    get children() {
        return (this.__file.children || this.__file.isLayout && this.__file.parent.children || [])
            .filter(c => !c.isNonIndexable)
            .sort((a, b) => {
                if (a.isMeta && b.isMeta) return 0
                a = (a.meta.index || a.meta.title || a.path).toString();
                b = (b.meta.index || b.meta.title || b.path).toString();
                return a.localeCompare((b), undefined, { numeric: true, sensitivity: 'base' })
            })
            .map(({ api }) => api)
    }
    get next() { return _navigate(this, +1) }
    get prev() { return _navigate(this, -1) }
    async preload() {
        const filePromises = [
            ...this.__file.layouts,
            this.__file,
            this.index && this.index.__file //if this is a layout, we want to include its index
        ]
            .filter(Boolean)
            .map(file => file.component());
        await Promise.all(filePromises);
    }
    get component() {
        return this.__file.component ? //is file?
            this.__file.component()
            : this.__file.index ? //is dir with index?
                this.__file.index.component()
                : false
    }
    get componentWithIndex() {
        return new Promise(resolve =>
            Promise.all([
                this.component,
                this.index && this.index.component
            ])
                .then(res => resolve(res))
        )
    }
    get index() {
        const child = this.__file.children &&
            this.__file.children.find(child => child.isIndex);
        return child && child.api
    }
}

function _navigate(node, direction) {
    if (!node.__file.root) {
        const siblings = node.parent.children;
        const index = siblings.indexOf(node);
        return node.parent.children[index + direction]
    }
}


function _prettyName(file) {
    if (typeof file.meta.title !== 'undefined') return file.meta.title
    else return (file.shortPath || file.path)
        .split('/')
        .pop()
        .replace(/-/g, ' ')
}

const plugins = {
  ...miscPlugins,
  restoreDefaults: ({ tree }) => restoreDefaults(tree),
  assignAPI
};

function buildClientTree(tree) {
  const order = [
    // all
    "restoreDefaults",
    // pages
    "setParamKeys", //pages only
    "setRegex", //pages only
    "setShortPath", //pages only
    "setRank", //pages only
    "assignLayout", //pages only,
    // all
    "setPrototype",
    "addMetaChildren",
    "assignRelations", //all (except meta components?)
    "setIsIndexable", //all
    "assignIndex", //all
    "assignAPI", //all
    // routes
    "createFlatList"
  ];

  const payload = { tree, routes: [] };
  for (let name of order) {
    // if plugin is a createNodeMiddleware, use the sync function
    const fn = plugins[name].sync || plugins[name];
    fn(payload);
  }
  return payload
}

/* src/pages/_fallback.svelte generated by Svelte v3.31.0 */

function add_css() {
	var style = element("style");
	style.id = "svelte-tbkjva-style";
	style.textContent = ".huge.svelte-tbkjva{font-size:12rem}.e404.svelte-tbkjva{position:absolute;left:50%;top:50%;transform:translate(-50%, -50%);text-align:center}";
	append(document.head, style);
}

function create_fragment$4(ctx) {
	let div2;
	let div0;
	let t1;
	let div1;
	let t2;
	let a;
	let t3;
	let a_href_value;

	return {
		c() {
			div2 = element("div");
			div0 = element("div");
			div0.textContent = "404";
			t1 = space();
			div1 = element("div");
			t2 = text$1("Page not found.\n\t\t\n\t\t");
			a = element("a");
			t3 = text$1("Go back");
			attr(div0, "class", "huge svelte-tbkjva");
			attr(a, "href", a_href_value = /*$url*/ ctx[0]("../"));
			attr(div1, "class", "big");
			attr(div2, "class", "e404 svelte-tbkjva");
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div0);
			append(div2, t1);
			append(div2, div1);
			append(div1, t2);
			append(div1, a);
			append(a, t3);
		},
		p(ctx, [dirty]) {
			if (dirty & /*$url*/ 1 && a_href_value !== (a_href_value = /*$url*/ ctx[0]("../"))) {
				attr(a, "href", a_href_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div2);
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	let $url;
	component_subscribe($$self, url, $$value => $$invalidate(0, $url = $$value));
	return [$url];
}

class Fallback extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-tbkjva-style")) add_css();
		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});
	}
}

/* src/pages/about/index.svelte generated by Svelte v3.31.0 */

function add_css$1() {
	var style = element("style");
	style.id = "svelte-rjst84-style";
	style.textContent = ".about.svelte-rjst84{width:100vw;height:100vh;color:#999999;overflow:scroll;display:grid;grid-template-rows:auto 1fr;grid-template-columns:1fr 4fr 1fr}.about-sema.svelte-rjst84{width:100%;height:100%;overflow:auto;grid-column:2/2}h2.svelte-rjst84{padding:10px 20px 0px 20px}p.svelte-rjst84{padding:10px 20px 0px 20px}.sema.svelte-rjst84{color:#FFFFFF}.iframe-container.svelte-rjst84{display:flex;justify-content:center;align-items:center}.image-container.svelte-rjst84{display:flex;justify-content:center;align-items:center}";
	append(document.head, style);
}

function create_fragment$5(ctx) {
	let t0;
	let div4;

	return {
		c() {
			t0 = space();
			div4 = element("div");

			div4.innerHTML = `<div class="about svelte-rjst84"><div class="about-sema svelte-rjst84"><h2 class="svelte-rjst84">about <span class="sema svelte-rjst84">sema</span></h2> 
      <p class="svelte-rjst84"><span>Sema lets you compose and perform music in real time using simple live coding languages. It also enables you to customise these languages, create new ones, and infuse your live code with bespoke neural networks, using interactive workflows and small training data sets.</span></p> 
      <div class="iframe-container svelte-rjst84"><iframe class="iframe svelte-rjst84" width="630" height="420" title="Sema-demo" src="https://www.youtube.com/embed/Qw4sYnTj-Ow?t=27s" crossorigin="anonymous"></iframe></div> 
      <p class="svelte-rjst84"><span><span>Sema is a live coding environment for sound and music similar to SuperCollider, TidalCycles and Gibber.</span>
          Uniquely, it provides many domain-specific languages and an integrated experience to language design and machine learning in your Web browser. This is achieved through the integration of:</span></p> 
      <ul><li>an interpreter for machine learning libraries (e.g. <a href="https://www.tensorflow.org/js/" target="_blank">tensorflow.js</a>) that lets you build and train neural networks</li> 
        <li>a compiler for <a href="https://hardmath123.github.io/earley.html" target="_blank">BNF grammars</a> that enables you to customise or create live coding languages</li></ul> 
      <p class="svelte-rjst84">Do you need help with sema? Check the following:</p> 
      
        <ul><li>articles and news in our <a href="https://blog.sema.codes" target="_blank">blog</a></li> 
          <li>video tutorials on our Youtube <a href="https://www.youtube.com/channel/UCMJVYzJaZBNnKP6f0le7Lxg" target="_blank">channel</a></li> 
          <li>issues on <a href="https://github.com/mimic-sussex/sema" target="_blank">Github</a></li> 
          <li>talk to us on <a href="https://discord.gg/nNZMJfUHrS" target="_blank">Discord</a></li> 
          <li>drop us an email at <a href="mailto://sema.live.coding@gmail.com" target="_blank">sema.live.coding@gmail.com</a></li></ul> 
      
      <div class="image-container svelte-rjst84"><img src="images/team/wac2019.jpg" alt="team" width="640" height="431"/></div> 
      <p class="svelte-rjst84"><span>Sema is developed at the University of Sussex, with  and funding from two UKRI/AHRC grants &#39;MIMIC - Musically Intelligent Machines Interacting Collaboratively&#39; and &#39;Innovating Sema&#39;.</span> 
        <span>It builds upon many amazing contributions of the open-source community, including <a href="https://svelte.dev/" target="_blank">Svelte</a>, <a href="https://routify.dev/" target="_blank">Routify</a>, <a href="https://nearley.js.org/" target="_blank">Nearley</a> and <a href="https://github.com/micknoise/Maximilian" target="_blank">Maximilian</a>.</span></p> 
      <p class="svelte-rjst84"></p></div></div>`;

			document.title = "Sema  About";
			attr(div4, "class", "center-all");
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, div4, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(div4);
		}
	};
}

class About extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-rjst84-style")) add_css$1();
		init(this, options, null, create_fragment$5, safe_not_equal, {});
	}
}

/* src/pages/admin/index.svelte generated by Svelte v3.31.0 */

function create_fragment$6(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			div.innerHTML = `<h1>ADMIN</h1>`;
			attr(div, "class", "center-all");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

class Admin extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, null, create_fragment$6, safe_not_equal, {});
	}
}

// constants.ts
const DEFAULT_HEADERS = {};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, basedir, module) {
	return module = {
	  path: basedir,
	  exports: {},
	  require: function (path, base) {
      return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
    }
	}, fn(module, module.exports), module.exports;
}

function getCjsExportFromNamespace (n) {
	return n && n['default'] || n;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var browserPonyfill = createCommonjsModule(function (module, exports) {
var global = typeof self !== 'undefined' ? self : commonjsGlobal;
var __self__ = (function () {
function F() {
this.fetch = false;
this.DOMException = global.DOMException;
}
F.prototype = global;
return new F();
})();
(function(self) {

var irrelevant = (function (exports) {

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob:
      'FileReader' in self &&
      'Blob' in self &&
      (function() {
        try {
          new Blob();
          return true
        } catch (e) {
          return false
        }
      })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  function isDataView(obj) {
    return obj && DataView.prototype.isPrototypeOf(obj)
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isArrayBufferView =
      ArrayBuffer.isView ||
      function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
      };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ', ' + value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push(name);
    });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) {
      items.push(value);
    });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        this._bodyText = body = Object.prototype.toString.call(body);
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      this.signal = input.signal;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'same-origin';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.signal = options.signal || this.signal;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);
  }

  Request.prototype.clone = function() {
    return new Request(this, {body: this._bodyInit})
  };

  function decode(body) {
    var form = new FormData();
    body
      .trim()
      .split('&')
      .forEach(function(bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  exports.DOMException = self.DOMException;
  try {
    new exports.DOMException();
  } catch (err) {
    exports.DOMException = function(message, name) {
      this.message = message;
      this.name = name;
      var error = Error(message);
      this.stack = error.stack;
    };
    exports.DOMException.prototype = Object.create(Error.prototype);
    exports.DOMException.prototype.constructor = exports.DOMException;
  }

  function fetch(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);

      if (request.signal && request.signal.aborted) {
        return reject(new exports.DOMException('Aborted', 'AbortError'))
      }

      var xhr = new XMLHttpRequest();

      function abortXhr() {
        xhr.abort();
      }

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.onabort = function() {
        reject(new exports.DOMException('Aborted', 'AbortError'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });

      if (request.signal) {
        request.signal.addEventListener('abort', abortXhr);

        xhr.onreadystatechange = function() {
          // DONE (success or failure)
          if (xhr.readyState === 4) {
            request.signal.removeEventListener('abort', abortXhr);
          }
        };
      }

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  }

  fetch.polyfill = true;

  if (!self.fetch) {
    self.fetch = fetch;
    self.Headers = Headers;
    self.Request = Request;
    self.Response = Response;
  }

  exports.Headers = Headers;
  exports.Request = Request;
  exports.Response = Response;
  exports.fetch = fetch;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

}({}));
})(__self__);
__self__.fetch.ponyfill = true;
// Remove "polyfill" property added by whatwg-fetch
delete __self__.fetch.polyfill;
// Choose between native implementation (global) or custom implementation (__self__)
// var ctx = global.fetch ? global : __self__;
var ctx = __self__; // this line disable service worker support temporarily
exports = ctx.fetch; // To enable: import fetch from 'cross-fetch'
exports.default = ctx.fetch; // For TypeScript consumers without esModuleInterop.
exports.fetch = ctx.fetch; // To enable: import {fetch} from 'cross-fetch'
exports.Headers = ctx.Headers;
exports.Request = ctx.Request;
exports.Response = ctx.Response;
module.exports = exports;
});

var fetch$1 = /*@__PURE__*/unwrapExports(browserPonyfill);

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const _getErrorMessage = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
const handleError = (error, reject) => {
    if (typeof error.json !== 'function') {
        return reject(error);
    }
    error.json().then((err) => {
        return reject({
            message: _getErrorMessage(err),
            status: (error === null || error === void 0 ? void 0 : error.status) || 500,
        });
    });
};
const _getRequestParams = (method, options, body) => {
    const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };
    if (method === 'GET') {
        return params;
    }
    params.headers = Object.assign({ 'Content-Type': 'text/plain;charset=UTF-8' }, options === null || options === void 0 ? void 0 : options.headers);
    params.body = JSON.stringify(body);
    return params;
};
function _handleRequest(method, url, options, body) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            fetch$1(url, _getRequestParams(method, options, body))
                .then((result) => {
                if (!result.ok)
                    throw result;
                if (options === null || options === void 0 ? void 0 : options.noResolveJson)
                    return resolve;
                return result.json();
            })
                .then((data) => resolve(data))
                .catch((error) => handleError(error, reject));
        });
    });
}
function get(url, options) {
    return __awaiter(this, void 0, void 0, function* () {
        return _handleRequest('GET', url, options);
    });
}
function post(url, body, options) {
    return __awaiter(this, void 0, void 0, function* () {
        return _handleRequest('POST', url, options, body);
    });
}
function put(url, body, options) {
    return __awaiter(this, void 0, void 0, function* () {
        return _handleRequest('PUT', url, options, body);
    });
}
function remove(url, body, options) {
    return __awaiter(this, void 0, void 0, function* () {
        return _handleRequest('DELETE', url, options, body);
    });
}

const GOTRUE_URL = 'http://localhost:9999';
const DEFAULT_HEADERS$1 = {};
const STORAGE_KEY = 'supabase.auth.token';
const COOKIE_OPTIONS = {
    name: 'sb:token',
    lifetime: 60 * 60 * 8,
    domain: '',
    path: '/',
    sameSite: 'lax',
};

/**
 * Serialize data into a cookie header.
 */
function serialize(name, val, options) {
    const opt = options || {};
    const enc = encodeURIComponent;
    const fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    if (typeof enc !== 'function') {
        throw new TypeError('option encode is invalid');
    }
    if (!fieldContentRegExp.test(name)) {
        throw new TypeError('argument name is invalid');
    }
    const value = enc(val);
    if (value && !fieldContentRegExp.test(value)) {
        throw new TypeError('argument val is invalid');
    }
    let str = name + '=' + value;
    if (null != opt.maxAge) {
        const maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge)) {
            throw new TypeError('option maxAge is invalid');
        }
        str += '; Max-Age=' + Math.floor(maxAge);
    }
    if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain)) {
            throw new TypeError('option domain is invalid');
        }
        str += '; Domain=' + opt.domain;
    }
    if (opt.path) {
        if (!fieldContentRegExp.test(opt.path)) {
            throw new TypeError('option path is invalid');
        }
        str += '; Path=' + opt.path;
    }
    if (opt.expires) {
        if (typeof opt.expires.toUTCString !== 'function') {
            throw new TypeError('option expires is invalid');
        }
        str += '; Expires=' + opt.expires.toUTCString();
    }
    if (opt.httpOnly) {
        str += '; HttpOnly';
    }
    if (opt.secure) {
        str += '; Secure';
    }
    if (opt.sameSite) {
        const sameSite = typeof opt.sameSite === 'string' ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
            case 'lax':
                str += '; SameSite=Lax';
                break;
            case 'strict':
                str += '; SameSite=Strict';
                break;
            case 'none':
                str += '; SameSite=None';
                break;
            default:
                throw new TypeError('option sameSite is invalid');
        }
    }
    return str;
}
/**
 * Based on the environment and the request we know if a secure cookie can be set.
 */
function isSecureEnvironment(req) {
    if (!req || !req.headers || !req.headers.host) {
        throw new Error('The "host" request header is not available');
    }
    const host = (req.headers.host.indexOf(':') > -1 && req.headers.host.split(':')[0]) || req.headers.host;
    if (['localhost', '127.0.0.1'].indexOf(host) > -1 || host.endsWith('.local')) {
        return false;
    }
    return true;
}
/**
 * Serialize a cookie to a string.
 */
function serializeCookie(cookie, secure) {
    var _a, _b, _c;
    return serialize(cookie.name, cookie.value, {
        maxAge: cookie.maxAge,
        expires: new Date(Date.now() + cookie.maxAge * 1000),
        httpOnly: true,
        secure,
        path: (_a = cookie.path) !== null && _a !== void 0 ? _a : '/',
        domain: (_b = cookie.domain) !== null && _b !== void 0 ? _b : '',
        sameSite: (_c = cookie.sameSite) !== null && _c !== void 0 ? _c : 'lax',
    });
}
/**
 * Set one or more cookies.
 */
function setCookies(req, res, cookies) {
    const strCookies = cookies.map((c) => serializeCookie(c, isSecureEnvironment(req)));
    const previousCookies = res.getHeader('Set-Cookie');
    if (previousCookies) {
        if (previousCookies instanceof Array) {
            Array.prototype.push.apply(strCookies, previousCookies);
        }
        else if (typeof previousCookies === 'string') {
            strCookies.push(previousCookies);
        }
    }
    res.setHeader('Set-Cookie', strCookies);
}
/**
 * Set one or more cookies.
 */
function setCookie(req, res, cookie) {
    setCookies(req, res, [cookie]);
}
function deleteCookie(req, res, name) {
    setCookie(req, res, {
        name,
        value: '',
        maxAge: -1,
    });
}

function expiresAt(expiresIn) {
    const timeNow = Math.round(Date.now() / 1000);
    return timeNow + expiresIn;
}
function uuid() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = (Math.random() * 16) | 0, v = c == 'x' ? r : (r & 0x3) | 0x8;
        return v.toString(16);
    });
}
const isBrowser = () => typeof window !== 'undefined';
function getParameterByName(name, url) {
    if (!url)
        url = window.location.href;
    name = name.replace(/[\[\]]/g, '\\$&');
    var regex = new RegExp('[?&#]' + name + '(=([^&#]*)|&|#|$)'), results = regex.exec(url);
    if (!results)
        return null;
    if (!results[2])
        return '';
    return decodeURIComponent(results[2].replace(/\+/g, ' '));
}
class LocalStorage {
    constructor(localStorage) {
        this.localStorage = localStorage || globalThis.localStorage;
    }
    clear() {
        return this.localStorage.clear();
    }
    key(index) {
        return this.localStorage.key(index);
    }
    setItem(key, value) {
        return this.localStorage.setItem(key, value);
    }
    getItem(key) {
        return this.localStorage.getItem(key);
    }
    removeItem(key) {
        return this.localStorage.removeItem(key);
    }
}

var __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class GoTrueApi {
    constructor({ url = '', headers = {}, cookieOptions, }) {
        this.url = url;
        this.headers = headers;
        this.cookieOptions = Object.assign(Object.assign({}, COOKIE_OPTIONS), cookieOptions);
    }
    /**
     * Creates a new user using their email address.
     * @param email The email address of the user.
     * @param password The password of the user.
     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.
     *
     * @returns A logged-in session if the server has "autoconfirm" ON
     * @returns A user if the server has "autoconfirm" OFF
     */
    signUpWithEmail(email, password, options = {}) {
        return __awaiter$1(this, void 0, void 0, function* () {
            try {
                let headers = Object.assign({}, this.headers);
                let queryString = '';
                if (options.redirectTo) {
                    queryString = '?redirect_to=' + encodeURIComponent(options.redirectTo);
                }
                const data = yield post(`${this.url}/signup${queryString}`, { email, password }, { headers });
                let session = Object.assign({}, data);
                if (session.expires_in)
                    session.expires_at = expiresAt(data.expires_in);
                return { data: session, error: null };
            }
            catch (error) {
                return { data: null, error };
            }
        });
    }
    /**
     * Logs in an existing user using their email address.
     * @param email The email address of the user.
     * @param password The password of the user.
     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.
     */
    signInWithEmail(email, password, options = {}) {
        return __awaiter$1(this, void 0, void 0, function* () {
            try {
                let headers = Object.assign({}, this.headers);
                let queryString = '?grant_type=password';
                if (options.redirectTo) {
                    queryString += '&redirect_to=' + encodeURIComponent(options.redirectTo);
                }
                const data = yield post(`${this.url}/token${queryString}`, { email, password }, { headers });
                let session = Object.assign({}, data);
                if (session.expires_in)
                    session.expires_at = expiresAt(data.expires_in);
                return { data: session, error: null };
            }
            catch (error) {
                return { data: null, error };
            }
        });
    }
    /**
     * Sends a magic login link to an email address.
     * @param email The email address of the user.
     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.
     */
    sendMagicLinkEmail(email, options = {}) {
        return __awaiter$1(this, void 0, void 0, function* () {
            try {
                let headers = Object.assign({}, this.headers);
                let queryString = '';
                if (options.redirectTo) {
                    queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);
                }
                const data = yield post(`${this.url}/magiclink${queryString}`, { email }, { headers });
                return { data, error: null };
            }
            catch (error) {
                return { data: null, error };
            }
        });
    }
    /**
     * Sends an invite link to an email address.
     * @param email The email address of the user.
     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.
     */
    inviteUserByEmail(email, options = {}) {
        return __awaiter$1(this, void 0, void 0, function* () {
            try {
                let headers = Object.assign({}, this.headers);
                let queryString = '';
                if (options.redirectTo) {
                    queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);
                }
                const data = yield post(`${this.url}/invite${queryString}`, { email }, { headers });
                return { data, error: null };
            }
            catch (error) {
                return { data: null, error };
            }
        });
    }
    /**
     * Sends a reset request to an email address.
     * @param email The email address of the user.
     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.
     */
    resetPasswordForEmail(email, options = {}) {
        return __awaiter$1(this, void 0, void 0, function* () {
            try {
                let headers = Object.assign({}, this.headers);
                let queryString = '';
                if (options.redirectTo) {
                    queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);
                }
                const data = yield post(`${this.url}/recover${queryString}`, { email }, { headers });
                return { data, error: null };
            }
            catch (error) {
                return { data: null, error };
            }
        });
    }
    /**
     * Create a temporary object with all configured headers and
     * adds the Authorization token to be used on request methods
     * @param jwt A valid, logged-in JWT.
     */
    _createRequestHeaders(jwt) {
        const headers = Object.assign({}, this.headers);
        headers['Authorization'] = `Bearer ${jwt}`;
        return headers;
    }
    /**
     * Removes a logged-in session.
     * @param jwt A valid, logged-in JWT.
     */
    signOut(jwt) {
        return __awaiter$1(this, void 0, void 0, function* () {
            try {
                yield post(`${this.url}/logout`, {}, { headers: this._createRequestHeaders(jwt), noResolveJson: true });
                return { error: null };
            }
            catch (error) {
                return { error };
            }
        });
    }
    /**
     * Generates the relevant login URL for a third-party provider.
     * @param provider One of the providers supported by GoTrue.
     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.
     * @param scopes A space-separated list of scopes granted to the OAuth application.
     */
    getUrlForProvider(provider, options) {
        let urlParams = [`provider=${encodeURIComponent(provider)}`];
        if (options === null || options === void 0 ? void 0 : options.redirectTo) {
            urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);
        }
        if (options === null || options === void 0 ? void 0 : options.scopes) {
            urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);
        }
        return `${this.url}/authorize?${urlParams.join('&')}`;
    }
    /**
     * Gets the user details.
     * @param jwt A valid, logged-in JWT.
     */
    getUser(jwt) {
        return __awaiter$1(this, void 0, void 0, function* () {
            try {
                const data = yield get(`${this.url}/user`, { headers: this._createRequestHeaders(jwt) });
                return { user: data, data, error: null };
            }
            catch (error) {
                return { user: null, data: null, error };
            }
        });
    }
    /**
     * Updates the user data.
     * @param jwt A valid, logged-in JWT.
     * @param attributes The data you want to update.
     */
    updateUser(jwt, attributes) {
        return __awaiter$1(this, void 0, void 0, function* () {
            try {
                const data = yield put(`${this.url}/user`, attributes, {
                    headers: this._createRequestHeaders(jwt),
                });
                return { user: data, data, error: null };
            }
            catch (error) {
                return { user: null, data: null, error };
            }
        });
    }
    /**
     * Delete an user.
     * @param uid The user uid you want to remove.
     * @param jwt A valid JWT. Must be a full-access API key (e.g. service_role key).
     */
    deleteUser(uid, jwt) {
        return __awaiter$1(this, void 0, void 0, function* () {
            try {
                const data = yield remove(`${this.url}/admin/users/${uid}`, {}, {
                    headers: this._createRequestHeaders(jwt),
                });
                return { user: data, data, error: null };
            }
            catch (error) {
                return { user: null, data: null, error };
            }
        });
    }
    /**
     * Generates a new JWT.
     * @param refreshToken A valid refresh token that was returned on login.
     */
    refreshAccessToken(refreshToken) {
        return __awaiter$1(this, void 0, void 0, function* () {
            try {
                const data = yield post(`${this.url}/token?grant_type=refresh_token`, { refresh_token: refreshToken }, { headers: this.headers });
                let session = Object.assign({}, data);
                if (session.expires_in)
                    session.expires_at = expiresAt(data.expires_in);
                return { data: session, error: null };
            }
            catch (error) {
                return { data: null, error };
            }
        });
    }
    /**
     * Set/delete the auth cookie based on the AuthChangeEvent.
     * Works for Next.js & Express (requires cookie-parser middleware).
     */
    setAuthCookie(req, res) {
        if (req.method !== 'POST') {
            res.setHeader('Allow', 'POST');
            res.status(405).end('Method Not Allowed');
        }
        const { event, session } = req.body;
        if (!event)
            throw new Error('Auth event missing!');
        if (event === 'SIGNED_IN') {
            if (!session)
                throw new Error('Auth session missing!');
            setCookie(req, res, {
                name: this.cookieOptions.name,
                value: session.access_token,
                domain: this.cookieOptions.domain,
                maxAge: this.cookieOptions.lifetime,
                path: this.cookieOptions.path,
                sameSite: this.cookieOptions.sameSite,
            });
        }
        if (event === 'SIGNED_OUT')
            deleteCookie(req, res, this.cookieOptions.name);
        res.status(200).json({});
    }
    /**
     * Get user by reading the cookie from the request.
     * Works for Next.js & Express (requires cookie-parser middleware).
     */
    getUserByCookie(req) {
        return __awaiter$1(this, void 0, void 0, function* () {
            try {
                if (!req.cookies)
                    throw new Error('Not able to parse cookies! When using Express make sure the cookie-parser middleware is in use!');
                if (!req.cookies[this.cookieOptions.name])
                    throw new Error('No cookie found!');
                const token = req.cookies[this.cookieOptions.name];
                const { user, error } = yield this.getUser(token);
                if (error)
                    throw error;
                return { user, data: user, error: null };
            }
            catch (error) {
                return { user: null, data: null, error };
            }
        });
    }
}

// @ts-nocheck
/**
 * https://mathiasbynens.be/notes/globalthis
 */
function polyfillGlobalThis() {
    if (typeof globalThis === 'object')
        return;
    try {
        Object.defineProperty(Object.prototype, '__magic__', {
            get: function () {
                return this;
            },
            configurable: true,
        });
        __magic__.globalThis = __magic__;
        delete Object.prototype.__magic__;
    }
    catch (e) {
        if (typeof self !== 'undefined') {
            self.globalThis = self;
        }
    }
}

var __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
polyfillGlobalThis(); // Make "globalThis" available
const DEFAULT_OPTIONS = {
    url: GOTRUE_URL,
    autoRefreshToken: true,
    persistSession: true,
    localStorage: globalThis.localStorage,
    detectSessionInUrl: true,
    headers: DEFAULT_HEADERS$1,
};
class GoTrueClient {
    /**
     * Create a new client for use in the browser.
     * @param options.url The URL of the GoTrue server.
     * @param options.headers Any additional headers to send to the GoTrue server.
     * @param options.detectSessionInUrl Set to "true" if you want to automatically detects OAuth grants in the URL and signs in the user.
     * @param options.autoRefreshToken Set to "true" if you want to automatically refresh the token before expiring.
     * @param options.persistSession Set to "true" if you want to automatically save the user session into local storage.
     * @param options.localStorage
     */
    constructor(options) {
        this.stateChangeEmitters = new Map();
        const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
        this.currentUser = null;
        this.currentSession = null;
        this.autoRefreshToken = settings.autoRefreshToken;
        this.persistSession = settings.persistSession;
        this.localStorage = new LocalStorage(settings.localStorage);
        this.api = new GoTrueApi({
            url: settings.url,
            headers: settings.headers,
            cookieOptions: settings.cookieOptions,
        });
        this._recoverSession();
        this._recoverAndRefresh();
        // Handle the OAuth redirect
        try {
            if (settings.detectSessionInUrl && isBrowser() && !!getParameterByName('access_token')) {
                this.getSessionFromUrl({ storeSession: true });
            }
        }
        catch (error) {
            console.log('Error getting session from URL.');
        }
    }
    /**
     * Creates a new user.
     * @type UserCredentials
     * @param email The user's email address.
     * @param password The user's password.
     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.
     */
    signUp({ email, password }, options = {}) {
        return __awaiter$2(this, void 0, void 0, function* () {
            try {
                this._removeSession();
                const { data, error } = yield this.api.signUpWithEmail(email, password, {
                    redirectTo: options.redirectTo,
                });
                if (error) {
                    throw error;
                }
                if (!data) {
                    throw 'An error occurred on sign up.';
                }
                let session = null;
                let user = null;
                if (data.access_token) {
                    session = data;
                    user = session.user;
                    this._saveSession(session);
                    this._notifyAllSubscribers('SIGNED_IN');
                }
                if (data.id) {
                    user = data;
                }
                return { data, user, session, error: null };
            }
            catch (error) {
                return { data: null, user: null, session: null, error };
            }
        });
    }
    /**
     * Log in an existing user, or login via a third-party provider.
     * @type UserCredentials
     * @param email The user's email address.
     * @param password The user's password.
     * @param refreshToken A valid refresh token that was returned on login.
     * @param provider One of the providers supported by GoTrue.
     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.
     * @param scopes A space-separated list of scopes granted to the OAuth application.
     */
    signIn({ email, password, refreshToken, provider }, options = {}) {
        return __awaiter$2(this, void 0, void 0, function* () {
            try {
                this._removeSession();
                if (email && !password) {
                    const { error } = yield this.api.sendMagicLinkEmail(email, {
                        redirectTo: options.redirectTo,
                    });
                    return { data: null, user: null, session: null, error };
                }
                if (email && password) {
                    return this._handleEmailSignIn(email, password, {
                        redirectTo: options.redirectTo,
                    });
                }
                if (refreshToken) {
                    // currentSession and currentUser will be updated to latest on _callRefreshToken using the passed refreshToken
                    const { error } = yield this._callRefreshToken(refreshToken);
                    if (error)
                        throw error;
                    return {
                        data: this.currentSession,
                        user: this.currentUser,
                        session: this.currentSession,
                        error: null,
                    };
                }
                if (provider) {
                    return this._handleProviderSignIn(provider, {
                        redirectTo: options.redirectTo,
                        scopes: options.scopes,
                    });
                }
                throw new Error(`You must provide either an email or a third-party provider.`);
            }
            catch (error) {
                return { data: null, user: null, session: null, error };
            }
        });
    }
    /**
     * Inside a browser context, `user()` will return the user data, if there is a logged in user.
     *
     * For server-side management, you can get a user through `auth.api.getUserByCookie()`
     */
    user() {
        return this.currentUser;
    }
    /**
     * Returns the session data, if there is an active session.
     */
    session() {
        return this.currentSession;
    }
    /**
     * Force refreshes the session including the user data in case it was updated in a different session.
     */
    refreshSession() {
        var _a;
        return __awaiter$2(this, void 0, void 0, function* () {
            try {
                if (!((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token))
                    throw new Error('Not logged in.');
                // currentSession and currentUser will be updated to latest on _callRefreshToken
                const { error } = yield this._callRefreshToken();
                if (error)
                    throw error;
                return { data: this.currentSession, user: this.currentUser, error: null };
            }
            catch (error) {
                return { data: null, user: null, error };
            }
        });
    }
    /**
     * Updates user data, if there is a logged in user.
     */
    update(attributes) {
        var _a;
        return __awaiter$2(this, void 0, void 0, function* () {
            try {
                if (!((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token))
                    throw new Error('Not logged in.');
                const { user, error } = yield this.api.updateUser(this.currentSession.access_token, attributes);
                if (error)
                    throw error;
                if (!user)
                    throw Error('Invalid user data.');
                const session = Object.assign(Object.assign({}, this.currentSession), { user });
                this._saveSession(session);
                this._notifyAllSubscribers('USER_UPDATED');
                return { data: user, user, error: null };
            }
            catch (error) {
                return { data: null, user: null, error };
            }
        });
    }
    /**
     * Sets the session data from refresh_token and returns current Session and Error
     * @param refresh_token a JWT token
     */
    setSession(refresh_token) {
        return __awaiter$2(this, void 0, void 0, function* () {
            try {
                if (!refresh_token) {
                    throw new Error('No current session.');
                }
                const { data, error } = yield this.api.refreshAccessToken(refresh_token);
                if (error) {
                    return { session: null, error: error };
                }
                if (!data) {
                    return {
                        session: null,
                        error: { name: 'Invalid refresh_token', message: 'JWT token provided is Invalid' },
                    };
                }
                this._saveSession(data);
                this._notifyAllSubscribers('SIGNED_IN');
                return { session: data, error: null };
            }
            catch (error) {
                return { error, session: null };
            }
        });
    }
    /**
     * Overrides the JWT on the current client. The JWT will then be sent in all subsequent network requests.
     * @param access_token a jwt access token
     */
    setAuth(access_token) {
        this.currentSession = Object.assign(Object.assign({}, this.currentSession), { access_token, token_type: 'bearer', user: null });
        return this.currentSession;
    }
    /**
     * Gets the session data from a URL string
     * @param options.storeSession Optionally store the session in the browser
     */
    getSessionFromUrl(options) {
        return __awaiter$2(this, void 0, void 0, function* () {
            try {
                if (!isBrowser())
                    throw new Error('No browser detected.');
                const error_description = getParameterByName('error_description');
                if (error_description)
                    throw new Error(error_description);
                const provider_token = getParameterByName('provider_token');
                const access_token = getParameterByName('access_token');
                if (!access_token)
                    throw new Error('No access_token detected.');
                const expires_in = getParameterByName('expires_in');
                if (!expires_in)
                    throw new Error('No expires_in detected.');
                const refresh_token = getParameterByName('refresh_token');
                if (!refresh_token)
                    throw new Error('No refresh_token detected.');
                const token_type = getParameterByName('token_type');
                if (!token_type)
                    throw new Error('No token_type detected.');
                const timeNow = Math.round(Date.now() / 1000);
                const expires_at = timeNow + parseInt(expires_in);
                const { user, error } = yield this.api.getUser(access_token);
                if (error)
                    throw error;
                const session = {
                    provider_token,
                    access_token,
                    expires_in: parseInt(expires_in),
                    expires_at,
                    refresh_token,
                    token_type,
                    user: user,
                };
                if (options === null || options === void 0 ? void 0 : options.storeSession) {
                    this._saveSession(session);
                    this._notifyAllSubscribers('SIGNED_IN');
                    if (getParameterByName('type') === 'recovery') {
                        this._notifyAllSubscribers('PASSWORD_RECOVERY');
                    }
                }
                // Remove tokens from URL
                window.location.hash = '';
                return { data: session, error: null };
            }
            catch (error) {
                return { data: null, error };
            }
        });
    }
    /**
     * Inside a browser context, `signOut()` will remove extract the logged in user from the browser session
     * and log them out - removing all items from localstorage and then trigger a "SIGNED_OUT" event.
     *
     * For server-side management, you can disable sessions by passing a JWT through to `auth.api.signOut(JWT: string)`
     */
    signOut() {
        var _a;
        return __awaiter$2(this, void 0, void 0, function* () {
            const accessToken = (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token;
            this._removeSession();
            this._notifyAllSubscribers('SIGNED_OUT');
            if (accessToken) {
                const { error } = yield this.api.signOut(accessToken);
                if (error)
                    return { error };
            }
            return { error: null };
        });
    }
    /**
     * Receive a notification every time an auth event happens.
     * @returns {Subscription} A subscription object which can be used to unsubscribe itself.
     */
    onAuthStateChange(callback) {
        try {
            const id = uuid();
            const self = this;
            const subscription = {
                id,
                callback,
                unsubscribe: () => {
                    self.stateChangeEmitters.delete(id);
                },
            };
            this.stateChangeEmitters.set(id, subscription);
            return { data: subscription, error: null };
        }
        catch (error) {
            return { data: null, error };
        }
    }
    _handleEmailSignIn(email, password, options = {}) {
        var _a;
        return __awaiter$2(this, void 0, void 0, function* () {
            try {
                const { data, error } = yield this.api.signInWithEmail(email, password, {
                    redirectTo: options.redirectTo,
                });
                if (error || !data)
                    return { data: null, user: null, session: null, error };
                if ((_a = data === null || data === void 0 ? void 0 : data.user) === null || _a === void 0 ? void 0 : _a.confirmed_at) {
                    this._saveSession(data);
                    this._notifyAllSubscribers('SIGNED_IN');
                }
                return { data, user: data.user, session: data, error: null };
            }
            catch (error) {
                return { data: null, user: null, session: null, error };
            }
        });
    }
    _handleProviderSignIn(provider, options = {}) {
        const url = this.api.getUrlForProvider(provider, {
            redirectTo: options.redirectTo,
            scopes: options.scopes,
        });
        try {
            // try to open on the browser
            if (isBrowser()) {
                window.location.href = url;
            }
            return { provider, url, data: null, session: null, user: null, error: null };
        }
        catch (error) {
            // fallback to returning the URL
            if (!!url)
                return { provider, url, data: null, session: null, user: null, error: null };
            return { data: null, user: null, session: null, error };
        }
    }
    /**
     * Attempts to get the session from LocalStorage
     * Note: this should never be async (even for React Native), as we need it to return immediately in the constructor.
     */
    _recoverSession() {
        var _a;
        try {
            const json = isBrowser() && ((_a = this.localStorage) === null || _a === void 0 ? void 0 : _a.getItem(STORAGE_KEY));
            if (!json || typeof json !== 'string') {
                return null;
            }
            const data = JSON.parse(json);
            const { currentSession, expiresAt } = data;
            const timeNow = Math.round(Date.now() / 1000);
            if (expiresAt >= timeNow && (currentSession === null || currentSession === void 0 ? void 0 : currentSession.user)) {
                this._saveSession(currentSession);
                this._notifyAllSubscribers('SIGNED_IN');
            }
        }
        catch (error) {
            console.log('error', error);
        }
    }
    /**
     * Recovers the session from LocalStorage and refreshes
     * Note: this method is async to accommodate for AsyncStorage e.g. in React native.
     */
    _recoverAndRefresh() {
        return __awaiter$2(this, void 0, void 0, function* () {
            try {
                const json = isBrowser() && (yield this.localStorage.getItem(STORAGE_KEY));
                if (!json) {
                    return null;
                }
                const data = JSON.parse(json);
                const { currentSession, expiresAt } = data;
                const timeNow = Math.round(Date.now() / 1000);
                if (expiresAt < timeNow) {
                    if (this.autoRefreshToken && currentSession.refresh_token) {
                        const { error } = yield this._callRefreshToken(currentSession.refresh_token);
                        if (error) {
                            console.log(error.message);
                            yield this._removeSession();
                        }
                    }
                    else {
                        this._removeSession();
                    }
                }
                else if (!currentSession || !currentSession.user) {
                    console.log('Current session is missing data.');
                    this._removeSession();
                }
                else {
                    // should be handled on _recoverSession method already
                    // But we still need the code here to accommodate for AsyncStorage e.g. in React native
                    this._saveSession(currentSession);
                    this._notifyAllSubscribers('SIGNED_IN');
                }
            }
            catch (err) {
                console.error(err);
                return null;
            }
        });
    }
    _callRefreshToken(refresh_token) {
        var _a;
        if (refresh_token === void 0) { refresh_token = (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.refresh_token; }
        return __awaiter$2(this, void 0, void 0, function* () {
            try {
                if (!refresh_token) {
                    throw new Error('No current session.');
                }
                const { data, error } = yield this.api.refreshAccessToken(refresh_token);
                if (error)
                    throw error;
                if (!data)
                    throw Error('Invalid session data.');
                this._saveSession(data);
                this._notifyAllSubscribers('SIGNED_IN');
                return { data, error: null };
            }
            catch (error) {
                return { data: null, error };
            }
        });
    }
    _notifyAllSubscribers(event) {
        this.stateChangeEmitters.forEach((x) => x.callback(event, this.currentSession));
    }
    /**
     * set currentSession and currentUser
     * process to _startAutoRefreshToken if possible
     */
    _saveSession(session) {
        this.currentSession = session;
        this.currentUser = session.user;
        const expiresAt = session.expires_at;
        if (expiresAt) {
            const timeNow = Math.round(Date.now() / 1000);
            const expiresIn = expiresAt - timeNow;
            const refreshDurationBeforeExpires = expiresIn > 60 ? 60 : 0.5;
            this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1000);
        }
        // Do we need any extra check before persist session
        // access_token or user ?
        if (this.persistSession && session.expires_at) {
            this._persistSession(this.currentSession);
        }
    }
    _persistSession(currentSession) {
        const data = { currentSession, expiresAt: currentSession.expires_at };
        isBrowser() && this.localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
    }
    _removeSession() {
        return __awaiter$2(this, void 0, void 0, function* () {
            this.currentSession = null;
            this.currentUser = null;
            if (this.refreshTokenTimer)
                clearTimeout(this.refreshTokenTimer);
            isBrowser() && (yield this.localStorage.removeItem(STORAGE_KEY));
        });
    }
    /**
     * Clear and re-create refresh token timer
     * @param value time intervals in milliseconds
     */
    _startAutoRefreshToken(value) {
        if (this.refreshTokenTimer)
            clearTimeout(this.refreshTokenTimer);
        if (value <= 0 || !this.autoRefreshToken)
            return;
        this.refreshTokenTimer = setTimeout(() => this._callRefreshToken(), value);
        if (typeof this.refreshTokenTimer.unref === 'function')
            this.refreshTokenTimer.unref();
    }
}

class SupabaseAuthClient extends GoTrueClient {
    constructor(options) {
        super(options);
    }
}

var __awaiter$3 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class PostgrestBuilder {
    constructor(builder) {
        Object.assign(this, builder);
    }
    /**
     * If there's an error with the query, throwOnError will reject the promise by
     * throwing the error instead of returning it as part of a successful response.
     *
     * {@link https://github.com/supabase/supabase-js/issues/92}
     */
    throwOnError() {
        this.shouldThrowOnError = true;
        return this;
    }
    then(onfulfilled, onrejected) {
        // https://postgrest.org/en/stable/api.html#switching-schemas
        if (typeof this.schema === 'undefined') ;
        else if (['GET', 'HEAD'].includes(this.method)) {
            this.headers['Accept-Profile'] = this.schema;
        }
        else {
            this.headers['Content-Profile'] = this.schema;
        }
        if (this.method !== 'GET' && this.method !== 'HEAD') {
            this.headers['Content-Type'] = 'application/json';
        }
        return fetch$1(this.url.toString(), {
            method: this.method,
            headers: this.headers,
            body: JSON.stringify(this.body),
        })
            .then((res) => __awaiter$3(this, void 0, void 0, function* () {
            var _a, _b, _c;
            let error = null;
            let data = null;
            let count = null;
            if (res.ok) {
                const isReturnMinimal = (_a = this.headers['Prefer']) === null || _a === void 0 ? void 0 : _a.split(',').includes('return=minimal');
                if (this.method !== 'HEAD' && !isReturnMinimal) {
                    const text = yield res.text();
                    if (!text) ;
                    else if (this.headers['Accept'] === 'text/csv') {
                        data = text;
                    }
                    else {
                        data = JSON.parse(text);
                    }
                }
                const countHeader = (_b = this.headers['Prefer']) === null || _b === void 0 ? void 0 : _b.match(/count=(exact|planned|estimated)/);
                const contentRange = (_c = res.headers.get('content-range')) === null || _c === void 0 ? void 0 : _c.split('/');
                if (countHeader && contentRange && contentRange.length > 1) {
                    count = parseInt(contentRange[1]);
                }
            }
            else {
                error = yield res.json();
                if (error && this.shouldThrowOnError) {
                    throw error;
                }
            }
            const postgrestResponse = {
                error,
                data,
                count,
                status: res.status,
                statusText: res.statusText,
                body: data,
            };
            return postgrestResponse;
        }))
            .then(onfulfilled, onrejected);
    }
}

/**
 * Post-filters (transforms)
 */
class PostgrestTransformBuilder extends PostgrestBuilder {
    /**
     * Performs vertical filtering with SELECT.
     *
     * @param columns  The columns to retrieve, separated by commas.
     */
    select(columns = '*') {
        // Remove whitespaces except when quoted
        let quoted = false;
        const cleanedColumns = columns
            .split('')
            .map((c) => {
            if (/\s/.test(c) && !quoted) {
                return '';
            }
            if (c === '"') {
                quoted = !quoted;
            }
            return c;
        })
            .join('');
        this.url.searchParams.set('select', cleanedColumns);
        return this;
    }
    /**
     * Orders the result with the specified `column`.
     *
     * @param column  The column to order on.
     * @param ascending  If `true`, the result will be in ascending order.
     * @param nullsFirst  If `true`, `null`s appear first.
     * @param foreignTable  The foreign table to use (if `column` is a foreign column).
     */
    order(column, { ascending = true, nullsFirst = false, foreignTable, } = {}) {
        const key = typeof foreignTable === 'undefined' ? 'order' : `${foreignTable}.order`;
        const existingOrder = this.url.searchParams.get(key);
        this.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : ''}${column}.${ascending ? 'asc' : 'desc'}.${nullsFirst ? 'nullsfirst' : 'nullslast'}`);
        return this;
    }
    /**
     * Limits the result with the specified `count`.
     *
     * @param count  The maximum no. of rows to limit to.
     * @param foreignTable  The foreign table to use (for foreign columns).
     */
    limit(count, { foreignTable } = {}) {
        const key = typeof foreignTable === 'undefined' ? 'limit' : `${foreignTable}.limit`;
        this.url.searchParams.set(key, `${count}`);
        return this;
    }
    /**
     * Limits the result to rows within the specified range, inclusive.
     *
     * @param from  The starting index from which to limit the result, inclusive.
     * @param to  The last index to which to limit the result, inclusive.
     * @param foreignTable  The foreign table to use (for foreign columns).
     */
    range(from, to, { foreignTable } = {}) {
        const keyOffset = typeof foreignTable === 'undefined' ? 'offset' : `${foreignTable}.offset`;
        const keyLimit = typeof foreignTable === 'undefined' ? 'limit' : `${foreignTable}.limit`;
        this.url.searchParams.set(keyOffset, `${from}`);
        // Range is inclusive, so add 1
        this.url.searchParams.set(keyLimit, `${to - from + 1}`);
        return this;
    }
    /**
     * Retrieves only one row from the result. Result must be one row (e.g. using
     * `limit`), otherwise this will result in an error.
     */
    single() {
        this.headers['Accept'] = 'application/vnd.pgrst.object+json';
        return this;
    }
    /**
     * Retrieves at most one row from the result. Result must be at most one row
     * (e.g. using `eq` on a UNIQUE column), otherwise this will result in an
     * error.
     */
    maybeSingle() {
        this.headers['Accept'] = 'application/vnd.pgrst.object+json';
        const _this = new PostgrestTransformBuilder(this);
        _this.then = ((onfulfilled, onrejected) => this.then((res) => {
            var _a;
            if ((_a = res.error) === null || _a === void 0 ? void 0 : _a.details.includes('Results contain 0 rows')) {
                return onfulfilled({
                    error: null,
                    data: null,
                    count: res.count,
                    status: 200,
                    statusText: 'OK',
                    body: null,
                });
            }
            return onfulfilled(res);
        }, onrejected));
        return _this;
    }
    /**
     * Set the response type to CSV.
     */
    csv() {
        this.headers['Accept'] = 'text/csv';
        return this;
    }
}

class PostgrestFilterBuilder extends PostgrestTransformBuilder {
    constructor() {
        super(...arguments);
        /** @deprecated Use `contains()` instead. */
        this.cs = this.contains;
        /** @deprecated Use `containedBy()` instead. */
        this.cd = this.containedBy;
        /** @deprecated Use `rangeLt()` instead. */
        this.sl = this.rangeLt;
        /** @deprecated Use `rangeGt()` instead. */
        this.sr = this.rangeGt;
        /** @deprecated Use `rangeGte()` instead. */
        this.nxl = this.rangeGte;
        /** @deprecated Use `rangeLte()` instead. */
        this.nxr = this.rangeLte;
        /** @deprecated Use `rangeAdjacent()` instead. */
        this.adj = this.rangeAdjacent;
        /** @deprecated Use `overlaps()` instead. */
        this.ov = this.overlaps;
    }
    /**
     * Finds all rows which doesn't satisfy the filter.
     *
     * @param column  The column to filter on.
     * @param operator  The operator to filter with.
     * @param value  The value to filter with.
     */
    not(column, operator, value) {
        this.url.searchParams.append(`${column}`, `not.${operator}.${value}`);
        return this;
    }
    /**
     * Finds all rows satisfying at least one of the filters.
     *
     * @param filters  The filters to use, separated by commas.
     * @param foreignTable  The foreign table to use (if `column` is a foreign column).
     */
    or(filters, { foreignTable } = {}) {
        const key = typeof foreignTable === 'undefined' ? 'or' : `${foreignTable}.or`;
        this.url.searchParams.append(key, `(${filters})`);
        return this;
    }
    /**
     * Finds all rows whose value on the stated `column` exactly matches the
     * specified `value`.
     *
     * @param column  The column to filter on.
     * @param value  The value to filter with.
     */
    eq(column, value) {
        this.url.searchParams.append(`${column}`, `eq.${value}`);
        return this;
    }
    /**
     * Finds all rows whose value on the stated `column` doesn't match the
     * specified `value`.
     *
     * @param column  The column to filter on.
     * @param value  The value to filter with.
     */
    neq(column, value) {
        this.url.searchParams.append(`${column}`, `neq.${value}`);
        return this;
    }
    /**
     * Finds all rows whose value on the stated `column` is greater than the
     * specified `value`.
     *
     * @param column  The column to filter on.
     * @param value  The value to filter with.
     */
    gt(column, value) {
        this.url.searchParams.append(`${column}`, `gt.${value}`);
        return this;
    }
    /**
     * Finds all rows whose value on the stated `column` is greater than or
     * equal to the specified `value`.
     *
     * @param column  The column to filter on.
     * @param value  The value to filter with.
     */
    gte(column, value) {
        this.url.searchParams.append(`${column}`, `gte.${value}`);
        return this;
    }
    /**
     * Finds all rows whose value on the stated `column` is less than the
     * specified `value`.
     *
     * @param column  The column to filter on.
     * @param value  The value to filter with.
     */
    lt(column, value) {
        this.url.searchParams.append(`${column}`, `lt.${value}`);
        return this;
    }
    /**
     * Finds all rows whose value on the stated `column` is less than or equal
     * to the specified `value`.
     *
     * @param column  The column to filter on.
     * @param value  The value to filter with.
     */
    lte(column, value) {
        this.url.searchParams.append(`${column}`, `lte.${value}`);
        return this;
    }
    /**
     * Finds all rows whose value in the stated `column` matches the supplied
     * `pattern` (case sensitive).
     *
     * @param column  The column to filter on.
     * @param pattern  The pattern to filter with.
     */
    like(column, pattern) {
        this.url.searchParams.append(`${column}`, `like.${pattern}`);
        return this;
    }
    /**
     * Finds all rows whose value in the stated `column` matches the supplied
     * `pattern` (case insensitive).
     *
     * @param column  The column to filter on.
     * @param pattern  The pattern to filter with.
     */
    ilike(column, pattern) {
        this.url.searchParams.append(`${column}`, `ilike.${pattern}`);
        return this;
    }
    /**
     * A check for exact equality (null, true, false), finds all rows whose
     * value on the stated `column` exactly match the specified `value`.
     *
     * @param column  The column to filter on.
     * @param value  The value to filter with.
     */
    is(column, value) {
        this.url.searchParams.append(`${column}`, `is.${value}`);
        return this;
    }
    /**
     * Finds all rows whose value on the stated `column` is found on the
     * specified `values`.
     *
     * @param column  The column to filter on.
     * @param values  The values to filter with.
     */
    in(column, values) {
        const cleanedValues = values
            .map((s) => {
            // handle postgrest reserved characters
            // https://postgrest.org/en/v7.0.0/api.html#reserved-characters
            if (typeof s === 'string' && new RegExp('[,()]').test(s))
                return `"${s}"`;
            else
                return `${s}`;
        })
            .join(',');
        this.url.searchParams.append(`${column}`, `in.(${cleanedValues})`);
        return this;
    }
    /**
     * Finds all rows whose json, array, or range value on the stated `column`
     * contains the values specified in `value`.
     *
     * @param column  The column to filter on.
     * @param value  The value to filter with.
     */
    contains(column, value) {
        if (typeof value === 'string') {
            // range types can be inclusive '[', ']' or exclusive '(', ')' so just
            // keep it simple and accept a string
            this.url.searchParams.append(`${column}`, `cs.${value}`);
        }
        else if (Array.isArray(value)) {
            // array
            this.url.searchParams.append(`${column}`, `cs.{${value.join(',')}}`);
        }
        else {
            // json
            this.url.searchParams.append(`${column}`, `cs.${JSON.stringify(value)}`);
        }
        return this;
    }
    /**
     * Finds all rows whose json, array, or range value on the stated `column` is
     * contained by the specified `value`.
     *
     * @param column  The column to filter on.
     * @param value  The value to filter with.
     */
    containedBy(column, value) {
        if (typeof value === 'string') {
            // range
            this.url.searchParams.append(`${column}`, `cd.${value}`);
        }
        else if (Array.isArray(value)) {
            // array
            this.url.searchParams.append(`${column}`, `cd.{${value.join(',')}}`);
        }
        else {
            // json
            this.url.searchParams.append(`${column}`, `cd.${JSON.stringify(value)}`);
        }
        return this;
    }
    /**
     * Finds all rows whose range value on the stated `column` is strictly to the
     * left of the specified `range`.
     *
     * @param column  The column to filter on.
     * @param range  The range to filter with.
     */
    rangeLt(column, range) {
        this.url.searchParams.append(`${column}`, `sl.${range}`);
        return this;
    }
    /**
     * Finds all rows whose range value on the stated `column` is strictly to
     * the right of the specified `range`.
     *
     * @param column  The column to filter on.
     * @param range  The range to filter with.
     */
    rangeGt(column, range) {
        this.url.searchParams.append(`${column}`, `sr.${range}`);
        return this;
    }
    /**
     * Finds all rows whose range value on the stated `column` does not extend
     * to the left of the specified `range`.
     *
     * @param column  The column to filter on.
     * @param range  The range to filter with.
     */
    rangeGte(column, range) {
        this.url.searchParams.append(`${column}`, `nxl.${range}`);
        return this;
    }
    /**
     * Finds all rows whose range value on the stated `column` does not extend
     * to the right of the specified `range`.
     *
     * @param column  The column to filter on.
     * @param range  The range to filter with.
     */
    rangeLte(column, range) {
        this.url.searchParams.append(`${column}`, `nxr.${range}`);
        return this;
    }
    /**
     * Finds all rows whose range value on the stated `column` is adjacent to
     * the specified `range`.
     *
     * @param column  The column to filter on.
     * @param range  The range to filter with.
     */
    rangeAdjacent(column, range) {
        this.url.searchParams.append(`${column}`, `adj.${range}`);
        return this;
    }
    /**
     * Finds all rows whose array or range value on the stated `column` overlaps
     * (has a value in common) with the specified `value`.
     *
     * @param column  The column to filter on.
     * @param value  The value to filter with.
     */
    overlaps(column, value) {
        if (typeof value === 'string') {
            // range
            this.url.searchParams.append(`${column}`, `ov.${value}`);
        }
        else {
            // array
            this.url.searchParams.append(`${column}`, `ov.{${value.join(',')}}`);
        }
        return this;
    }
    /**
     * Finds all rows whose text or tsvector value on the stated `column` matches
     * the tsquery in `query`.
     *
     * @param column  The column to filter on.
     * @param query  The Postgres tsquery string to filter with.
     * @param config  The text search configuration to use.
     * @param type  The type of tsquery conversion to use on `query`.
     */
    textSearch(column, query, { config, type = null, } = {}) {
        let typePart = '';
        if (type === 'plain') {
            typePart = 'pl';
        }
        else if (type === 'phrase') {
            typePart = 'ph';
        }
        else if (type === 'websearch') {
            typePart = 'w';
        }
        const configPart = config === undefined ? '' : `(${config})`;
        this.url.searchParams.append(`${column}`, `${typePart}fts${configPart}.${query}`);
        return this;
    }
    /**
     * Finds all rows whose tsvector value on the stated `column` matches
     * to_tsquery(`query`).
     *
     * @param column  The column to filter on.
     * @param query  The Postgres tsquery string to filter with.
     * @param config  The text search configuration to use.
     *
     * @deprecated Use `textSearch()` instead.
     */
    fts(column, query, { config } = {}) {
        const configPart = typeof config === 'undefined' ? '' : `(${config})`;
        this.url.searchParams.append(`${column}`, `fts${configPart}.${query}`);
        return this;
    }
    /**
     * Finds all rows whose tsvector value on the stated `column` matches
     * plainto_tsquery(`query`).
     *
     * @param column  The column to filter on.
     * @param query  The Postgres tsquery string to filter with.
     * @param config  The text search configuration to use.
     *
     * @deprecated Use `textSearch()` with `type: 'plain'` instead.
     */
    plfts(column, query, { config } = {}) {
        const configPart = typeof config === 'undefined' ? '' : `(${config})`;
        this.url.searchParams.append(`${column}`, `plfts${configPart}.${query}`);
        return this;
    }
    /**
     * Finds all rows whose tsvector value on the stated `column` matches
     * phraseto_tsquery(`query`).
     *
     * @param column  The column to filter on.
     * @param query  The Postgres tsquery string to filter with.
     * @param config  The text search configuration to use.
     *
     * @deprecated Use `textSearch()` with `type: 'phrase'` instead.
     */
    phfts(column, query, { config } = {}) {
        const configPart = typeof config === 'undefined' ? '' : `(${config})`;
        this.url.searchParams.append(`${column}`, `phfts${configPart}.${query}`);
        return this;
    }
    /**
     * Finds all rows whose tsvector value on the stated `column` matches
     * websearch_to_tsquery(`query`).
     *
     * @param column  The column to filter on.
     * @param query  The Postgres tsquery string to filter with.
     * @param config  The text search configuration to use.
     *
     * @deprecated Use `textSearch()` with `type: 'websearch'` instead.
     */
    wfts(column, query, { config } = {}) {
        const configPart = typeof config === 'undefined' ? '' : `(${config})`;
        this.url.searchParams.append(`${column}`, `wfts${configPart}.${query}`);
        return this;
    }
    /**
     * Finds all rows whose `column` satisfies the filter.
     *
     * @param column  The column to filter on.
     * @param operator  The operator to filter with.
     * @param value  The value to filter with.
     */
    filter(column, operator, value) {
        this.url.searchParams.append(`${column}`, `${operator}.${value}`);
        return this;
    }
    /**
     * Finds all rows whose columns match the specified `query` object.
     *
     * @param query  The object to filter with, with column names as keys mapped
     *               to their filter values.
     */
    match(query) {
        Object.keys(query).forEach((key) => {
            this.url.searchParams.append(`${key}`, `eq.${query[key]}`);
        });
        return this;
    }
}

class PostgrestQueryBuilder extends PostgrestBuilder {
    constructor(url, { headers = {}, schema } = {}) {
        super({});
        this.url = new URL(url);
        this.headers = Object.assign({}, headers);
        this.schema = schema;
    }
    /**
     * Performs vertical filtering with SELECT.
     *
     * @param columns  The columns to retrieve, separated by commas.
     * @param head  When set to true, select will void data.
     * @param count  Count algorithm to use to count rows in a table.
     */
    select(columns = '*', { head = false, count = null, } = {}) {
        this.method = 'GET';
        // Remove whitespaces except when quoted
        let quoted = false;
        const cleanedColumns = columns
            .split('')
            .map((c) => {
            if (/\s/.test(c) && !quoted) {
                return '';
            }
            if (c === '"') {
                quoted = !quoted;
            }
            return c;
        })
            .join('');
        this.url.searchParams.set('select', cleanedColumns);
        if (count) {
            this.headers['Prefer'] = `count=${count}`;
        }
        if (head) {
            this.method = 'HEAD';
        }
        return new PostgrestFilterBuilder(this);
    }
    insert(values, { upsert = false, onConflict, returning = 'representation', count = null, } = {}) {
        this.method = 'POST';
        const prefersHeaders = [`return=${returning}`];
        if (upsert)
            prefersHeaders.push('resolution=merge-duplicates');
        if (upsert && onConflict !== undefined)
            this.url.searchParams.set('on_conflict', onConflict);
        this.body = values;
        if (count) {
            prefersHeaders.push(`count=${count}`);
        }
        this.headers['Prefer'] = prefersHeaders.join(',');
        if (Array.isArray(values)) {
            const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);
            if (columns.length > 0) {
                const uniqueColumns = [...new Set(columns)];
                this.url.searchParams.set('columns', uniqueColumns.join(','));
            }
        }
        return new PostgrestFilterBuilder(this);
    }
    /**
     * Performs an UPSERT into the table.
     *
     * @param values  The values to insert.
     * @param onConflict  By specifying the `on_conflict` query parameter, you can make UPSERT work on a column(s) that has a UNIQUE constraint.
     * @param returning  By default the new record is returned. Set this to 'minimal' if you don't need this value.
     * @param count  Count algorithm to use to count rows in a table.
     * @param ignoreDuplicates  Specifies if duplicate rows should be ignored and not inserted.
     */
    upsert(values, { onConflict, returning = 'representation', count = null, ignoreDuplicates = false, } = {}) {
        this.method = 'POST';
        const prefersHeaders = [
            `resolution=${ignoreDuplicates ? 'ignore' : 'merge'}-duplicates`,
            `return=${returning}`,
        ];
        if (onConflict !== undefined)
            this.url.searchParams.set('on_conflict', onConflict);
        this.body = values;
        if (count) {
            prefersHeaders.push(`count=${count}`);
        }
        this.headers['Prefer'] = prefersHeaders.join(',');
        return new PostgrestFilterBuilder(this);
    }
    /**
     * Performs an UPDATE on the table.
     *
     * @param values  The values to update.
     * @param returning  By default the updated record is returned. Set this to 'minimal' if you don't need this value.
     * @param count  Count algorithm to use to count rows in a table.
     */
    update(values, { returning = 'representation', count = null, } = {}) {
        this.method = 'PATCH';
        const prefersHeaders = [`return=${returning}`];
        this.body = values;
        if (count) {
            prefersHeaders.push(`count=${count}`);
        }
        this.headers['Prefer'] = prefersHeaders.join(',');
        return new PostgrestFilterBuilder(this);
    }
    /**
     * Performs a DELETE on the table.
     *
     * @param returning  If `true`, return the deleted row(s) in the response.
     * @param count  Count algorithm to use to count rows in a table.
     */
    delete({ returning = 'representation', count = null, } = {}) {
        this.method = 'DELETE';
        const prefersHeaders = [`return=${returning}`];
        if (count) {
            prefersHeaders.push(`count=${count}`);
        }
        this.headers['Prefer'] = prefersHeaders.join(',');
        return new PostgrestFilterBuilder(this);
    }
}

class PostgrestRpcBuilder extends PostgrestBuilder {
    constructor(url, { headers = {}, schema } = {}) {
        super({});
        this.url = new URL(url);
        this.headers = Object.assign({}, headers);
        this.schema = schema;
    }
    /**
     * Perform a stored procedure call.
     */
    rpc(params, { count = null, } = {}) {
        this.method = 'POST';
        this.body = params;
        if (count) {
            if (this.headers['Prefer'] !== undefined)
                this.headers['Prefer'] += `,count=${count}`;
            else
                this.headers['Prefer'] = `count=${count}`;
        }
        return new PostgrestFilterBuilder(this);
    }
}

class PostgrestClient {
    /**
     * Creates a PostgREST client.
     *
     * @param url  URL of the PostgREST endpoint.
     * @param headers  Custom headers.
     * @param schema  Postgres schema to switch to.
     */
    constructor(url, { headers = {}, schema } = {}) {
        this.url = url;
        this.headers = headers;
        this.schema = schema;
    }
    /**
     * Authenticates the request with JWT.
     *
     * @param token  The JWT token to use.
     */
    auth(token) {
        this.headers['Authorization'] = `Bearer ${token}`;
        return this;
    }
    /**
     * Perform a table operation.
     *
     * @param table  The table name to operate on.
     */
    from(table) {
        const url = `${this.url}/${table}`;
        return new PostgrestQueryBuilder(url, { headers: this.headers, schema: this.schema });
    }
    /**
     * Perform a stored procedure call.
     *
     * @param fn  The function name to call.
     * @param params  The parameters to pass to the function call.
     * @param count  Count algorithm to use to count rows in a table.
     */
    rpc(fn, params, { count = null, } = {}) {
        const url = `${this.url}/rpc/${fn}`;
        return new PostgrestRpcBuilder(url, {
            headers: this.headers,
            schema: this.schema,
        }).rpc(params, { count });
    }
}

/**
 * Helpers to convert the change Payload into native JS types.
 */
// Adapted from epgsql (src/epgsql_binary.erl), this module licensed under
// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE
var PostgresTypes;
(function (PostgresTypes) {
    PostgresTypes["abstime"] = "abstime";
    PostgresTypes["bool"] = "bool";
    PostgresTypes["date"] = "date";
    PostgresTypes["daterange"] = "daterange";
    PostgresTypes["float4"] = "float4";
    PostgresTypes["float8"] = "float8";
    PostgresTypes["int2"] = "int2";
    PostgresTypes["int4"] = "int4";
    PostgresTypes["int4range"] = "int4range";
    PostgresTypes["int8"] = "int8";
    PostgresTypes["int8range"] = "int8range";
    PostgresTypes["json"] = "json";
    PostgresTypes["jsonb"] = "jsonb";
    PostgresTypes["money"] = "money";
    PostgresTypes["numeric"] = "numeric";
    PostgresTypes["oid"] = "oid";
    PostgresTypes["reltime"] = "reltime";
    PostgresTypes["time"] = "time";
    PostgresTypes["timestamp"] = "timestamp";
    PostgresTypes["timestamptz"] = "timestamptz";
    PostgresTypes["timetz"] = "timetz";
    PostgresTypes["tsrange"] = "tsrange";
    PostgresTypes["tstzrange"] = "tstzrange";
})(PostgresTypes || (PostgresTypes = {}));
/**
 * Takes an array of columns and an object of string values then converts each string value
 * to its mapped type.
 *
 * @param {{name: String, type: String}[]} columns
 * @param {Object} records
 * @param {Object} options The map of various options that can be applied to the mapper
 * @param {Array} options.skipTypes The array of types that should not be converted
 *
 * @example convertChangeData([{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age:'33'}, {})
 * //=>{ first_name: 'Paul', age: 33 }
 */
const convertChangeData = (columns, records, options = {}) => {
    let result = {};
    let skipTypes = typeof options.skipTypes !== 'undefined' ? options.skipTypes : [];
    Object.entries(records).map(([key, value]) => {
        result[key] = convertColumn(key, columns, records, skipTypes);
    });
    return result;
};
/**
 * Converts the value of an individual column.
 *
 * @param {String} columnName The column that you want to convert
 * @param {{name: String, type: String}[]} columns All of the columns
 * @param {Object} records The map of string values
 * @param {Array} skipTypes An array of types that should not be converted
 * @return {object} Useless information
 *
 * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], ['Paul', '33'], [])
 * //=> 33
 * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], ['Paul', '33'], ['int4'])
 * //=> "33"
 */
const convertColumn = (columnName, columns, records, skipTypes) => {
    let column = columns.find((x) => x.name == columnName);
    if (!column || skipTypes.includes(column.type)) {
        return noop$1(records[columnName]);
    }
    else {
        return convertCell(column.type, records[columnName]);
    }
};
/**
 * If the value of the cell is `null`, returns null.
 * Otherwise converts the string value to the correct type.
 * @param {String} type A postgres column type
 * @param {String} stringValue The cell value
 *
 * @example convertCell('bool', 'true')
 * //=> true
 * @example convertCell('int8', '10')
 * //=> 10
 * @example convertCell('_int4', '{1,2,3,4}')
 * //=> [1,2,3,4]
 */
const convertCell = (type, stringValue) => {
    try {
        if (stringValue === null)
            return null;
        // if data type is an array
        if (type.charAt(0) === '_') {
            let arrayValue = type.slice(1, type.length);
            return toArray(stringValue, arrayValue);
        }
        // If not null, convert to correct type.
        switch (type) {
            case PostgresTypes.abstime:
                return noop$1(stringValue); // To allow users to cast it based on Timezone
            case PostgresTypes.bool:
                return toBoolean(stringValue);
            case PostgresTypes.date:
                return noop$1(stringValue); // To allow users to cast it based on Timezone
            case PostgresTypes.daterange:
                return toDateRange(stringValue);
            case PostgresTypes.float4:
                return toFloat(stringValue);
            case PostgresTypes.float8:
                return toFloat(stringValue);
            case PostgresTypes.int2:
                return toInt(stringValue);
            case PostgresTypes.int4:
                return toInt(stringValue);
            case PostgresTypes.int4range:
                return toIntRange(stringValue);
            case PostgresTypes.int8:
                return toInt(stringValue);
            case PostgresTypes.int8range:
                return toIntRange(stringValue);
            case PostgresTypes.json:
                return toJson(stringValue);
            case PostgresTypes.jsonb:
                return toJson(stringValue);
            case PostgresTypes.money:
                return toFloat(stringValue);
            case PostgresTypes.numeric:
                return toFloat(stringValue);
            case PostgresTypes.oid:
                return toInt(stringValue);
            case PostgresTypes.reltime:
                return noop$1(stringValue); // To allow users to cast it based on Timezone
            case PostgresTypes.time:
                return noop$1(stringValue); // To allow users to cast it based on Timezone
            case PostgresTypes.timestamp:
                return toTimestampString(stringValue); // Format to be consistent with PostgREST
            case PostgresTypes.timestamptz:
                return noop$1(stringValue); // To allow users to cast it based on Timezone
            case PostgresTypes.timetz:
                return noop$1(stringValue); // To allow users to cast it based on Timezone
            case PostgresTypes.tsrange:
                return toDateRange(stringValue);
            case PostgresTypes.tstzrange:
                return toDateRange(stringValue);
            default:
                // All the rest will be returned as strings
                return noop$1(stringValue);
        }
    }
    catch (error) {
        console.log(`Could not convert cell of type ${type} and value ${stringValue}`);
        console.log(`This is the error: ${error}`);
        return stringValue;
    }
};
const noop$1 = (stringValue) => {
    return stringValue;
};
const toBoolean = (stringValue) => {
    switch (stringValue) {
        case 't':
            return true;
        case 'f':
            return false;
        default:
            return null;
    }
};
const toDateRange = (stringValue) => {
    let arr = JSON.parse(stringValue);
    return [new Date(arr[0]), new Date(arr[1])];
};
const toFloat = (stringValue) => {
    return parseFloat(stringValue);
};
const toInt = (stringValue) => {
    return parseInt(stringValue);
};
const toIntRange = (stringValue) => {
    let arr = JSON.parse(stringValue);
    return [parseInt(arr[0]), parseInt(arr[1])];
};
const toJson = (stringValue) => {
    return JSON.parse(stringValue);
};
/**
 * Converts a Postgres Array into a native JS array
 *
 * @example toArray('{1,2,3,4}', 'int4')
 * //=> [1,2,3,4]
 * @example toArray('{}', 'int4')
 * //=> []
 */
const toArray = (stringValue, type) => {
    // this takes off the '{' & '}'
    let stringEnriched = stringValue.slice(1, stringValue.length - 1);
    // converts the string into an array
    // if string is empty (meaning the array was empty), an empty array will be immediately returned
    let stringArray = stringEnriched.length > 0 ? stringEnriched.split(',') : [];
    let array = stringArray.map((string) => {
        return convertCell(type, string);
    });
    return array;
};
/**
 * Fixes timestamp to be ISO-8601. Swaps the space between the date and time for a 'T'
 * See https://github.com/supabase/supabase/issues/18
 *
 * @example toTimestampString('2019-09-10 00:00:00')
 * //=> '2019-09-10T00:00:00'
 */
const toTimestampString = (stringValue) => {
    return stringValue.replace(' ', 'T');
};

const VSN = '1.0.0';
const DEFAULT_TIMEOUT = 10000;
const WS_CLOSE_NORMAL = 1000;
var SOCKET_STATES;
(function (SOCKET_STATES) {
    SOCKET_STATES[SOCKET_STATES["connecting"] = 0] = "connecting";
    SOCKET_STATES[SOCKET_STATES["open"] = 1] = "open";
    SOCKET_STATES[SOCKET_STATES["closing"] = 2] = "closing";
    SOCKET_STATES[SOCKET_STATES["closed"] = 3] = "closed";
})(SOCKET_STATES || (SOCKET_STATES = {}));
var CHANNEL_STATES;
(function (CHANNEL_STATES) {
    CHANNEL_STATES["closed"] = "closed";
    CHANNEL_STATES["errored"] = "errored";
    CHANNEL_STATES["joined"] = "joined";
    CHANNEL_STATES["joining"] = "joining";
    CHANNEL_STATES["leaving"] = "leaving";
})(CHANNEL_STATES || (CHANNEL_STATES = {}));
var CHANNEL_EVENTS;
(function (CHANNEL_EVENTS) {
    CHANNEL_EVENTS["close"] = "phx_close";
    CHANNEL_EVENTS["error"] = "phx_error";
    CHANNEL_EVENTS["join"] = "phx_join";
    CHANNEL_EVENTS["reply"] = "phx_reply";
    CHANNEL_EVENTS["leave"] = "phx_leave";
})(CHANNEL_EVENTS || (CHANNEL_EVENTS = {}));
var TRANSPORTS;
(function (TRANSPORTS) {
    TRANSPORTS["websocket"] = "websocket";
})(TRANSPORTS || (TRANSPORTS = {}));

/**
 * Creates a timer that accepts a `timerCalc` function to perform calculated timeout retries, such as exponential backoff.
 *
 * @example
 *    let reconnectTimer = new Timer(() => this.connect(), function(tries){
 *      return [1000, 5000, 10000][tries - 1] || 10000
 *    })
 *    reconnectTimer.scheduleTimeout() // fires after 1000
 *    reconnectTimer.scheduleTimeout() // fires after 5000
 *    reconnectTimer.reset()
 *    reconnectTimer.scheduleTimeout() // fires after 1000
 */
class Timer {
    constructor(callback, timerCalc) {
        this.callback = callback;
        this.timerCalc = timerCalc;
        this.timer = undefined;
        this.tries = 0;
        this.callback = callback;
        this.timerCalc = timerCalc;
    }
    reset() {
        this.tries = 0;
        clearTimeout(this.timer);
    }
    // Cancels any previous scheduleTimeout and schedules callback
    scheduleTimeout() {
        clearTimeout(this.timer);
        this.timer = setTimeout(() => {
            this.tries = this.tries + 1;
            this.callback();
        }, this.timerCalc(this.tries + 1));
    }
}

class Push {
    /**
     * Initializes the Push
     *
     * @param channel The Channel
     * @param event The event, for example `"phx_join"`
     * @param payload The payload, for example `{user_id: 123}`
     * @param timeout The push timeout in milliseconds
     */
    constructor(channel, event, payload = {}, timeout = DEFAULT_TIMEOUT) {
        this.channel = channel;
        this.event = event;
        this.payload = payload;
        this.timeout = timeout;
        this.sent = false;
        this.timeoutTimer = undefined;
        this.ref = '';
        this.receivedResp = null;
        this.recHooks = [];
        this.refEvent = null;
    }
    resend(timeout) {
        this.timeout = timeout;
        this._cancelRefEvent();
        this.ref = '';
        this.refEvent = null;
        this.receivedResp = null;
        this.sent = false;
        this.send();
    }
    send() {
        if (this._hasReceived('timeout')) {
            return;
        }
        this.startTimeout();
        this.sent = true;
        this.channel.socket.push({
            topic: this.channel.topic,
            event: this.event,
            payload: this.payload,
            ref: this.ref,
        });
    }
    receive(status, callback) {
        var _a;
        if (this._hasReceived(status)) {
            callback((_a = this.receivedResp) === null || _a === void 0 ? void 0 : _a.response);
        }
        this.recHooks.push({ status, callback });
        return this;
    }
    startTimeout() {
        if (this.timeoutTimer) {
            return;
        }
        this.ref = this.channel.socket.makeRef();
        this.refEvent = this.channel.replyEventName(this.ref);
        this.channel.on(this.refEvent, (payload) => {
            this._cancelRefEvent();
            this._cancelTimeout();
            this.receivedResp = payload;
            this._matchReceive(payload);
        });
        this.timeoutTimer = setTimeout(() => {
            this.trigger('timeout', {});
        }, this.timeout);
    }
    trigger(status, response) {
        if (this.refEvent)
            this.channel.trigger(this.refEvent, { status, response });
    }
    _cancelRefEvent() {
        if (!this.refEvent) {
            return;
        }
        this.channel.off(this.refEvent);
    }
    _cancelTimeout() {
        clearTimeout(this.timeoutTimer);
        this.timeoutTimer = undefined;
    }
    _matchReceive({ status, response, }) {
        this.recHooks
            .filter((h) => h.status === status)
            .forEach((h) => h.callback(response));
    }
    _hasReceived(status) {
        return this.receivedResp && this.receivedResp.status === status;
    }
}

class RealtimeSubscription {
    constructor(topic, params = {}, socket) {
        this.topic = topic;
        this.params = params;
        this.socket = socket;
        this.bindings = [];
        this.state = CHANNEL_STATES.closed;
        this.joinedOnce = false;
        this.pushBuffer = [];
        this.timeout = this.socket.timeout;
        this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);
        this.rejoinTimer = new Timer(() => this.rejoinUntilConnected(), this.socket.reconnectAfterMs);
        this.joinPush.receive('ok', () => {
            this.state = CHANNEL_STATES.joined;
            this.rejoinTimer.reset();
            this.pushBuffer.forEach((pushEvent) => pushEvent.send());
            this.pushBuffer = [];
        });
        this.onClose(() => {
            this.rejoinTimer.reset();
            this.socket.log('channel', `close ${this.topic} ${this.joinRef()}`);
            this.state = CHANNEL_STATES.closed;
            this.socket.remove(this);
        });
        this.onError((reason) => {
            if (this.isLeaving() || this.isClosed()) {
                return;
            }
            this.socket.log('channel', `error ${this.topic}`, reason);
            this.state = CHANNEL_STATES.errored;
            this.rejoinTimer.scheduleTimeout();
        });
        this.joinPush.receive('timeout', () => {
            if (!this.isJoining()) {
                return;
            }
            this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout);
            this.state = CHANNEL_STATES.errored;
            this.rejoinTimer.scheduleTimeout();
        });
        this.on(CHANNEL_EVENTS.reply, (payload, ref) => {
            this.trigger(this.replyEventName(ref), payload);
        });
    }
    rejoinUntilConnected() {
        this.rejoinTimer.scheduleTimeout();
        if (this.socket.isConnected()) {
            this.rejoin();
        }
    }
    subscribe(timeout = this.timeout) {
        if (this.joinedOnce) {
            throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`;
        }
        else {
            this.joinedOnce = true;
            this.rejoin(timeout);
            return this.joinPush;
        }
    }
    onClose(callback) {
        this.on(CHANNEL_EVENTS.close, callback);
    }
    onError(callback) {
        this.on(CHANNEL_EVENTS.error, (reason) => callback(reason));
    }
    on(event, callback) {
        this.bindings.push({ event, callback });
    }
    off(event) {
        this.bindings = this.bindings.filter((bind) => bind.event !== event);
    }
    canPush() {
        return this.socket.isConnected() && this.isJoined();
    }
    push(event, payload, timeout = this.timeout) {
        if (!this.joinedOnce) {
            throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;
        }
        let pushEvent = new Push(this, event, payload, timeout);
        if (this.canPush()) {
            pushEvent.send();
        }
        else {
            pushEvent.startTimeout();
            this.pushBuffer.push(pushEvent);
        }
        return pushEvent;
    }
    /**
     * Leaves the channel
     *
     * Unsubscribes from server events, and instructs channel to terminate on server.
     * Triggers onClose() hooks.
     *
     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:
     * channel.unsubscribe().receive("ok", () => alert("left!") )
     */
    unsubscribe(timeout = this.timeout) {
        this.state = CHANNEL_STATES.leaving;
        let onClose = () => {
            this.socket.log('channel', `leave ${this.topic}`);
            this.trigger(CHANNEL_EVENTS.close, 'leave', this.joinRef());
        };
        let leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);
        leavePush.receive('ok', () => onClose()).receive('timeout', () => onClose());
        leavePush.send();
        if (!this.canPush()) {
            leavePush.trigger('ok', {});
        }
        return leavePush;
    }
    /**
     * Overridable message hook
     *
     * Receives all events for specialized message handling before dispatching to the channel callbacks.
     * Must return the payload, modified or unmodified.
     */
    onMessage(event, payload, ref) {
        return payload;
    }
    isMember(topic) {
        return this.topic === topic;
    }
    joinRef() {
        return this.joinPush.ref;
    }
    sendJoin(timeout) {
        this.state = CHANNEL_STATES.joining;
        this.joinPush.resend(timeout);
    }
    rejoin(timeout = this.timeout) {
        if (this.isLeaving()) {
            return;
        }
        this.sendJoin(timeout);
    }
    trigger(event, payload, ref) {
        let { close, error, leave, join } = CHANNEL_EVENTS;
        let events = [close, error, leave, join];
        if (ref && events.indexOf(event) >= 0 && ref !== this.joinRef()) {
            return;
        }
        let handledPayload = this.onMessage(event, payload, ref);
        if (payload && !handledPayload) {
            throw 'channel onMessage callbacks must return the payload, modified or unmodified';
        }
        this.bindings
            .filter((bind) => {
            // Bind all events if the user specifies a wildcard.
            if (bind.event === '*') {
                return event === (payload === null || payload === void 0 ? void 0 : payload.type);
            }
            else {
                return bind.event === event;
            }
        })
            .map((bind) => bind.callback(handledPayload, ref));
    }
    replyEventName(ref) {
        return `chan_reply_${ref}`;
    }
    isClosed() {
        return this.state === CHANNEL_STATES.closed;
    }
    isErrored() {
        return this.state === CHANNEL_STATES.errored;
    }
    isJoined() {
        return this.state === CHANNEL_STATES.joined;
    }
    isJoining() {
        return this.state === CHANNEL_STATES.joining;
    }
    isLeaving() {
        return this.state === CHANNEL_STATES.leaving;
    }
}

var naiveFallback = function () {
	if (typeof self === "object" && self) return self;
	if (typeof window === "object" && window) return window;
	throw new Error("Unable to resolve global `this`");
};

var global$1 = (function () {
	if (this) return this;

	// Unexpected strict mode (may happen if e.g. bundled into ESM module)

	// Fallback to standard globalThis if available
	if (typeof globalThis === "object" && globalThis) return globalThis;

	// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis
	// In all ES5+ engines global object inherits from Object.prototype
	// (if you approached one that doesn't please report)
	try {
		Object.defineProperty(Object.prototype, "__global__", {
			get: function () { return this; },
			configurable: true
		});
	} catch (error) {
		// Unfortunate case of updates to Object.prototype being restricted
		// via preventExtensions, seal or freeze
		return naiveFallback();
	}
	try {
		// Safari case (window.__global__ works, but __global__ does not)
		if (!__global__) return naiveFallback();
		return __global__;
	} finally {
		delete Object.prototype.__global__;
	}
})();

var _from = "websocket@^1.0.34";
var _id = "websocket@1.0.34";
var _inBundle = false;
var _integrity = "sha512-PRDso2sGwF6kM75QykIesBijKSVceR6jL2G8NGYyq2XrItNC2P5/qL5XeR056GhA+Ly7JMFvJb9I312mJfmqnQ==";
var _location = "/websocket";
var _phantomChildren = {
};
var _requested = {
	type: "range",
	registry: true,
	raw: "websocket@^1.0.34",
	name: "websocket",
	escapedName: "websocket",
	rawSpec: "^1.0.34",
	saveSpec: null,
	fetchSpec: "^1.0.34"
};
var _requiredBy = [
	"/@supabase/realtime-js"
];
var _resolved = "https://registry.npmjs.org/websocket/-/websocket-1.0.34.tgz";
var _shasum = "2bdc2602c08bf2c82253b730655c0ef7dcab3111";
var _spec = "websocket@^1.0.34";
var _where = "/Users/francisco/Documents/dev/MIMIC/sema/node_modules/@supabase/realtime-js";
var author = {
	name: "Brian McKelvey",
	email: "theturtle32@gmail.com",
	url: "https://github.com/theturtle32"
};
var browser = "lib/browser.js";
var bugs = {
	url: "https://github.com/theturtle32/WebSocket-Node/issues"
};
var bundleDependencies = false;
var config = {
	verbose: false
};
var contributors = [
	{
		name: "Iaki Baz Castillo",
		email: "ibc@aliax.net",
		url: "http://dev.sipdoc.net"
	}
];
var dependencies = {
	bufferutil: "^4.0.1",
	debug: "^2.2.0",
	"es5-ext": "^0.10.50",
	"typedarray-to-buffer": "^3.1.5",
	"utf-8-validate": "^5.0.2",
	yaeti: "^0.0.6"
};
var deprecated = false;
var description = "Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.";
var devDependencies = {
	"buffer-equal": "^1.0.0",
	gulp: "^4.0.2",
	"gulp-jshint": "^2.0.4",
	jshint: "^2.0.0",
	"jshint-stylish": "^2.2.1",
	tape: "^4.9.1"
};
var directories = {
	lib: "./lib"
};
var engines = {
	node: ">=4.0.0"
};
var homepage = "https://github.com/theturtle32/WebSocket-Node";
var keywords = [
	"websocket",
	"websockets",
	"socket",
	"networking",
	"comet",
	"push",
	"RFC-6455",
	"realtime",
	"server",
	"client"
];
var license = "Apache-2.0";
var main = "index";
var name = "websocket";
var repository = {
	type: "git",
	url: "git+https://github.com/theturtle32/WebSocket-Node.git"
};
var scripts = {
	gulp: "gulp",
	test: "tape test/unit/*.js"
};
var version = "1.0.34";
var _package = {
	_from: _from,
	_id: _id,
	_inBundle: _inBundle,
	_integrity: _integrity,
	_location: _location,
	_phantomChildren: _phantomChildren,
	_requested: _requested,
	_requiredBy: _requiredBy,
	_resolved: _resolved,
	_shasum: _shasum,
	_spec: _spec,
	_where: _where,
	author: author,
	browser: browser,
	bugs: bugs,
	bundleDependencies: bundleDependencies,
	config: config,
	contributors: contributors,
	dependencies: dependencies,
	deprecated: deprecated,
	description: description,
	devDependencies: devDependencies,
	directories: directories,
	engines: engines,
	homepage: homepage,
	keywords: keywords,
	license: license,
	main: main,
	name: name,
	repository: repository,
	scripts: scripts,
	version: version
};

var _package$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    _from: _from,
    _id: _id,
    _inBundle: _inBundle,
    _integrity: _integrity,
    _location: _location,
    _phantomChildren: _phantomChildren,
    _requested: _requested,
    _requiredBy: _requiredBy,
    _resolved: _resolved,
    _shasum: _shasum,
    _spec: _spec,
    _where: _where,
    author: author,
    browser: browser,
    bugs: bugs,
    bundleDependencies: bundleDependencies,
    config: config,
    contributors: contributors,
    dependencies: dependencies,
    deprecated: deprecated,
    description: description,
    devDependencies: devDependencies,
    directories: directories,
    engines: engines,
    homepage: homepage,
    keywords: keywords,
    license: license,
    main: main,
    name: name,
    repository: repository,
    scripts: scripts,
    version: version,
    'default': _package
});

var require$$0 = getCjsExportFromNamespace(_package$1);

var version$1 = require$$0.version;

var _globalThis;
if (typeof globalThis === 'object') {
	_globalThis = globalThis;
} else {
	try {
		_globalThis = global$1;
	} catch (error) {
	} finally {
		if (!_globalThis && typeof window !== 'undefined') { _globalThis = window; }
		if (!_globalThis) { throw new Error('Could not determine global this'); }
	}
}

var NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;



/**
 * Expose a W3C WebSocket class with just one or two arguments.
 */
function W3CWebSocket(uri, protocols) {
	var native_instance;

	if (protocols) {
		native_instance = new NativeWebSocket(uri, protocols);
	}
	else {
		native_instance = new NativeWebSocket(uri);
	}

	/**
	 * 'native_instance' is an instance of nativeWebSocket (the browser's WebSocket
	 * class). Since it is an Object it will be returned as it is when creating an
	 * instance of W3CWebSocket via 'new W3CWebSocket()'.
	 *
	 * ECMAScript 5: http://bclary.com/2004/11/07/#a-13.2.2
	 */
	return native_instance;
}
if (NativeWebSocket) {
	['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'].forEach(function(prop) {
		Object.defineProperty(W3CWebSocket, prop, {
			get: function() { return NativeWebSocket[prop]; }
		});
	});
}

/**
 * Module exports.
 */
var browser$1 = {
    'w3cwebsocket' : NativeWebSocket ? W3CWebSocket : null,
    'version'      : version$1
};

// This file draws heavily from https://github.com/phoenixframework/phoenix/commit/cf098e9cf7a44ee6479d31d911a97d3c7430c6fe
// License: https://github.com/phoenixframework/phoenix/blob/master/LICENSE.md
class Serializer {
    constructor() {
        this.HEADER_LENGTH = 1;
    }
    decode(rawPayload, callback) {
        if (rawPayload.constructor === ArrayBuffer) {
            return callback(this._binaryDecode(rawPayload));
        }
        if (typeof rawPayload === 'string') {
            return callback(JSON.parse(rawPayload));
        }
        return callback({});
    }
    _binaryDecode(buffer) {
        const view = new DataView(buffer);
        const decoder = new TextDecoder();
        return this._decodeBroadcast(buffer, view, decoder);
    }
    _decodeBroadcast(buffer, view, decoder) {
        const topicSize = view.getUint8(1);
        const eventSize = view.getUint8(2);
        let offset = this.HEADER_LENGTH + 2;
        const topic = decoder.decode(buffer.slice(offset, offset + topicSize));
        offset = offset + topicSize;
        const event = decoder.decode(buffer.slice(offset, offset + eventSize));
        offset = offset + eventSize;
        const data = JSON.parse(decoder.decode(buffer.slice(offset, buffer.byteLength)));
        return { ref: null, topic: topic, event: event, payload: data };
    }
}

var __awaiter$4 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const noop$2 = () => { };
class RealtimeClient {
    /**
     * Initializes the Socket
     *
     * @param endPoint The string WebSocket endpoint, ie, "ws://example.com/socket", "wss://example.com", "/socket" (inherited host & protocol)
     * @param options.transport The Websocket Transport, for example WebSocket.
     * @param options.timeout The default timeout in milliseconds to trigger push timeouts.
     * @param options.params The optional params to pass when connecting.
     * @param options.headers The optional headers to pass when connecting.
     * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.
     * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }
     * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))
     * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.
     * @param options.longpollerTimeout The maximum timeout of a long poll AJAX request. Defaults to 20s (double the server long poll timer).
     * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.
     */
    constructor(endPoint, options) {
        this.channels = [];
        this.endPoint = '';
        this.headers = {};
        this.params = {};
        this.timeout = DEFAULT_TIMEOUT;
        this.transport = browser$1.w3cwebsocket;
        this.heartbeatIntervalMs = 30000;
        this.longpollerTimeout = 20000;
        this.heartbeatTimer = undefined;
        this.pendingHeartbeatRef = null;
        this.ref = 0;
        this.logger = noop$2;
        this.conn = null;
        this.sendBuffer = [];
        this.serializer = new Serializer();
        this.stateChangeCallbacks = {
            open: [],
            close: [],
            error: [],
            message: [],
        };
        this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;
        if (options === null || options === void 0 ? void 0 : options.params)
            this.params = options.params;
        if (options === null || options === void 0 ? void 0 : options.headers)
            this.headers = options.headers;
        if (options === null || options === void 0 ? void 0 : options.timeout)
            this.timeout = options.timeout;
        if (options === null || options === void 0 ? void 0 : options.logger)
            this.logger = options.logger;
        if (options === null || options === void 0 ? void 0 : options.transport)
            this.transport = options.transport;
        if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs)
            this.heartbeatIntervalMs = options.heartbeatIntervalMs;
        if (options === null || options === void 0 ? void 0 : options.longpollerTimeout)
            this.longpollerTimeout = options.longpollerTimeout;
        this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs) ? options.reconnectAfterMs
            : (tries) => {
                return [1000, 2000, 5000, 10000][tries - 1] || 10000;
            };
        this.encode = (options === null || options === void 0 ? void 0 : options.encode) ? options.encode
            : (payload, callback) => {
                return callback(JSON.stringify(payload));
            };
        this.decode = (options === null || options === void 0 ? void 0 : options.decode) ? options.decode
            : this.serializer.decode.bind(this.serializer);
        this.reconnectTimer = new Timer(() => __awaiter$4(this, void 0, void 0, function* () {
            yield this.disconnect();
            this.connect();
        }), this.reconnectAfterMs);
    }
    /**
     * Connects the socket.
     */
    connect() {
        if (this.conn) {
            return;
        }
        this.conn = new this.transport(this.endPointURL(), [], null, this.headers);
        if (this.conn) {
            // this.conn.timeout = this.longpollerTimeout // TYPE ERROR
            this.conn.binaryType = 'arraybuffer';
            this.conn.onopen = () => this._onConnOpen();
            this.conn.onerror = (error) => this._onConnError(error);
            this.conn.onmessage = (event) => this.onConnMessage(event);
            this.conn.onclose = (event) => this._onConnClose(event);
        }
    }
    /**
     * Disconnects the socket.
     *
     * @param code A numeric status code to send on disconnect.
     * @param reason A custom reason for the disconnect.
     */
    disconnect(code, reason) {
        return new Promise((resolve, _reject) => {
            try {
                if (this.conn) {
                    this.conn.onclose = function () { }; // noop
                    if (code) {
                        this.conn.close(code, reason || '');
                    }
                    else {
                        this.conn.close();
                    }
                    this.conn = null;
                }
                resolve({ error: null, data: true });
            }
            catch (error) {
                resolve({ error, data: false });
            }
        });
    }
    /**
     * Logs the message. Override `this.logger` for specialized logging.
     */
    log(kind, msg, data) {
        this.logger(kind, msg, data);
    }
    /**
     * Registers a callback for connection state change event.
     * @param callback A function to be called when the event occurs.
     *
     * @example
     *    socket.onOpen(() => console.log("Socket opened."))
     */
    onOpen(callback) {
        this.stateChangeCallbacks.open.push(callback);
    }
    /**
     * Registers a callbacks for connection state change events.
     * @param callback A function to be called when the event occurs.
     *
     * @example
     *    socket.onOpen(() => console.log("Socket closed."))
     */
    onClose(callback) {
        this.stateChangeCallbacks.close.push(callback);
    }
    /**
     * Registers a callback for connection state change events.
     * @param callback A function to be called when the event occurs.
     *
     * @example
     *    socket.onOpen((error) => console.log("An error occurred"))
     */
    onError(callback) {
        this.stateChangeCallbacks.error.push(callback);
    }
    /**
     * Calls a function any time a message is received.
     * @param callback A function to be called when the event occurs.
     *
     * @example
     *    socket.onMessage((message) => console.log(message))
     */
    onMessage(callback) {
        this.stateChangeCallbacks.message.push(callback);
    }
    /**
     * Returns the current state of the socket.
     */
    connectionState() {
        switch (this.conn && this.conn.readyState) {
            case SOCKET_STATES.connecting:
                return 'connecting';
            case SOCKET_STATES.open:
                return 'open';
            case SOCKET_STATES.closing:
                return 'closing';
            default:
                return 'closed';
        }
    }
    /**
     * Retuns `true` is the connection is open.
     */
    isConnected() {
        return this.connectionState() === 'open';
    }
    /**
     * Removes a subscription from the socket.
     *
     * @param channel An open subscription.
     */
    remove(channel) {
        this.channels = this.channels.filter((c) => c.joinRef() !== channel.joinRef());
    }
    channel(topic, chanParams = {}) {
        let chan = new RealtimeSubscription(topic, chanParams, this);
        this.channels.push(chan);
        return chan;
    }
    push(data) {
        let { topic, event, payload, ref } = data;
        let callback = () => {
            this.encode(data, (result) => {
                var _a;
                (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);
            });
        };
        this.log('push', `${topic} ${event} (${ref})`, payload);
        if (this.isConnected()) {
            callback();
        }
        else {
            this.sendBuffer.push(callback);
        }
    }
    onConnMessage(rawMessage) {
        this.decode(rawMessage.data, (msg) => {
            let { topic, event, payload, ref } = msg;
            if (ref && ref === this.pendingHeartbeatRef) {
                this.pendingHeartbeatRef = null;
            }
            else if (event === (payload === null || payload === void 0 ? void 0 : payload.type)) {
                this._resetHeartbeat();
            }
            this.log('receive', `${payload.status || ''} ${topic} ${event} ${(ref && '(' + ref + ')') || ''}`, payload);
            this.channels
                .filter((channel) => channel.isMember(topic))
                .forEach((channel) => channel.trigger(event, payload, ref));
            this.stateChangeCallbacks.message.forEach((callback) => callback(msg));
        });
    }
    /**
     * Returns the URL of the websocket.
     */
    endPointURL() {
        return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: VSN }));
    }
    /**
     * Return the next message ref, accounting for overflows
     */
    makeRef() {
        let newRef = this.ref + 1;
        if (newRef === this.ref) {
            this.ref = 0;
        }
        else {
            this.ref = newRef;
        }
        return this.ref.toString();
    }
    _onConnOpen() {
        this.log('transport', `connected to ${this.endPointURL()}`);
        this._flushSendBuffer();
        this.reconnectTimer.reset();
        this._resetHeartbeat();
        this.stateChangeCallbacks.open.forEach((callback) => callback());
    }
    _onConnClose(event) {
        this.log('transport', 'close', event);
        this._triggerChanError();
        this.heartbeatTimer && clearInterval(this.heartbeatTimer);
        this.reconnectTimer.scheduleTimeout();
        this.stateChangeCallbacks.close.forEach((callback) => callback(event));
    }
    _onConnError(error) {
        this.log('transport', error.message);
        this._triggerChanError();
        this.stateChangeCallbacks.error.forEach((callback) => callback(error));
    }
    _triggerChanError() {
        this.channels.forEach((channel) => channel.trigger(CHANNEL_EVENTS.error));
    }
    _appendParams(url, params) {
        if (Object.keys(params).length === 0) {
            return url;
        }
        const prefix = url.match(/\?/) ? '&' : '?';
        const query = new URLSearchParams(params);
        return `${url}${prefix}${query}`;
    }
    _flushSendBuffer() {
        if (this.isConnected() && this.sendBuffer.length > 0) {
            this.sendBuffer.forEach((callback) => callback());
            this.sendBuffer = [];
        }
    }
    _resetHeartbeat() {
        this.pendingHeartbeatRef = null;
        this.heartbeatTimer && clearInterval(this.heartbeatTimer);
        this.heartbeatTimer = setInterval(() => this._sendHeartbeat(), this.heartbeatIntervalMs);
    }
    _sendHeartbeat() {
        var _a;
        if (!this.isConnected()) {
            return;
        }
        if (this.pendingHeartbeatRef) {
            this.pendingHeartbeatRef = null;
            this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');
            (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, 'hearbeat timeout');
            return;
        }
        this.pendingHeartbeatRef = this.makeRef();
        this.push({
            topic: 'phoenix',
            event: 'heartbeat',
            payload: {},
            ref: this.pendingHeartbeatRef,
        });
    }
}

class SupabaseRealtimeClient {
    constructor(socket, schema, tableName) {
        const topic = tableName === '*' ? `realtime:${schema}` : `realtime:${schema}:${tableName}`;
        this.subscription = socket.channel(topic);
    }
    getPayloadRecords(payload) {
        const records = {
            new: {},
            old: {},
        };
        if (payload.type === 'INSERT' || payload.type === 'UPDATE') {
            records.new = convertChangeData(payload.columns, payload.record);
        }
        if (payload.type === 'UPDATE' || payload.type === 'DELETE') {
            records.old = convertChangeData(payload.columns, payload.old_record);
        }
        return records;
    }
    /**
     * The event you want to listen to.
     *
     * @param event The event
     * @param callback A callback function that is called whenever the event occurs.
     */
    on(event, callback) {
        this.subscription.on(event, (payload) => {
            let enrichedPayload = {
                schema: payload.schema,
                table: payload.table,
                commit_timestamp: payload.commit_timestamp,
                eventType: payload.type,
                new: {},
                old: {},
            };
            enrichedPayload = Object.assign(Object.assign({}, enrichedPayload), this.getPayloadRecords(payload));
            callback(enrichedPayload);
        });
        return this;
    }
    /**
     * Enables the subscription.
     */
    subscribe(callback = () => { }) {
        this.subscription.onError((e) => callback('SUBSCRIPTION_ERROR', e));
        this.subscription.onClose(() => callback('CLOSED'));
        this.subscription
            .subscribe()
            .receive('ok', () => callback('SUBSCRIBED'))
            .receive('error', (e) => callback('SUBSCRIPTION_ERROR', e))
            .receive('timeout', () => callback('RETRYING_AFTER_TIMEOUT'));
        return this.subscription;
    }
}

class SupabaseQueryBuilder extends PostgrestQueryBuilder {
    constructor(url, { headers = {}, schema, realtime, table, }) {
        super(url, { headers, schema });
        this._subscription = new SupabaseRealtimeClient(realtime, schema, table);
        this._realtime = realtime;
    }
    /**
     * Subscribe to realtime changes in your databse.
     * @param event The database event which you would like to receive updates for, or you can use the special wildcard `*` to listen to all changes.
     * @param callback A callback that will handle the payload that is sent whenever your database changes.
     */
    on(event, callback) {
        if (!this._realtime.isConnected()) {
            this._realtime.connect();
        }
        return this._subscription.on(event, callback);
    }
}

var __awaiter$5 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const _getErrorMessage$1 = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
const handleError$1 = (error, reject) => {
    if (typeof error.json !== 'function') {
        return reject(error);
    }
    error.json().then((err) => {
        return reject({
            message: _getErrorMessage$1(err),
            status: (error === null || error === void 0 ? void 0 : error.status) || 500,
        });
    });
};
const _getRequestParams$1 = (method, options, parameters, body) => {
    const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };
    if (method === 'GET') {
        return params;
    }
    params.headers = Object.assign({ 'Content-Type': 'application/json' }, options === null || options === void 0 ? void 0 : options.headers);
    params.body = JSON.stringify(body);
    return Object.assign(Object.assign({}, params), parameters);
};
function _handleRequest$1(method, url, options, parameters, body) {
    return __awaiter$5(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            fetch$1(url, _getRequestParams$1(method, options, parameters, body))
                .then((result) => {
                if (!result.ok)
                    throw result;
                if (options === null || options === void 0 ? void 0 : options.noResolveJson)
                    return resolve(result);
                return result.json();
            })
                .then((data) => resolve(data))
                .catch((error) => handleError$1(error, reject));
        });
    });
}
function get$1(url, options, parameters) {
    return __awaiter$5(this, void 0, void 0, function* () {
        return _handleRequest$1('GET', url, options, parameters);
    });
}
function post$1(url, body, options, parameters) {
    return __awaiter$5(this, void 0, void 0, function* () {
        return _handleRequest$1('POST', url, options, parameters, body);
    });
}
function put$1(url, body, options, parameters) {
    return __awaiter$5(this, void 0, void 0, function* () {
        return _handleRequest$1('PUT', url, options, parameters, body);
    });
}
function remove$1(url, body, options, parameters) {
    return __awaiter$5(this, void 0, void 0, function* () {
        return _handleRequest$1('DELETE', url, options, parameters, body);
    });
}

var __awaiter$6 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class StorageBucketApi {
    constructor(url, headers = {}) {
        this.url = url;
        this.headers = headers;
    }
    /**
     * Retrieves the details of all Storage buckets within an existing product.
     */
    listBuckets() {
        return __awaiter$6(this, void 0, void 0, function* () {
            try {
                const data = yield get$1(`${this.url}/bucket`, { headers: this.headers });
                return { data, error: null };
            }
            catch (error) {
                return { data: null, error };
            }
        });
    }
    /**
     * Retrieves the details of an existing Storage bucket.
     *
     * @param id The unique identifier of the bucket you would like to retrieve.
     */
    getBucket(id) {
        return __awaiter$6(this, void 0, void 0, function* () {
            try {
                const data = yield get$1(`${this.url}/bucket/${id}`, { headers: this.headers });
                return { data, error: null };
            }
            catch (error) {
                return { data: null, error };
            }
        });
    }
    /**
     * Creates a new Storage bucket
     *
     * @param id A unique identifier for the bucket you are creating.
     * @returns newly created bucket id
     */
    createBucket(id, options = { public: false }) {
        return __awaiter$6(this, void 0, void 0, function* () {
            try {
                const data = yield post$1(`${this.url}/bucket`, { id, name: id, public: options.public }, { headers: this.headers });
                return { data: data.name, error: null };
            }
            catch (error) {
                return { data: null, error };
            }
        });
    }
    /**
     * Updates a new Storage bucket
     *
     * @param id A unique identifier for the bucket you are creating.
     */
    updateBucket(id, options) {
        return __awaiter$6(this, void 0, void 0, function* () {
            try {
                const data = yield put$1(`${this.url}/bucket/${id}`, { id, name: id, public: options.public }, { headers: this.headers });
                return { data, error: null };
            }
            catch (error) {
                return { data: null, error };
            }
        });
    }
    /**
     * Removes all objects inside a single bucket.
     *
     * @param id The unique identifier of the bucket you would like to empty.
     */
    emptyBucket(id) {
        return __awaiter$6(this, void 0, void 0, function* () {
            try {
                const data = yield post$1(`${this.url}/bucket/${id}/empty`, {}, { headers: this.headers });
                return { data, error: null };
            }
            catch (error) {
                return { data: null, error };
            }
        });
    }
    /**
     * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.
     * You must first `empty()` the bucket.
     *
     * @param id The unique identifier of the bucket you would like to delete.
     */
    deleteBucket(id) {
        return __awaiter$6(this, void 0, void 0, function* () {
            try {
                const data = yield remove$1(`${this.url}/bucket/${id}`, {}, { headers: this.headers });
                return { data, error: null };
            }
            catch (error) {
                return { data: null, error };
            }
        });
    }
}

const isBrowser$1 = () => typeof window !== 'undefined';

var __awaiter$7 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const DEFAULT_SEARCH_OPTIONS = {
    limit: 100,
    offset: 0,
    sortBy: {
        column: 'name',
        order: 'asc',
    },
};
const DEFAULT_FILE_OPTIONS = {
    cacheControl: '3600',
    upsert: false,
};
class StorageFileApi {
    constructor(url, headers = {}, bucketId) {
        this.url = url;
        this.headers = headers;
        this.bucketId = bucketId;
    }
    /**
     * Uploads a file to an existing bucket.
     *
     * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
     * @param file The File object to be stored in the bucket.
     * @param fileOptions HTTP headers. For example `cacheControl`
     */
    upload(path, file, fileOptions) {
        return __awaiter$7(this, void 0, void 0, function* () {
            try {
                if (!isBrowser$1())
                    throw new Error('No browser detected.');
                const formData = new FormData();
                const options = Object.assign(Object.assign({}, DEFAULT_FILE_OPTIONS), fileOptions);
                formData.append('cacheControl', options.cacheControl);
                formData.append('', file, file.name);
                const _path = this._getFinalPath(path);
                const res = yield fetch(`${this.url}/object/${_path}`, {
                    method: 'POST',
                    body: formData,
                    headers: Object.assign(Object.assign({}, this.headers), { 'x-upsert': String(fileOptions === null || fileOptions === void 0 ? void 0 : fileOptions.upsert) }),
                });
                if (res.ok) {
                    // const data = await res.json()
                    // temporary fix till backend is updated to the latest storage-api version
                    return { data: { Key: _path }, error: null };
                }
                else {
                    const error = yield res.json();
                    return { data: null, error };
                }
            }
            catch (error) {
                return { data: null, error };
            }
        });
    }
    /**
     * Replaces an existing file at the specified path with a new one.
     *
     * @param path The relative file path. Should be of the format `folder/subfolder`. The bucket already exist before attempting to upload.
     * @param file The file object to be stored in the bucket.
     * @param fileOptions HTTP headers. For example `cacheControl`
     */
    update(path, file, fileOptions) {
        return __awaiter$7(this, void 0, void 0, function* () {
            try {
                if (!isBrowser$1())
                    throw new Error('No browser detected.');
                const formData = new FormData();
                const options = Object.assign(Object.assign({}, DEFAULT_FILE_OPTIONS), fileOptions);
                formData.append('cacheControl', options.cacheControl);
                formData.append('', file, file.name);
                const _path = this._getFinalPath(path);
                const res = yield fetch(`${this.url}/object/${_path}`, {
                    method: 'PUT',
                    body: formData,
                    headers: Object.assign({}, this.headers),
                });
                if (res.ok) {
                    // const data = await res.json()
                    // temporary fix till backend is updated to the latest storage-api version
                    return { data: { Key: _path }, error: null };
                }
                else {
                    const error = yield res.json();
                    return { data: null, error };
                }
            }
            catch (error) {
                return { data: null, error };
            }
        });
    }
    /**
     * Moves an existing file, optionally renaming it at the same time.
     *
     * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
     * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.
     */
    move(fromPath, toPath) {
        return __awaiter$7(this, void 0, void 0, function* () {
            try {
                const data = yield post$1(`${this.url}/object/move`, { bucketId: this.bucketId, sourceKey: fromPath, destinationKey: toPath }, { headers: this.headers });
                return { data, error: null };
            }
            catch (error) {
                return { data: null, error };
            }
        });
    }
    /**
     * Create signed url to download file without requiring permissions. This URL can be valid for a set number of seconds.
     *
     * @param path The file path to be downloaded, including the current file name. For example `folder/image.png`.
     * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.
     */
    createSignedUrl(path, expiresIn) {
        return __awaiter$7(this, void 0, void 0, function* () {
            try {
                const _path = this._getFinalPath(path);
                let data = yield post$1(`${this.url}/object/sign/${_path}`, { expiresIn }, { headers: this.headers });
                const signedURL = `${this.url}${data.signedURL}`;
                data = { signedURL };
                return { data, error: null, signedURL };
            }
            catch (error) {
                return { data: null, error, signedURL: null };
            }
        });
    }
    /**
     * Downloads a file.
     *
     * @param path The file path to be downloaded, including the path and file name. For example `folder/image.png`.
     */
    download(path) {
        return __awaiter$7(this, void 0, void 0, function* () {
            try {
                const _path = this._getFinalPath(path);
                const res = yield get$1(`${this.url}/object/${_path}`, {
                    headers: this.headers,
                    noResolveJson: true,
                });
                const data = yield res.blob();
                return { data, error: null };
            }
            catch (error) {
                return { data: null, error };
            }
        });
    }
    /**
     * Retrieve URLs for assets in public buckets
     *
     * @param path The file path to be downloaded, including the path and file name. For example `folder/image.png`.
     */
    getPublicUrl(path) {
        try {
            const _path = this._getFinalPath(path);
            const publicURL = `${this.url}/object/public/${_path}`;
            const data = { publicURL };
            return { data, error: null, publicURL };
        }
        catch (error) {
            return { data: null, error, publicURL: null };
        }
    }
    /**
     * Deletes files within the same bucket
     *
     * @param paths An array of files to be deletes, including the path and file name. For example [`folder/image.png`].
     */
    remove(paths) {
        return __awaiter$7(this, void 0, void 0, function* () {
            try {
                const data = yield remove$1(`${this.url}/object/${this.bucketId}`, { prefixes: paths }, { headers: this.headers });
                return { data, error: null };
            }
            catch (error) {
                return { data: null, error };
            }
        });
    }
    /**
     * Get file metadata
     * @param id the file id to retrieve metadata
     */
    // async getMetadata(id: string): Promise<{ data: Metadata | null; error: Error | null }> {
    //   try {
    //     const data = await get(`${this.url}/metadata/${id}`, { headers: this.headers })
    //     return { data, error: null }
    //   } catch (error) {
    //     return { data: null, error }
    //   }
    // }
    /**
     * Update file metadata
     * @param id the file id to update metadata
     * @param meta the new file metadata
     */
    // async updateMetadata(
    //   id: string,
    //   meta: Metadata
    // ): Promise<{ data: Metadata | null; error: Error | null }> {
    //   try {
    //     const data = await post(`${this.url}/metadata/${id}`, { ...meta }, { headers: this.headers })
    //     return { data, error: null }
    //   } catch (error) {
    //     return { data: null, error }
    //   }
    // }
    /**
     * Lists all the files within a bucket.
     * @param path The folder path.
     * @param options Search options, including `limit`, `offset`, and `sortBy`.
     * @param parameters Fetch parameters, currently only supports `signal`, which is an AbortController's signal
     */
    list(path, options, parameters) {
        return __awaiter$7(this, void 0, void 0, function* () {
            try {
                const body = Object.assign(Object.assign(Object.assign({}, DEFAULT_SEARCH_OPTIONS), options), { prefix: path || '' });
                const data = yield post$1(`${this.url}/object/list/${this.bucketId}`, body, { headers: this.headers }, parameters);
                return { data, error: null };
            }
            catch (error) {
                return { data: null, error };
            }
        });
    }
    _getFinalPath(path) {
        return `${this.bucketId}/${path}`;
    }
}

class SupabaseStorageClient extends StorageBucketApi {
    constructor(url, headers = {}) {
        super(url, headers);
    }
    /**
     * Perform file operation in a bucket.
     *
     * @param id The bucket id to operate on.
     */
    from(id) {
        return new StorageFileApi(this.url, this.headers, id);
    }
}

var __awaiter$8 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const DEFAULT_OPTIONS$1 = {
    schema: 'public',
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: true,
    localStorage: globalThis.localStorage,
    headers: DEFAULT_HEADERS,
};
/**
 * Supabase Client.
 *
 * An isomorphic Javascript client for interacting with Postgres.
 */
class SupabaseClient {
    /**
     * Create a new client for use in the browser.
     * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.
     * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.
     * @param options.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.
     * @param options.autoRefreshToken Set to "true" if you want to automatically refresh the token before expiring.
     * @param options.persistSession Set to "true" if you want to automatically save the user session into local storage.
     * @param options.detectSessionInUrl Set to "true" if you want to automatically detects OAuth grants in the URL and signs in the user.
     * @param options.headers Any additional headers to send with each network request.
     */
    constructor(supabaseUrl, supabaseKey, options) {
        this.supabaseUrl = supabaseUrl;
        this.supabaseKey = supabaseKey;
        if (!supabaseUrl)
            throw new Error('supabaseUrl is required.');
        if (!supabaseKey)
            throw new Error('supabaseKey is required.');
        const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS$1), options);
        this.restUrl = `${supabaseUrl}/rest/v1`;
        this.realtimeUrl = `${supabaseUrl}/realtime/v1`.replace('http', 'ws');
        this.authUrl = `${supabaseUrl}/auth/v1`;
        this.storageUrl = `${supabaseUrl}/storage/v1`;
        this.schema = settings.schema;
        this.auth = this._initSupabaseAuthClient(settings);
        this.realtime = this._initRealtimeClient();
        // In the future we might allow the user to pass in a logger to receive these events.
        // this.realtime.onOpen(() => console.log('OPEN'))
        // this.realtime.onClose(() => console.log('CLOSED'))
        // this.realtime.onError((e: Error) => console.log('Socket error', e))
    }
    /**
     * Supabase Storage allows you to manage user-generated content, such as photos or videos.
     */
    get storage() {
        return new SupabaseStorageClient(this.storageUrl, this._getAuthHeaders());
    }
    /**
     * Perform a table operation.
     *
     * @param table The table name to operate on.
     */
    from(table) {
        const url = `${this.restUrl}/${table}`;
        return new SupabaseQueryBuilder(url, {
            headers: this._getAuthHeaders(),
            schema: this.schema,
            realtime: this.realtime,
            table,
        });
    }
    /**
     * Perform a stored procedure call.
     *
     * @param fn  The function name to call.
     * @param params  The parameters to pass to the function call.
     */
    rpc(fn, params) {
        const rest = this._initPostgRESTClient();
        return rest.rpc(fn, params);
    }
    /**
     * Removes an active subscription and returns the number of open connections.
     *
     * @param subscription The subscription you want to remove.
     */
    removeSubscription(subscription) {
        return new Promise((resolve) => __awaiter$8(this, void 0, void 0, function* () {
            try {
                yield this._closeSubscription(subscription);
                const openSubscriptions = this.getSubscriptions().length;
                if (!openSubscriptions) {
                    const { error } = yield this.realtime.disconnect();
                    if (error)
                        return resolve({ error });
                }
                return resolve({ error: null, data: { openSubscriptions } });
            }
            catch (error) {
                return resolve({ error });
            }
        }));
    }
    _closeSubscription(subscription) {
        return __awaiter$8(this, void 0, void 0, function* () {
            if (!subscription.isClosed()) {
                yield this._closeChannel(subscription);
            }
        });
    }
    /**
     * Returns an array of all your subscriptions.
     */
    getSubscriptions() {
        return this.realtime.channels;
    }
    _initSupabaseAuthClient({ autoRefreshToken, persistSession, detectSessionInUrl, localStorage, }) {
        return new SupabaseAuthClient({
            url: this.authUrl,
            headers: {
                Authorization: `Bearer ${this.supabaseKey}`,
                apikey: `${this.supabaseKey}`,
            },
            autoRefreshToken,
            persistSession,
            detectSessionInUrl,
            localStorage,
        });
    }
    _initRealtimeClient() {
        return new RealtimeClient(this.realtimeUrl, {
            params: { apikey: this.supabaseKey },
        });
    }
    _initPostgRESTClient() {
        return new PostgrestClient(this.restUrl, {
            headers: this._getAuthHeaders(),
            schema: this.schema,
        });
    }
    _getAuthHeaders() {
        var _a, _b;
        const headers = {};
        const authBearer = (_b = (_a = this.auth.session()) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : this.supabaseKey;
        headers['apikey'] = this.supabaseKey;
        headers['Authorization'] = `Bearer ${authBearer}`;
        return headers;
    }
    _closeChannel(subscription) {
        return new Promise((resolve, reject) => {
            subscription
                .unsubscribe()
                .receive('ok', () => {
                this.realtime.remove(subscription);
                return resolve(true);
            })
                .receive('error', (e) => reject(e));
        });
    }
}

/**
 * Creates a new Supabase Client.
 */
const createClient = (supabaseUrl, supabaseKey, options) => {
    return new SupabaseClient(supabaseUrl, supabaseKey, options);
};

const supabaseUrl = {"env":{"SUPABASE_URL":"https://slrzbqsttxerrsrbyppa.supabase.co","SUPABASE_ANON_KEY":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYW5vbiIsImlhdCI6MTYyNjM1NjY1MSwiZXhwIjoxOTQxOTMyNjUxfQ.yOgR1FB87112TOq19riICFOw-Ue8R2k9R4dcDoLOgPw"}}.env.SUPABASE_URL;
const supabaseAnonKey = {"env":{"SUPABASE_URL":"https://slrzbqsttxerrsrbyppa.supabase.co","SUPABASE_ANON_KEY":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYW5vbiIsImlhdCI6MTYyNjM1NjY1MSwiZXhwIjoxOTQxOTMyNjUxfQ.yOgR1FB87112TOq19riICFOw-Ue8R2k9R4dcDoLOgPw"}}.env.SUPABASE_ANON_KEY;

const supabase = createClient(supabaseUrl, supabaseAnonKey);

//  Supabase OAuth Client Code

// import { user } from '../../stores/auth.js'

let loading = writable('');
let username = writable('');
let website = writable('');
let avatar_url = writable('');


async function init$2() {
	// auth0 = await createAuth0Client(AUTH_CONFIG)
	// // update store
	// user.set(await auth0.getUser())
	// loading.set(false)
	// authenticated.set(true)
}


async function getProfile() {
	try {
		loading = true;
		const user = supabase.auth.user();
		let { data, error, status } = await supabase
			.from('profiles')
			.select(`username, website, avatar_url`)
			.eq('id', user.id)
			.single();
		if (error && status !== 406) throw error
		if (data) {
			username = data.username;
			website = data.website;
			avatar_url = data.avatar_url;
		}
	} catch (error) {
		alert(error.message);
	} finally {
		loading = false;
	}
}

async function updateProfile() {
	try {
		loading = true;
		const user = supabase.auth.user();
		const updates = {
			id: user.id,
			username,
			website,
			avatar_url,
			updated_at: new Date(),
		};
		let { error } = await supabase.from('profiles').upsert(updates, {
			returning: 'minimal', // Don't return the value after inserting
		});
		if (error) throw error
	} catch (error) {
		alert(error.message);
	} finally {
		loading = false;
	}
}

async function signOut() {
	try {
		loading = true;
		let { error } = await supabase.auth.signOut();
		if (error) throw error
	} catch (error) {
		alert(error.message);
	} finally {
		loading = false;
	}
}

async function signIn() {
	const { user, session, error } = await supabase.auth.signIn({
		provider: 'google',
	});
	const { user1, session1, error1 } = await supabase.auth.signIn({
		provider: 'github',
	});
	const { user2, session2, error2 } = await supabase.auth.signIn({
		provider: 'github',
	});
}

/* src/pages/login/index.svelte generated by Svelte v3.31.0 */

function create_fragment$7(ctx) {
	let div1;
	let div0;
	let h3;
	let t1;
	let p;
	let t3;
	let button;
	let mounted;
	let dispose;

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			h3 = element("h3");
			h3.textContent = "We're super lazy about our login form";
			t1 = space();
			p = element("p");
			p.textContent = "So we leave it to auth0";
			t3 = space();
			button = element("button");
			button.textContent = "sign in";
			attr(button, "class", "button");
			attr(div0, "class", "card");
			attr(div1, "class", "center-all");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			append(div0, h3);
			append(div0, t1);
			append(div0, p);
			append(div0, t3);
			append(div0, button);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler*/ ctx[0]);
				mounted = true;
			}
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div1);
			mounted = false;
			dispose();
		}
	};
}

function instance$5($$self) {
	const click_handler = () => signIn();
	return [click_handler];
}

class Login extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$5, create_fragment$7, safe_not_equal, {});
	}
}

/* src/pages/admin/_layout.svelte generated by Svelte v3.31.0 */

function create_else_block(ctx) {
	let login;
	let current;
	login = new Login({});

	return {
		c() {
			create_component(login.$$.fragment);
		},
		m(target, anchor) {
			mount_component(login, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(login.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(login.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(login, detaching);
		}
	};
}

// (30:21) 
function create_if_block_2$1(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (26:20) 
function create_if_block_1$1(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			div.innerHTML = `<h1>Loading...</h1>`;
			attr(div, "class", "center-all");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (24:1) {#if !window.routify.inBrowser}
function create_if_block$2(ctx) {
	let t;

	return {
		c() {
			t = text$1("Hello bot. This page is only available to humans.");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment$8(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block$2, create_if_block_1$1, create_if_block_2$1, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (!window.routify.inBrowser) return 0;
		if (/*$loading*/ ctx[1]) return 1;
		if (/*$username*/ ctx[0]) return 2;
		return 3;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			div = element("div");
			if_block.c();
			attr(div, "class", "admin-module");
			toggle_class(div, "not-authed", !/*$username*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div, null);
			}

			if (dirty & /*$username*/ 1) {
				toggle_class(div, "not-authed", !/*$username*/ ctx[0]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if_blocks[current_block_type_index].d();
		}
	};
}

function instance$6($$self, $$props, $$invalidate) {
	let $ready;
	let $username;
	let $loading;
	component_subscribe($$self, ready, $$value => $$invalidate(4, $ready = $$value));
	component_subscribe($$self, username, $$value => $$invalidate(0, $username = $$value));
	component_subscribe($$self, loading, $$value => $$invalidate(1, $loading = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	$ready();

	$$self.$$set = $$props => {
		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	return [$username, $loading, $$scope, slots];
}

class Layout extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$6, create_fragment$8, safe_not_equal, {});
	}
}

/* src/pages/docs/[docId]/index.svelte generated by Svelte v3.31.0 */

class U5BdocIdu5D extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, null, null, safe_not_equal, {});
	}
}

var marked = createCommonjsModule(function (module, exports) {
/**
 * marked - a markdown parser
 * Copyright (c) 2011-2021, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/markedjs/marked
 */

/**
 * DO NOT EDIT THIS FILE
 * The code in this file is generated from files in ./src/
 */

(function (global, factory) {
   module.exports = factory() ;
}(commonjsGlobal, (function () {
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it;

    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    it = o[Symbol.iterator]();
    return it.next.bind(it);
  }

  function createCommonjsModule(fn) {
    var module = { exports: {} };
  	return fn(module, module.exports), module.exports;
  }

  var defaults = createCommonjsModule(function (module) {
    function getDefaults() {
      return {
        baseUrl: null,
        breaks: false,
        gfm: true,
        headerIds: true,
        headerPrefix: '',
        highlight: null,
        langPrefix: 'language-',
        mangle: true,
        pedantic: false,
        renderer: null,
        sanitize: false,
        sanitizer: null,
        silent: false,
        smartLists: false,
        smartypants: false,
        tokenizer: null,
        walkTokens: null,
        xhtml: false
      };
    }

    function changeDefaults(newDefaults) {
      module.exports.defaults = newDefaults;
    }

    module.exports = {
      defaults: getDefaults(),
      getDefaults: getDefaults,
      changeDefaults: changeDefaults
    };
  });

  /**
   * Helpers
   */
  var escapeTest = /[&<>"']/;
  var escapeReplace = /[&<>"']/g;
  var escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
  var escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
  var escapeReplacements = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  var getEscapeReplacement = function getEscapeReplacement(ch) {
    return escapeReplacements[ch];
  };

  function escape(html, encode) {
    if (encode) {
      if (escapeTest.test(html)) {
        return html.replace(escapeReplace, getEscapeReplacement);
      }
    } else {
      if (escapeTestNoEncode.test(html)) {
        return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
      }
    }

    return html;
  }

  var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;

  function unescape(html) {
    // explicitly match decimal, hex, and named HTML entities
    return html.replace(unescapeTest, function (_, n) {
      n = n.toLowerCase();
      if (n === 'colon') return ':';

      if (n.charAt(0) === '#') {
        return n.charAt(1) === 'x' ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
      }

      return '';
    });
  }

  var caret = /(^|[^\[])\^/g;

  function edit(regex, opt) {
    regex = regex.source || regex;
    opt = opt || '';
    var obj = {
      replace: function replace(name, val) {
        val = val.source || val;
        val = val.replace(caret, '$1');
        regex = regex.replace(name, val);
        return obj;
      },
      getRegex: function getRegex() {
        return new RegExp(regex, opt);
      }
    };
    return obj;
  }

  var nonWordAndColonTest = /[^\w:]/g;
  var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;

  function cleanUrl(sanitize, base, href) {
    if (sanitize) {
      var prot;

      try {
        prot = decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, '').toLowerCase();
      } catch (e) {
        return null;
      }

      if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
        return null;
      }
    }

    if (base && !originIndependentUrl.test(href)) {
      href = resolveUrl(base, href);
    }

    try {
      href = encodeURI(href).replace(/%25/g, '%');
    } catch (e) {
      return null;
    }

    return href;
  }

  var baseUrls = {};
  var justDomain = /^[^:]+:\/*[^/]*$/;
  var protocol = /^([^:]+:)[\s\S]*$/;
  var domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;

  function resolveUrl(base, href) {
    if (!baseUrls[' ' + base]) {
      // we can ignore everything in base after the last slash of its path component,
      // but we might need to add _that_
      // https://tools.ietf.org/html/rfc3986#section-3
      if (justDomain.test(base)) {
        baseUrls[' ' + base] = base + '/';
      } else {
        baseUrls[' ' + base] = rtrim(base, '/', true);
      }
    }

    base = baseUrls[' ' + base];
    var relativeBase = base.indexOf(':') === -1;

    if (href.substring(0, 2) === '//') {
      if (relativeBase) {
        return href;
      }

      return base.replace(protocol, '$1') + href;
    } else if (href.charAt(0) === '/') {
      if (relativeBase) {
        return href;
      }

      return base.replace(domain, '$1') + href;
    } else {
      return base + href;
    }
  }

  var noopTest = {
    exec: function noopTest() {}
  };

  function merge(obj) {
    var i = 1,
        target,
        key;

    for (; i < arguments.length; i++) {
      target = arguments[i];

      for (key in target) {
        if (Object.prototype.hasOwnProperty.call(target, key)) {
          obj[key] = target[key];
        }
      }
    }

    return obj;
  }

  function splitCells(tableRow, count) {
    // ensure that every cell-delimiting pipe has a space
    // before it to distinguish it from an escaped pipe
    var row = tableRow.replace(/\|/g, function (match, offset, str) {
      var escaped = false,
          curr = offset;

      while (--curr >= 0 && str[curr] === '\\') {
        escaped = !escaped;
      }

      if (escaped) {
        // odd number of slashes means | is escaped
        // so we leave it alone
        return '|';
      } else {
        // add space before unescaped |
        return ' |';
      }
    }),
        cells = row.split(/ \|/);
    var i = 0;

    if (cells.length > count) {
      cells.splice(count);
    } else {
      while (cells.length < count) {
        cells.push('');
      }
    }

    for (; i < cells.length; i++) {
      // leading or trailing whitespace is ignored per the gfm spec
      cells[i] = cells[i].trim().replace(/\\\|/g, '|');
    }

    return cells;
  } // Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
  // /c*$/ is vulnerable to REDOS.
  // invert: Remove suffix of non-c chars instead. Default falsey.


  function rtrim(str, c, invert) {
    var l = str.length;

    if (l === 0) {
      return '';
    } // Length of suffix matching the invert condition.


    var suffLen = 0; // Step left until we fail to match the invert condition.

    while (suffLen < l) {
      var currChar = str.charAt(l - suffLen - 1);

      if (currChar === c && !invert) {
        suffLen++;
      } else if (currChar !== c && invert) {
        suffLen++;
      } else {
        break;
      }
    }

    return str.substr(0, l - suffLen);
  }

  function findClosingBracket(str, b) {
    if (str.indexOf(b[1]) === -1) {
      return -1;
    }

    var l = str.length;
    var level = 0,
        i = 0;

    for (; i < l; i++) {
      if (str[i] === '\\') {
        i++;
      } else if (str[i] === b[0]) {
        level++;
      } else if (str[i] === b[1]) {
        level--;

        if (level < 0) {
          return i;
        }
      }
    }

    return -1;
  }

  function checkSanitizeDeprecation(opt) {
    if (opt && opt.sanitize && !opt.silent) {
      console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');
    }
  } // copied from https://stackoverflow.com/a/5450113/806777


  function repeatString(pattern, count) {
    if (count < 1) {
      return '';
    }

    var result = '';

    while (count > 1) {
      if (count & 1) {
        result += pattern;
      }

      count >>= 1;
      pattern += pattern;
    }

    return result + pattern;
  }

  var helpers = {
    escape: escape,
    unescape: unescape,
    edit: edit,
    cleanUrl: cleanUrl,
    resolveUrl: resolveUrl,
    noopTest: noopTest,
    merge: merge,
    splitCells: splitCells,
    rtrim: rtrim,
    findClosingBracket: findClosingBracket,
    checkSanitizeDeprecation: checkSanitizeDeprecation,
    repeatString: repeatString
  };

  var defaults$1 = defaults.defaults;
  var rtrim$1 = helpers.rtrim,
      splitCells$1 = helpers.splitCells,
      _escape = helpers.escape,
      findClosingBracket$1 = helpers.findClosingBracket;

  function outputLink(cap, link, raw) {
    var href = link.href;
    var title = link.title ? _escape(link.title) : null;
    var text = cap[1].replace(/\\([\[\]])/g, '$1');

    if (cap[0].charAt(0) !== '!') {
      return {
        type: 'link',
        raw: raw,
        href: href,
        title: title,
        text: text
      };
    } else {
      return {
        type: 'image',
        raw: raw,
        href: href,
        title: title,
        text: _escape(text)
      };
    }
  }

  function indentCodeCompensation(raw, text) {
    var matchIndentToCode = raw.match(/^(\s+)(?:```)/);

    if (matchIndentToCode === null) {
      return text;
    }

    var indentToCode = matchIndentToCode[1];
    return text.split('\n').map(function (node) {
      var matchIndentInNode = node.match(/^\s+/);

      if (matchIndentInNode === null) {
        return node;
      }

      var indentInNode = matchIndentInNode[0];

      if (indentInNode.length >= indentToCode.length) {
        return node.slice(indentToCode.length);
      }

      return node;
    }).join('\n');
  }
  /**
   * Tokenizer
   */


  var Tokenizer_1 = /*#__PURE__*/function () {
    function Tokenizer(options) {
      this.options = options || defaults$1;
    }

    var _proto = Tokenizer.prototype;

    _proto.space = function space(src) {
      var cap = this.rules.block.newline.exec(src);

      if (cap) {
        if (cap[0].length > 1) {
          return {
            type: 'space',
            raw: cap[0]
          };
        }

        return {
          raw: '\n'
        };
      }
    };

    _proto.code = function code(src) {
      var cap = this.rules.block.code.exec(src);

      if (cap) {
        var text = cap[0].replace(/^ {1,4}/gm, '');
        return {
          type: 'code',
          raw: cap[0],
          codeBlockStyle: 'indented',
          text: !this.options.pedantic ? rtrim$1(text, '\n') : text
        };
      }
    };

    _proto.fences = function fences(src) {
      var cap = this.rules.block.fences.exec(src);

      if (cap) {
        var raw = cap[0];
        var text = indentCodeCompensation(raw, cap[3] || '');
        return {
          type: 'code',
          raw: raw,
          lang: cap[2] ? cap[2].trim() : cap[2],
          text: text
        };
      }
    };

    _proto.heading = function heading(src) {
      var cap = this.rules.block.heading.exec(src);

      if (cap) {
        var text = cap[2].trim(); // remove trailing #s

        if (/#$/.test(text)) {
          var trimmed = rtrim$1(text, '#');

          if (this.options.pedantic) {
            text = trimmed.trim();
          } else if (!trimmed || / $/.test(trimmed)) {
            // CommonMark requires space before trailing #s
            text = trimmed.trim();
          }
        }

        return {
          type: 'heading',
          raw: cap[0],
          depth: cap[1].length,
          text: text
        };
      }
    };

    _proto.nptable = function nptable(src) {
      var cap = this.rules.block.nptable.exec(src);

      if (cap) {
        var item = {
          type: 'table',
          header: splitCells$1(cap[1].replace(/^ *| *\| *$/g, '')),
          align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
          cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : [],
          raw: cap[0]
        };

        if (item.header.length === item.align.length) {
          var l = item.align.length;
          var i;

          for (i = 0; i < l; i++) {
            if (/^ *-+: *$/.test(item.align[i])) {
              item.align[i] = 'right';
            } else if (/^ *:-+: *$/.test(item.align[i])) {
              item.align[i] = 'center';
            } else if (/^ *:-+ *$/.test(item.align[i])) {
              item.align[i] = 'left';
            } else {
              item.align[i] = null;
            }
          }

          l = item.cells.length;

          for (i = 0; i < l; i++) {
            item.cells[i] = splitCells$1(item.cells[i], item.header.length);
          }

          return item;
        }
      }
    };

    _proto.hr = function hr(src) {
      var cap = this.rules.block.hr.exec(src);

      if (cap) {
        return {
          type: 'hr',
          raw: cap[0]
        };
      }
    };

    _proto.blockquote = function blockquote(src) {
      var cap = this.rules.block.blockquote.exec(src);

      if (cap) {
        var text = cap[0].replace(/^ *> ?/gm, '');
        return {
          type: 'blockquote',
          raw: cap[0],
          text: text
        };
      }
    };

    _proto.list = function list(src) {
      var cap = this.rules.block.list.exec(src);

      if (cap) {
        var raw = cap[0];
        var bull = cap[2];
        var isordered = bull.length > 1;
        var list = {
          type: 'list',
          raw: raw,
          ordered: isordered,
          start: isordered ? +bull.slice(0, -1) : '',
          loose: false,
          items: []
        }; // Get each top-level item.

        var itemMatch = cap[0].match(this.rules.block.item);
        var next = false,
            item,
            space,
            bcurr,
            bnext,
            addBack,
            loose,
            istask,
            ischecked;
        var l = itemMatch.length;
        bcurr = this.rules.block.listItemStart.exec(itemMatch[0]);

        for (var i = 0; i < l; i++) {
          item = itemMatch[i];
          raw = item; // Determine whether the next list item belongs here.
          // Backpedal if it does not belong in this list.

          if (i !== l - 1) {
            bnext = this.rules.block.listItemStart.exec(itemMatch[i + 1]);

            if (!this.options.pedantic ? bnext[1].length > bcurr[0].length || bnext[1].length > 3 : bnext[1].length > bcurr[1].length) {
              // nested list
              itemMatch.splice(i, 2, itemMatch[i] + '\n' + itemMatch[i + 1]);
              i--;
              l--;
              continue;
            } else {
              if ( // different bullet style
              !this.options.pedantic || this.options.smartLists ? bnext[2][bnext[2].length - 1] !== bull[bull.length - 1] : isordered === (bnext[2].length === 1)) {
                addBack = itemMatch.slice(i + 1).join('\n');
                list.raw = list.raw.substring(0, list.raw.length - addBack.length);
                i = l - 1;
              }
            }

            bcurr = bnext;
          } // Remove the list item's bullet
          // so it is seen as the next token.


          space = item.length;
          item = item.replace(/^ *([*+-]|\d+[.)]) ?/, ''); // Outdent whatever the
          // list item contains. Hacky.

          if (~item.indexOf('\n ')) {
            space -= item.length;
            item = !this.options.pedantic ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '') : item.replace(/^ {1,4}/gm, '');
          } // Determine whether item is loose or not.
          // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
          // for discount behavior.


          loose = next || /\n\n(?!\s*$)/.test(item);

          if (i !== l - 1) {
            next = item.charAt(item.length - 1) === '\n';
            if (!loose) loose = next;
          }

          if (loose) {
            list.loose = true;
          } // Check for task list items


          if (this.options.gfm) {
            istask = /^\[[ xX]\] /.test(item);
            ischecked = undefined;

            if (istask) {
              ischecked = item[1] !== ' ';
              item = item.replace(/^\[[ xX]\] +/, '');
            }
          }

          list.items.push({
            type: 'list_item',
            raw: raw,
            task: istask,
            checked: ischecked,
            loose: loose,
            text: item
          });
        }

        return list;
      }
    };

    _proto.html = function html(src) {
      var cap = this.rules.block.html.exec(src);

      if (cap) {
        return {
          type: this.options.sanitize ? 'paragraph' : 'html',
          raw: cap[0],
          pre: !this.options.sanitizer && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
          text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0]
        };
      }
    };

    _proto.def = function def(src) {
      var cap = this.rules.block.def.exec(src);

      if (cap) {
        if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);
        var tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
        return {
          tag: tag,
          raw: cap[0],
          href: cap[2],
          title: cap[3]
        };
      }
    };

    _proto.table = function table(src) {
      var cap = this.rules.block.table.exec(src);

      if (cap) {
        var item = {
          type: 'table',
          header: splitCells$1(cap[1].replace(/^ *| *\| *$/g, '')),
          align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
          cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : []
        };

        if (item.header.length === item.align.length) {
          item.raw = cap[0];
          var l = item.align.length;
          var i;

          for (i = 0; i < l; i++) {
            if (/^ *-+: *$/.test(item.align[i])) {
              item.align[i] = 'right';
            } else if (/^ *:-+: *$/.test(item.align[i])) {
              item.align[i] = 'center';
            } else if (/^ *:-+ *$/.test(item.align[i])) {
              item.align[i] = 'left';
            } else {
              item.align[i] = null;
            }
          }

          l = item.cells.length;

          for (i = 0; i < l; i++) {
            item.cells[i] = splitCells$1(item.cells[i].replace(/^ *\| *| *\| *$/g, ''), item.header.length);
          }

          return item;
        }
      }
    };

    _proto.lheading = function lheading(src) {
      var cap = this.rules.block.lheading.exec(src);

      if (cap) {
        return {
          type: 'heading',
          raw: cap[0],
          depth: cap[2].charAt(0) === '=' ? 1 : 2,
          text: cap[1]
        };
      }
    };

    _proto.paragraph = function paragraph(src) {
      var cap = this.rules.block.paragraph.exec(src);

      if (cap) {
        return {
          type: 'paragraph',
          raw: cap[0],
          text: cap[1].charAt(cap[1].length - 1) === '\n' ? cap[1].slice(0, -1) : cap[1]
        };
      }
    };

    _proto.text = function text(src) {
      var cap = this.rules.block.text.exec(src);

      if (cap) {
        return {
          type: 'text',
          raw: cap[0],
          text: cap[0]
        };
      }
    };

    _proto.escape = function escape(src) {
      var cap = this.rules.inline.escape.exec(src);

      if (cap) {
        return {
          type: 'escape',
          raw: cap[0],
          text: _escape(cap[1])
        };
      }
    };

    _proto.tag = function tag(src, inLink, inRawBlock) {
      var cap = this.rules.inline.tag.exec(src);

      if (cap) {
        if (!inLink && /^<a /i.test(cap[0])) {
          inLink = true;
        } else if (inLink && /^<\/a>/i.test(cap[0])) {
          inLink = false;
        }

        if (!inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
          inRawBlock = true;
        } else if (inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
          inRawBlock = false;
        }

        return {
          type: this.options.sanitize ? 'text' : 'html',
          raw: cap[0],
          inLink: inLink,
          inRawBlock: inRawBlock,
          text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0]
        };
      }
    };

    _proto.link = function link(src) {
      var cap = this.rules.inline.link.exec(src);

      if (cap) {
        var trimmedUrl = cap[2].trim();

        if (!this.options.pedantic && /^</.test(trimmedUrl)) {
          // commonmark requires matching angle brackets
          if (!/>$/.test(trimmedUrl)) {
            return;
          } // ending angle bracket cannot be escaped


          var rtrimSlash = rtrim$1(trimmedUrl.slice(0, -1), '\\');

          if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
            return;
          }
        } else {
          // find closing parenthesis
          var lastParenIndex = findClosingBracket$1(cap[2], '()');

          if (lastParenIndex > -1) {
            var start = cap[0].indexOf('!') === 0 ? 5 : 4;
            var linkLen = start + cap[1].length + lastParenIndex;
            cap[2] = cap[2].substring(0, lastParenIndex);
            cap[0] = cap[0].substring(0, linkLen).trim();
            cap[3] = '';
          }
        }

        var href = cap[2];
        var title = '';

        if (this.options.pedantic) {
          // split pedantic href and title
          var link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);

          if (link) {
            href = link[1];
            title = link[3];
          }
        } else {
          title = cap[3] ? cap[3].slice(1, -1) : '';
        }

        href = href.trim();

        if (/^</.test(href)) {
          if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
            // pedantic allows starting angle bracket without ending angle bracket
            href = href.slice(1);
          } else {
            href = href.slice(1, -1);
          }
        }

        return outputLink(cap, {
          href: href ? href.replace(this.rules.inline._escapes, '$1') : href,
          title: title ? title.replace(this.rules.inline._escapes, '$1') : title
        }, cap[0]);
      }
    };

    _proto.reflink = function reflink(src, links) {
      var cap;

      if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
        var link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
        link = links[link.toLowerCase()];

        if (!link || !link.href) {
          var text = cap[0].charAt(0);
          return {
            type: 'text',
            raw: text,
            text: text
          };
        }

        return outputLink(cap, link, cap[0]);
      }
    };

    _proto.emStrong = function emStrong(src, maskedSrc, prevChar) {
      if (prevChar === void 0) {
        prevChar = '';
      }

      var match = this.rules.inline.emStrong.lDelim.exec(src);
      if (!match) return;
      if (match[3] && prevChar.match(/(?:[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u0660-\u0669\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0966-\u096F\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09F9\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AE6-\u0AEF\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B6F\u0B71-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0BE6-\u0BF2\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C66-\u0C6F\u0C78-\u0C7E\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D58-\u0D61\u0D66-\u0D78\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DE6-\u0DEF\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F20-\u0F33\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F-\u1049\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u1090-\u1099\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A20-\u1A54\u1A80-\u1A89\u1A90-\u1A99\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B50-\u1B59\u1B83-\u1BA0\u1BAE-\u1BE5\u1C00-\u1C23\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BF\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA830-\uA835\uA840-\uA873\uA882-\uA8B3\uA8D0-\uA8D9\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA900-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF-\uA9D9\uA9E0-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDE80-\uDE9C\uDEA0-\uDED0\uDEE1-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE40-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE4\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD23\uDD30-\uDD39\uDE60-\uDE7E\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF27\uDF30-\uDF45\uDF51-\uDF54\uDFB0-\uDFCB\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC52-\uDC6F\uDC83-\uDCAF\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD03-\uDD26\uDD36-\uDD3F\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDEF0-\uDEF9\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC50-\uDC59\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE50-\uDE59\uDE80-\uDEAA\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF30-\uDF3B]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCF2\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF2\uDFB0\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82C[\uDC00-\uDD1E\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD40-\uDD49\uDD4E\uDEC0-\uDEEB\uDEF0-\uDEF9]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCCF\uDD00-\uDD43\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDD\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/)) return; // _ can't be between two alphanumerics. \p{L}\p{N} includes non-english alphabet/numbers as well

      var nextChar = match[1] || match[2] || '';

      if (!nextChar || nextChar && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar))) {
        var lLength = match[0].length - 1;
        var rDelim,
            rLength,
            delimTotal = lLength,
            midDelimTotal = 0;
        var endReg = match[0][0] === '*' ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
        endReg.lastIndex = 0;
        maskedSrc = maskedSrc.slice(-1 * src.length + lLength); // Bump maskedSrc to same section of string as src (move to lexer?)

        while ((match = endReg.exec(maskedSrc)) != null) {
          rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
          if (!rDelim) continue; // matched the first alternative in rules.js (skip the * in __abc*abc__)

          rLength = rDelim.length;

          if (match[3] || match[4]) {
            // found another Left Delim
            delimTotal += rLength;
            continue;
          } else if (match[5] || match[6]) {
            // either Left or Right Delim
            if (lLength % 3 && !((lLength + rLength) % 3)) {
              midDelimTotal += rLength;
              continue; // CommonMark Emphasis Rules 9-10
            }
          }

          delimTotal -= rLength;
          if (delimTotal > 0) continue; // Haven't found enough closing delimiters
          // If this is the last rDelimiter, remove extra characters. *a*** -> *a*

          if (delimTotal + midDelimTotal - rLength <= 0 && !maskedSrc.slice(endReg.lastIndex).match(endReg)) {
            rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
          }

          if (Math.min(lLength, rLength) % 2) {
            return {
              type: 'em',
              raw: src.slice(0, lLength + match.index + rLength + 1),
              text: src.slice(1, lLength + match.index + rLength)
            };
          }

          if (Math.min(lLength, rLength) % 2 === 0) {
            return {
              type: 'strong',
              raw: src.slice(0, lLength + match.index + rLength + 1),
              text: src.slice(2, lLength + match.index + rLength - 1)
            };
          }
        }
      }
    };

    _proto.codespan = function codespan(src) {
      var cap = this.rules.inline.code.exec(src);

      if (cap) {
        var text = cap[2].replace(/\n/g, ' ');
        var hasNonSpaceChars = /[^ ]/.test(text);
        var hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);

        if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
          text = text.substring(1, text.length - 1);
        }

        text = _escape(text, true);
        return {
          type: 'codespan',
          raw: cap[0],
          text: text
        };
      }
    };

    _proto.br = function br(src) {
      var cap = this.rules.inline.br.exec(src);

      if (cap) {
        return {
          type: 'br',
          raw: cap[0]
        };
      }
    };

    _proto.del = function del(src) {
      var cap = this.rules.inline.del.exec(src);

      if (cap) {
        return {
          type: 'del',
          raw: cap[0],
          text: cap[2]
        };
      }
    };

    _proto.autolink = function autolink(src, mangle) {
      var cap = this.rules.inline.autolink.exec(src);

      if (cap) {
        var text, href;

        if (cap[2] === '@') {
          text = _escape(this.options.mangle ? mangle(cap[1]) : cap[1]);
          href = 'mailto:' + text;
        } else {
          text = _escape(cap[1]);
          href = text;
        }

        return {
          type: 'link',
          raw: cap[0],
          text: text,
          href: href,
          tokens: [{
            type: 'text',
            raw: text,
            text: text
          }]
        };
      }
    };

    _proto.url = function url(src, mangle) {
      var cap;

      if (cap = this.rules.inline.url.exec(src)) {
        var text, href;

        if (cap[2] === '@') {
          text = _escape(this.options.mangle ? mangle(cap[0]) : cap[0]);
          href = 'mailto:' + text;
        } else {
          // do extended autolink path validation
          var prevCapZero;

          do {
            prevCapZero = cap[0];
            cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
          } while (prevCapZero !== cap[0]);

          text = _escape(cap[0]);

          if (cap[1] === 'www.') {
            href = 'http://' + text;
          } else {
            href = text;
          }
        }

        return {
          type: 'link',
          raw: cap[0],
          text: text,
          href: href,
          tokens: [{
            type: 'text',
            raw: text,
            text: text
          }]
        };
      }
    };

    _proto.inlineText = function inlineText(src, inRawBlock, smartypants) {
      var cap = this.rules.inline.text.exec(src);

      if (cap) {
        var text;

        if (inRawBlock) {
          text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0];
        } else {
          text = _escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);
        }

        return {
          type: 'text',
          raw: cap[0],
          text: text
        };
      }
    };

    return Tokenizer;
  }();

  var noopTest$1 = helpers.noopTest,
      edit$1 = helpers.edit,
      merge$1 = helpers.merge;
  /**
   * Block-Level Grammar
   */

  var block = {
    newline: /^(?: *(?:\n|$))+/,
    code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
    fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?:\n+|$)|$)/,
    hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
    heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
    blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
    list: /^( {0,3})(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?! {0,3}bull )\n*|\s*$)/,
    html: '^ {0,3}(?:' // optional indentation
    + '<(script|pre|style)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
    + '|comment[^\\n]*(\\n+|$)' // (2)
    + '|<\\?[\\s\\S]*?(?:\\?>\\n*|$)' // (3)
    + '|<![A-Z][\\s\\S]*?(?:>\\n*|$)' // (4)
    + '|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)' // (5)
    + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:\\n{2,}|$)' // (6)
    + '|<(?!script|pre|style)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) open tag
    + '|</(?!script|pre|style)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) closing tag
    + ')',
    def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
    nptable: noopTest$1,
    table: noopTest$1,
    lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
    // regex template, placeholders will be replaced according to different paragraph
    // interruption rules of commonmark and the original markdown spec:
    _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html| +\n)[^\n]+)*)/,
    text: /^[^\n]+/
  };
  block._label = /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/;
  block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
  block.def = edit$1(block.def).replace('label', block._label).replace('title', block._title).getRegex();
  block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
  block.item = /^( *)(bull) ?[^\n]*(?:\n(?! *bull ?)[^\n]*)*/;
  block.item = edit$1(block.item, 'gm').replace(/bull/g, block.bullet).getRegex();
  block.listItemStart = edit$1(/^( *)(bull)/).replace('bull', block.bullet).getRegex();
  block.list = edit$1(block.list).replace(/bull/g, block.bullet).replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))').replace('def', '\\n+(?=' + block.def.source + ')').getRegex();
  block._tag = 'address|article|aside|base|basefont|blockquote|body|caption' + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption' + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe' + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option' + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr' + '|track|ul';
  block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
  block.html = edit$1(block.html, 'i').replace('comment', block._comment).replace('tag', block._tag).replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
  block.paragraph = edit$1(block._paragraph).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
  .replace('blockquote', ' {0,3}>').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
  .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)').replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
  .getRegex();
  block.blockquote = edit$1(block.blockquote).replace('paragraph', block.paragraph).getRegex();
  /**
   * Normal Block Grammar
   */

  block.normal = merge$1({}, block);
  /**
   * GFM Block Grammar
   */

  block.gfm = merge$1({}, block.normal, {
    nptable: '^ *([^|\\n ].*\\|.*)\\n' // Header
    + ' {0,3}([-:]+ *\\|[-| :]*)' // Align
    + '(?:\\n((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)',
    // Cells
    table: '^ *\\|(.+)\\n' // Header
    + ' {0,3}\\|?( *[-:]+[-| :]*)' // Align
    + '(?:\\n *((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)' // Cells

  });
  block.gfm.nptable = edit$1(block.gfm.nptable).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('blockquote', ' {0,3}>').replace('code', ' {4}[^\\n]').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
  .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)').replace('tag', block._tag) // tables can be interrupted by type (6) html blocks
  .getRegex();
  block.gfm.table = edit$1(block.gfm.table).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('blockquote', ' {0,3}>').replace('code', ' {4}[^\\n]').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
  .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)').replace('tag', block._tag) // tables can be interrupted by type (6) html blocks
  .getRegex();
  /**
   * Pedantic grammar (original John Gruber's loose markdown specification)
   */

  block.pedantic = merge$1({}, block.normal, {
    html: edit$1('^ *(?:comment *(?:\\n|\\s*$)' + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
    + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))').replace('comment', block._comment).replace(/tag/g, '(?!(?:' + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub' + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)' + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b').getRegex(),
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
    heading: /^(#{1,6})(.*)(?:\n+|$)/,
    fences: noopTest$1,
    // fences not supported
    paragraph: edit$1(block.normal._paragraph).replace('hr', block.hr).replace('heading', ' *#{1,6} *[^\n]').replace('lheading', block.lheading).replace('blockquote', ' {0,3}>').replace('|fences', '').replace('|list', '').replace('|html', '').getRegex()
  });
  /**
   * Inline-Level Grammar
   */

  var inline = {
    escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
    autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
    url: noopTest$1,
    tag: '^comment' + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
    + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
    + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
    + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
    + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>',
    // CDATA section
    link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
    reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
    nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,
    reflinkSearch: 'reflink|nolink(?!\\()',
    emStrong: {
      lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
      //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
      //        () Skip other delimiter (1) #***                (2) a***#, a***                   (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a
      rDelimAst: /\_\_[^_]*?\*[^_]*?\_\_|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,
      rDelimUnd: /\*\*[^*]*?\_[^*]*?\*\*|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/ // ^- Not allowed for _

    },
    code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
    br: /^( {2,}|\\)\n(?!\s*$)/,
    del: noopTest$1,
    text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
    punctuation: /^([\spunctuation])/
  }; // list of punctuation marks from CommonMark spec
  // without * and _ to handle the different emphasis markers * and _

  inline._punctuation = '!"#$%&\'()+\\-.,/:;<=>?@\\[\\]`^{|}~';
  inline.punctuation = edit$1(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex(); // sequences em should skip over [title](link), `code`, <html>

  inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
  inline.escapedEmSt = /\\\*|\\_/g;
  inline._comment = edit$1(block._comment).replace('(?:-->|$)', '-->').getRegex();
  inline.emStrong.lDelim = edit$1(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();
  inline.emStrong.rDelimAst = edit$1(inline.emStrong.rDelimAst, 'g').replace(/punct/g, inline._punctuation).getRegex();
  inline.emStrong.rDelimUnd = edit$1(inline.emStrong.rDelimUnd, 'g').replace(/punct/g, inline._punctuation).getRegex();
  inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
  inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
  inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
  inline.autolink = edit$1(inline.autolink).replace('scheme', inline._scheme).replace('email', inline._email).getRegex();
  inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
  inline.tag = edit$1(inline.tag).replace('comment', inline._comment).replace('attribute', inline._attribute).getRegex();
  inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
  inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
  inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
  inline.link = edit$1(inline.link).replace('label', inline._label).replace('href', inline._href).replace('title', inline._title).getRegex();
  inline.reflink = edit$1(inline.reflink).replace('label', inline._label).getRegex();
  inline.reflinkSearch = edit$1(inline.reflinkSearch, 'g').replace('reflink', inline.reflink).replace('nolink', inline.nolink).getRegex();
  /**
   * Normal Inline Grammar
   */

  inline.normal = merge$1({}, inline);
  /**
   * Pedantic Inline Grammar
   */

  inline.pedantic = merge$1({}, inline.normal, {
    strong: {
      start: /^__|\*\*/,
      middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
      endAst: /\*\*(?!\*)/g,
      endUnd: /__(?!_)/g
    },
    em: {
      start: /^_|\*/,
      middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
      endAst: /\*(?!\*)/g,
      endUnd: /_(?!_)/g
    },
    link: edit$1(/^!?\[(label)\]\((.*?)\)/).replace('label', inline._label).getRegex(),
    reflink: edit$1(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace('label', inline._label).getRegex()
  });
  /**
   * GFM Inline Grammar
   */

  inline.gfm = merge$1({}, inline.normal, {
    escape: edit$1(inline.escape).replace('])', '~|])').getRegex(),
    _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
    url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
    _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
    del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
    text: /^([`~]+|[^`~])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))/
  });
  inline.gfm.url = edit$1(inline.gfm.url, 'i').replace('email', inline.gfm._extended_email).getRegex();
  /**
   * GFM + Line Breaks Inline Grammar
   */

  inline.breaks = merge$1({}, inline.gfm, {
    br: edit$1(inline.br).replace('{2,}', '*').getRegex(),
    text: edit$1(inline.gfm.text).replace('\\b_', '\\b_| {2,}\\n').replace(/\{2,\}/g, '*').getRegex()
  });
  var rules = {
    block: block,
    inline: inline
  };

  var defaults$2 = defaults.defaults;
  var block$1 = rules.block,
      inline$1 = rules.inline;
  var repeatString$1 = helpers.repeatString;
  /**
   * smartypants text replacement
   */

  function smartypants(text) {
    return text // em-dashes
    .replace(/---/g, "\u2014") // en-dashes
    .replace(/--/g, "\u2013") // opening singles
    .replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018") // closing singles & apostrophes
    .replace(/'/g, "\u2019") // opening doubles
    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C") // closing doubles
    .replace(/"/g, "\u201D") // ellipses
    .replace(/\.{3}/g, "\u2026");
  }
  /**
   * mangle email addresses
   */


  function mangle(text) {
    var out = '',
        i,
        ch;
    var l = text.length;

    for (i = 0; i < l; i++) {
      ch = text.charCodeAt(i);

      if (Math.random() > 0.5) {
        ch = 'x' + ch.toString(16);
      }

      out += '&#' + ch + ';';
    }

    return out;
  }
  /**
   * Block Lexer
   */


  var Lexer_1 = /*#__PURE__*/function () {
    function Lexer(options) {
      this.tokens = [];
      this.tokens.links = Object.create(null);
      this.options = options || defaults$2;
      this.options.tokenizer = this.options.tokenizer || new Tokenizer_1();
      this.tokenizer = this.options.tokenizer;
      this.tokenizer.options = this.options;
      var rules = {
        block: block$1.normal,
        inline: inline$1.normal
      };

      if (this.options.pedantic) {
        rules.block = block$1.pedantic;
        rules.inline = inline$1.pedantic;
      } else if (this.options.gfm) {
        rules.block = block$1.gfm;

        if (this.options.breaks) {
          rules.inline = inline$1.breaks;
        } else {
          rules.inline = inline$1.gfm;
        }
      }

      this.tokenizer.rules = rules;
    }
    /**
     * Expose Rules
     */


    /**
     * Static Lex Method
     */
    Lexer.lex = function lex(src, options) {
      var lexer = new Lexer(options);
      return lexer.lex(src);
    }
    /**
     * Static Lex Inline Method
     */
    ;

    Lexer.lexInline = function lexInline(src, options) {
      var lexer = new Lexer(options);
      return lexer.inlineTokens(src);
    }
    /**
     * Preprocessing
     */
    ;

    var _proto = Lexer.prototype;

    _proto.lex = function lex(src) {
      src = src.replace(/\r\n|\r/g, '\n').replace(/\t/g, '    ');
      this.blockTokens(src, this.tokens, true);
      this.inline(this.tokens);
      return this.tokens;
    }
    /**
     * Lexing
     */
    ;

    _proto.blockTokens = function blockTokens(src, tokens, top) {
      if (tokens === void 0) {
        tokens = [];
      }

      if (top === void 0) {
        top = true;
      }

      if (this.options.pedantic) {
        src = src.replace(/^ +$/gm, '');
      }

      var token, i, l, lastToken;

      while (src) {
        // newline
        if (token = this.tokenizer.space(src)) {
          src = src.substring(token.raw.length);

          if (token.type) {
            tokens.push(token);
          }

          continue;
        } // code


        if (token = this.tokenizer.code(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1]; // An indented code block cannot interrupt a paragraph.

          if (lastToken && lastToken.type === 'paragraph') {
            lastToken.raw += '\n' + token.raw;
            lastToken.text += '\n' + token.text;
          } else {
            tokens.push(token);
          }

          continue;
        } // fences


        if (token = this.tokenizer.fences(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // heading


        if (token = this.tokenizer.heading(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // table no leading pipe (gfm)


        if (token = this.tokenizer.nptable(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // hr


        if (token = this.tokenizer.hr(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // blockquote


        if (token = this.tokenizer.blockquote(src)) {
          src = src.substring(token.raw.length);
          token.tokens = this.blockTokens(token.text, [], top);
          tokens.push(token);
          continue;
        } // list


        if (token = this.tokenizer.list(src)) {
          src = src.substring(token.raw.length);
          l = token.items.length;

          for (i = 0; i < l; i++) {
            token.items[i].tokens = this.blockTokens(token.items[i].text, [], false);
          }

          tokens.push(token);
          continue;
        } // html


        if (token = this.tokenizer.html(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // def


        if (top && (token = this.tokenizer.def(src))) {
          src = src.substring(token.raw.length);

          if (!this.tokens.links[token.tag]) {
            this.tokens.links[token.tag] = {
              href: token.href,
              title: token.title
            };
          }

          continue;
        } // table (gfm)


        if (token = this.tokenizer.table(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // lheading


        if (token = this.tokenizer.lheading(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // top-level paragraph


        if (top && (token = this.tokenizer.paragraph(src))) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // text


        if (token = this.tokenizer.text(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];

          if (lastToken && lastToken.type === 'text') {
            lastToken.raw += '\n' + token.raw;
            lastToken.text += '\n' + token.text;
          } else {
            tokens.push(token);
          }

          continue;
        }

        if (src) {
          var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);

          if (this.options.silent) {
            console.error(errMsg);
            break;
          } else {
            throw new Error(errMsg);
          }
        }
      }

      return tokens;
    };

    _proto.inline = function inline(tokens) {
      var i, j, k, l2, row, token;
      var l = tokens.length;

      for (i = 0; i < l; i++) {
        token = tokens[i];

        switch (token.type) {
          case 'paragraph':
          case 'text':
          case 'heading':
            {
              token.tokens = [];
              this.inlineTokens(token.text, token.tokens);
              break;
            }

          case 'table':
            {
              token.tokens = {
                header: [],
                cells: []
              }; // header

              l2 = token.header.length;

              for (j = 0; j < l2; j++) {
                token.tokens.header[j] = [];
                this.inlineTokens(token.header[j], token.tokens.header[j]);
              } // cells


              l2 = token.cells.length;

              for (j = 0; j < l2; j++) {
                row = token.cells[j];
                token.tokens.cells[j] = [];

                for (k = 0; k < row.length; k++) {
                  token.tokens.cells[j][k] = [];
                  this.inlineTokens(row[k], token.tokens.cells[j][k]);
                }
              }

              break;
            }

          case 'blockquote':
            {
              this.inline(token.tokens);
              break;
            }

          case 'list':
            {
              l2 = token.items.length;

              for (j = 0; j < l2; j++) {
                this.inline(token.items[j].tokens);
              }

              break;
            }
        }
      }

      return tokens;
    }
    /**
     * Lexing/Compiling
     */
    ;

    _proto.inlineTokens = function inlineTokens(src, tokens, inLink, inRawBlock) {
      if (tokens === void 0) {
        tokens = [];
      }

      if (inLink === void 0) {
        inLink = false;
      }

      if (inRawBlock === void 0) {
        inRawBlock = false;
      }

      var token, lastToken; // String with links masked to avoid interference with em and strong

      var maskedSrc = src;
      var match;
      var keepPrevChar, prevChar; // Mask out reflinks

      if (this.tokens.links) {
        var links = Object.keys(this.tokens.links);

        if (links.length > 0) {
          while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
            if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {
              maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString$1('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
            }
          }
        }
      } // Mask out other blocks


      while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
        maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString$1('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
      } // Mask out escaped em & strong delimiters


      while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
        maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
      }

      while (src) {
        if (!keepPrevChar) {
          prevChar = '';
        }

        keepPrevChar = false; // escape

        if (token = this.tokenizer.escape(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // tag


        if (token = this.tokenizer.tag(src, inLink, inRawBlock)) {
          src = src.substring(token.raw.length);
          inLink = token.inLink;
          inRawBlock = token.inRawBlock;
          var _lastToken = tokens[tokens.length - 1];

          if (_lastToken && token.type === 'text' && _lastToken.type === 'text') {
            _lastToken.raw += token.raw;
            _lastToken.text += token.text;
          } else {
            tokens.push(token);
          }

          continue;
        } // link


        if (token = this.tokenizer.link(src)) {
          src = src.substring(token.raw.length);

          if (token.type === 'link') {
            token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);
          }

          tokens.push(token);
          continue;
        } // reflink, nolink


        if (token = this.tokenizer.reflink(src, this.tokens.links)) {
          src = src.substring(token.raw.length);
          var _lastToken2 = tokens[tokens.length - 1];

          if (token.type === 'link') {
            token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);
            tokens.push(token);
          } else if (_lastToken2 && token.type === 'text' && _lastToken2.type === 'text') {
            _lastToken2.raw += token.raw;
            _lastToken2.text += token.text;
          } else {
            tokens.push(token);
          }

          continue;
        } // em & strong


        if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
          src = src.substring(token.raw.length);
          token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
          tokens.push(token);
          continue;
        } // code


        if (token = this.tokenizer.codespan(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // br


        if (token = this.tokenizer.br(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // del (gfm)


        if (token = this.tokenizer.del(src)) {
          src = src.substring(token.raw.length);
          token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
          tokens.push(token);
          continue;
        } // autolink


        if (token = this.tokenizer.autolink(src, mangle)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // url (gfm)


        if (!inLink && (token = this.tokenizer.url(src, mangle))) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // text


        if (token = this.tokenizer.inlineText(src, inRawBlock, smartypants)) {
          src = src.substring(token.raw.length);

          if (token.raw.slice(-1) !== '_') {
            // Track prevChar before string of ____ started
            prevChar = token.raw.slice(-1);
          }

          keepPrevChar = true;
          lastToken = tokens[tokens.length - 1];

          if (lastToken && lastToken.type === 'text') {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }

          continue;
        }

        if (src) {
          var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);

          if (this.options.silent) {
            console.error(errMsg);
            break;
          } else {
            throw new Error(errMsg);
          }
        }
      }

      return tokens;
    };

    _createClass(Lexer, null, [{
      key: "rules",
      get: function get() {
        return {
          block: block$1,
          inline: inline$1
        };
      }
    }]);

    return Lexer;
  }();

  var defaults$3 = defaults.defaults;
  var cleanUrl$1 = helpers.cleanUrl,
      escape$1 = helpers.escape;
  /**
   * Renderer
   */

  var Renderer_1 = /*#__PURE__*/function () {
    function Renderer(options) {
      this.options = options || defaults$3;
    }

    var _proto = Renderer.prototype;

    _proto.code = function code(_code, infostring, escaped) {
      var lang = (infostring || '').match(/\S*/)[0];

      if (this.options.highlight) {
        var out = this.options.highlight(_code, lang);

        if (out != null && out !== _code) {
          escaped = true;
          _code = out;
        }
      }

      _code = _code.replace(/\n$/, '') + '\n';

      if (!lang) {
        return '<pre><code>' + (escaped ? _code : escape$1(_code, true)) + '</code></pre>\n';
      }

      return '<pre><code class="' + this.options.langPrefix + escape$1(lang, true) + '">' + (escaped ? _code : escape$1(_code, true)) + '</code></pre>\n';
    };

    _proto.blockquote = function blockquote(quote) {
      return '<blockquote>\n' + quote + '</blockquote>\n';
    };

    _proto.html = function html(_html) {
      return _html;
    };

    _proto.heading = function heading(text, level, raw, slugger) {
      if (this.options.headerIds) {
        return '<h' + level + ' id="' + this.options.headerPrefix + slugger.slug(raw) + '">' + text + '</h' + level + '>\n';
      } // ignore IDs


      return '<h' + level + '>' + text + '</h' + level + '>\n';
    };

    _proto.hr = function hr() {
      return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
    };

    _proto.list = function list(body, ordered, start) {
      var type = ordered ? 'ol' : 'ul',
          startatt = ordered && start !== 1 ? ' start="' + start + '"' : '';
      return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
    };

    _proto.listitem = function listitem(text) {
      return '<li>' + text + '</li>\n';
    };

    _proto.checkbox = function checkbox(checked) {
      return '<input ' + (checked ? 'checked="" ' : '') + 'disabled="" type="checkbox"' + (this.options.xhtml ? ' /' : '') + '> ';
    };

    _proto.paragraph = function paragraph(text) {
      return '<p>' + text + '</p>\n';
    };

    _proto.table = function table(header, body) {
      if (body) body = '<tbody>' + body + '</tbody>';
      return '<table>\n' + '<thead>\n' + header + '</thead>\n' + body + '</table>\n';
    };

    _proto.tablerow = function tablerow(content) {
      return '<tr>\n' + content + '</tr>\n';
    };

    _proto.tablecell = function tablecell(content, flags) {
      var type = flags.header ? 'th' : 'td';
      var tag = flags.align ? '<' + type + ' align="' + flags.align + '">' : '<' + type + '>';
      return tag + content + '</' + type + '>\n';
    } // span level renderer
    ;

    _proto.strong = function strong(text) {
      return '<strong>' + text + '</strong>';
    };

    _proto.em = function em(text) {
      return '<em>' + text + '</em>';
    };

    _proto.codespan = function codespan(text) {
      return '<code>' + text + '</code>';
    };

    _proto.br = function br() {
      return this.options.xhtml ? '<br/>' : '<br>';
    };

    _proto.del = function del(text) {
      return '<del>' + text + '</del>';
    };

    _proto.link = function link(href, title, text) {
      href = cleanUrl$1(this.options.sanitize, this.options.baseUrl, href);

      if (href === null) {
        return text;
      }

      var out = '<a href="' + escape$1(href) + '"';

      if (title) {
        out += ' title="' + title + '"';
      }

      out += '>' + text + '</a>';
      return out;
    };

    _proto.image = function image(href, title, text) {
      href = cleanUrl$1(this.options.sanitize, this.options.baseUrl, href);

      if (href === null) {
        return text;
      }

      var out = '<img src="' + href + '" alt="' + text + '"';

      if (title) {
        out += ' title="' + title + '"';
      }

      out += this.options.xhtml ? '/>' : '>';
      return out;
    };

    _proto.text = function text(_text) {
      return _text;
    };

    return Renderer;
  }();

  /**
   * TextRenderer
   * returns only the textual part of the token
   */
  var TextRenderer_1 = /*#__PURE__*/function () {
    function TextRenderer() {}

    var _proto = TextRenderer.prototype;

    // no need for block level renderers
    _proto.strong = function strong(text) {
      return text;
    };

    _proto.em = function em(text) {
      return text;
    };

    _proto.codespan = function codespan(text) {
      return text;
    };

    _proto.del = function del(text) {
      return text;
    };

    _proto.html = function html(text) {
      return text;
    };

    _proto.text = function text(_text) {
      return _text;
    };

    _proto.link = function link(href, title, text) {
      return '' + text;
    };

    _proto.image = function image(href, title, text) {
      return '' + text;
    };

    _proto.br = function br() {
      return '';
    };

    return TextRenderer;
  }();

  /**
   * Slugger generates header id
   */
  var Slugger_1 = /*#__PURE__*/function () {
    function Slugger() {
      this.seen = {};
    }

    var _proto = Slugger.prototype;

    _proto.serialize = function serialize(value) {
      return value.toLowerCase().trim() // remove html tags
      .replace(/<[!\/a-z].*?>/ig, '') // remove unwanted chars
      .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, '').replace(/\s/g, '-');
    }
    /**
     * Finds the next safe (unique) slug to use
     */
    ;

    _proto.getNextSafeSlug = function getNextSafeSlug(originalSlug, isDryRun) {
      var slug = originalSlug;
      var occurenceAccumulator = 0;

      if (this.seen.hasOwnProperty(slug)) {
        occurenceAccumulator = this.seen[originalSlug];

        do {
          occurenceAccumulator++;
          slug = originalSlug + '-' + occurenceAccumulator;
        } while (this.seen.hasOwnProperty(slug));
      }

      if (!isDryRun) {
        this.seen[originalSlug] = occurenceAccumulator;
        this.seen[slug] = 0;
      }

      return slug;
    }
    /**
     * Convert string to unique id
     * @param {object} options
     * @param {boolean} options.dryrun Generates the next unique slug without updating the internal accumulator.
     */
    ;

    _proto.slug = function slug(value, options) {
      if (options === void 0) {
        options = {};
      }

      var slug = this.serialize(value);
      return this.getNextSafeSlug(slug, options.dryrun);
    };

    return Slugger;
  }();

  var defaults$4 = defaults.defaults;
  var unescape$1 = helpers.unescape;
  /**
   * Parsing & Compiling
   */

  var Parser_1 = /*#__PURE__*/function () {
    function Parser(options) {
      this.options = options || defaults$4;
      this.options.renderer = this.options.renderer || new Renderer_1();
      this.renderer = this.options.renderer;
      this.renderer.options = this.options;
      this.textRenderer = new TextRenderer_1();
      this.slugger = new Slugger_1();
    }
    /**
     * Static Parse Method
     */


    Parser.parse = function parse(tokens, options) {
      var parser = new Parser(options);
      return parser.parse(tokens);
    }
    /**
     * Static Parse Inline Method
     */
    ;

    Parser.parseInline = function parseInline(tokens, options) {
      var parser = new Parser(options);
      return parser.parseInline(tokens);
    }
    /**
     * Parse Loop
     */
    ;

    var _proto = Parser.prototype;

    _proto.parse = function parse(tokens, top) {
      if (top === void 0) {
        top = true;
      }

      var out = '',
          i,
          j,
          k,
          l2,
          l3,
          row,
          cell,
          header,
          body,
          token,
          ordered,
          start,
          loose,
          itemBody,
          item,
          checked,
          task,
          checkbox;
      var l = tokens.length;

      for (i = 0; i < l; i++) {
        token = tokens[i];

        switch (token.type) {
          case 'space':
            {
              continue;
            }

          case 'hr':
            {
              out += this.renderer.hr();
              continue;
            }

          case 'heading':
            {
              out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape$1(this.parseInline(token.tokens, this.textRenderer)), this.slugger);
              continue;
            }

          case 'code':
            {
              out += this.renderer.code(token.text, token.lang, token.escaped);
              continue;
            }

          case 'table':
            {
              header = ''; // header

              cell = '';
              l2 = token.header.length;

              for (j = 0; j < l2; j++) {
                cell += this.renderer.tablecell(this.parseInline(token.tokens.header[j]), {
                  header: true,
                  align: token.align[j]
                });
              }

              header += this.renderer.tablerow(cell);
              body = '';
              l2 = token.cells.length;

              for (j = 0; j < l2; j++) {
                row = token.tokens.cells[j];
                cell = '';
                l3 = row.length;

                for (k = 0; k < l3; k++) {
                  cell += this.renderer.tablecell(this.parseInline(row[k]), {
                    header: false,
                    align: token.align[k]
                  });
                }

                body += this.renderer.tablerow(cell);
              }

              out += this.renderer.table(header, body);
              continue;
            }

          case 'blockquote':
            {
              body = this.parse(token.tokens);
              out += this.renderer.blockquote(body);
              continue;
            }

          case 'list':
            {
              ordered = token.ordered;
              start = token.start;
              loose = token.loose;
              l2 = token.items.length;
              body = '';

              for (j = 0; j < l2; j++) {
                item = token.items[j];
                checked = item.checked;
                task = item.task;
                itemBody = '';

                if (item.task) {
                  checkbox = this.renderer.checkbox(checked);

                  if (loose) {
                    if (item.tokens.length > 0 && item.tokens[0].type === 'text') {
                      item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;

                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {
                        item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;
                      }
                    } else {
                      item.tokens.unshift({
                        type: 'text',
                        text: checkbox
                      });
                    }
                  } else {
                    itemBody += checkbox;
                  }
                }

                itemBody += this.parse(item.tokens, loose);
                body += this.renderer.listitem(itemBody, task, checked);
              }

              out += this.renderer.list(body, ordered, start);
              continue;
            }

          case 'html':
            {
              // TODO parse inline content if parameter markdown=1
              out += this.renderer.html(token.text);
              continue;
            }

          case 'paragraph':
            {
              out += this.renderer.paragraph(this.parseInline(token.tokens));
              continue;
            }

          case 'text':
            {
              body = token.tokens ? this.parseInline(token.tokens) : token.text;

              while (i + 1 < l && tokens[i + 1].type === 'text') {
                token = tokens[++i];
                body += '\n' + (token.tokens ? this.parseInline(token.tokens) : token.text);
              }

              out += top ? this.renderer.paragraph(body) : body;
              continue;
            }

          default:
            {
              var errMsg = 'Token with "' + token.type + '" type was not found.';

              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
        }
      }

      return out;
    }
    /**
     * Parse Inline Tokens
     */
    ;

    _proto.parseInline = function parseInline(tokens, renderer) {
      renderer = renderer || this.renderer;
      var out = '',
          i,
          token;
      var l = tokens.length;

      for (i = 0; i < l; i++) {
        token = tokens[i];

        switch (token.type) {
          case 'escape':
            {
              out += renderer.text(token.text);
              break;
            }

          case 'html':
            {
              out += renderer.html(token.text);
              break;
            }

          case 'link':
            {
              out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
              break;
            }

          case 'image':
            {
              out += renderer.image(token.href, token.title, token.text);
              break;
            }

          case 'strong':
            {
              out += renderer.strong(this.parseInline(token.tokens, renderer));
              break;
            }

          case 'em':
            {
              out += renderer.em(this.parseInline(token.tokens, renderer));
              break;
            }

          case 'codespan':
            {
              out += renderer.codespan(token.text);
              break;
            }

          case 'br':
            {
              out += renderer.br();
              break;
            }

          case 'del':
            {
              out += renderer.del(this.parseInline(token.tokens, renderer));
              break;
            }

          case 'text':
            {
              out += renderer.text(token.text);
              break;
            }

          default:
            {
              var errMsg = 'Token with "' + token.type + '" type was not found.';

              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
        }
      }

      return out;
    };

    return Parser;
  }();

  var merge$2 = helpers.merge,
      checkSanitizeDeprecation$1 = helpers.checkSanitizeDeprecation,
      escape$2 = helpers.escape;
  var getDefaults = defaults.getDefaults,
      changeDefaults = defaults.changeDefaults,
      defaults$5 = defaults.defaults;
  /**
   * Marked
   */

  function marked(src, opt, callback) {
    // throw error in case of non string input
    if (typeof src === 'undefined' || src === null) {
      throw new Error('marked(): input parameter is undefined or null');
    }

    if (typeof src !== 'string') {
      throw new Error('marked(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');
    }

    if (typeof opt === 'function') {
      callback = opt;
      opt = null;
    }

    opt = merge$2({}, marked.defaults, opt || {});
    checkSanitizeDeprecation$1(opt);

    if (callback) {
      var highlight = opt.highlight;
      var tokens;

      try {
        tokens = Lexer_1.lex(src, opt);
      } catch (e) {
        return callback(e);
      }

      var done = function done(err) {
        var out;

        if (!err) {
          try {
            out = Parser_1.parse(tokens, opt);
          } catch (e) {
            err = e;
          }
        }

        opt.highlight = highlight;
        return err ? callback(err) : callback(null, out);
      };

      if (!highlight || highlight.length < 3) {
        return done();
      }

      delete opt.highlight;
      if (!tokens.length) return done();
      var pending = 0;
      marked.walkTokens(tokens, function (token) {
        if (token.type === 'code') {
          pending++;
          setTimeout(function () {
            highlight(token.text, token.lang, function (err, code) {
              if (err) {
                return done(err);
              }

              if (code != null && code !== token.text) {
                token.text = code;
                token.escaped = true;
              }

              pending--;

              if (pending === 0) {
                done();
              }
            });
          }, 0);
        }
      });

      if (pending === 0) {
        done();
      }

      return;
    }

    try {
      var _tokens = Lexer_1.lex(src, opt);

      if (opt.walkTokens) {
        marked.walkTokens(_tokens, opt.walkTokens);
      }

      return Parser_1.parse(_tokens, opt);
    } catch (e) {
      e.message += '\nPlease report this to https://github.com/markedjs/marked.';

      if (opt.silent) {
        return '<p>An error occurred:</p><pre>' + escape$2(e.message + '', true) + '</pre>';
      }

      throw e;
    }
  }
  /**
   * Options
   */


  marked.options = marked.setOptions = function (opt) {
    merge$2(marked.defaults, opt);
    changeDefaults(marked.defaults);
    return marked;
  };

  marked.getDefaults = getDefaults;
  marked.defaults = defaults$5;
  /**
   * Use Extension
   */

  marked.use = function (extension) {
    var opts = merge$2({}, extension);

    if (extension.renderer) {
      (function () {
        var renderer = marked.defaults.renderer || new Renderer_1();

        var _loop = function _loop(prop) {
          var prevRenderer = renderer[prop];

          renderer[prop] = function () {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            var ret = extension.renderer[prop].apply(renderer, args);

            if (ret === false) {
              ret = prevRenderer.apply(renderer, args);
            }

            return ret;
          };
        };

        for (var prop in extension.renderer) {
          _loop(prop);
        }

        opts.renderer = renderer;
      })();
    }

    if (extension.tokenizer) {
      (function () {
        var tokenizer = marked.defaults.tokenizer || new Tokenizer_1();

        var _loop2 = function _loop2(prop) {
          var prevTokenizer = tokenizer[prop];

          tokenizer[prop] = function () {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }

            var ret = extension.tokenizer[prop].apply(tokenizer, args);

            if (ret === false) {
              ret = prevTokenizer.apply(tokenizer, args);
            }

            return ret;
          };
        };

        for (var prop in extension.tokenizer) {
          _loop2(prop);
        }

        opts.tokenizer = tokenizer;
      })();
    }

    if (extension.walkTokens) {
      var walkTokens = marked.defaults.walkTokens;

      opts.walkTokens = function (token) {
        extension.walkTokens(token);

        if (walkTokens) {
          walkTokens(token);
        }
      };
    }

    marked.setOptions(opts);
  };
  /**
   * Run callback for every token
   */


  marked.walkTokens = function (tokens, callback) {
    for (var _iterator = _createForOfIteratorHelperLoose(tokens), _step; !(_step = _iterator()).done;) {
      var token = _step.value;
      callback(token);

      switch (token.type) {
        case 'table':
          {
            for (var _iterator2 = _createForOfIteratorHelperLoose(token.tokens.header), _step2; !(_step2 = _iterator2()).done;) {
              var cell = _step2.value;
              marked.walkTokens(cell, callback);
            }

            for (var _iterator3 = _createForOfIteratorHelperLoose(token.tokens.cells), _step3; !(_step3 = _iterator3()).done;) {
              var row = _step3.value;

              for (var _iterator4 = _createForOfIteratorHelperLoose(row), _step4; !(_step4 = _iterator4()).done;) {
                var _cell = _step4.value;
                marked.walkTokens(_cell, callback);
              }
            }

            break;
          }

        case 'list':
          {
            marked.walkTokens(token.items, callback);
            break;
          }

        default:
          {
            if (token.tokens) {
              marked.walkTokens(token.tokens, callback);
            }
          }
      }
    }
  };
  /**
   * Parse Inline
   */


  marked.parseInline = function (src, opt) {
    // throw error in case of non string input
    if (typeof src === 'undefined' || src === null) {
      throw new Error('marked.parseInline(): input parameter is undefined or null');
    }

    if (typeof src !== 'string') {
      throw new Error('marked.parseInline(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');
    }

    opt = merge$2({}, marked.defaults, opt || {});
    checkSanitizeDeprecation$1(opt);

    try {
      var tokens = Lexer_1.lexInline(src, opt);

      if (opt.walkTokens) {
        marked.walkTokens(tokens, opt.walkTokens);
      }

      return Parser_1.parseInline(tokens, opt);
    } catch (e) {
      e.message += '\nPlease report this to https://github.com/markedjs/marked.';

      if (opt.silent) {
        return '<p>An error occurred:</p><pre>' + escape$2(e.message + '', true) + '</pre>';
      }

      throw e;
    }
  };
  /**
   * Expose
   */


  marked.Parser = Parser_1;
  marked.parser = Parser_1.parse;
  marked.Renderer = Renderer_1;
  marked.TextRenderer = TextRenderer_1;
  marked.Lexer = Lexer_1;
  marked.lexer = Lexer_1.lex;
  marked.Tokenizer = Tokenizer_1;
  marked.Slugger = Slugger_1;
  marked.parse = marked;
  var marked_1 = marked;

  return marked_1;

})));
});

let docsLandingPage = './welcome'; // when /docs is loaded the welcome page should be displayed.

let links = writable([]);
let chosenDocs = writable(docsLandingPage);

/* src/pages/docs/[docId]/_layout.svelte generated by Svelte v3.31.0 */

const { document: document_1 } = globals;

function add_css$2() {
	var style = element("style");
	style.id = "svelte-pthvna-style";
	style.textContent = ".markdown-container.svelte-pthvna{height:calc(100vh - 86px);padding:10px 20px 0px 10px;overflow-y:auto}";
	append(document_1.head, style);
}

// (175:2) {#if $links != []}
function create_if_block$3(ctx) {
	let await_block_anchor;
	let promise_1;

	let info = {
		ctx,
		current: null,
		token: null,
		hasCatch: true,
		pending: create_pending_block,
		then: create_then_block,
		catch: create_catch_block,
		value: 10,
		error: 11
	};

	handle_promise(promise_1 = /*promise*/ ctx[2], info);

	return {
		c() {
			await_block_anchor = empty();
			info.block.c();
		},
		m(target, anchor) {
			insert(target, await_block_anchor, anchor);
			info.block.m(target, info.anchor = anchor);
			info.mount = () => await_block_anchor.parentNode;
			info.anchor = await_block_anchor;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			info.ctx = ctx;

			if (dirty & /*promise*/ 4 && promise_1 !== (promise_1 = /*promise*/ ctx[2]) && handle_promise(promise_1, info)) ; else {
				const child_ctx = ctx.slice();
				child_ctx[10] = child_ctx[11] = info.resolved;
				info.block.p(child_ctx, dirty);
			}
		},
		d(detaching) {
			if (detaching) detach(await_block_anchor);
			info.block.d(detaching);
			info.token = null;
			info = null;
		}
	};
}

// (180:4) {:catch error}
function create_catch_block(ctx) {
	let p;

	return {
		c() {
			p = element("p");
			p.textContent = "no markdown :(";
			set_style(p, "color", "red");
		},
		m(target, anchor) {
			insert(target, p, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (178:4) {:then number}
function create_then_block(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			attr(div, "class", "markdown-output");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			div.innerHTML = /*markdown*/ ctx[1];
		},
		p(ctx, dirty) {
			if (dirty & /*markdown*/ 2) div.innerHTML = /*markdown*/ ctx[1];		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (176:20)        <p>...waiting</p>     {:then number}
function create_pending_block(ctx) {
	let p;

	return {
		c() {
			p = element("p");
			p.textContent = "...waiting";
		},
		m(target, anchor) {
			insert(target, p, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

function create_fragment$9(ctx) {
	let div;
	let if_block = /*$links*/ ctx[0] != [] && create_if_block$3(ctx);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			attr(div, "class", "markdown-container svelte-pthvna");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
		},
		p(ctx, [dirty]) {
			if (/*$links*/ ctx[0] != []) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$3(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
		}
	};
}
//if (window.location.hash != null){

function findFileName(path, links) {
	if (links != undefined) {
		for (let i = 0; i < links.length; i++) {
			if (links[i]["path"] == "./" + path) {
				//console.log('here ./'+path);
				return links[i]["file"];
			}
		}
	}
}

function instance$7($$self, $$props, $$invalidate) {
	let $params;
	let $links;
	let $chosenDocs;
	let $afterPageLoad;
	component_subscribe($$self, params, $$value => $$invalidate(3, $params = $$value));
	component_subscribe($$self, links, $$value => $$invalidate(0, $links = $$value));
	component_subscribe($$self, chosenDocs, $$value => $$invalidate(5, $chosenDocs = $$value));
	component_subscribe($$self, afterPageLoad, $$value => $$invalidate(6, $afterPageLoad = $$value));
	let lastLoadedDoc = ""; //$chosenDocs;

	/*
$: promise.then(value => {
    jumpToHash();
  }, reason => {
    console.log("no hash sad");
  }).catch(e => {
    console.log(e);
  });
*/
	

	//  document.getElementById(window.location.hash).scrollIntoView({behavior: 'auto'});
	//}
	let markdown;

	// sets chosenDocs in store to the current page so that its rememebered for when the user returns
	function setLastVisitedPage() {
		set_store_value(chosenDocs, $chosenDocs = "./" + $params.docId, $chosenDocs);
	} //console.log("chosen docs:)", $chosenDocs);

	//const links = getContext('links');
	//console.log("links inner", $links);
	//custom renderer to make headers have anchor links
	const renderer = {
		heading(text, level) {
			const escapedText = text.toLowerCase().replace(/[^\w]+/g, "-");

			return `
              <h${level}>
                <a name="${escapedText}" class="anchor" href="#${escapedText}" id="#${escapedText}" target="_self">
                  <span class="header-link"></span>
                #
                </a>
                ${text}
              </h${level}>`;
		}
	};

	marked.use({ renderer });

	/*
//make marked renderer make links open in a new tab
let renderer = new marked.Renderer();
renderer.link = function(href, title, text) {
  let link = marked.Renderer.prototype.link.apply(this, arguments);
  return link.replace("<a","<a target='_blank'");
};

marked.setOptions({
  renderer: renderer
});
*/
	//$: docId = $params.docId; //get the doc part of the url
	let fetchMarkdown = async (docId, links) => {
		console.log("HERE last loaded doc", lastLoadedDoc);
		console.log("HERE docId", docId);

		if (docId == lastLoadedDoc) {
			return;
		}

		lastLoadedDoc = docId;

		//docId is the $params.id, the url slug
		let doc = findFileName(docId, links);

		console.log("fetching markdown", doc);

		if (doc != undefined) {
			// There is a call with undefined value when navigating to Playground
			const res = await fetch(document.location.origin + `/docs/${doc}.md`);

			const text = await res.text();

			// console.log(`DEBUG:[/${chapter}]/[${section}]:fetchMarkdown: `, text);
			// await tick();
			if (res.ok) {
				// console.log('markdown processed');
				$$invalidate(1, markdown = marked(text));

				//change code elements to have a copy button
				let codeID = 0;

				while (markdown.indexOf("<pre><code>") > -1) {
					$$invalidate(1, markdown = markdown.replace("<pre><code>", `<pre style="margin-top:-25px">
              <button style="font-size:70%; text-align: center; float: right; z-index: 1000; top: 30px; position: relative;" type="button" onclick="copyCode('code${codeID}')">copy</button>
              <code style="-moz-user-select: text; -html-user-select: text; -webkit-user-select: text; -ms-user-select: text; user-select: text; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word;" id='code${codeID++}'>`));
				}

				
			}
		} else {
			throw new Error(text);
		}
	};

	//$: if (docId) fetchMarkdown(docId);
	//console.log("docId:", docId);
	onMount(async () => {
		//promise = fetchMarkdown(doc);
		console.log("DEBUG:routes/docs/" + $params.docId + "/_layout:onMount");
	});

	$afterPageLoad(page => {
		console.log("loaded " + page.title);
		lastLoadedDoc = ""; //reset lastLoadedDocument
	}); /*
console.log("HERE location.hash before if", location.hash);
if (location.hash != null || location.hash == ""){
  console.log("HERE location.hash on page load", location.hash);
  document.getElementById(location.hash).scrollIntoView({behavior: 'auto'});
}
*/

	let promise;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$params*/ 8) {
			 setLastVisitedPage($params.docId);
		}

		if ($$self.$$.dirty & /*$params, $links*/ 9) {
			 $$invalidate(2, promise = fetchMarkdown($params.docId, $links)); //promise is reactive to changes in url docId and links since they load asynchrynously
		}
	};

	return [$links, markdown, promise, $params];
}

class Layout$1 extends SvelteComponent {
	constructor(options) {
		super();
		if (!document_1.getElementById("svelte-pthvna-style")) add_css$2();
		init(this, options, instance$7, create_fragment$9, safe_not_equal, {});
	}
}

/* src/pages/docs/CollapsibleSection.svelte generated by Svelte v3.31.0 */

function add_css$3() {
	var style = element("style");
	style.id = "svelte-u3hgq1-style";
	style.textContent = ".collapsible.svelte-u3hgq1.svelte-u3hgq1{border-bottom:1px solid var(--gray-light, #eee)}button.svelte-u3hgq1.svelte-u3hgq1{background-color:var(--background, #949090);color:var(--gray-darkest, #282828);display:flex;justify-content:space-between;width:100%;border:5px;margin:0;padding:0.5em 0.5em}button[aria-expanded=\"true\"].svelte-u3hgq1.svelte-u3hgq1{border-bottom:1px solid var(--gray-light, #eee);background-color:var(--background, #5b5757)}button[aria-expanded=\"true\"].svelte-u3hgq1 .vert.svelte-u3hgq1{display:none}button.svelte-u3hgq1:focus svg.svelte-u3hgq1{outline:2px solid}svg.svelte-u3hgq1.svelte-u3hgq1{height:0.6em;width:0.6em;justify-content:flex-end}.nav-links.svelte-u3hgq1.svelte-u3hgq1{text-align:left;justify-content:flex-start;color:white}";
	append(document.head, style);
}

function create_fragment$a(ctx) {
	let div1;
	let button;
	let a;
	let t0;
	let a_href_value;
	let t1;
	let svg;
	let path0;
	let path1;
	let t2;
	let div0;
	let div0_hidden_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

	return {
		c() {
			div1 = element("div");
			button = element("button");
			a = element("a");
			t0 = text$1(/*headerText*/ ctx[0]);
			t1 = space();
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			t2 = space();
			div0 = element("div");
			if (default_slot) default_slot.c();
			attr(a, "class", "nav-links svelte-u3hgq1");
			attr(a, "href", a_href_value = /*$url*/ ctx[3](/*path*/ ctx[1]));
			toggle_class(a, "active", /*$isActive*/ ctx[4](/*path*/ ctx[1]));
			attr(path0, "class", "vert svelte-u3hgq1");
			attr(path0, "d", "M10 1V19");
			attr(path0, "stroke", "black");
			attr(path0, "stroke-width", "2");
			attr(path1, "d", "M1 10L19 10");
			attr(path1, "stroke", "black");
			attr(path1, "stroke-width", "2");
			attr(svg, "viewBox", "0 0 20 20");
			attr(svg, "fill", "none");
			attr(svg, "class", "svelte-u3hgq1");
			attr(button, "aria-expanded", /*expanded*/ ctx[2]);
			attr(button, "class", "svelte-u3hgq1");
			attr(div0, "class", "contents");
			div0.hidden = div0_hidden_value = !/*expanded*/ ctx[2];
			attr(div1, "class", "collapsible svelte-u3hgq1");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, button);
			append(button, a);
			append(a, t0);
			append(button, t1);
			append(button, svg);
			append(svg, path0);
			append(svg, path1);
			append(div1, t2);
			append(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler*/ ctx[7]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (!current || dirty & /*headerText*/ 1) set_data(t0, /*headerText*/ ctx[0]);

			if (!current || dirty & /*$url, path*/ 10 && a_href_value !== (a_href_value = /*$url*/ ctx[3](/*path*/ ctx[1]))) {
				attr(a, "href", a_href_value);
			}

			if (dirty & /*$isActive, path*/ 18) {
				toggle_class(a, "active", /*$isActive*/ ctx[4](/*path*/ ctx[1]));
			}

			if (!current || dirty & /*expanded*/ 4) {
				attr(button, "aria-expanded", /*expanded*/ ctx[2]);
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
				}
			}

			if (!current || dirty & /*expanded*/ 4 && div0_hidden_value !== (div0_hidden_value = !/*expanded*/ ctx[2])) {
				div0.hidden = div0_hidden_value;
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance$8($$self, $$props, $$invalidate) {
	let $url;
	let $isActive;
	component_subscribe($$self, url, $$value => $$invalidate(3, $url = $$value));
	component_subscribe($$self, isActive, $$value => $$invalidate(4, $isActive = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	let { headerText } = $$props;
	let { path } = $$props;
	let expanded = false;
	const click_handler = () => $$invalidate(2, expanded = !expanded);

	$$self.$$set = $$props => {
		if ("headerText" in $$props) $$invalidate(0, headerText = $$props.headerText);
		if ("path" in $$props) $$invalidate(1, path = $$props.path);
		if ("$$scope" in $$props) $$invalidate(5, $$scope = $$props.$$scope);
	};

	return [headerText, path, expanded, $url, $isActive, $$scope, slots, click_handler];
}

class CollapsibleSection extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-u3hgq1-style")) add_css$3();
		init(this, options, instance$8, create_fragment$a, safe_not_equal, { headerText: 0, path: 1 });
	}
}

/* src/pages/docs/index.svelte generated by Svelte v3.31.0 */

class Docs extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, null, null, safe_not_equal, {});
	}
}

/* src/pages/docs/sidebar-menu.svelte generated by Svelte v3.31.0 */

function instance$9($$self) {
	let treeHeadings = []; //to store the headers scraped from each markdown file

	//get headings to display in the sidebar
	let getHeadings = async doc => {
		if (doc != undefined) {
			// There is a call with undefined value when navigating to Playground
			const res = await fetch(document.location.origin + `/docs/${doc}.md`);

			const text = await res.text();

			// await tick();
			if (res.ok) {
				//get tokens from the marked lexer
				let tokens = marked.lexer(text);

				//loop through them
				for (let i = 0; i < tokens.length; i++) {
					//console.log(tokens[i])
					if (tokens[i].type == "heading" && tokens[i].depth == 1) {
						//console.log(tokens[i]);
						treeHeadings.push(tokens[i].text.replace(/\s+/g, "-").toLowerCase());
					}
				}
			} else {
				throw new Error(text); //console.log(tokens[0]);
			}
		}
	};

	getHeadings("default-language");
	console.log("threeheadings", treeHeadings);
	const links = getContext("links");
	return [];
}

class Sidebar_menu extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$9, null, safe_not_equal, {});
	}
}

/* src/pages/docs/_layout.svelte generated by Svelte v3.31.0 */

function add_css$4() {
	var style = element("style");
	style.id = "svelte-1oxffwg-style";
	style.textContent = ".svelte-1oxffwg .cards{display:flex;flex-wrap:wrap;justify-content:space-evenly;padding:0}.svelte-1oxffwg .card{border-radius:0.25rem;border-width:1px;border:1px solid #e2e8f0;margin-bottom:3rem;padding:2rem;background:white;list-style:none;width:25%;position:relative;cursor:pointer}.svelte-1oxffwg .container{position:fixed;left:0;top:0;right:0;bottom:0;padding-top:5rem;background:rgba(0, 0, 0, 0.2)}.svelte-1oxffwg .modal{margin:auto;background:white;font-size:5rem;border:1px solid #e2e8f0;width:30%;padding-top:3rem;padding-bottom:3rem;text-align:center}.active.svelte-1oxffwg{font-weight:bold}.container-docs.svelte-1oxffwg{display:grid;grid-template-areas:\"header header\"\n      \"sidebar settings\"\n  \t\t\"sidebar layout\";grid-template-columns:260px 1fr;grid-template-rows:auto 1fr}.sidebar-menu.svelte-1oxffwg{display:flex;flex-direction:column;padding:20px 2px 0px 2px;background-color:#999;border-radius:5px;overflow-y:auto;height:calc(100vh - 86px);bottom:0}.nav-links-title.svelte-1oxffwg{text-align:center;width:100%;justify-content:center;color:white}.sub-nav-links.svelte-1oxffwg{color:black;font-size:14px}h2.svelte-1oxffwg{text-align:center;color:#777777;text-decoration:underline}";
	append(document.head, style);
}

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i].path;
	child_ctx[8] = list[i].name;
	child_ctx[9] = list[i].file;
	child_ctx[10] = list[i].subs;
	child_ctx[12] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[13] = list[i].heading;
	child_ctx[14] = list[i].route;
	child_ctx[15] = list[i].active;
	return child_ctx;
}

// (144:34) 
function create_if_block_1$2(ctx) {
	let collapsiblesection;
	let current;

	collapsiblesection = new CollapsibleSection({
			props: {
				headerText: /*name*/ ctx[8],
				path: /*path*/ ctx[7],
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(collapsiblesection.$$.fragment);
		},
		m(target, anchor) {
			mount_component(collapsiblesection, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const collapsiblesection_changes = {};
			if (dirty & /*$links*/ 2) collapsiblesection_changes.headerText = /*name*/ ctx[8];
			if (dirty & /*$links*/ 2) collapsiblesection_changes.path = /*path*/ ctx[7];

			if (dirty & /*$$scope, $links, $url, $isActive*/ 23) {
				collapsiblesection_changes.$$scope = { dirty, ctx };
			}

			collapsiblesection.$set(collapsiblesection_changes);
		},
		i(local) {
			if (current) return;
			transition_in(collapsiblesection.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(collapsiblesection.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(collapsiblesection, detaching);
		}
	};
}

// (139:6) {#if name == 'Welcome'}
function create_if_block$4(ctx) {
	let h2;
	let a;
	let t0_value = /*name*/ ctx[8] + "";
	let t0;
	let a_href_value;
	let t1;
	let br;

	return {
		c() {
			h2 = element("h2");
			a = element("a");
			t0 = text$1(t0_value);
			t1 = space();
			br = element("br");
			attr(a, "class", "nav-links-title svelte-1oxffwg");
			attr(a, "href", a_href_value = /*$url*/ ctx[0](/*path*/ ctx[7]));
			toggle_class(a, "active", /*$isActive*/ ctx[2](/*path*/ ctx[7]));
			attr(h2, "class", "svelte-1oxffwg");
			attr(br, "class", "svelte-1oxffwg");
		},
		m(target, anchor) {
			insert(target, h2, anchor);
			append(h2, a);
			append(a, t0);
			insert(target, t1, anchor);
			insert(target, br, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*$links*/ 2 && t0_value !== (t0_value = /*name*/ ctx[8] + "")) set_data(t0, t0_value);

			if (dirty & /*$url, $links*/ 3 && a_href_value !== (a_href_value = /*$url*/ ctx[0](/*path*/ ctx[7]))) {
				attr(a, "href", a_href_value);
			}

			if (dirty & /*$isActive, $links*/ 6) {
				toggle_class(a, "active", /*$isActive*/ ctx[2](/*path*/ ctx[7]));
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(h2);
			if (detaching) detach(t1);
			if (detaching) detach(br);
		}
	};
}

// (148:16) {#each subs as {heading, route, active}}
function create_each_block_1(ctx) {
	let li;
	let a;
	let t0_value = /*heading*/ ctx[13] + "";
	let t0;
	let a_href_value;
	let t1;

	return {
		c() {
			li = element("li");
			a = element("a");
			t0 = text$1(t0_value);
			t1 = space();
			attr(a, "class", "sub-nav-links svelte-1oxffwg");
			attr(a, "href", a_href_value = /*$url*/ ctx[0](/*path*/ ctx[7] + "#" + /*route*/ ctx[14]));
			attr(a, "target", "_self");
			toggle_class(a, "active", /*$isActive*/ ctx[2](/*route*/ ctx[14]));
			attr(li, "class", "svelte-1oxffwg");
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, a);
			append(a, t0);
			append(li, t1);
		},
		p(ctx, dirty) {
			if (dirty & /*$links*/ 2 && t0_value !== (t0_value = /*heading*/ ctx[13] + "")) set_data(t0, t0_value);

			if (dirty & /*$url, $links*/ 3 && a_href_value !== (a_href_value = /*$url*/ ctx[0](/*path*/ ctx[7] + "#" + /*route*/ ctx[14]))) {
				attr(a, "href", a_href_value);
			}

			if (dirty & /*$isActive, $links*/ 6) {
				toggle_class(a, "active", /*$isActive*/ ctx[2](/*route*/ ctx[14]));
			}
		},
		d(detaching) {
			if (detaching) detach(li);
		}
	};
}

// (145:8) <CollapsibleSection headerText={name} path={path}>
function create_default_slot$1(ctx) {
	let div;
	let ul;
	let t;
	let each_value_1 = /*subs*/ ctx[10];
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	return {
		c() {
			div = element("div");
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			attr(ul, "class", "svelte-1oxffwg");
			attr(div, "class", "dropdown-content svelte-1oxffwg");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*$url, $links, $isActive*/ 7) {
				each_value_1 = /*subs*/ ctx[10];
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ul, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
			if (detaching) detach(t);
		}
	};
}

// (138:4) {#each $links as {path, name, file, subs}
function create_each_block$2(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$4, create_if_block_1$2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*name*/ ctx[8] == "Welcome") return 0;
		if (/*name*/ ctx[8] != "Welcome") return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment$b(ctx) {
	let t0;
	let div1;
	let ul;
	let t1;
	let div0;
	let current;
	let each_value = /*$links*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	return {
		c() {
			t0 = space();
			div1 = element("div");
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			div0 = element("div");
			if (default_slot) default_slot.c();
			document.title = "Sema  Documentation";
			attr(ul, "class", "sidebar-menu svelte-1oxffwg");
			attr(div0, "class", "svelte-1oxffwg");
			attr(div1, "class", "container-docs svelte-1oxffwg");
			attr(div1, "data-routify", "scroll-lock");
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, div1, anchor);
			append(div1, ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			append(div1, t1);
			append(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*$url, $links, $isActive*/ 7) {
				each_value = /*$links*/ ctx[1];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(ul, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(div1);
			destroy_each(each_blocks, detaching);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$a($$self, $$props, $$invalidate) {
	let $redirect;
	let $url;
	let $chosenDocs;
	let $links;
	let $isActive;
	component_subscribe($$self, redirect, $$value => $$invalidate(5, $redirect = $$value));
	component_subscribe($$self, url, $$value => $$invalidate(0, $url = $$value));
	component_subscribe($$self, chosenDocs, $$value => $$invalidate(6, $chosenDocs = $$value));
	component_subscribe($$self, links, $$value => $$invalidate(1, $links = $$value));
	component_subscribe($$self, isActive, $$value => $$invalidate(2, $isActive = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;

	onMount(async () => {
		//promise = fetchMarkdown(doc);
		console.log("DEBUG:routes/docs/_layout:onMount");

		//console.log('onMount', $chosenDocs)
		$redirect($url($chosenDocs));

		console.log("$links on mount", $links);
	});

	$$self.$$set = $$props => {
		if ("$$scope" in $$props) $$invalidate(4, $$scope = $$props.$$scope);
	};

	return [$url, $links, $isActive, slots, $$scope];
}

class Layout$2 extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1oxffwg-style")) add_css$4();
		init(this, options, instance$a, create_fragment$b, safe_not_equal, {});
	}
}

var regl = createCommonjsModule(function (module, exports) {
(function (global, factory) {
     module.exports = factory() ;
}(commonjsGlobal, (function () {
var isTypedArray = function (x) {
  return (
    x instanceof Uint8Array ||
    x instanceof Uint16Array ||
    x instanceof Uint32Array ||
    x instanceof Int8Array ||
    x instanceof Int16Array ||
    x instanceof Int32Array ||
    x instanceof Float32Array ||
    x instanceof Float64Array ||
    x instanceof Uint8ClampedArray
  )
};

var extend = function (base, opts) {
  var keys = Object.keys(opts);
  for (var i = 0; i < keys.length; ++i) {
    base[keys[i]] = opts[keys[i]];
  }
  return base
};

// Error checking and parameter validation.
//
// Statements for the form `check.someProcedure(...)` get removed by
// a browserify transform for optimized/minified bundles.
//
/* globals atob */
var endl = '\n';

// only used for extracting shader names.  if atob not present, then errors
// will be slightly crappier
function decodeB64 (str) {
  if (typeof atob !== 'undefined') {
    return atob(str)
  }
  return 'base64:' + str
}

function raise (message) {
  var error = new Error('(regl) ' + message);
  console.error(error);
  throw error
}

function check (pred, message) {
  if (!pred) {
    raise(message);
  }
}

function encolon (message) {
  if (message) {
    return ': ' + message
  }
  return ''
}

function checkParameter (param, possibilities, message) {
  if (!(param in possibilities)) {
    raise('unknown parameter (' + param + ')' + encolon(message) +
          '. possible values: ' + Object.keys(possibilities).join());
  }
}

function checkIsTypedArray (data, message) {
  if (!isTypedArray(data)) {
    raise(
      'invalid parameter type' + encolon(message) +
      '. must be a typed array');
  }
}

function standardTypeEh (value, type) {
  switch (type) {
    case 'number': return typeof value === 'number'
    case 'object': return typeof value === 'object'
    case 'string': return typeof value === 'string'
    case 'boolean': return typeof value === 'boolean'
    case 'function': return typeof value === 'function'
    case 'undefined': return typeof value === 'undefined'
    case 'symbol': return typeof value === 'symbol'
  }
}

function checkTypeOf (value, type, message) {
  if (!standardTypeEh(value, type)) {
    raise(
      'invalid parameter type' + encolon(message) +
      '. expected ' + type + ', got ' + (typeof value));
  }
}

function checkNonNegativeInt (value, message) {
  if (!((value >= 0) &&
        ((value | 0) === value))) {
    raise('invalid parameter type, (' + value + ')' + encolon(message) +
          '. must be a nonnegative integer');
  }
}

function checkOneOf (value, list, message) {
  if (list.indexOf(value) < 0) {
    raise('invalid value' + encolon(message) + '. must be one of: ' + list);
  }
}

var constructorKeys = [
  'gl',
  'canvas',
  'container',
  'attributes',
  'pixelRatio',
  'extensions',
  'optionalExtensions',
  'profile',
  'onDone'
];

function checkConstructor (obj) {
  Object.keys(obj).forEach(function (key) {
    if (constructorKeys.indexOf(key) < 0) {
      raise('invalid regl constructor argument "' + key + '". must be one of ' + constructorKeys);
    }
  });
}

function leftPad (str, n) {
  str = str + '';
  while (str.length < n) {
    str = ' ' + str;
  }
  return str
}

function ShaderFile () {
  this.name = 'unknown';
  this.lines = [];
  this.index = {};
  this.hasErrors = false;
}

function ShaderLine (number, line) {
  this.number = number;
  this.line = line;
  this.errors = [];
}

function ShaderError (fileNumber, lineNumber, message) {
  this.file = fileNumber;
  this.line = lineNumber;
  this.message = message;
}

function guessCommand () {
  var error = new Error();
  var stack = (error.stack || error).toString();
  var pat = /compileProcedure.*\n\s*at.*\((.*)\)/.exec(stack);
  if (pat) {
    return pat[1]
  }
  var pat2 = /compileProcedure.*\n\s*at\s+(.*)(\n|$)/.exec(stack);
  if (pat2) {
    return pat2[1]
  }
  return 'unknown'
}

function guessCallSite () {
  var error = new Error();
  var stack = (error.stack || error).toString();
  var pat = /at REGLCommand.*\n\s+at.*\((.*)\)/.exec(stack);
  if (pat) {
    return pat[1]
  }
  var pat2 = /at REGLCommand.*\n\s+at\s+(.*)\n/.exec(stack);
  if (pat2) {
    return pat2[1]
  }
  return 'unknown'
}

function parseSource (source, command) {
  var lines = source.split('\n');
  var lineNumber = 1;
  var fileNumber = 0;
  var files = {
    unknown: new ShaderFile(),
    0: new ShaderFile()
  };
  files.unknown.name = files[0].name = command || guessCommand();
  files.unknown.lines.push(new ShaderLine(0, ''));
  for (var i = 0; i < lines.length; ++i) {
    var line = lines[i];
    var parts = /^\s*#\s*(\w+)\s+(.+)\s*$/.exec(line);
    if (parts) {
      switch (parts[1]) {
        case 'line':
          var lineNumberInfo = /(\d+)(\s+\d+)?/.exec(parts[2]);
          if (lineNumberInfo) {
            lineNumber = lineNumberInfo[1] | 0;
            if (lineNumberInfo[2]) {
              fileNumber = lineNumberInfo[2] | 0;
              if (!(fileNumber in files)) {
                files[fileNumber] = new ShaderFile();
              }
            }
          }
          break
        case 'define':
          var nameInfo = /SHADER_NAME(_B64)?\s+(.*)$/.exec(parts[2]);
          if (nameInfo) {
            files[fileNumber].name = (nameInfo[1]
              ? decodeB64(nameInfo[2])
              : nameInfo[2]);
          }
          break
      }
    }
    files[fileNumber].lines.push(new ShaderLine(lineNumber++, line));
  }
  Object.keys(files).forEach(function (fileNumber) {
    var file = files[fileNumber];
    file.lines.forEach(function (line) {
      file.index[line.number] = line;
    });
  });
  return files
}

function parseErrorLog (errLog) {
  var result = [];
  errLog.split('\n').forEach(function (errMsg) {
    if (errMsg.length < 5) {
      return
    }
    var parts = /^ERROR:\s+(\d+):(\d+):\s*(.*)$/.exec(errMsg);
    if (parts) {
      result.push(new ShaderError(
        parts[1] | 0,
        parts[2] | 0,
        parts[3].trim()));
    } else if (errMsg.length > 0) {
      result.push(new ShaderError('unknown', 0, errMsg));
    }
  });
  return result
}

function annotateFiles (files, errors) {
  errors.forEach(function (error) {
    var file = files[error.file];
    if (file) {
      var line = file.index[error.line];
      if (line) {
        line.errors.push(error);
        file.hasErrors = true;
        return
      }
    }
    files.unknown.hasErrors = true;
    files.unknown.lines[0].errors.push(error);
  });
}

function checkShaderError (gl, shader, source, type, command) {
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    var errLog = gl.getShaderInfoLog(shader);
    var typeName = type === gl.FRAGMENT_SHADER ? 'fragment' : 'vertex';
    checkCommandType(source, 'string', typeName + ' shader source must be a string', command);
    var files = parseSource(source, command);
    var errors = parseErrorLog(errLog);
    annotateFiles(files, errors);

    Object.keys(files).forEach(function (fileNumber) {
      var file = files[fileNumber];
      if (!file.hasErrors) {
        return
      }

      var strings = [''];
      var styles = [''];

      function push (str, style) {
        strings.push(str);
        styles.push(style || '');
      }

      push('file number ' + fileNumber + ': ' + file.name + '\n', 'color:red;text-decoration:underline;font-weight:bold');

      file.lines.forEach(function (line) {
        if (line.errors.length > 0) {
          push(leftPad(line.number, 4) + '|  ', 'background-color:yellow; font-weight:bold');
          push(line.line + endl, 'color:red; background-color:yellow; font-weight:bold');

          // try to guess token
          var offset = 0;
          line.errors.forEach(function (error) {
            var message = error.message;
            var token = /^\s*'(.*)'\s*:\s*(.*)$/.exec(message);
            if (token) {
              var tokenPat = token[1];
              message = token[2];
              switch (tokenPat) {
                case 'assign':
                  tokenPat = '=';
                  break
              }
              offset = Math.max(line.line.indexOf(tokenPat, offset), 0);
            } else {
              offset = 0;
            }

            push(leftPad('| ', 6));
            push(leftPad('^^^', offset + 3) + endl, 'font-weight:bold');
            push(leftPad('| ', 6));
            push(message + endl, 'font-weight:bold');
          });
          push(leftPad('| ', 6) + endl);
        } else {
          push(leftPad(line.number, 4) + '|  ');
          push(line.line + endl, 'color:red');
        }
      });
      if (typeof document !== 'undefined' && !window.chrome) {
        styles[0] = strings.join('%c');
        console.log.apply(console, styles);
      } else {
        console.log(strings.join(''));
      }
    });

    check.raise('Error compiling ' + typeName + ' shader, ' + files[0].name);
  }
}

function checkLinkError (gl, program, fragShader, vertShader, command) {
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    var errLog = gl.getProgramInfoLog(program);
    var fragParse = parseSource(fragShader, command);
    var vertParse = parseSource(vertShader, command);

    var header = 'Error linking program with vertex shader, "' +
      vertParse[0].name + '", and fragment shader "' + fragParse[0].name + '"';

    if (typeof document !== 'undefined') {
      console.log('%c' + header + endl + '%c' + errLog,
        'color:red;text-decoration:underline;font-weight:bold',
        'color:red');
    } else {
      console.log(header + endl + errLog);
    }
    check.raise(header);
  }
}

function saveCommandRef (object) {
  object._commandRef = guessCommand();
}

function saveDrawCommandInfo (opts, uniforms, attributes, stringStore) {
  saveCommandRef(opts);

  function id (str) {
    if (str) {
      return stringStore.id(str)
    }
    return 0
  }
  opts._fragId = id(opts.static.frag);
  opts._vertId = id(opts.static.vert);

  function addProps (dict, set) {
    Object.keys(set).forEach(function (u) {
      dict[stringStore.id(u)] = true;
    });
  }

  var uniformSet = opts._uniformSet = {};
  addProps(uniformSet, uniforms.static);
  addProps(uniformSet, uniforms.dynamic);

  var attributeSet = opts._attributeSet = {};
  addProps(attributeSet, attributes.static);
  addProps(attributeSet, attributes.dynamic);

  opts._hasCount = (
    'count' in opts.static ||
    'count' in opts.dynamic ||
    'elements' in opts.static ||
    'elements' in opts.dynamic);
}

function commandRaise (message, command) {
  var callSite = guessCallSite();
  raise(message +
    ' in command ' + (command || guessCommand()) +
    (callSite === 'unknown' ? '' : ' called from ' + callSite));
}

function checkCommand (pred, message, command) {
  if (!pred) {
    commandRaise(message, command || guessCommand());
  }
}

function checkParameterCommand (param, possibilities, message, command) {
  if (!(param in possibilities)) {
    commandRaise(
      'unknown parameter (' + param + ')' + encolon(message) +
      '. possible values: ' + Object.keys(possibilities).join(),
      command || guessCommand());
  }
}

function checkCommandType (value, type, message, command) {
  if (!standardTypeEh(value, type)) {
    commandRaise(
      'invalid parameter type' + encolon(message) +
      '. expected ' + type + ', got ' + (typeof value),
      command || guessCommand());
  }
}

function checkOptional (block) {
  block();
}

function checkFramebufferFormat (attachment, texFormats, rbFormats) {
  if (attachment.texture) {
    checkOneOf(
      attachment.texture._texture.internalformat,
      texFormats,
      'unsupported texture format for attachment');
  } else {
    checkOneOf(
      attachment.renderbuffer._renderbuffer.format,
      rbFormats,
      'unsupported renderbuffer format for attachment');
  }
}

var GL_CLAMP_TO_EDGE = 0x812F;

var GL_NEAREST = 0x2600;
var GL_NEAREST_MIPMAP_NEAREST = 0x2700;
var GL_LINEAR_MIPMAP_NEAREST = 0x2701;
var GL_NEAREST_MIPMAP_LINEAR = 0x2702;
var GL_LINEAR_MIPMAP_LINEAR = 0x2703;

var GL_BYTE = 5120;
var GL_UNSIGNED_BYTE = 5121;
var GL_SHORT = 5122;
var GL_UNSIGNED_SHORT = 5123;
var GL_INT = 5124;
var GL_UNSIGNED_INT = 5125;
var GL_FLOAT = 5126;

var GL_UNSIGNED_SHORT_4_4_4_4 = 0x8033;
var GL_UNSIGNED_SHORT_5_5_5_1 = 0x8034;
var GL_UNSIGNED_SHORT_5_6_5 = 0x8363;
var GL_UNSIGNED_INT_24_8_WEBGL = 0x84FA;

var GL_HALF_FLOAT_OES = 0x8D61;

var TYPE_SIZE = {};

TYPE_SIZE[GL_BYTE] =
TYPE_SIZE[GL_UNSIGNED_BYTE] = 1;

TYPE_SIZE[GL_SHORT] =
TYPE_SIZE[GL_UNSIGNED_SHORT] =
TYPE_SIZE[GL_HALF_FLOAT_OES] =
TYPE_SIZE[GL_UNSIGNED_SHORT_5_6_5] =
TYPE_SIZE[GL_UNSIGNED_SHORT_4_4_4_4] =
TYPE_SIZE[GL_UNSIGNED_SHORT_5_5_5_1] = 2;

TYPE_SIZE[GL_INT] =
TYPE_SIZE[GL_UNSIGNED_INT] =
TYPE_SIZE[GL_FLOAT] =
TYPE_SIZE[GL_UNSIGNED_INT_24_8_WEBGL] = 4;

function pixelSize (type, channels) {
  if (type === GL_UNSIGNED_SHORT_5_5_5_1 ||
      type === GL_UNSIGNED_SHORT_4_4_4_4 ||
      type === GL_UNSIGNED_SHORT_5_6_5) {
    return 2
  } else if (type === GL_UNSIGNED_INT_24_8_WEBGL) {
    return 4
  } else {
    return TYPE_SIZE[type] * channels
  }
}

function isPow2 (v) {
  return !(v & (v - 1)) && (!!v)
}

function checkTexture2D (info, mipData, limits) {
  var i;
  var w = mipData.width;
  var h = mipData.height;
  var c = mipData.channels;

  // Check texture shape
  check(w > 0 && w <= limits.maxTextureSize &&
        h > 0 && h <= limits.maxTextureSize,
  'invalid texture shape');

  // check wrap mode
  if (info.wrapS !== GL_CLAMP_TO_EDGE || info.wrapT !== GL_CLAMP_TO_EDGE) {
    check(isPow2(w) && isPow2(h),
      'incompatible wrap mode for texture, both width and height must be power of 2');
  }

  if (mipData.mipmask === 1) {
    if (w !== 1 && h !== 1) {
      check(
        info.minFilter !== GL_NEAREST_MIPMAP_NEAREST &&
        info.minFilter !== GL_NEAREST_MIPMAP_LINEAR &&
        info.minFilter !== GL_LINEAR_MIPMAP_NEAREST &&
        info.minFilter !== GL_LINEAR_MIPMAP_LINEAR,
        'min filter requires mipmap');
    }
  } else {
    // texture must be power of 2
    check(isPow2(w) && isPow2(h),
      'texture must be a square power of 2 to support mipmapping');
    check(mipData.mipmask === (w << 1) - 1,
      'missing or incomplete mipmap data');
  }

  if (mipData.type === GL_FLOAT) {
    if (limits.extensions.indexOf('oes_texture_float_linear') < 0) {
      check(info.minFilter === GL_NEAREST && info.magFilter === GL_NEAREST,
        'filter not supported, must enable oes_texture_float_linear');
    }
    check(!info.genMipmaps,
      'mipmap generation not supported with float textures');
  }

  // check image complete
  var mipimages = mipData.images;
  for (i = 0; i < 16; ++i) {
    if (mipimages[i]) {
      var mw = w >> i;
      var mh = h >> i;
      check(mipData.mipmask & (1 << i), 'missing mipmap data');

      var img = mipimages[i];

      check(
        img.width === mw &&
        img.height === mh,
        'invalid shape for mip images');

      check(
        img.format === mipData.format &&
        img.internalformat === mipData.internalformat &&
        img.type === mipData.type,
        'incompatible type for mip image');

      if (img.compressed) ; else if (img.data) {
        // check(img.data.byteLength === mw * mh *
        // Math.max(pixelSize(img.type, c), img.unpackAlignment),
        var rowSize = Math.ceil(pixelSize(img.type, c) * mw / img.unpackAlignment) * img.unpackAlignment;
        check(img.data.byteLength === rowSize * mh,
          'invalid data for image, buffer size is inconsistent with image format');
      } else if (img.element) ; else if (img.copy) ;
    } else if (!info.genMipmaps) {
      check((mipData.mipmask & (1 << i)) === 0, 'extra mipmap data');
    }
  }

  if (mipData.compressed) {
    check(!info.genMipmaps,
      'mipmap generation for compressed images not supported');
  }
}

function checkTextureCube (texture, info, faces, limits) {
  var w = texture.width;
  var h = texture.height;
  var c = texture.channels;

  // Check texture shape
  check(
    w > 0 && w <= limits.maxTextureSize && h > 0 && h <= limits.maxTextureSize,
    'invalid texture shape');
  check(
    w === h,
    'cube map must be square');
  check(
    info.wrapS === GL_CLAMP_TO_EDGE && info.wrapT === GL_CLAMP_TO_EDGE,
    'wrap mode not supported by cube map');

  for (var i = 0; i < faces.length; ++i) {
    var face = faces[i];
    check(
      face.width === w && face.height === h,
      'inconsistent cube map face shape');

    if (info.genMipmaps) {
      check(!face.compressed,
        'can not generate mipmap for compressed textures');
      check(face.mipmask === 1,
        'can not specify mipmaps and generate mipmaps');
    }

    var mipmaps = face.images;
    for (var j = 0; j < 16; ++j) {
      var img = mipmaps[j];
      if (img) {
        var mw = w >> j;
        var mh = h >> j;
        check(face.mipmask & (1 << j), 'missing mipmap data');
        check(
          img.width === mw &&
          img.height === mh,
          'invalid shape for mip images');
        check(
          img.format === texture.format &&
          img.internalformat === texture.internalformat &&
          img.type === texture.type,
          'incompatible type for mip image');

        if (img.compressed) ; else if (img.data) {
          check(img.data.byteLength === mw * mh *
            Math.max(pixelSize(img.type, c), img.unpackAlignment),
          'invalid data for image, buffer size is inconsistent with image format');
        } else if (img.element) ; else if (img.copy) ;
      }
    }
  }
}

var check$1 = extend(check, {
  optional: checkOptional,
  raise: raise,
  commandRaise: commandRaise,
  command: checkCommand,
  parameter: checkParameter,
  commandParameter: checkParameterCommand,
  constructor: checkConstructor,
  type: checkTypeOf,
  commandType: checkCommandType,
  isTypedArray: checkIsTypedArray,
  nni: checkNonNegativeInt,
  oneOf: checkOneOf,
  shaderError: checkShaderError,
  linkError: checkLinkError,
  callSite: guessCallSite,
  saveCommandRef: saveCommandRef,
  saveDrawInfo: saveDrawCommandInfo,
  framebufferFormat: checkFramebufferFormat,
  guessCommand: guessCommand,
  texture2D: checkTexture2D,
  textureCube: checkTextureCube
});

var VARIABLE_COUNTER = 0;

var DYN_FUNC = 0;
var DYN_CONSTANT = 5;
var DYN_ARRAY = 6;

function DynamicVariable (type, data) {
  this.id = (VARIABLE_COUNTER++);
  this.type = type;
  this.data = data;
}

function escapeStr (str) {
  return str.replace(/\\/g, '\\\\').replace(/"/g, '\\"')
}

function splitParts (str) {
  if (str.length === 0) {
    return []
  }

  var firstChar = str.charAt(0);
  var lastChar = str.charAt(str.length - 1);

  if (str.length > 1 &&
      firstChar === lastChar &&
      (firstChar === '"' || firstChar === "'")) {
    return ['"' + escapeStr(str.substr(1, str.length - 2)) + '"']
  }

  var parts = /\[(false|true|null|\d+|'[^']*'|"[^"]*")\]/.exec(str);
  if (parts) {
    return (
      splitParts(str.substr(0, parts.index))
        .concat(splitParts(parts[1]))
        .concat(splitParts(str.substr(parts.index + parts[0].length)))
    )
  }

  var subparts = str.split('.');
  if (subparts.length === 1) {
    return ['"' + escapeStr(str) + '"']
  }

  var result = [];
  for (var i = 0; i < subparts.length; ++i) {
    result = result.concat(splitParts(subparts[i]));
  }
  return result
}

function toAccessorString (str) {
  return '[' + splitParts(str).join('][') + ']'
}

function defineDynamic (type, data) {
  return new DynamicVariable(type, toAccessorString(data + ''))
}

function isDynamic (x) {
  return (typeof x === 'function' && !x._reglType) || (x instanceof DynamicVariable)
}

function unbox (x, path) {
  if (typeof x === 'function') {
    return new DynamicVariable(DYN_FUNC, x)
  } else if (typeof x === 'number' || typeof x === 'boolean') {
    return new DynamicVariable(DYN_CONSTANT, x)
  } else if (Array.isArray(x)) {
    return new DynamicVariable(DYN_ARRAY, x.map(function (y, i) { return unbox(y, path + '[' + i + ']') }))
  } else if (x instanceof DynamicVariable) {
    return x
  }
  check$1(false, 'invalid option type in uniform ' + path);
}

var dynamic = {
  DynamicVariable: DynamicVariable,
  define: defineDynamic,
  isDynamic: isDynamic,
  unbox: unbox,
  accessor: toAccessorString
};

/* globals requestAnimationFrame, cancelAnimationFrame */
var raf = {
  next: typeof requestAnimationFrame === 'function'
    ? function (cb) { return requestAnimationFrame(cb) }
    : function (cb) { return setTimeout(cb, 16) },
  cancel: typeof cancelAnimationFrame === 'function'
    ? function (raf) { return cancelAnimationFrame(raf) }
    : clearTimeout
};

/* globals performance */
var clock = (typeof performance !== 'undefined' && performance.now)
    ? function () { return performance.now() }
    : function () { return +(new Date()) };

function createStringStore () {
  var stringIds = { '': 0 };
  var stringValues = [''];
  return {
    id: function (str) {
      var result = stringIds[str];
      if (result) {
        return result
      }
      result = stringIds[str] = stringValues.length;
      stringValues.push(str);
      return result
    },

    str: function (id) {
      return stringValues[id]
    }
  }
}

// Context and canvas creation helper functions
function createCanvas (element, onDone, pixelRatio) {
  var canvas = document.createElement('canvas');
  extend(canvas.style, {
    border: 0,
    margin: 0,
    padding: 0,
    top: 0,
    left: 0,
    width: '100%',
    height: '100%'
  });
  element.appendChild(canvas);

  if (element === document.body) {
    canvas.style.position = 'absolute';
    extend(element.style, {
      margin: 0,
      padding: 0
    });
  }

  function resize () {
    var w = window.innerWidth;
    var h = window.innerHeight;
    if (element !== document.body) {
      var bounds = canvas.getBoundingClientRect();
      w = bounds.right - bounds.left;
      h = bounds.bottom - bounds.top;
    }
    canvas.width = pixelRatio * w;
    canvas.height = pixelRatio * h;
  }

  var resizeObserver;
  if (element !== document.body && typeof ResizeObserver === 'function') {
    // ignore 'ResizeObserver' is not defined
    // eslint-disable-next-line
    resizeObserver = new ResizeObserver(function () {
      // setTimeout to avoid flicker
      setTimeout(resize);
    });
    resizeObserver.observe(element);
  } else {
    window.addEventListener('resize', resize, false);
  }

  function onDestroy () {
    if (resizeObserver) {
      resizeObserver.disconnect();
    } else {
      window.removeEventListener('resize', resize);
    }
    element.removeChild(canvas);
  }

  resize();

  return {
    canvas: canvas,
    onDestroy: onDestroy
  }
}

function createContext (canvas, contextAttributes) {
  function get (name) {
    try {
      return canvas.getContext(name, contextAttributes)
    } catch (e) {
      return null
    }
  }
  return (
    get('webgl') ||
    get('experimental-webgl') ||
    get('webgl-experimental')
  )
}

function isHTMLElement (obj) {
  return (
    typeof obj.nodeName === 'string' &&
    typeof obj.appendChild === 'function' &&
    typeof obj.getBoundingClientRect === 'function'
  )
}

function isWebGLContext (obj) {
  return (
    typeof obj.drawArrays === 'function' ||
    typeof obj.drawElements === 'function'
  )
}

function parseExtensions (input) {
  if (typeof input === 'string') {
    return input.split()
  }
  check$1(Array.isArray(input), 'invalid extension array');
  return input
}

function getElement (desc) {
  if (typeof desc === 'string') {
    check$1(typeof document !== 'undefined', 'not supported outside of DOM');
    return document.querySelector(desc)
  }
  return desc
}

function parseArgs (args_) {
  var args = args_ || {};
  var element, container, canvas, gl;
  var contextAttributes = {};
  var extensions = [];
  var optionalExtensions = [];
  var pixelRatio = (typeof window === 'undefined' ? 1 : window.devicePixelRatio);
  var profile = false;
  var onDone = function (err) {
    if (err) {
      check$1.raise(err);
    }
  };
  var onDestroy = function () {};
  if (typeof args === 'string') {
    check$1(
      typeof document !== 'undefined',
      'selector queries only supported in DOM enviroments');
    element = document.querySelector(args);
    check$1(element, 'invalid query string for element');
  } else if (typeof args === 'object') {
    if (isHTMLElement(args)) {
      element = args;
    } else if (isWebGLContext(args)) {
      gl = args;
      canvas = gl.canvas;
    } else {
      check$1.constructor(args);
      if ('gl' in args) {
        gl = args.gl;
      } else if ('canvas' in args) {
        canvas = getElement(args.canvas);
      } else if ('container' in args) {
        container = getElement(args.container);
      }
      if ('attributes' in args) {
        contextAttributes = args.attributes;
        check$1.type(contextAttributes, 'object', 'invalid context attributes');
      }
      if ('extensions' in args) {
        extensions = parseExtensions(args.extensions);
      }
      if ('optionalExtensions' in args) {
        optionalExtensions = parseExtensions(args.optionalExtensions);
      }
      if ('onDone' in args) {
        check$1.type(
          args.onDone, 'function',
          'invalid or missing onDone callback');
        onDone = args.onDone;
      }
      if ('profile' in args) {
        profile = !!args.profile;
      }
      if ('pixelRatio' in args) {
        pixelRatio = +args.pixelRatio;
        check$1(pixelRatio > 0, 'invalid pixel ratio');
      }
    }
  } else {
    check$1.raise('invalid arguments to regl');
  }

  if (element) {
    if (element.nodeName.toLowerCase() === 'canvas') {
      canvas = element;
    } else {
      container = element;
    }
  }

  if (!gl) {
    if (!canvas) {
      check$1(
        typeof document !== 'undefined',
        'must manually specify webgl context outside of DOM environments');
      var result = createCanvas(container || document.body, onDone, pixelRatio);
      if (!result) {
        return null
      }
      canvas = result.canvas;
      onDestroy = result.onDestroy;
    }
    // workaround for chromium bug, premultiplied alpha value is platform dependent
    if (contextAttributes.premultipliedAlpha === undefined) contextAttributes.premultipliedAlpha = true;
    gl = createContext(canvas, contextAttributes);
  }

  if (!gl) {
    onDestroy();
    onDone('webgl not supported, try upgrading your browser or graphics drivers http://get.webgl.org');
    return null
  }

  return {
    gl: gl,
    canvas: canvas,
    container: container,
    extensions: extensions,
    optionalExtensions: optionalExtensions,
    pixelRatio: pixelRatio,
    profile: profile,
    onDone: onDone,
    onDestroy: onDestroy
  }
}

function createExtensionCache (gl, config) {
  var extensions = {};

  function tryLoadExtension (name_) {
    check$1.type(name_, 'string', 'extension name must be string');
    var name = name_.toLowerCase();
    var ext;
    try {
      ext = extensions[name] = gl.getExtension(name);
    } catch (e) {}
    return !!ext
  }

  for (var i = 0; i < config.extensions.length; ++i) {
    var name = config.extensions[i];
    if (!tryLoadExtension(name)) {
      config.onDestroy();
      config.onDone('"' + name + '" extension is not supported by the current WebGL context, try upgrading your system or a different browser');
      return null
    }
  }

  config.optionalExtensions.forEach(tryLoadExtension);

  return {
    extensions: extensions,
    restore: function () {
      Object.keys(extensions).forEach(function (name) {
        if (extensions[name] && !tryLoadExtension(name)) {
          throw new Error('(regl): error restoring extension ' + name)
        }
      });
    }
  }
}

function loop (n, f) {
  var result = Array(n);
  for (var i = 0; i < n; ++i) {
    result[i] = f(i);
  }
  return result
}

var GL_BYTE$1 = 5120;
var GL_UNSIGNED_BYTE$2 = 5121;
var GL_SHORT$1 = 5122;
var GL_UNSIGNED_SHORT$1 = 5123;
var GL_INT$1 = 5124;
var GL_UNSIGNED_INT$1 = 5125;
var GL_FLOAT$2 = 5126;

function nextPow16 (v) {
  for (var i = 16; i <= (1 << 28); i *= 16) {
    if (v <= i) {
      return i
    }
  }
  return 0
}

function log2 (v) {
  var r, shift;
  r = (v > 0xFFFF) << 4;
  v >>>= r;
  shift = (v > 0xFF) << 3;
  v >>>= shift; r |= shift;
  shift = (v > 0xF) << 2;
  v >>>= shift; r |= shift;
  shift = (v > 0x3) << 1;
  v >>>= shift; r |= shift;
  return r | (v >> 1)
}

function createPool () {
  var bufferPool = loop(8, function () {
    return []
  });

  function alloc (n) {
    var sz = nextPow16(n);
    var bin = bufferPool[log2(sz) >> 2];
    if (bin.length > 0) {
      return bin.pop()
    }
    return new ArrayBuffer(sz)
  }

  function free (buf) {
    bufferPool[log2(buf.byteLength) >> 2].push(buf);
  }

  function allocType (type, n) {
    var result = null;
    switch (type) {
      case GL_BYTE$1:
        result = new Int8Array(alloc(n), 0, n);
        break
      case GL_UNSIGNED_BYTE$2:
        result = new Uint8Array(alloc(n), 0, n);
        break
      case GL_SHORT$1:
        result = new Int16Array(alloc(2 * n), 0, n);
        break
      case GL_UNSIGNED_SHORT$1:
        result = new Uint16Array(alloc(2 * n), 0, n);
        break
      case GL_INT$1:
        result = new Int32Array(alloc(4 * n), 0, n);
        break
      case GL_UNSIGNED_INT$1:
        result = new Uint32Array(alloc(4 * n), 0, n);
        break
      case GL_FLOAT$2:
        result = new Float32Array(alloc(4 * n), 0, n);
        break
      default:
        return null
    }
    if (result.length !== n) {
      return result.subarray(0, n)
    }
    return result
  }

  function freeType (array) {
    free(array.buffer);
  }

  return {
    alloc: alloc,
    free: free,
    allocType: allocType,
    freeType: freeType
  }
}

var pool = createPool();

// zero pool for initial zero data
pool.zero = createPool();

var GL_SUBPIXEL_BITS = 0x0D50;
var GL_RED_BITS = 0x0D52;
var GL_GREEN_BITS = 0x0D53;
var GL_BLUE_BITS = 0x0D54;
var GL_ALPHA_BITS = 0x0D55;
var GL_DEPTH_BITS = 0x0D56;
var GL_STENCIL_BITS = 0x0D57;

var GL_ALIASED_POINT_SIZE_RANGE = 0x846D;
var GL_ALIASED_LINE_WIDTH_RANGE = 0x846E;

var GL_MAX_TEXTURE_SIZE = 0x0D33;
var GL_MAX_VIEWPORT_DIMS = 0x0D3A;
var GL_MAX_VERTEX_ATTRIBS = 0x8869;
var GL_MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB;
var GL_MAX_VARYING_VECTORS = 0x8DFC;
var GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;
var GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C;
var GL_MAX_TEXTURE_IMAGE_UNITS = 0x8872;
var GL_MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD;
var GL_MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C;
var GL_MAX_RENDERBUFFER_SIZE = 0x84E8;

var GL_VENDOR = 0x1F00;
var GL_RENDERER = 0x1F01;
var GL_VERSION = 0x1F02;
var GL_SHADING_LANGUAGE_VERSION = 0x8B8C;

var GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FF;

var GL_MAX_COLOR_ATTACHMENTS_WEBGL = 0x8CDF;
var GL_MAX_DRAW_BUFFERS_WEBGL = 0x8824;

var GL_TEXTURE_2D = 0x0DE1;
var GL_TEXTURE_CUBE_MAP = 0x8513;
var GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;
var GL_TEXTURE0 = 0x84C0;
var GL_RGBA = 0x1908;
var GL_FLOAT$1 = 0x1406;
var GL_UNSIGNED_BYTE$1 = 0x1401;
var GL_FRAMEBUFFER = 0x8D40;
var GL_FRAMEBUFFER_COMPLETE = 0x8CD5;
var GL_COLOR_ATTACHMENT0 = 0x8CE0;
var GL_COLOR_BUFFER_BIT$1 = 0x4000;

var wrapLimits = function (gl, extensions) {
  var maxAnisotropic = 1;
  if (extensions.ext_texture_filter_anisotropic) {
    maxAnisotropic = gl.getParameter(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT);
  }

  var maxDrawbuffers = 1;
  var maxColorAttachments = 1;
  if (extensions.webgl_draw_buffers) {
    maxDrawbuffers = gl.getParameter(GL_MAX_DRAW_BUFFERS_WEBGL);
    maxColorAttachments = gl.getParameter(GL_MAX_COLOR_ATTACHMENTS_WEBGL);
  }

  // detect if reading float textures is available (Safari doesn't support)
  var readFloat = !!extensions.oes_texture_float;
  if (readFloat) {
    var readFloatTexture = gl.createTexture();
    gl.bindTexture(GL_TEXTURE_2D, readFloatTexture);
    gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 1, 1, 0, GL_RGBA, GL_FLOAT$1, null);

    var fbo = gl.createFramebuffer();
    gl.bindFramebuffer(GL_FRAMEBUFFER, fbo);
    gl.framebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, readFloatTexture, 0);
    gl.bindTexture(GL_TEXTURE_2D, null);

    if (gl.checkFramebufferStatus(GL_FRAMEBUFFER) !== GL_FRAMEBUFFER_COMPLETE) readFloat = false;

    else {
      gl.viewport(0, 0, 1, 1);
      gl.clearColor(1.0, 0.0, 0.0, 1.0);
      gl.clear(GL_COLOR_BUFFER_BIT$1);
      var pixels = pool.allocType(GL_FLOAT$1, 4);
      gl.readPixels(0, 0, 1, 1, GL_RGBA, GL_FLOAT$1, pixels);

      if (gl.getError()) readFloat = false;
      else {
        gl.deleteFramebuffer(fbo);
        gl.deleteTexture(readFloatTexture);

        readFloat = pixels[0] === 1.0;
      }

      pool.freeType(pixels);
    }
  }

  // detect non power of two cube textures support (IE doesn't support)
  var isIE = typeof navigator !== 'undefined' && (/MSIE/.test(navigator.userAgent) || /Trident\//.test(navigator.appVersion) || /Edge/.test(navigator.userAgent));

  var npotTextureCube = true;

  if (!isIE) {
    var cubeTexture = gl.createTexture();
    var data = pool.allocType(GL_UNSIGNED_BYTE$1, 36);
    gl.activeTexture(GL_TEXTURE0);
    gl.bindTexture(GL_TEXTURE_CUBE_MAP, cubeTexture);
    gl.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0, GL_RGBA, 3, 3, 0, GL_RGBA, GL_UNSIGNED_BYTE$1, data);
    pool.freeType(data);
    gl.bindTexture(GL_TEXTURE_CUBE_MAP, null);
    gl.deleteTexture(cubeTexture);
    npotTextureCube = !gl.getError();
  }

  return {
    // drawing buffer bit depth
    colorBits: [
      gl.getParameter(GL_RED_BITS),
      gl.getParameter(GL_GREEN_BITS),
      gl.getParameter(GL_BLUE_BITS),
      gl.getParameter(GL_ALPHA_BITS)
    ],
    depthBits: gl.getParameter(GL_DEPTH_BITS),
    stencilBits: gl.getParameter(GL_STENCIL_BITS),
    subpixelBits: gl.getParameter(GL_SUBPIXEL_BITS),

    // supported extensions
    extensions: Object.keys(extensions).filter(function (ext) {
      return !!extensions[ext]
    }),

    // max aniso samples
    maxAnisotropic: maxAnisotropic,

    // max draw buffers
    maxDrawbuffers: maxDrawbuffers,
    maxColorAttachments: maxColorAttachments,

    // point and line size ranges
    pointSizeDims: gl.getParameter(GL_ALIASED_POINT_SIZE_RANGE),
    lineWidthDims: gl.getParameter(GL_ALIASED_LINE_WIDTH_RANGE),
    maxViewportDims: gl.getParameter(GL_MAX_VIEWPORT_DIMS),
    maxCombinedTextureUnits: gl.getParameter(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS),
    maxCubeMapSize: gl.getParameter(GL_MAX_CUBE_MAP_TEXTURE_SIZE),
    maxRenderbufferSize: gl.getParameter(GL_MAX_RENDERBUFFER_SIZE),
    maxTextureUnits: gl.getParameter(GL_MAX_TEXTURE_IMAGE_UNITS),
    maxTextureSize: gl.getParameter(GL_MAX_TEXTURE_SIZE),
    maxAttributes: gl.getParameter(GL_MAX_VERTEX_ATTRIBS),
    maxVertexUniforms: gl.getParameter(GL_MAX_VERTEX_UNIFORM_VECTORS),
    maxVertexTextureUnits: gl.getParameter(GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    maxVaryingVectors: gl.getParameter(GL_MAX_VARYING_VECTORS),
    maxFragmentUniforms: gl.getParameter(GL_MAX_FRAGMENT_UNIFORM_VECTORS),

    // vendor info
    glsl: gl.getParameter(GL_SHADING_LANGUAGE_VERSION),
    renderer: gl.getParameter(GL_RENDERER),
    vendor: gl.getParameter(GL_VENDOR),
    version: gl.getParameter(GL_VERSION),

    // quirks
    readFloat: readFloat,
    npotTextureCube: npotTextureCube
  }
};

function isNDArrayLike (obj) {
  return (
    !!obj &&
    typeof obj === 'object' &&
    Array.isArray(obj.shape) &&
    Array.isArray(obj.stride) &&
    typeof obj.offset === 'number' &&
    obj.shape.length === obj.stride.length &&
    (Array.isArray(obj.data) ||
      isTypedArray(obj.data)))
}

var values = function (obj) {
  return Object.keys(obj).map(function (key) { return obj[key] })
};

var flattenUtils = {
  shape: arrayShape$1,
  flatten: flattenArray
};

function flatten1D (array, nx, out) {
  for (var i = 0; i < nx; ++i) {
    out[i] = array[i];
  }
}

function flatten2D (array, nx, ny, out) {
  var ptr = 0;
  for (var i = 0; i < nx; ++i) {
    var row = array[i];
    for (var j = 0; j < ny; ++j) {
      out[ptr++] = row[j];
    }
  }
}

function flatten3D (array, nx, ny, nz, out, ptr_) {
  var ptr = ptr_;
  for (var i = 0; i < nx; ++i) {
    var row = array[i];
    for (var j = 0; j < ny; ++j) {
      var col = row[j];
      for (var k = 0; k < nz; ++k) {
        out[ptr++] = col[k];
      }
    }
  }
}

function flattenRec (array, shape, level, out, ptr) {
  var stride = 1;
  for (var i = level + 1; i < shape.length; ++i) {
    stride *= shape[i];
  }
  var n = shape[level];
  if (shape.length - level === 4) {
    var nx = shape[level + 1];
    var ny = shape[level + 2];
    var nz = shape[level + 3];
    for (i = 0; i < n; ++i) {
      flatten3D(array[i], nx, ny, nz, out, ptr);
      ptr += stride;
    }
  } else {
    for (i = 0; i < n; ++i) {
      flattenRec(array[i], shape, level + 1, out, ptr);
      ptr += stride;
    }
  }
}

function flattenArray (array, shape, type, out_) {
  var sz = 1;
  if (shape.length) {
    for (var i = 0; i < shape.length; ++i) {
      sz *= shape[i];
    }
  } else {
    sz = 0;
  }
  var out = out_ || pool.allocType(type, sz);
  switch (shape.length) {
    case 0:
      break
    case 1:
      flatten1D(array, shape[0], out);
      break
    case 2:
      flatten2D(array, shape[0], shape[1], out);
      break
    case 3:
      flatten3D(array, shape[0], shape[1], shape[2], out, 0);
      break
    default:
      flattenRec(array, shape, 0, out, 0);
  }
  return out
}

function arrayShape$1 (array_) {
  var shape = [];
  for (var array = array_; array.length; array = array[0]) {
    shape.push(array.length);
  }
  return shape
}

var arrayTypes =  {
	"[object Int8Array]": 5120,
	"[object Int16Array]": 5122,
	"[object Int32Array]": 5124,
	"[object Uint8Array]": 5121,
	"[object Uint8ClampedArray]": 5121,
	"[object Uint16Array]": 5123,
	"[object Uint32Array]": 5125,
	"[object Float32Array]": 5126,
	"[object Float64Array]": 5121,
	"[object ArrayBuffer]": 5121
};

var int8 = 5120;
var int16 = 5122;
var int32 = 5124;
var uint8 = 5121;
var uint16 = 5123;
var uint32 = 5125;
var float = 5126;
var float32 = 5126;
var glTypes = {
	int8: int8,
	int16: int16,
	int32: int32,
	uint8: uint8,
	uint16: uint16,
	uint32: uint32,
	float: float,
	float32: float32
};

var dynamic$1 = 35048;
var stream = 35040;
var usageTypes = {
	dynamic: dynamic$1,
	stream: stream,
	"static": 35044
};

var arrayFlatten = flattenUtils.flatten;
var arrayShape = flattenUtils.shape;

var GL_STATIC_DRAW = 0x88E4;
var GL_STREAM_DRAW = 0x88E0;

var GL_UNSIGNED_BYTE$3 = 5121;
var GL_FLOAT$3 = 5126;

var DTYPES_SIZES = [];
DTYPES_SIZES[5120] = 1; // int8
DTYPES_SIZES[5122] = 2; // int16
DTYPES_SIZES[5124] = 4; // int32
DTYPES_SIZES[5121] = 1; // uint8
DTYPES_SIZES[5123] = 2; // uint16
DTYPES_SIZES[5125] = 4; // uint32
DTYPES_SIZES[5126] = 4; // float32

function typedArrayCode (data) {
  return arrayTypes[Object.prototype.toString.call(data)] | 0
}

function copyArray (out, inp) {
  for (var i = 0; i < inp.length; ++i) {
    out[i] = inp[i];
  }
}

function transpose (
  result, data, shapeX, shapeY, strideX, strideY, offset) {
  var ptr = 0;
  for (var i = 0; i < shapeX; ++i) {
    for (var j = 0; j < shapeY; ++j) {
      result[ptr++] = data[strideX * i + strideY * j + offset];
    }
  }
}

function wrapBufferState (gl, stats, config, destroyBuffer) {
  var bufferCount = 0;
  var bufferSet = {};

  function REGLBuffer (type) {
    this.id = bufferCount++;
    this.buffer = gl.createBuffer();
    this.type = type;
    this.usage = GL_STATIC_DRAW;
    this.byteLength = 0;
    this.dimension = 1;
    this.dtype = GL_UNSIGNED_BYTE$3;

    this.persistentData = null;

    if (config.profile) {
      this.stats = { size: 0 };
    }
  }

  REGLBuffer.prototype.bind = function () {
    gl.bindBuffer(this.type, this.buffer);
  };

  REGLBuffer.prototype.destroy = function () {
    destroy(this);
  };

  var streamPool = [];

  function createStream (type, data) {
    var buffer = streamPool.pop();
    if (!buffer) {
      buffer = new REGLBuffer(type);
    }
    buffer.bind();
    initBufferFromData(buffer, data, GL_STREAM_DRAW, 0, 1, false);
    return buffer
  }

  function destroyStream (stream$$1) {
    streamPool.push(stream$$1);
  }

  function initBufferFromTypedArray (buffer, data, usage) {
    buffer.byteLength = data.byteLength;
    gl.bufferData(buffer.type, data, usage);
  }

  function initBufferFromData (buffer, data, usage, dtype, dimension, persist) {
    var shape;
    buffer.usage = usage;
    if (Array.isArray(data)) {
      buffer.dtype = dtype || GL_FLOAT$3;
      if (data.length > 0) {
        var flatData;
        if (Array.isArray(data[0])) {
          shape = arrayShape(data);
          var dim = 1;
          for (var i = 1; i < shape.length; ++i) {
            dim *= shape[i];
          }
          buffer.dimension = dim;
          flatData = arrayFlatten(data, shape, buffer.dtype);
          initBufferFromTypedArray(buffer, flatData, usage);
          if (persist) {
            buffer.persistentData = flatData;
          } else {
            pool.freeType(flatData);
          }
        } else if (typeof data[0] === 'number') {
          buffer.dimension = dimension;
          var typedData = pool.allocType(buffer.dtype, data.length);
          copyArray(typedData, data);
          initBufferFromTypedArray(buffer, typedData, usage);
          if (persist) {
            buffer.persistentData = typedData;
          } else {
            pool.freeType(typedData);
          }
        } else if (isTypedArray(data[0])) {
          buffer.dimension = data[0].length;
          buffer.dtype = dtype || typedArrayCode(data[0]) || GL_FLOAT$3;
          flatData = arrayFlatten(
            data,
            [data.length, data[0].length],
            buffer.dtype);
          initBufferFromTypedArray(buffer, flatData, usage);
          if (persist) {
            buffer.persistentData = flatData;
          } else {
            pool.freeType(flatData);
          }
        } else {
          check$1.raise('invalid buffer data');
        }
      }
    } else if (isTypedArray(data)) {
      buffer.dtype = dtype || typedArrayCode(data);
      buffer.dimension = dimension;
      initBufferFromTypedArray(buffer, data, usage);
      if (persist) {
        buffer.persistentData = new Uint8Array(new Uint8Array(data.buffer));
      }
    } else if (isNDArrayLike(data)) {
      shape = data.shape;
      var stride = data.stride;
      var offset = data.offset;

      var shapeX = 0;
      var shapeY = 0;
      var strideX = 0;
      var strideY = 0;
      if (shape.length === 1) {
        shapeX = shape[0];
        shapeY = 1;
        strideX = stride[0];
        strideY = 0;
      } else if (shape.length === 2) {
        shapeX = shape[0];
        shapeY = shape[1];
        strideX = stride[0];
        strideY = stride[1];
      } else {
        check$1.raise('invalid shape');
      }

      buffer.dtype = dtype || typedArrayCode(data.data) || GL_FLOAT$3;
      buffer.dimension = shapeY;

      var transposeData = pool.allocType(buffer.dtype, shapeX * shapeY);
      transpose(transposeData,
        data.data,
        shapeX, shapeY,
        strideX, strideY,
        offset);
      initBufferFromTypedArray(buffer, transposeData, usage);
      if (persist) {
        buffer.persistentData = transposeData;
      } else {
        pool.freeType(transposeData);
      }
    } else if (data instanceof ArrayBuffer) {
      buffer.dtype = GL_UNSIGNED_BYTE$3;
      buffer.dimension = dimension;
      initBufferFromTypedArray(buffer, data, usage);
      if (persist) {
        buffer.persistentData = new Uint8Array(new Uint8Array(data));
      }
    } else {
      check$1.raise('invalid buffer data');
    }
  }

  function destroy (buffer) {
    stats.bufferCount--;

    // remove attribute link
    destroyBuffer(buffer);

    var handle = buffer.buffer;
    check$1(handle, 'buffer must not be deleted already');
    gl.deleteBuffer(handle);
    buffer.buffer = null;
    delete bufferSet[buffer.id];
  }

  function createBuffer (options, type, deferInit, persistent) {
    stats.bufferCount++;

    var buffer = new REGLBuffer(type);
    bufferSet[buffer.id] = buffer;

    function reglBuffer (options) {
      var usage = GL_STATIC_DRAW;
      var data = null;
      var byteLength = 0;
      var dtype = 0;
      var dimension = 1;
      if (Array.isArray(options) ||
          isTypedArray(options) ||
          isNDArrayLike(options) ||
          options instanceof ArrayBuffer) {
        data = options;
      } else if (typeof options === 'number') {
        byteLength = options | 0;
      } else if (options) {
        check$1.type(
          options, 'object',
          'buffer arguments must be an object, a number or an array');

        if ('data' in options) {
          check$1(
            data === null ||
            Array.isArray(data) ||
            isTypedArray(data) ||
            isNDArrayLike(data),
            'invalid data for buffer');
          data = options.data;
        }

        if ('usage' in options) {
          check$1.parameter(options.usage, usageTypes, 'invalid buffer usage');
          usage = usageTypes[options.usage];
        }

        if ('type' in options) {
          check$1.parameter(options.type, glTypes, 'invalid buffer type');
          dtype = glTypes[options.type];
        }

        if ('dimension' in options) {
          check$1.type(options.dimension, 'number', 'invalid dimension');
          dimension = options.dimension | 0;
        }

        if ('length' in options) {
          check$1.nni(byteLength, 'buffer length must be a nonnegative integer');
          byteLength = options.length | 0;
        }
      }

      buffer.bind();
      if (!data) {
        // #475
        if (byteLength) gl.bufferData(buffer.type, byteLength, usage);
        buffer.dtype = dtype || GL_UNSIGNED_BYTE$3;
        buffer.usage = usage;
        buffer.dimension = dimension;
        buffer.byteLength = byteLength;
      } else {
        initBufferFromData(buffer, data, usage, dtype, dimension, persistent);
      }

      if (config.profile) {
        buffer.stats.size = buffer.byteLength * DTYPES_SIZES[buffer.dtype];
      }

      return reglBuffer
    }

    function setSubData (data, offset) {
      check$1(offset + data.byteLength <= buffer.byteLength,
        'invalid buffer subdata call, buffer is too small. ' + ' Can\'t write data of size ' + data.byteLength + ' starting from offset ' + offset + ' to a buffer of size ' + buffer.byteLength);

      gl.bufferSubData(buffer.type, offset, data);
    }

    function subdata (data, offset_) {
      var offset = (offset_ || 0) | 0;
      var shape;
      buffer.bind();
      if (isTypedArray(data) || data instanceof ArrayBuffer) {
        setSubData(data, offset);
      } else if (Array.isArray(data)) {
        if (data.length > 0) {
          if (typeof data[0] === 'number') {
            var converted = pool.allocType(buffer.dtype, data.length);
            copyArray(converted, data);
            setSubData(converted, offset);
            pool.freeType(converted);
          } else if (Array.isArray(data[0]) || isTypedArray(data[0])) {
            shape = arrayShape(data);
            var flatData = arrayFlatten(data, shape, buffer.dtype);
            setSubData(flatData, offset);
            pool.freeType(flatData);
          } else {
            check$1.raise('invalid buffer data');
          }
        }
      } else if (isNDArrayLike(data)) {
        shape = data.shape;
        var stride = data.stride;

        var shapeX = 0;
        var shapeY = 0;
        var strideX = 0;
        var strideY = 0;
        if (shape.length === 1) {
          shapeX = shape[0];
          shapeY = 1;
          strideX = stride[0];
          strideY = 0;
        } else if (shape.length === 2) {
          shapeX = shape[0];
          shapeY = shape[1];
          strideX = stride[0];
          strideY = stride[1];
        } else {
          check$1.raise('invalid shape');
        }
        var dtype = Array.isArray(data.data)
          ? buffer.dtype
          : typedArrayCode(data.data);

        var transposeData = pool.allocType(dtype, shapeX * shapeY);
        transpose(transposeData,
          data.data,
          shapeX, shapeY,
          strideX, strideY,
          data.offset);
        setSubData(transposeData, offset);
        pool.freeType(transposeData);
      } else {
        check$1.raise('invalid data for buffer subdata');
      }
      return reglBuffer
    }

    if (!deferInit) {
      reglBuffer(options);
    }

    reglBuffer._reglType = 'buffer';
    reglBuffer._buffer = buffer;
    reglBuffer.subdata = subdata;
    if (config.profile) {
      reglBuffer.stats = buffer.stats;
    }
    reglBuffer.destroy = function () { destroy(buffer); };

    return reglBuffer
  }

  function restoreBuffers () {
    values(bufferSet).forEach(function (buffer) {
      buffer.buffer = gl.createBuffer();
      gl.bindBuffer(buffer.type, buffer.buffer);
      gl.bufferData(
        buffer.type, buffer.persistentData || buffer.byteLength, buffer.usage);
    });
  }

  if (config.profile) {
    stats.getTotalBufferSize = function () {
      var total = 0;
      // TODO: Right now, the streams are not part of the total count.
      Object.keys(bufferSet).forEach(function (key) {
        total += bufferSet[key].stats.size;
      });
      return total
    };
  }

  return {
    create: createBuffer,

    createStream: createStream,
    destroyStream: destroyStream,

    clear: function () {
      values(bufferSet).forEach(destroy);
      streamPool.forEach(destroy);
    },

    getBuffer: function (wrapper) {
      if (wrapper && wrapper._buffer instanceof REGLBuffer) {
        return wrapper._buffer
      }
      return null
    },

    restore: restoreBuffers,

    _initBuffer: initBufferFromData
  }
}

var points = 0;
var point = 0;
var lines = 1;
var line = 1;
var triangles = 4;
var triangle = 4;
var primTypes = {
	points: points,
	point: point,
	lines: lines,
	line: line,
	triangles: triangles,
	triangle: triangle,
	"line loop": 2,
	"line strip": 3,
	"triangle strip": 5,
	"triangle fan": 6
};

var GL_POINTS = 0;
var GL_LINES = 1;
var GL_TRIANGLES = 4;

var GL_BYTE$2 = 5120;
var GL_UNSIGNED_BYTE$4 = 5121;
var GL_SHORT$2 = 5122;
var GL_UNSIGNED_SHORT$2 = 5123;
var GL_INT$2 = 5124;
var GL_UNSIGNED_INT$2 = 5125;

var GL_ELEMENT_ARRAY_BUFFER = 34963;

var GL_STREAM_DRAW$1 = 0x88E0;
var GL_STATIC_DRAW$1 = 0x88E4;

function wrapElementsState (gl, extensions, bufferState, stats) {
  var elementSet = {};
  var elementCount = 0;

  var elementTypes = {
    'uint8': GL_UNSIGNED_BYTE$4,
    'uint16': GL_UNSIGNED_SHORT$2
  };

  if (extensions.oes_element_index_uint) {
    elementTypes.uint32 = GL_UNSIGNED_INT$2;
  }

  function REGLElementBuffer (buffer) {
    this.id = elementCount++;
    elementSet[this.id] = this;
    this.buffer = buffer;
    this.primType = GL_TRIANGLES;
    this.vertCount = 0;
    this.type = 0;
  }

  REGLElementBuffer.prototype.bind = function () {
    this.buffer.bind();
  };

  var bufferPool = [];

  function createElementStream (data) {
    var result = bufferPool.pop();
    if (!result) {
      result = new REGLElementBuffer(bufferState.create(
        null,
        GL_ELEMENT_ARRAY_BUFFER,
        true,
        false)._buffer);
    }
    initElements(result, data, GL_STREAM_DRAW$1, -1, -1, 0, 0);
    return result
  }

  function destroyElementStream (elements) {
    bufferPool.push(elements);
  }

  function initElements (
    elements,
    data,
    usage,
    prim,
    count,
    byteLength,
    type) {
    elements.buffer.bind();
    var dtype;
    if (data) {
      var predictedType = type;
      if (!type && (
        !isTypedArray(data) ||
         (isNDArrayLike(data) && !isTypedArray(data.data)))) {
        predictedType = extensions.oes_element_index_uint
          ? GL_UNSIGNED_INT$2
          : GL_UNSIGNED_SHORT$2;
      }
      bufferState._initBuffer(
        elements.buffer,
        data,
        usage,
        predictedType,
        3);
    } else {
      gl.bufferData(GL_ELEMENT_ARRAY_BUFFER, byteLength, usage);
      elements.buffer.dtype = dtype || GL_UNSIGNED_BYTE$4;
      elements.buffer.usage = usage;
      elements.buffer.dimension = 3;
      elements.buffer.byteLength = byteLength;
    }

    dtype = type;
    if (!type) {
      switch (elements.buffer.dtype) {
        case GL_UNSIGNED_BYTE$4:
        case GL_BYTE$2:
          dtype = GL_UNSIGNED_BYTE$4;
          break

        case GL_UNSIGNED_SHORT$2:
        case GL_SHORT$2:
          dtype = GL_UNSIGNED_SHORT$2;
          break

        case GL_UNSIGNED_INT$2:
        case GL_INT$2:
          dtype = GL_UNSIGNED_INT$2;
          break

        default:
          check$1.raise('unsupported type for element array');
      }
      elements.buffer.dtype = dtype;
    }
    elements.type = dtype;

    // Check oes_element_index_uint extension
    check$1(
      dtype !== GL_UNSIGNED_INT$2 ||
      !!extensions.oes_element_index_uint,
      '32 bit element buffers not supported, enable oes_element_index_uint first');

    // try to guess default primitive type and arguments
    var vertCount = count;
    if (vertCount < 0) {
      vertCount = elements.buffer.byteLength;
      if (dtype === GL_UNSIGNED_SHORT$2) {
        vertCount >>= 1;
      } else if (dtype === GL_UNSIGNED_INT$2) {
        vertCount >>= 2;
      }
    }
    elements.vertCount = vertCount;

    // try to guess primitive type from cell dimension
    var primType = prim;
    if (prim < 0) {
      primType = GL_TRIANGLES;
      var dimension = elements.buffer.dimension;
      if (dimension === 1) primType = GL_POINTS;
      if (dimension === 2) primType = GL_LINES;
      if (dimension === 3) primType = GL_TRIANGLES;
    }
    elements.primType = primType;
  }

  function destroyElements (elements) {
    stats.elementsCount--;

    check$1(elements.buffer !== null, 'must not double destroy elements');
    delete elementSet[elements.id];
    elements.buffer.destroy();
    elements.buffer = null;
  }

  function createElements (options, persistent) {
    var buffer = bufferState.create(null, GL_ELEMENT_ARRAY_BUFFER, true);
    var elements = new REGLElementBuffer(buffer._buffer);
    stats.elementsCount++;

    function reglElements (options) {
      if (!options) {
        buffer();
        elements.primType = GL_TRIANGLES;
        elements.vertCount = 0;
        elements.type = GL_UNSIGNED_BYTE$4;
      } else if (typeof options === 'number') {
        buffer(options);
        elements.primType = GL_TRIANGLES;
        elements.vertCount = options | 0;
        elements.type = GL_UNSIGNED_BYTE$4;
      } else {
        var data = null;
        var usage = GL_STATIC_DRAW$1;
        var primType = -1;
        var vertCount = -1;
        var byteLength = 0;
        var dtype = 0;
        if (Array.isArray(options) ||
            isTypedArray(options) ||
            isNDArrayLike(options)) {
          data = options;
        } else {
          check$1.type(options, 'object', 'invalid arguments for elements');
          if ('data' in options) {
            data = options.data;
            check$1(
              Array.isArray(data) ||
                isTypedArray(data) ||
                isNDArrayLike(data),
              'invalid data for element buffer');
          }
          if ('usage' in options) {
            check$1.parameter(
              options.usage,
              usageTypes,
              'invalid element buffer usage');
            usage = usageTypes[options.usage];
          }
          if ('primitive' in options) {
            check$1.parameter(
              options.primitive,
              primTypes,
              'invalid element buffer primitive');
            primType = primTypes[options.primitive];
          }
          if ('count' in options) {
            check$1(
              typeof options.count === 'number' && options.count >= 0,
              'invalid vertex count for elements');
            vertCount = options.count | 0;
          }
          if ('type' in options) {
            check$1.parameter(
              options.type,
              elementTypes,
              'invalid buffer type');
            dtype = elementTypes[options.type];
          }
          if ('length' in options) {
            byteLength = options.length | 0;
          } else {
            byteLength = vertCount;
            if (dtype === GL_UNSIGNED_SHORT$2 || dtype === GL_SHORT$2) {
              byteLength *= 2;
            } else if (dtype === GL_UNSIGNED_INT$2 || dtype === GL_INT$2) {
              byteLength *= 4;
            }
          }
        }
        initElements(
          elements,
          data,
          usage,
          primType,
          vertCount,
          byteLength,
          dtype);
      }

      return reglElements
    }

    reglElements(options);

    reglElements._reglType = 'elements';
    reglElements._elements = elements;
    reglElements.subdata = function (data, offset) {
      buffer.subdata(data, offset);
      return reglElements
    };
    reglElements.destroy = function () {
      destroyElements(elements);
    };

    return reglElements
  }

  return {
    create: createElements,
    createStream: createElementStream,
    destroyStream: destroyElementStream,
    getElements: function (elements) {
      if (typeof elements === 'function' &&
          elements._elements instanceof REGLElementBuffer) {
        return elements._elements
      }
      return null
    },
    clear: function () {
      values(elementSet).forEach(destroyElements);
    }
  }
}

var FLOAT = new Float32Array(1);
var INT = new Uint32Array(FLOAT.buffer);

var GL_UNSIGNED_SHORT$4 = 5123;

function convertToHalfFloat (array) {
  var ushorts = pool.allocType(GL_UNSIGNED_SHORT$4, array.length);

  for (var i = 0; i < array.length; ++i) {
    if (isNaN(array[i])) {
      ushorts[i] = 0xffff;
    } else if (array[i] === Infinity) {
      ushorts[i] = 0x7c00;
    } else if (array[i] === -Infinity) {
      ushorts[i] = 0xfc00;
    } else {
      FLOAT[0] = array[i];
      var x = INT[0];

      var sgn = (x >>> 31) << 15;
      var exp = ((x << 1) >>> 24) - 127;
      var frac = (x >> 13) & ((1 << 10) - 1);

      if (exp < -24) {
        // round non-representable denormals to 0
        ushorts[i] = sgn;
      } else if (exp < -14) {
        // handle denormals
        var s = -14 - exp;
        ushorts[i] = sgn + ((frac + (1 << 10)) >> s);
      } else if (exp > 15) {
        // round overflow to +/- Infinity
        ushorts[i] = sgn + 0x7c00;
      } else {
        // otherwise convert directly
        ushorts[i] = sgn + ((exp + 15) << 10) + frac;
      }
    }
  }

  return ushorts
}

function isArrayLike (s) {
  return Array.isArray(s) || isTypedArray(s)
}

var isPow2$1 = function (v) {
  return !(v & (v - 1)) && (!!v)
};

var GL_COMPRESSED_TEXTURE_FORMATS = 0x86A3;

var GL_TEXTURE_2D$1 = 0x0DE1;
var GL_TEXTURE_CUBE_MAP$1 = 0x8513;
var GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 = 0x8515;

var GL_RGBA$1 = 0x1908;
var GL_ALPHA = 0x1906;
var GL_RGB = 0x1907;
var GL_LUMINANCE = 0x1909;
var GL_LUMINANCE_ALPHA = 0x190A;

var GL_RGBA4 = 0x8056;
var GL_RGB5_A1 = 0x8057;
var GL_RGB565 = 0x8D62;

var GL_UNSIGNED_SHORT_4_4_4_4$1 = 0x8033;
var GL_UNSIGNED_SHORT_5_5_5_1$1 = 0x8034;
var GL_UNSIGNED_SHORT_5_6_5$1 = 0x8363;
var GL_UNSIGNED_INT_24_8_WEBGL$1 = 0x84FA;

var GL_DEPTH_COMPONENT = 0x1902;
var GL_DEPTH_STENCIL = 0x84F9;

var GL_SRGB_EXT = 0x8C40;
var GL_SRGB_ALPHA_EXT = 0x8C42;

var GL_HALF_FLOAT_OES$1 = 0x8D61;

var GL_COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0;
var GL_COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1;
var GL_COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2;
var GL_COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3;

var GL_COMPRESSED_RGB_ATC_WEBGL = 0x8C92;
var GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 0x8C93;
var GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 0x87EE;

var GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 0x8C00;
var GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 0x8C01;
var GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8C02;
var GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 0x8C03;

var GL_COMPRESSED_RGB_ETC1_WEBGL = 0x8D64;

var GL_UNSIGNED_BYTE$5 = 0x1401;
var GL_UNSIGNED_SHORT$3 = 0x1403;
var GL_UNSIGNED_INT$3 = 0x1405;
var GL_FLOAT$4 = 0x1406;

var GL_TEXTURE_WRAP_S = 0x2802;
var GL_TEXTURE_WRAP_T = 0x2803;

var GL_REPEAT = 0x2901;
var GL_CLAMP_TO_EDGE$1 = 0x812F;
var GL_MIRRORED_REPEAT = 0x8370;

var GL_TEXTURE_MAG_FILTER = 0x2800;
var GL_TEXTURE_MIN_FILTER = 0x2801;

var GL_NEAREST$1 = 0x2600;
var GL_LINEAR = 0x2601;
var GL_NEAREST_MIPMAP_NEAREST$1 = 0x2700;
var GL_LINEAR_MIPMAP_NEAREST$1 = 0x2701;
var GL_NEAREST_MIPMAP_LINEAR$1 = 0x2702;
var GL_LINEAR_MIPMAP_LINEAR$1 = 0x2703;

var GL_GENERATE_MIPMAP_HINT = 0x8192;
var GL_DONT_CARE = 0x1100;
var GL_FASTEST = 0x1101;
var GL_NICEST = 0x1102;

var GL_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FE;

var GL_UNPACK_ALIGNMENT = 0x0CF5;
var GL_UNPACK_FLIP_Y_WEBGL = 0x9240;
var GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;
var GL_UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;

var GL_BROWSER_DEFAULT_WEBGL = 0x9244;

var GL_TEXTURE0$1 = 0x84C0;

var MIPMAP_FILTERS = [
  GL_NEAREST_MIPMAP_NEAREST$1,
  GL_NEAREST_MIPMAP_LINEAR$1,
  GL_LINEAR_MIPMAP_NEAREST$1,
  GL_LINEAR_MIPMAP_LINEAR$1
];

var CHANNELS_FORMAT = [
  0,
  GL_LUMINANCE,
  GL_LUMINANCE_ALPHA,
  GL_RGB,
  GL_RGBA$1
];

var FORMAT_CHANNELS = {};
FORMAT_CHANNELS[GL_LUMINANCE] =
FORMAT_CHANNELS[GL_ALPHA] =
FORMAT_CHANNELS[GL_DEPTH_COMPONENT] = 1;
FORMAT_CHANNELS[GL_DEPTH_STENCIL] =
FORMAT_CHANNELS[GL_LUMINANCE_ALPHA] = 2;
FORMAT_CHANNELS[GL_RGB] =
FORMAT_CHANNELS[GL_SRGB_EXT] = 3;
FORMAT_CHANNELS[GL_RGBA$1] =
FORMAT_CHANNELS[GL_SRGB_ALPHA_EXT] = 4;

function objectName (str) {
  return '[object ' + str + ']'
}

var CANVAS_CLASS = objectName('HTMLCanvasElement');
var OFFSCREENCANVAS_CLASS = objectName('OffscreenCanvas');
var CONTEXT2D_CLASS = objectName('CanvasRenderingContext2D');
var BITMAP_CLASS = objectName('ImageBitmap');
var IMAGE_CLASS = objectName('HTMLImageElement');
var VIDEO_CLASS = objectName('HTMLVideoElement');

var PIXEL_CLASSES = Object.keys(arrayTypes).concat([
  CANVAS_CLASS,
  OFFSCREENCANVAS_CLASS,
  CONTEXT2D_CLASS,
  BITMAP_CLASS,
  IMAGE_CLASS,
  VIDEO_CLASS
]);

// for every texture type, store
// the size in bytes.
var TYPE_SIZES = [];
TYPE_SIZES[GL_UNSIGNED_BYTE$5] = 1;
TYPE_SIZES[GL_FLOAT$4] = 4;
TYPE_SIZES[GL_HALF_FLOAT_OES$1] = 2;

TYPE_SIZES[GL_UNSIGNED_SHORT$3] = 2;
TYPE_SIZES[GL_UNSIGNED_INT$3] = 4;

var FORMAT_SIZES_SPECIAL = [];
FORMAT_SIZES_SPECIAL[GL_RGBA4] = 2;
FORMAT_SIZES_SPECIAL[GL_RGB5_A1] = 2;
FORMAT_SIZES_SPECIAL[GL_RGB565] = 2;
FORMAT_SIZES_SPECIAL[GL_DEPTH_STENCIL] = 4;

FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5;
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5;
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1;
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1;

FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ATC_WEBGL] = 0.5;
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1;
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1;

FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5;
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25;
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5;
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25;

FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ETC1_WEBGL] = 0.5;

function isNumericArray (arr) {
  return (
    Array.isArray(arr) &&
    (arr.length === 0 ||
    typeof arr[0] === 'number'))
}

function isRectArray (arr) {
  if (!Array.isArray(arr)) {
    return false
  }
  var width = arr.length;
  if (width === 0 || !isArrayLike(arr[0])) {
    return false
  }
  return true
}

function classString (x) {
  return Object.prototype.toString.call(x)
}

function isCanvasElement (object) {
  return classString(object) === CANVAS_CLASS
}

function isOffscreenCanvas (object) {
  return classString(object) === OFFSCREENCANVAS_CLASS
}

function isContext2D (object) {
  return classString(object) === CONTEXT2D_CLASS
}

function isBitmap (object) {
  return classString(object) === BITMAP_CLASS
}

function isImageElement (object) {
  return classString(object) === IMAGE_CLASS
}

function isVideoElement (object) {
  return classString(object) === VIDEO_CLASS
}

function isPixelData (object) {
  if (!object) {
    return false
  }
  var className = classString(object);
  if (PIXEL_CLASSES.indexOf(className) >= 0) {
    return true
  }
  return (
    isNumericArray(object) ||
    isRectArray(object) ||
    isNDArrayLike(object))
}

function typedArrayCode$1 (data) {
  return arrayTypes[Object.prototype.toString.call(data)] | 0
}

function convertData (result, data) {
  var n = data.length;
  switch (result.type) {
    case GL_UNSIGNED_BYTE$5:
    case GL_UNSIGNED_SHORT$3:
    case GL_UNSIGNED_INT$3:
    case GL_FLOAT$4:
      var converted = pool.allocType(result.type, n);
      converted.set(data);
      result.data = converted;
      break

    case GL_HALF_FLOAT_OES$1:
      result.data = convertToHalfFloat(data);
      break

    default:
      check$1.raise('unsupported texture type, must specify a typed array');
  }
}

function preConvert (image, n) {
  return pool.allocType(
    image.type === GL_HALF_FLOAT_OES$1
      ? GL_FLOAT$4
      : image.type, n)
}

function postConvert (image, data) {
  if (image.type === GL_HALF_FLOAT_OES$1) {
    image.data = convertToHalfFloat(data);
    pool.freeType(data);
  } else {
    image.data = data;
  }
}

function transposeData (image, array, strideX, strideY, strideC, offset) {
  var w = image.width;
  var h = image.height;
  var c = image.channels;
  var n = w * h * c;
  var data = preConvert(image, n);

  var p = 0;
  for (var i = 0; i < h; ++i) {
    for (var j = 0; j < w; ++j) {
      for (var k = 0; k < c; ++k) {
        data[p++] = array[strideX * j + strideY * i + strideC * k + offset];
      }
    }
  }

  postConvert(image, data);
}

function getTextureSize (format, type, width, height, isMipmap, isCube) {
  var s;
  if (typeof FORMAT_SIZES_SPECIAL[format] !== 'undefined') {
    // we have a special array for dealing with weird color formats such as RGB5A1
    s = FORMAT_SIZES_SPECIAL[format];
  } else {
    s = FORMAT_CHANNELS[format] * TYPE_SIZES[type];
  }

  if (isCube) {
    s *= 6;
  }

  if (isMipmap) {
    // compute the total size of all the mipmaps.
    var total = 0;

    var w = width;
    while (w >= 1) {
      // we can only use mipmaps on a square image,
      // so we can simply use the width and ignore the height:
      total += s * w * w;
      w /= 2;
    }
    return total
  } else {
    return s * width * height
  }
}

function createTextureSet (
  gl, extensions, limits, reglPoll, contextState, stats, config) {
  // -------------------------------------------------------
  // Initialize constants and parameter tables here
  // -------------------------------------------------------
  var mipmapHint = {
    "don't care": GL_DONT_CARE,
    'dont care': GL_DONT_CARE,
    'nice': GL_NICEST,
    'fast': GL_FASTEST
  };

  var wrapModes = {
    'repeat': GL_REPEAT,
    'clamp': GL_CLAMP_TO_EDGE$1,
    'mirror': GL_MIRRORED_REPEAT
  };

  var magFilters = {
    'nearest': GL_NEAREST$1,
    'linear': GL_LINEAR
  };

  var minFilters = extend({
    'mipmap': GL_LINEAR_MIPMAP_LINEAR$1,
    'nearest mipmap nearest': GL_NEAREST_MIPMAP_NEAREST$1,
    'linear mipmap nearest': GL_LINEAR_MIPMAP_NEAREST$1,
    'nearest mipmap linear': GL_NEAREST_MIPMAP_LINEAR$1,
    'linear mipmap linear': GL_LINEAR_MIPMAP_LINEAR$1
  }, magFilters);

  var colorSpace = {
    'none': 0,
    'browser': GL_BROWSER_DEFAULT_WEBGL
  };

  var textureTypes = {
    'uint8': GL_UNSIGNED_BYTE$5,
    'rgba4': GL_UNSIGNED_SHORT_4_4_4_4$1,
    'rgb565': GL_UNSIGNED_SHORT_5_6_5$1,
    'rgb5 a1': GL_UNSIGNED_SHORT_5_5_5_1$1
  };

  var textureFormats = {
    'alpha': GL_ALPHA,
    'luminance': GL_LUMINANCE,
    'luminance alpha': GL_LUMINANCE_ALPHA,
    'rgb': GL_RGB,
    'rgba': GL_RGBA$1,
    'rgba4': GL_RGBA4,
    'rgb5 a1': GL_RGB5_A1,
    'rgb565': GL_RGB565
  };

  var compressedTextureFormats = {};

  if (extensions.ext_srgb) {
    textureFormats.srgb = GL_SRGB_EXT;
    textureFormats.srgba = GL_SRGB_ALPHA_EXT;
  }

  if (extensions.oes_texture_float) {
    textureTypes.float32 = textureTypes.float = GL_FLOAT$4;
  }

  if (extensions.oes_texture_half_float) {
    textureTypes['float16'] = textureTypes['half float'] = GL_HALF_FLOAT_OES$1;
  }

  if (extensions.webgl_depth_texture) {
    extend(textureFormats, {
      'depth': GL_DEPTH_COMPONENT,
      'depth stencil': GL_DEPTH_STENCIL
    });

    extend(textureTypes, {
      'uint16': GL_UNSIGNED_SHORT$3,
      'uint32': GL_UNSIGNED_INT$3,
      'depth stencil': GL_UNSIGNED_INT_24_8_WEBGL$1
    });
  }

  if (extensions.webgl_compressed_texture_s3tc) {
    extend(compressedTextureFormats, {
      'rgb s3tc dxt1': GL_COMPRESSED_RGB_S3TC_DXT1_EXT,
      'rgba s3tc dxt1': GL_COMPRESSED_RGBA_S3TC_DXT1_EXT,
      'rgba s3tc dxt3': GL_COMPRESSED_RGBA_S3TC_DXT3_EXT,
      'rgba s3tc dxt5': GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
    });
  }

  if (extensions.webgl_compressed_texture_atc) {
    extend(compressedTextureFormats, {
      'rgb atc': GL_COMPRESSED_RGB_ATC_WEBGL,
      'rgba atc explicit alpha': GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL,
      'rgba atc interpolated alpha': GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL
    });
  }

  if (extensions.webgl_compressed_texture_pvrtc) {
    extend(compressedTextureFormats, {
      'rgb pvrtc 4bppv1': GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG,
      'rgb pvrtc 2bppv1': GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG,
      'rgba pvrtc 4bppv1': GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,
      'rgba pvrtc 2bppv1': GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
    });
  }

  if (extensions.webgl_compressed_texture_etc1) {
    compressedTextureFormats['rgb etc1'] = GL_COMPRESSED_RGB_ETC1_WEBGL;
  }

  // Copy over all texture formats
  var supportedCompressedFormats = Array.prototype.slice.call(
    gl.getParameter(GL_COMPRESSED_TEXTURE_FORMATS));
  Object.keys(compressedTextureFormats).forEach(function (name) {
    var format = compressedTextureFormats[name];
    if (supportedCompressedFormats.indexOf(format) >= 0) {
      textureFormats[name] = format;
    }
  });

  var supportedFormats = Object.keys(textureFormats);
  limits.textureFormats = supportedFormats;

  // associate with every format string its
  // corresponding GL-value.
  var textureFormatsInvert = [];
  Object.keys(textureFormats).forEach(function (key) {
    var val = textureFormats[key];
    textureFormatsInvert[val] = key;
  });

  // associate with every type string its
  // corresponding GL-value.
  var textureTypesInvert = [];
  Object.keys(textureTypes).forEach(function (key) {
    var val = textureTypes[key];
    textureTypesInvert[val] = key;
  });

  var magFiltersInvert = [];
  Object.keys(magFilters).forEach(function (key) {
    var val = magFilters[key];
    magFiltersInvert[val] = key;
  });

  var minFiltersInvert = [];
  Object.keys(minFilters).forEach(function (key) {
    var val = minFilters[key];
    minFiltersInvert[val] = key;
  });

  var wrapModesInvert = [];
  Object.keys(wrapModes).forEach(function (key) {
    var val = wrapModes[key];
    wrapModesInvert[val] = key;
  });

  // colorFormats[] gives the format (channels) associated to an
  // internalformat
  var colorFormats = supportedFormats.reduce(function (color, key) {
    var glenum = textureFormats[key];
    if (glenum === GL_LUMINANCE ||
        glenum === GL_ALPHA ||
        glenum === GL_LUMINANCE ||
        glenum === GL_LUMINANCE_ALPHA ||
        glenum === GL_DEPTH_COMPONENT ||
        glenum === GL_DEPTH_STENCIL ||
        (extensions.ext_srgb &&
                (glenum === GL_SRGB_EXT ||
                 glenum === GL_SRGB_ALPHA_EXT))) {
      color[glenum] = glenum;
    } else if (glenum === GL_RGB5_A1 || key.indexOf('rgba') >= 0) {
      color[glenum] = GL_RGBA$1;
    } else {
      color[glenum] = GL_RGB;
    }
    return color
  }, {});

  function TexFlags () {
    // format info
    this.internalformat = GL_RGBA$1;
    this.format = GL_RGBA$1;
    this.type = GL_UNSIGNED_BYTE$5;
    this.compressed = false;

    // pixel storage
    this.premultiplyAlpha = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.colorSpace = GL_BROWSER_DEFAULT_WEBGL;

    // shape info
    this.width = 0;
    this.height = 0;
    this.channels = 0;
  }

  function copyFlags (result, other) {
    result.internalformat = other.internalformat;
    result.format = other.format;
    result.type = other.type;
    result.compressed = other.compressed;

    result.premultiplyAlpha = other.premultiplyAlpha;
    result.flipY = other.flipY;
    result.unpackAlignment = other.unpackAlignment;
    result.colorSpace = other.colorSpace;

    result.width = other.width;
    result.height = other.height;
    result.channels = other.channels;
  }

  function parseFlags (flags, options) {
    if (typeof options !== 'object' || !options) {
      return
    }

    if ('premultiplyAlpha' in options) {
      check$1.type(options.premultiplyAlpha, 'boolean',
        'invalid premultiplyAlpha');
      flags.premultiplyAlpha = options.premultiplyAlpha;
    }

    if ('flipY' in options) {
      check$1.type(options.flipY, 'boolean',
        'invalid texture flip');
      flags.flipY = options.flipY;
    }

    if ('alignment' in options) {
      check$1.oneOf(options.alignment, [1, 2, 4, 8],
        'invalid texture unpack alignment');
      flags.unpackAlignment = options.alignment;
    }

    if ('colorSpace' in options) {
      check$1.parameter(options.colorSpace, colorSpace,
        'invalid colorSpace');
      flags.colorSpace = colorSpace[options.colorSpace];
    }

    if ('type' in options) {
      var type = options.type;
      check$1(extensions.oes_texture_float ||
        !(type === 'float' || type === 'float32'),
      'you must enable the OES_texture_float extension in order to use floating point textures.');
      check$1(extensions.oes_texture_half_float ||
        !(type === 'half float' || type === 'float16'),
      'you must enable the OES_texture_half_float extension in order to use 16-bit floating point textures.');
      check$1(extensions.webgl_depth_texture ||
        !(type === 'uint16' || type === 'uint32' || type === 'depth stencil'),
      'you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures.');
      check$1.parameter(type, textureTypes,
        'invalid texture type');
      flags.type = textureTypes[type];
    }

    var w = flags.width;
    var h = flags.height;
    var c = flags.channels;
    var hasChannels = false;
    if ('shape' in options) {
      check$1(Array.isArray(options.shape) && options.shape.length >= 2,
        'shape must be an array');
      w = options.shape[0];
      h = options.shape[1];
      if (options.shape.length === 3) {
        c = options.shape[2];
        check$1(c > 0 && c <= 4, 'invalid number of channels');
        hasChannels = true;
      }
      check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid width');
      check$1(h >= 0 && h <= limits.maxTextureSize, 'invalid height');
    } else {
      if ('radius' in options) {
        w = h = options.radius;
        check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid radius');
      }
      if ('width' in options) {
        w = options.width;
        check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid width');
      }
      if ('height' in options) {
        h = options.height;
        check$1(h >= 0 && h <= limits.maxTextureSize, 'invalid height');
      }
      if ('channels' in options) {
        c = options.channels;
        check$1(c > 0 && c <= 4, 'invalid number of channels');
        hasChannels = true;
      }
    }
    flags.width = w | 0;
    flags.height = h | 0;
    flags.channels = c | 0;

    var hasFormat = false;
    if ('format' in options) {
      var formatStr = options.format;
      check$1(extensions.webgl_depth_texture ||
        !(formatStr === 'depth' || formatStr === 'depth stencil'),
      'you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures.');
      check$1.parameter(formatStr, textureFormats,
        'invalid texture format');
      var internalformat = flags.internalformat = textureFormats[formatStr];
      flags.format = colorFormats[internalformat];
      if (formatStr in textureTypes) {
        if (!('type' in options)) {
          flags.type = textureTypes[formatStr];
        }
      }
      if (formatStr in compressedTextureFormats) {
        flags.compressed = true;
      }
      hasFormat = true;
    }

    // Reconcile channels and format
    if (!hasChannels && hasFormat) {
      flags.channels = FORMAT_CHANNELS[flags.format];
    } else if (hasChannels && !hasFormat) {
      if (flags.channels !== CHANNELS_FORMAT[flags.format]) {
        flags.format = flags.internalformat = CHANNELS_FORMAT[flags.channels];
      }
    } else if (hasFormat && hasChannels) {
      check$1(
        flags.channels === FORMAT_CHANNELS[flags.format],
        'number of channels inconsistent with specified format');
    }
  }

  function setFlags (flags) {
    gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, flags.flipY);
    gl.pixelStorei(GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, flags.premultiplyAlpha);
    gl.pixelStorei(GL_UNPACK_COLORSPACE_CONVERSION_WEBGL, flags.colorSpace);
    gl.pixelStorei(GL_UNPACK_ALIGNMENT, flags.unpackAlignment);
  }

  // -------------------------------------------------------
  // Tex image data
  // -------------------------------------------------------
  function TexImage () {
    TexFlags.call(this);

    this.xOffset = 0;
    this.yOffset = 0;

    // data
    this.data = null;
    this.needsFree = false;

    // html element
    this.element = null;

    // copyTexImage info
    this.needsCopy = false;
  }

  function parseImage (image, options) {
    var data = null;
    if (isPixelData(options)) {
      data = options;
    } else if (options) {
      check$1.type(options, 'object', 'invalid pixel data type');
      parseFlags(image, options);
      if ('x' in options) {
        image.xOffset = options.x | 0;
      }
      if ('y' in options) {
        image.yOffset = options.y | 0;
      }
      if (isPixelData(options.data)) {
        data = options.data;
      }
    }

    check$1(
      !image.compressed ||
      data instanceof Uint8Array,
      'compressed texture data must be stored in a uint8array');

    if (options.copy) {
      check$1(!data, 'can not specify copy and data field for the same texture');
      var viewW = contextState.viewportWidth;
      var viewH = contextState.viewportHeight;
      image.width = image.width || (viewW - image.xOffset);
      image.height = image.height || (viewH - image.yOffset);
      image.needsCopy = true;
      check$1(image.xOffset >= 0 && image.xOffset < viewW &&
            image.yOffset >= 0 && image.yOffset < viewH &&
            image.width > 0 && image.width <= viewW &&
            image.height > 0 && image.height <= viewH,
      'copy texture read out of bounds');
    } else if (!data) {
      image.width = image.width || 1;
      image.height = image.height || 1;
      image.channels = image.channels || 4;
    } else if (isTypedArray(data)) {
      image.channels = image.channels || 4;
      image.data = data;
      if (!('type' in options) && image.type === GL_UNSIGNED_BYTE$5) {
        image.type = typedArrayCode$1(data);
      }
    } else if (isNumericArray(data)) {
      image.channels = image.channels || 4;
      convertData(image, data);
      image.alignment = 1;
      image.needsFree = true;
    } else if (isNDArrayLike(data)) {
      var array = data.data;
      if (!Array.isArray(array) && image.type === GL_UNSIGNED_BYTE$5) {
        image.type = typedArrayCode$1(array);
      }
      var shape = data.shape;
      var stride = data.stride;
      var shapeX, shapeY, shapeC, strideX, strideY, strideC;
      if (shape.length === 3) {
        shapeC = shape[2];
        strideC = stride[2];
      } else {
        check$1(shape.length === 2, 'invalid ndarray pixel data, must be 2 or 3D');
        shapeC = 1;
        strideC = 1;
      }
      shapeX = shape[0];
      shapeY = shape[1];
      strideX = stride[0];
      strideY = stride[1];
      image.alignment = 1;
      image.width = shapeX;
      image.height = shapeY;
      image.channels = shapeC;
      image.format = image.internalformat = CHANNELS_FORMAT[shapeC];
      image.needsFree = true;
      transposeData(image, array, strideX, strideY, strideC, data.offset);
    } else if (isCanvasElement(data) || isOffscreenCanvas(data) || isContext2D(data)) {
      if (isCanvasElement(data) || isOffscreenCanvas(data)) {
        image.element = data;
      } else {
        image.element = data.canvas;
      }
      image.width = image.element.width;
      image.height = image.element.height;
      image.channels = 4;
    } else if (isBitmap(data)) {
      image.element = data;
      image.width = data.width;
      image.height = data.height;
      image.channels = 4;
    } else if (isImageElement(data)) {
      image.element = data;
      image.width = data.naturalWidth;
      image.height = data.naturalHeight;
      image.channels = 4;
    } else if (isVideoElement(data)) {
      image.element = data;
      image.width = data.videoWidth;
      image.height = data.videoHeight;
      image.channels = 4;
    } else if (isRectArray(data)) {
      var w = image.width || data[0].length;
      var h = image.height || data.length;
      var c = image.channels;
      if (isArrayLike(data[0][0])) {
        c = c || data[0][0].length;
      } else {
        c = c || 1;
      }
      var arrayShape = flattenUtils.shape(data);
      var n = 1;
      for (var dd = 0; dd < arrayShape.length; ++dd) {
        n *= arrayShape[dd];
      }
      var allocData = preConvert(image, n);
      flattenUtils.flatten(data, arrayShape, '', allocData);
      postConvert(image, allocData);
      image.alignment = 1;
      image.width = w;
      image.height = h;
      image.channels = c;
      image.format = image.internalformat = CHANNELS_FORMAT[c];
      image.needsFree = true;
    }

    if (image.type === GL_FLOAT$4) {
      check$1(limits.extensions.indexOf('oes_texture_float') >= 0,
        'oes_texture_float extension not enabled');
    } else if (image.type === GL_HALF_FLOAT_OES$1) {
      check$1(limits.extensions.indexOf('oes_texture_half_float') >= 0,
        'oes_texture_half_float extension not enabled');
    }

    // do compressed texture  validation here.
  }

  function setImage (info, target, miplevel) {
    var element = info.element;
    var data = info.data;
    var internalformat = info.internalformat;
    var format = info.format;
    var type = info.type;
    var width = info.width;
    var height = info.height;

    setFlags(info);

    if (element) {
      gl.texImage2D(target, miplevel, format, format, type, element);
    } else if (info.compressed) {
      gl.compressedTexImage2D(target, miplevel, internalformat, width, height, 0, data);
    } else if (info.needsCopy) {
      reglPoll();
      gl.copyTexImage2D(
        target, miplevel, format, info.xOffset, info.yOffset, width, height, 0);
    } else {
      gl.texImage2D(target, miplevel, format, width, height, 0, format, type, data || null);
    }
  }

  function setSubImage (info, target, x, y, miplevel) {
    var element = info.element;
    var data = info.data;
    var internalformat = info.internalformat;
    var format = info.format;
    var type = info.type;
    var width = info.width;
    var height = info.height;

    setFlags(info);

    if (element) {
      gl.texSubImage2D(
        target, miplevel, x, y, format, type, element);
    } else if (info.compressed) {
      gl.compressedTexSubImage2D(
        target, miplevel, x, y, internalformat, width, height, data);
    } else if (info.needsCopy) {
      reglPoll();
      gl.copyTexSubImage2D(
        target, miplevel, x, y, info.xOffset, info.yOffset, width, height);
    } else {
      gl.texSubImage2D(
        target, miplevel, x, y, width, height, format, type, data);
    }
  }

  // texImage pool
  var imagePool = [];

  function allocImage () {
    return imagePool.pop() || new TexImage()
  }

  function freeImage (image) {
    if (image.needsFree) {
      pool.freeType(image.data);
    }
    TexImage.call(image);
    imagePool.push(image);
  }

  // -------------------------------------------------------
  // Mip map
  // -------------------------------------------------------
  function MipMap () {
    TexFlags.call(this);

    this.genMipmaps = false;
    this.mipmapHint = GL_DONT_CARE;
    this.mipmask = 0;
    this.images = Array(16);
  }

  function parseMipMapFromShape (mipmap, width, height) {
    var img = mipmap.images[0] = allocImage();
    mipmap.mipmask = 1;
    img.width = mipmap.width = width;
    img.height = mipmap.height = height;
    img.channels = mipmap.channels = 4;
  }

  function parseMipMapFromObject (mipmap, options) {
    var imgData = null;
    if (isPixelData(options)) {
      imgData = mipmap.images[0] = allocImage();
      copyFlags(imgData, mipmap);
      parseImage(imgData, options);
      mipmap.mipmask = 1;
    } else {
      parseFlags(mipmap, options);
      if (Array.isArray(options.mipmap)) {
        var mipData = options.mipmap;
        for (var i = 0; i < mipData.length; ++i) {
          imgData = mipmap.images[i] = allocImage();
          copyFlags(imgData, mipmap);
          imgData.width >>= i;
          imgData.height >>= i;
          parseImage(imgData, mipData[i]);
          mipmap.mipmask |= (1 << i);
        }
      } else {
        imgData = mipmap.images[0] = allocImage();
        copyFlags(imgData, mipmap);
        parseImage(imgData, options);
        mipmap.mipmask = 1;
      }
    }
    copyFlags(mipmap, mipmap.images[0]);

    // For textures of the compressed format WEBGL_compressed_texture_s3tc
    // we must have that
    //
    // "When level equals zero width and height must be a multiple of 4.
    // When level is greater than 0 width and height must be 0, 1, 2 or a multiple of 4. "
    //
    // but we do not yet support having multiple mipmap levels for compressed textures,
    // so we only test for level zero.

    if (
      mipmap.compressed &&
      (
        mipmap.internalformat === GL_COMPRESSED_RGB_S3TC_DXT1_EXT ||
        mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT1_EXT ||
        mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT3_EXT ||
        mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
      )
    ) {
      check$1(mipmap.width % 4 === 0 && mipmap.height % 4 === 0,
        'for compressed texture formats, mipmap level 0 must have width and height that are a multiple of 4');
    }
  }

  function setMipMap (mipmap, target) {
    var images = mipmap.images;
    for (var i = 0; i < images.length; ++i) {
      if (!images[i]) {
        return
      }
      setImage(images[i], target, i);
    }
  }

  var mipPool = [];

  function allocMipMap () {
    var result = mipPool.pop() || new MipMap();
    TexFlags.call(result);
    result.mipmask = 0;
    for (var i = 0; i < 16; ++i) {
      result.images[i] = null;
    }
    return result
  }

  function freeMipMap (mipmap) {
    var images = mipmap.images;
    for (var i = 0; i < images.length; ++i) {
      if (images[i]) {
        freeImage(images[i]);
      }
      images[i] = null;
    }
    mipPool.push(mipmap);
  }

  // -------------------------------------------------------
  // Tex info
  // -------------------------------------------------------
  function TexInfo () {
    this.minFilter = GL_NEAREST$1;
    this.magFilter = GL_NEAREST$1;

    this.wrapS = GL_CLAMP_TO_EDGE$1;
    this.wrapT = GL_CLAMP_TO_EDGE$1;

    this.anisotropic = 1;

    this.genMipmaps = false;
    this.mipmapHint = GL_DONT_CARE;
  }

  function parseTexInfo (info, options) {
    if ('min' in options) {
      var minFilter = options.min;
      check$1.parameter(minFilter, minFilters);
      info.minFilter = minFilters[minFilter];
      if (MIPMAP_FILTERS.indexOf(info.minFilter) >= 0 && !('faces' in options)) {
        info.genMipmaps = true;
      }
    }

    if ('mag' in options) {
      var magFilter = options.mag;
      check$1.parameter(magFilter, magFilters);
      info.magFilter = magFilters[magFilter];
    }

    var wrapS = info.wrapS;
    var wrapT = info.wrapT;
    if ('wrap' in options) {
      var wrap = options.wrap;
      if (typeof wrap === 'string') {
        check$1.parameter(wrap, wrapModes);
        wrapS = wrapT = wrapModes[wrap];
      } else if (Array.isArray(wrap)) {
        check$1.parameter(wrap[0], wrapModes);
        check$1.parameter(wrap[1], wrapModes);
        wrapS = wrapModes[wrap[0]];
        wrapT = wrapModes[wrap[1]];
      }
    } else {
      if ('wrapS' in options) {
        var optWrapS = options.wrapS;
        check$1.parameter(optWrapS, wrapModes);
        wrapS = wrapModes[optWrapS];
      }
      if ('wrapT' in options) {
        var optWrapT = options.wrapT;
        check$1.parameter(optWrapT, wrapModes);
        wrapT = wrapModes[optWrapT];
      }
    }
    info.wrapS = wrapS;
    info.wrapT = wrapT;

    if ('anisotropic' in options) {
      var anisotropic = options.anisotropic;
      check$1(typeof anisotropic === 'number' &&
         anisotropic >= 1 && anisotropic <= limits.maxAnisotropic,
      'aniso samples must be between 1 and ');
      info.anisotropic = options.anisotropic;
    }

    if ('mipmap' in options) {
      var hasMipMap = false;
      switch (typeof options.mipmap) {
        case 'string':
          check$1.parameter(options.mipmap, mipmapHint,
            'invalid mipmap hint');
          info.mipmapHint = mipmapHint[options.mipmap];
          info.genMipmaps = true;
          hasMipMap = true;
          break

        case 'boolean':
          hasMipMap = info.genMipmaps = options.mipmap;
          break

        case 'object':
          check$1(Array.isArray(options.mipmap), 'invalid mipmap type');
          info.genMipmaps = false;
          hasMipMap = true;
          break

        default:
          check$1.raise('invalid mipmap type');
      }
      if (hasMipMap && !('min' in options)) {
        info.minFilter = GL_NEAREST_MIPMAP_NEAREST$1;
      }
    }
  }

  function setTexInfo (info, target) {
    gl.texParameteri(target, GL_TEXTURE_MIN_FILTER, info.minFilter);
    gl.texParameteri(target, GL_TEXTURE_MAG_FILTER, info.magFilter);
    gl.texParameteri(target, GL_TEXTURE_WRAP_S, info.wrapS);
    gl.texParameteri(target, GL_TEXTURE_WRAP_T, info.wrapT);
    if (extensions.ext_texture_filter_anisotropic) {
      gl.texParameteri(target, GL_TEXTURE_MAX_ANISOTROPY_EXT, info.anisotropic);
    }
    if (info.genMipmaps) {
      gl.hint(GL_GENERATE_MIPMAP_HINT, info.mipmapHint);
      gl.generateMipmap(target);
    }
  }

  // -------------------------------------------------------
  // Full texture object
  // -------------------------------------------------------
  var textureCount = 0;
  var textureSet = {};
  var numTexUnits = limits.maxTextureUnits;
  var textureUnits = Array(numTexUnits).map(function () {
    return null
  });

  function REGLTexture (target) {
    TexFlags.call(this);
    this.mipmask = 0;
    this.internalformat = GL_RGBA$1;

    this.id = textureCount++;

    this.refCount = 1;

    this.target = target;
    this.texture = gl.createTexture();

    this.unit = -1;
    this.bindCount = 0;

    this.texInfo = new TexInfo();

    if (config.profile) {
      this.stats = { size: 0 };
    }
  }

  function tempBind (texture) {
    gl.activeTexture(GL_TEXTURE0$1);
    gl.bindTexture(texture.target, texture.texture);
  }

  function tempRestore () {
    var prev = textureUnits[0];
    if (prev) {
      gl.bindTexture(prev.target, prev.texture);
    } else {
      gl.bindTexture(GL_TEXTURE_2D$1, null);
    }
  }

  function destroy (texture) {
    var handle = texture.texture;
    check$1(handle, 'must not double destroy texture');
    var unit = texture.unit;
    var target = texture.target;
    if (unit >= 0) {
      gl.activeTexture(GL_TEXTURE0$1 + unit);
      gl.bindTexture(target, null);
      textureUnits[unit] = null;
    }
    gl.deleteTexture(handle);
    texture.texture = null;
    texture.params = null;
    texture.pixels = null;
    texture.refCount = 0;
    delete textureSet[texture.id];
    stats.textureCount--;
  }

  extend(REGLTexture.prototype, {
    bind: function () {
      var texture = this;
      texture.bindCount += 1;
      var unit = texture.unit;
      if (unit < 0) {
        for (var i = 0; i < numTexUnits; ++i) {
          var other = textureUnits[i];
          if (other) {
            if (other.bindCount > 0) {
              continue
            }
            other.unit = -1;
          }
          textureUnits[i] = texture;
          unit = i;
          break
        }
        if (unit >= numTexUnits) {
          check$1.raise('insufficient number of texture units');
        }
        if (config.profile && stats.maxTextureUnits < (unit + 1)) {
          stats.maxTextureUnits = unit + 1; // +1, since the units are zero-based
        }
        texture.unit = unit;
        gl.activeTexture(GL_TEXTURE0$1 + unit);
        gl.bindTexture(texture.target, texture.texture);
      }
      return unit
    },

    unbind: function () {
      this.bindCount -= 1;
    },

    decRef: function () {
      if (--this.refCount <= 0) {
        destroy(this);
      }
    }
  });

  function createTexture2D (a, b) {
    var texture = new REGLTexture(GL_TEXTURE_2D$1);
    textureSet[texture.id] = texture;
    stats.textureCount++;

    function reglTexture2D (a, b) {
      var texInfo = texture.texInfo;
      TexInfo.call(texInfo);
      var mipData = allocMipMap();

      if (typeof a === 'number') {
        if (typeof b === 'number') {
          parseMipMapFromShape(mipData, a | 0, b | 0);
        } else {
          parseMipMapFromShape(mipData, a | 0, a | 0);
        }
      } else if (a) {
        check$1.type(a, 'object', 'invalid arguments to regl.texture');
        parseTexInfo(texInfo, a);
        parseMipMapFromObject(mipData, a);
      } else {
        // empty textures get assigned a default shape of 1x1
        parseMipMapFromShape(mipData, 1, 1);
      }

      if (texInfo.genMipmaps) {
        mipData.mipmask = (mipData.width << 1) - 1;
      }
      texture.mipmask = mipData.mipmask;

      copyFlags(texture, mipData);

      check$1.texture2D(texInfo, mipData, limits);
      texture.internalformat = mipData.internalformat;

      reglTexture2D.width = mipData.width;
      reglTexture2D.height = mipData.height;

      tempBind(texture);
      setMipMap(mipData, GL_TEXTURE_2D$1);
      setTexInfo(texInfo, GL_TEXTURE_2D$1);
      tempRestore();

      freeMipMap(mipData);

      if (config.profile) {
        texture.stats.size = getTextureSize(
          texture.internalformat,
          texture.type,
          mipData.width,
          mipData.height,
          texInfo.genMipmaps,
          false);
      }
      reglTexture2D.format = textureFormatsInvert[texture.internalformat];
      reglTexture2D.type = textureTypesInvert[texture.type];

      reglTexture2D.mag = magFiltersInvert[texInfo.magFilter];
      reglTexture2D.min = minFiltersInvert[texInfo.minFilter];

      reglTexture2D.wrapS = wrapModesInvert[texInfo.wrapS];
      reglTexture2D.wrapT = wrapModesInvert[texInfo.wrapT];

      return reglTexture2D
    }

    function subimage (image, x_, y_, level_) {
      check$1(!!image, 'must specify image data');

      var x = x_ | 0;
      var y = y_ | 0;
      var level = level_ | 0;

      var imageData = allocImage();
      copyFlags(imageData, texture);
      imageData.width = 0;
      imageData.height = 0;
      parseImage(imageData, image);
      imageData.width = imageData.width || ((texture.width >> level) - x);
      imageData.height = imageData.height || ((texture.height >> level) - y);

      check$1(
        texture.type === imageData.type &&
        texture.format === imageData.format &&
        texture.internalformat === imageData.internalformat,
        'incompatible format for texture.subimage');
      check$1(
        x >= 0 && y >= 0 &&
        x + imageData.width <= texture.width &&
        y + imageData.height <= texture.height,
        'texture.subimage write out of bounds');
      check$1(
        texture.mipmask & (1 << level),
        'missing mipmap data');
      check$1(
        imageData.data || imageData.element || imageData.needsCopy,
        'missing image data');

      tempBind(texture);
      setSubImage(imageData, GL_TEXTURE_2D$1, x, y, level);
      tempRestore();

      freeImage(imageData);

      return reglTexture2D
    }

    function resize (w_, h_) {
      var w = w_ | 0;
      var h = (h_ | 0) || w;
      if (w === texture.width && h === texture.height) {
        return reglTexture2D
      }

      reglTexture2D.width = texture.width = w;
      reglTexture2D.height = texture.height = h;

      tempBind(texture);

      for (var i = 0; texture.mipmask >> i; ++i) {
        var _w = w >> i;
        var _h = h >> i;
        if (!_w || !_h) break
        gl.texImage2D(
          GL_TEXTURE_2D$1,
          i,
          texture.format,
          _w,
          _h,
          0,
          texture.format,
          texture.type,
          null);
      }
      tempRestore();

      // also, recompute the texture size.
      if (config.profile) {
        texture.stats.size = getTextureSize(
          texture.internalformat,
          texture.type,
          w,
          h,
          false,
          false);
      }

      return reglTexture2D
    }

    reglTexture2D(a, b);

    reglTexture2D.subimage = subimage;
    reglTexture2D.resize = resize;
    reglTexture2D._reglType = 'texture2d';
    reglTexture2D._texture = texture;
    if (config.profile) {
      reglTexture2D.stats = texture.stats;
    }
    reglTexture2D.destroy = function () {
      texture.decRef();
    };

    return reglTexture2D
  }

  function createTextureCube (a0, a1, a2, a3, a4, a5) {
    var texture = new REGLTexture(GL_TEXTURE_CUBE_MAP$1);
    textureSet[texture.id] = texture;
    stats.cubeCount++;

    var faces = new Array(6);

    function reglTextureCube (a0, a1, a2, a3, a4, a5) {
      var i;
      var texInfo = texture.texInfo;
      TexInfo.call(texInfo);
      for (i = 0; i < 6; ++i) {
        faces[i] = allocMipMap();
      }

      if (typeof a0 === 'number' || !a0) {
        var s = (a0 | 0) || 1;
        for (i = 0; i < 6; ++i) {
          parseMipMapFromShape(faces[i], s, s);
        }
      } else if (typeof a0 === 'object') {
        if (a1) {
          parseMipMapFromObject(faces[0], a0);
          parseMipMapFromObject(faces[1], a1);
          parseMipMapFromObject(faces[2], a2);
          parseMipMapFromObject(faces[3], a3);
          parseMipMapFromObject(faces[4], a4);
          parseMipMapFromObject(faces[5], a5);
        } else {
          parseTexInfo(texInfo, a0);
          parseFlags(texture, a0);
          if ('faces' in a0) {
            var faceInput = a0.faces;
            check$1(Array.isArray(faceInput) && faceInput.length === 6,
              'cube faces must be a length 6 array');
            for (i = 0; i < 6; ++i) {
              check$1(typeof faceInput[i] === 'object' && !!faceInput[i],
                'invalid input for cube map face');
              copyFlags(faces[i], texture);
              parseMipMapFromObject(faces[i], faceInput[i]);
            }
          } else {
            for (i = 0; i < 6; ++i) {
              parseMipMapFromObject(faces[i], a0);
            }
          }
        }
      } else {
        check$1.raise('invalid arguments to cube map');
      }

      copyFlags(texture, faces[0]);
      check$1.optional(function () {
        if (!limits.npotTextureCube) {
          check$1(isPow2$1(texture.width) && isPow2$1(texture.height), 'your browser does not support non power or two texture dimensions');
        }
      });

      if (texInfo.genMipmaps) {
        texture.mipmask = (faces[0].width << 1) - 1;
      } else {
        texture.mipmask = faces[0].mipmask;
      }

      check$1.textureCube(texture, texInfo, faces, limits);
      texture.internalformat = faces[0].internalformat;

      reglTextureCube.width = faces[0].width;
      reglTextureCube.height = faces[0].height;

      tempBind(texture);
      for (i = 0; i < 6; ++i) {
        setMipMap(faces[i], GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + i);
      }
      setTexInfo(texInfo, GL_TEXTURE_CUBE_MAP$1);
      tempRestore();

      if (config.profile) {
        texture.stats.size = getTextureSize(
          texture.internalformat,
          texture.type,
          reglTextureCube.width,
          reglTextureCube.height,
          texInfo.genMipmaps,
          true);
      }

      reglTextureCube.format = textureFormatsInvert[texture.internalformat];
      reglTextureCube.type = textureTypesInvert[texture.type];

      reglTextureCube.mag = magFiltersInvert[texInfo.magFilter];
      reglTextureCube.min = minFiltersInvert[texInfo.minFilter];

      reglTextureCube.wrapS = wrapModesInvert[texInfo.wrapS];
      reglTextureCube.wrapT = wrapModesInvert[texInfo.wrapT];

      for (i = 0; i < 6; ++i) {
        freeMipMap(faces[i]);
      }

      return reglTextureCube
    }

    function subimage (face, image, x_, y_, level_) {
      check$1(!!image, 'must specify image data');
      check$1(typeof face === 'number' && face === (face | 0) &&
        face >= 0 && face < 6, 'invalid face');

      var x = x_ | 0;
      var y = y_ | 0;
      var level = level_ | 0;

      var imageData = allocImage();
      copyFlags(imageData, texture);
      imageData.width = 0;
      imageData.height = 0;
      parseImage(imageData, image);
      imageData.width = imageData.width || ((texture.width >> level) - x);
      imageData.height = imageData.height || ((texture.height >> level) - y);

      check$1(
        texture.type === imageData.type &&
        texture.format === imageData.format &&
        texture.internalformat === imageData.internalformat,
        'incompatible format for texture.subimage');
      check$1(
        x >= 0 && y >= 0 &&
        x + imageData.width <= texture.width &&
        y + imageData.height <= texture.height,
        'texture.subimage write out of bounds');
      check$1(
        texture.mipmask & (1 << level),
        'missing mipmap data');
      check$1(
        imageData.data || imageData.element || imageData.needsCopy,
        'missing image data');

      tempBind(texture);
      setSubImage(imageData, GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + face, x, y, level);
      tempRestore();

      freeImage(imageData);

      return reglTextureCube
    }

    function resize (radius_) {
      var radius = radius_ | 0;
      if (radius === texture.width) {
        return
      }

      reglTextureCube.width = texture.width = radius;
      reglTextureCube.height = texture.height = radius;

      tempBind(texture);
      for (var i = 0; i < 6; ++i) {
        for (var j = 0; texture.mipmask >> j; ++j) {
          gl.texImage2D(
            GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + i,
            j,
            texture.format,
            radius >> j,
            radius >> j,
            0,
            texture.format,
            texture.type,
            null);
        }
      }
      tempRestore();

      if (config.profile) {
        texture.stats.size = getTextureSize(
          texture.internalformat,
          texture.type,
          reglTextureCube.width,
          reglTextureCube.height,
          false,
          true);
      }

      return reglTextureCube
    }

    reglTextureCube(a0, a1, a2, a3, a4, a5);

    reglTextureCube.subimage = subimage;
    reglTextureCube.resize = resize;
    reglTextureCube._reglType = 'textureCube';
    reglTextureCube._texture = texture;
    if (config.profile) {
      reglTextureCube.stats = texture.stats;
    }
    reglTextureCube.destroy = function () {
      texture.decRef();
    };

    return reglTextureCube
  }

  // Called when regl is destroyed
  function destroyTextures () {
    for (var i = 0; i < numTexUnits; ++i) {
      gl.activeTexture(GL_TEXTURE0$1 + i);
      gl.bindTexture(GL_TEXTURE_2D$1, null);
      textureUnits[i] = null;
    }
    values(textureSet).forEach(destroy);

    stats.cubeCount = 0;
    stats.textureCount = 0;
  }

  if (config.profile) {
    stats.getTotalTextureSize = function () {
      var total = 0;
      Object.keys(textureSet).forEach(function (key) {
        total += textureSet[key].stats.size;
      });
      return total
    };
  }

  function restoreTextures () {
    for (var i = 0; i < numTexUnits; ++i) {
      var tex = textureUnits[i];
      if (tex) {
        tex.bindCount = 0;
        tex.unit = -1;
        textureUnits[i] = null;
      }
    }

    values(textureSet).forEach(function (texture) {
      texture.texture = gl.createTexture();
      gl.bindTexture(texture.target, texture.texture);
      for (var i = 0; i < 32; ++i) {
        if ((texture.mipmask & (1 << i)) === 0) {
          continue
        }
        if (texture.target === GL_TEXTURE_2D$1) {
          gl.texImage2D(GL_TEXTURE_2D$1,
            i,
            texture.internalformat,
            texture.width >> i,
            texture.height >> i,
            0,
            texture.internalformat,
            texture.type,
            null);
        } else {
          for (var j = 0; j < 6; ++j) {
            gl.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + j,
              i,
              texture.internalformat,
              texture.width >> i,
              texture.height >> i,
              0,
              texture.internalformat,
              texture.type,
              null);
          }
        }
      }
      setTexInfo(texture.texInfo, texture.target);
    });
  }

  function refreshTextures () {
    for (var i = 0; i < numTexUnits; ++i) {
      var tex = textureUnits[i];
      if (tex) {
        tex.bindCount = 0;
        tex.unit = -1;
        textureUnits[i] = null;
      }
      gl.activeTexture(GL_TEXTURE0$1 + i);
      gl.bindTexture(GL_TEXTURE_2D$1, null);
      gl.bindTexture(GL_TEXTURE_CUBE_MAP$1, null);
    }
  }

  return {
    create2D: createTexture2D,
    createCube: createTextureCube,
    clear: destroyTextures,
    getTexture: function (wrapper) {
      return null
    },
    restore: restoreTextures,
    refresh: refreshTextures
  }
}

var GL_RENDERBUFFER = 0x8D41;

var GL_RGBA4$1 = 0x8056;
var GL_RGB5_A1$1 = 0x8057;
var GL_RGB565$1 = 0x8D62;
var GL_DEPTH_COMPONENT16 = 0x81A5;
var GL_STENCIL_INDEX8 = 0x8D48;
var GL_DEPTH_STENCIL$1 = 0x84F9;

var GL_SRGB8_ALPHA8_EXT = 0x8C43;

var GL_RGBA32F_EXT = 0x8814;

var GL_RGBA16F_EXT = 0x881A;
var GL_RGB16F_EXT = 0x881B;

var FORMAT_SIZES = [];

FORMAT_SIZES[GL_RGBA4$1] = 2;
FORMAT_SIZES[GL_RGB5_A1$1] = 2;
FORMAT_SIZES[GL_RGB565$1] = 2;

FORMAT_SIZES[GL_DEPTH_COMPONENT16] = 2;
FORMAT_SIZES[GL_STENCIL_INDEX8] = 1;
FORMAT_SIZES[GL_DEPTH_STENCIL$1] = 4;

FORMAT_SIZES[GL_SRGB8_ALPHA8_EXT] = 4;
FORMAT_SIZES[GL_RGBA32F_EXT] = 16;
FORMAT_SIZES[GL_RGBA16F_EXT] = 8;
FORMAT_SIZES[GL_RGB16F_EXT] = 6;

function getRenderbufferSize (format, width, height) {
  return FORMAT_SIZES[format] * width * height
}

var wrapRenderbuffers = function (gl, extensions, limits, stats, config) {
  var formatTypes = {
    'rgba4': GL_RGBA4$1,
    'rgb565': GL_RGB565$1,
    'rgb5 a1': GL_RGB5_A1$1,
    'depth': GL_DEPTH_COMPONENT16,
    'stencil': GL_STENCIL_INDEX8,
    'depth stencil': GL_DEPTH_STENCIL$1
  };

  if (extensions.ext_srgb) {
    formatTypes['srgba'] = GL_SRGB8_ALPHA8_EXT;
  }

  if (extensions.ext_color_buffer_half_float) {
    formatTypes['rgba16f'] = GL_RGBA16F_EXT;
    formatTypes['rgb16f'] = GL_RGB16F_EXT;
  }

  if (extensions.webgl_color_buffer_float) {
    formatTypes['rgba32f'] = GL_RGBA32F_EXT;
  }

  var formatTypesInvert = [];
  Object.keys(formatTypes).forEach(function (key) {
    var val = formatTypes[key];
    formatTypesInvert[val] = key;
  });

  var renderbufferCount = 0;
  var renderbufferSet = {};

  function REGLRenderbuffer (renderbuffer) {
    this.id = renderbufferCount++;
    this.refCount = 1;

    this.renderbuffer = renderbuffer;

    this.format = GL_RGBA4$1;
    this.width = 0;
    this.height = 0;

    if (config.profile) {
      this.stats = { size: 0 };
    }
  }

  REGLRenderbuffer.prototype.decRef = function () {
    if (--this.refCount <= 0) {
      destroy(this);
    }
  };

  function destroy (rb) {
    var handle = rb.renderbuffer;
    check$1(handle, 'must not double destroy renderbuffer');
    gl.bindRenderbuffer(GL_RENDERBUFFER, null);
    gl.deleteRenderbuffer(handle);
    rb.renderbuffer = null;
    rb.refCount = 0;
    delete renderbufferSet[rb.id];
    stats.renderbufferCount--;
  }

  function createRenderbuffer (a, b) {
    var renderbuffer = new REGLRenderbuffer(gl.createRenderbuffer());
    renderbufferSet[renderbuffer.id] = renderbuffer;
    stats.renderbufferCount++;

    function reglRenderbuffer (a, b) {
      var w = 0;
      var h = 0;
      var format = GL_RGBA4$1;

      if (typeof a === 'object' && a) {
        var options = a;
        if ('shape' in options) {
          var shape = options.shape;
          check$1(Array.isArray(shape) && shape.length >= 2,
            'invalid renderbuffer shape');
          w = shape[0] | 0;
          h = shape[1] | 0;
        } else {
          if ('radius' in options) {
            w = h = options.radius | 0;
          }
          if ('width' in options) {
            w = options.width | 0;
          }
          if ('height' in options) {
            h = options.height | 0;
          }
        }
        if ('format' in options) {
          check$1.parameter(options.format, formatTypes,
            'invalid renderbuffer format');
          format = formatTypes[options.format];
        }
      } else if (typeof a === 'number') {
        w = a | 0;
        if (typeof b === 'number') {
          h = b | 0;
        } else {
          h = w;
        }
      } else if (!a) {
        w = h = 1;
      } else {
        check$1.raise('invalid arguments to renderbuffer constructor');
      }

      // check shape
      check$1(
        w > 0 && h > 0 &&
        w <= limits.maxRenderbufferSize && h <= limits.maxRenderbufferSize,
        'invalid renderbuffer size');

      if (w === renderbuffer.width &&
          h === renderbuffer.height &&
          format === renderbuffer.format) {
        return
      }

      reglRenderbuffer.width = renderbuffer.width = w;
      reglRenderbuffer.height = renderbuffer.height = h;
      renderbuffer.format = format;

      gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer);
      gl.renderbufferStorage(GL_RENDERBUFFER, format, w, h);

      check$1(
        gl.getError() === 0,
        'invalid render buffer format');

      if (config.profile) {
        renderbuffer.stats.size = getRenderbufferSize(renderbuffer.format, renderbuffer.width, renderbuffer.height);
      }
      reglRenderbuffer.format = formatTypesInvert[renderbuffer.format];

      return reglRenderbuffer
    }

    function resize (w_, h_) {
      var w = w_ | 0;
      var h = (h_ | 0) || w;

      if (w === renderbuffer.width && h === renderbuffer.height) {
        return reglRenderbuffer
      }

      // check shape
      check$1(
        w > 0 && h > 0 &&
        w <= limits.maxRenderbufferSize && h <= limits.maxRenderbufferSize,
        'invalid renderbuffer size');

      reglRenderbuffer.width = renderbuffer.width = w;
      reglRenderbuffer.height = renderbuffer.height = h;

      gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer);
      gl.renderbufferStorage(GL_RENDERBUFFER, renderbuffer.format, w, h);

      check$1(
        gl.getError() === 0,
        'invalid render buffer format');

      // also, recompute size.
      if (config.profile) {
        renderbuffer.stats.size = getRenderbufferSize(
          renderbuffer.format, renderbuffer.width, renderbuffer.height);
      }

      return reglRenderbuffer
    }

    reglRenderbuffer(a, b);

    reglRenderbuffer.resize = resize;
    reglRenderbuffer._reglType = 'renderbuffer';
    reglRenderbuffer._renderbuffer = renderbuffer;
    if (config.profile) {
      reglRenderbuffer.stats = renderbuffer.stats;
    }
    reglRenderbuffer.destroy = function () {
      renderbuffer.decRef();
    };

    return reglRenderbuffer
  }

  if (config.profile) {
    stats.getTotalRenderbufferSize = function () {
      var total = 0;
      Object.keys(renderbufferSet).forEach(function (key) {
        total += renderbufferSet[key].stats.size;
      });
      return total
    };
  }

  function restoreRenderbuffers () {
    values(renderbufferSet).forEach(function (rb) {
      rb.renderbuffer = gl.createRenderbuffer();
      gl.bindRenderbuffer(GL_RENDERBUFFER, rb.renderbuffer);
      gl.renderbufferStorage(GL_RENDERBUFFER, rb.format, rb.width, rb.height);
    });
    gl.bindRenderbuffer(GL_RENDERBUFFER, null);
  }

  return {
    create: createRenderbuffer,
    clear: function () {
      values(renderbufferSet).forEach(destroy);
    },
    restore: restoreRenderbuffers
  }
};

// We store these constants so that the minifier can inline them
var GL_FRAMEBUFFER$1 = 0x8D40;
var GL_RENDERBUFFER$1 = 0x8D41;

var GL_TEXTURE_2D$2 = 0x0DE1;
var GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 = 0x8515;

var GL_COLOR_ATTACHMENT0$1 = 0x8CE0;
var GL_DEPTH_ATTACHMENT = 0x8D00;
var GL_STENCIL_ATTACHMENT = 0x8D20;
var GL_DEPTH_STENCIL_ATTACHMENT = 0x821A;

var GL_FRAMEBUFFER_COMPLETE$1 = 0x8CD5;
var GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6;
var GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7;
var GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9;
var GL_FRAMEBUFFER_UNSUPPORTED = 0x8CDD;

var GL_HALF_FLOAT_OES$2 = 0x8D61;
var GL_UNSIGNED_BYTE$6 = 0x1401;
var GL_FLOAT$5 = 0x1406;

var GL_RGB$1 = 0x1907;
var GL_RGBA$2 = 0x1908;

var GL_DEPTH_COMPONENT$1 = 0x1902;

var colorTextureFormatEnums = [
  GL_RGB$1,
  GL_RGBA$2
];

// for every texture format, store
// the number of channels
var textureFormatChannels = [];
textureFormatChannels[GL_RGBA$2] = 4;
textureFormatChannels[GL_RGB$1] = 3;

// for every texture type, store
// the size in bytes.
var textureTypeSizes = [];
textureTypeSizes[GL_UNSIGNED_BYTE$6] = 1;
textureTypeSizes[GL_FLOAT$5] = 4;
textureTypeSizes[GL_HALF_FLOAT_OES$2] = 2;

var GL_RGBA4$2 = 0x8056;
var GL_RGB5_A1$2 = 0x8057;
var GL_RGB565$2 = 0x8D62;
var GL_DEPTH_COMPONENT16$1 = 0x81A5;
var GL_STENCIL_INDEX8$1 = 0x8D48;
var GL_DEPTH_STENCIL$2 = 0x84F9;

var GL_SRGB8_ALPHA8_EXT$1 = 0x8C43;

var GL_RGBA32F_EXT$1 = 0x8814;

var GL_RGBA16F_EXT$1 = 0x881A;
var GL_RGB16F_EXT$1 = 0x881B;

var colorRenderbufferFormatEnums = [
  GL_RGBA4$2,
  GL_RGB5_A1$2,
  GL_RGB565$2,
  GL_SRGB8_ALPHA8_EXT$1,
  GL_RGBA16F_EXT$1,
  GL_RGB16F_EXT$1,
  GL_RGBA32F_EXT$1
];

var statusCode = {};
statusCode[GL_FRAMEBUFFER_COMPLETE$1] = 'complete';
statusCode[GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT] = 'incomplete attachment';
statusCode[GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS] = 'incomplete dimensions';
statusCode[GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT] = 'incomplete, missing attachment';
statusCode[GL_FRAMEBUFFER_UNSUPPORTED] = 'unsupported';

function wrapFBOState (
  gl,
  extensions,
  limits,
  textureState,
  renderbufferState,
  stats) {
  var framebufferState = {
    cur: null,
    next: null,
    dirty: false,
    setFBO: null
  };

  var colorTextureFormats = ['rgba'];
  var colorRenderbufferFormats = ['rgba4', 'rgb565', 'rgb5 a1'];

  if (extensions.ext_srgb) {
    colorRenderbufferFormats.push('srgba');
  }

  if (extensions.ext_color_buffer_half_float) {
    colorRenderbufferFormats.push('rgba16f', 'rgb16f');
  }

  if (extensions.webgl_color_buffer_float) {
    colorRenderbufferFormats.push('rgba32f');
  }

  var colorTypes = ['uint8'];
  if (extensions.oes_texture_half_float) {
    colorTypes.push('half float', 'float16');
  }
  if (extensions.oes_texture_float) {
    colorTypes.push('float', 'float32');
  }

  function FramebufferAttachment (target, texture, renderbuffer) {
    this.target = target;
    this.texture = texture;
    this.renderbuffer = renderbuffer;

    var w = 0;
    var h = 0;
    if (texture) {
      w = texture.width;
      h = texture.height;
    } else if (renderbuffer) {
      w = renderbuffer.width;
      h = renderbuffer.height;
    }
    this.width = w;
    this.height = h;
  }

  function decRef (attachment) {
    if (attachment) {
      if (attachment.texture) {
        attachment.texture._texture.decRef();
      }
      if (attachment.renderbuffer) {
        attachment.renderbuffer._renderbuffer.decRef();
      }
    }
  }

  function incRefAndCheckShape (attachment, width, height) {
    if (!attachment) {
      return
    }
    if (attachment.texture) {
      var texture = attachment.texture._texture;
      var tw = Math.max(1, texture.width);
      var th = Math.max(1, texture.height);
      check$1(tw === width && th === height,
        'inconsistent width/height for supplied texture');
      texture.refCount += 1;
    } else {
      var renderbuffer = attachment.renderbuffer._renderbuffer;
      check$1(
        renderbuffer.width === width && renderbuffer.height === height,
        'inconsistent width/height for renderbuffer');
      renderbuffer.refCount += 1;
    }
  }

  function attach (location, attachment) {
    if (attachment) {
      if (attachment.texture) {
        gl.framebufferTexture2D(
          GL_FRAMEBUFFER$1,
          location,
          attachment.target,
          attachment.texture._texture.texture,
          0);
      } else {
        gl.framebufferRenderbuffer(
          GL_FRAMEBUFFER$1,
          location,
          GL_RENDERBUFFER$1,
          attachment.renderbuffer._renderbuffer.renderbuffer);
      }
    }
  }

  function parseAttachment (attachment) {
    var target = GL_TEXTURE_2D$2;
    var texture = null;
    var renderbuffer = null;

    var data = attachment;
    if (typeof attachment === 'object') {
      data = attachment.data;
      if ('target' in attachment) {
        target = attachment.target | 0;
      }
    }

    check$1.type(data, 'function', 'invalid attachment data');

    var type = data._reglType;
    if (type === 'texture2d') {
      texture = data;
      check$1(target === GL_TEXTURE_2D$2);
    } else if (type === 'textureCube') {
      texture = data;
      check$1(
        target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 &&
        target < GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 + 6,
        'invalid cube map target');
    } else if (type === 'renderbuffer') {
      renderbuffer = data;
      target = GL_RENDERBUFFER$1;
    } else {
      check$1.raise('invalid regl object for attachment');
    }

    return new FramebufferAttachment(target, texture, renderbuffer)
  }

  function allocAttachment (
    width,
    height,
    isTexture,
    format,
    type) {
    if (isTexture) {
      var texture = textureState.create2D({
        width: width,
        height: height,
        format: format,
        type: type
      });
      texture._texture.refCount = 0;
      return new FramebufferAttachment(GL_TEXTURE_2D$2, texture, null)
    } else {
      var rb = renderbufferState.create({
        width: width,
        height: height,
        format: format
      });
      rb._renderbuffer.refCount = 0;
      return new FramebufferAttachment(GL_RENDERBUFFER$1, null, rb)
    }
  }

  function unwrapAttachment (attachment) {
    return attachment && (attachment.texture || attachment.renderbuffer)
  }

  function resizeAttachment (attachment, w, h) {
    if (attachment) {
      if (attachment.texture) {
        attachment.texture.resize(w, h);
      } else if (attachment.renderbuffer) {
        attachment.renderbuffer.resize(w, h);
      }
      attachment.width = w;
      attachment.height = h;
    }
  }

  var framebufferCount = 0;
  var framebufferSet = {};

  function REGLFramebuffer () {
    this.id = framebufferCount++;
    framebufferSet[this.id] = this;

    this.framebuffer = gl.createFramebuffer();
    this.width = 0;
    this.height = 0;

    this.colorAttachments = [];
    this.depthAttachment = null;
    this.stencilAttachment = null;
    this.depthStencilAttachment = null;
  }

  function decFBORefs (framebuffer) {
    framebuffer.colorAttachments.forEach(decRef);
    decRef(framebuffer.depthAttachment);
    decRef(framebuffer.stencilAttachment);
    decRef(framebuffer.depthStencilAttachment);
  }

  function destroy (framebuffer) {
    var handle = framebuffer.framebuffer;
    check$1(handle, 'must not double destroy framebuffer');
    gl.deleteFramebuffer(handle);
    framebuffer.framebuffer = null;
    stats.framebufferCount--;
    delete framebufferSet[framebuffer.id];
  }

  function updateFramebuffer (framebuffer) {
    var i;

    gl.bindFramebuffer(GL_FRAMEBUFFER$1, framebuffer.framebuffer);
    var colorAttachments = framebuffer.colorAttachments;
    for (i = 0; i < colorAttachments.length; ++i) {
      attach(GL_COLOR_ATTACHMENT0$1 + i, colorAttachments[i]);
    }
    for (i = colorAttachments.length; i < limits.maxColorAttachments; ++i) {
      gl.framebufferTexture2D(
        GL_FRAMEBUFFER$1,
        GL_COLOR_ATTACHMENT0$1 + i,
        GL_TEXTURE_2D$2,
        null,
        0);
    }

    gl.framebufferTexture2D(
      GL_FRAMEBUFFER$1,
      GL_DEPTH_STENCIL_ATTACHMENT,
      GL_TEXTURE_2D$2,
      null,
      0);
    gl.framebufferTexture2D(
      GL_FRAMEBUFFER$1,
      GL_DEPTH_ATTACHMENT,
      GL_TEXTURE_2D$2,
      null,
      0);
    gl.framebufferTexture2D(
      GL_FRAMEBUFFER$1,
      GL_STENCIL_ATTACHMENT,
      GL_TEXTURE_2D$2,
      null,
      0);

    attach(GL_DEPTH_ATTACHMENT, framebuffer.depthAttachment);
    attach(GL_STENCIL_ATTACHMENT, framebuffer.stencilAttachment);
    attach(GL_DEPTH_STENCIL_ATTACHMENT, framebuffer.depthStencilAttachment);

    // Check status code
    var status = gl.checkFramebufferStatus(GL_FRAMEBUFFER$1);
    if (!gl.isContextLost() && status !== GL_FRAMEBUFFER_COMPLETE$1) {
      check$1.raise('framebuffer configuration not supported, status = ' +
        statusCode[status]);
    }

    gl.bindFramebuffer(GL_FRAMEBUFFER$1, framebufferState.next ? framebufferState.next.framebuffer : null);
    framebufferState.cur = framebufferState.next;

    // FIXME: Clear error code here.  This is a work around for a bug in
    // headless-gl
    gl.getError();
  }

  function createFBO (a0, a1) {
    var framebuffer = new REGLFramebuffer();
    stats.framebufferCount++;

    function reglFramebuffer (a, b) {
      var i;

      check$1(framebufferState.next !== framebuffer,
        'can not update framebuffer which is currently in use');

      var width = 0;
      var height = 0;

      var needsDepth = true;
      var needsStencil = true;

      var colorBuffer = null;
      var colorTexture = true;
      var colorFormat = 'rgba';
      var colorType = 'uint8';
      var colorCount = 1;

      var depthBuffer = null;
      var stencilBuffer = null;
      var depthStencilBuffer = null;
      var depthStencilTexture = false;

      if (typeof a === 'number') {
        width = a | 0;
        height = (b | 0) || width;
      } else if (!a) {
        width = height = 1;
      } else {
        check$1.type(a, 'object', 'invalid arguments for framebuffer');
        var options = a;

        if ('shape' in options) {
          var shape = options.shape;
          check$1(Array.isArray(shape) && shape.length >= 2,
            'invalid shape for framebuffer');
          width = shape[0];
          height = shape[1];
        } else {
          if ('radius' in options) {
            width = height = options.radius;
          }
          if ('width' in options) {
            width = options.width;
          }
          if ('height' in options) {
            height = options.height;
          }
        }

        if ('color' in options ||
            'colors' in options) {
          colorBuffer =
            options.color ||
            options.colors;
          if (Array.isArray(colorBuffer)) {
            check$1(
              colorBuffer.length === 1 || extensions.webgl_draw_buffers,
              'multiple render targets not supported');
          }
        }

        if (!colorBuffer) {
          if ('colorCount' in options) {
            colorCount = options.colorCount | 0;
            check$1(colorCount > 0, 'invalid color buffer count');
          }

          if ('colorTexture' in options) {
            colorTexture = !!options.colorTexture;
            colorFormat = 'rgba4';
          }

          if ('colorType' in options) {
            colorType = options.colorType;
            if (!colorTexture) {
              if (colorType === 'half float' || colorType === 'float16') {
                check$1(extensions.ext_color_buffer_half_float,
                  'you must enable EXT_color_buffer_half_float to use 16-bit render buffers');
                colorFormat = 'rgba16f';
              } else if (colorType === 'float' || colorType === 'float32') {
                check$1(extensions.webgl_color_buffer_float,
                  'you must enable WEBGL_color_buffer_float in order to use 32-bit floating point renderbuffers');
                colorFormat = 'rgba32f';
              }
            } else {
              check$1(extensions.oes_texture_float ||
                !(colorType === 'float' || colorType === 'float32'),
              'you must enable OES_texture_float in order to use floating point framebuffer objects');
              check$1(extensions.oes_texture_half_float ||
                !(colorType === 'half float' || colorType === 'float16'),
              'you must enable OES_texture_half_float in order to use 16-bit floating point framebuffer objects');
            }
            check$1.oneOf(colorType, colorTypes, 'invalid color type');
          }

          if ('colorFormat' in options) {
            colorFormat = options.colorFormat;
            if (colorTextureFormats.indexOf(colorFormat) >= 0) {
              colorTexture = true;
            } else if (colorRenderbufferFormats.indexOf(colorFormat) >= 0) {
              colorTexture = false;
            } else {
              check$1.optional(function () {
                if (colorTexture) {
                  check$1.oneOf(
                    options.colorFormat, colorTextureFormats,
                    'invalid color format for texture');
                } else {
                  check$1.oneOf(
                    options.colorFormat, colorRenderbufferFormats,
                    'invalid color format for renderbuffer');
                }
              });
            }
          }
        }

        if ('depthTexture' in options || 'depthStencilTexture' in options) {
          depthStencilTexture = !!(options.depthTexture ||
            options.depthStencilTexture);
          check$1(!depthStencilTexture || extensions.webgl_depth_texture,
            'webgl_depth_texture extension not supported');
        }

        if ('depth' in options) {
          if (typeof options.depth === 'boolean') {
            needsDepth = options.depth;
          } else {
            depthBuffer = options.depth;
            needsStencil = false;
          }
        }

        if ('stencil' in options) {
          if (typeof options.stencil === 'boolean') {
            needsStencil = options.stencil;
          } else {
            stencilBuffer = options.stencil;
            needsDepth = false;
          }
        }

        if ('depthStencil' in options) {
          if (typeof options.depthStencil === 'boolean') {
            needsDepth = needsStencil = options.depthStencil;
          } else {
            depthStencilBuffer = options.depthStencil;
            needsDepth = false;
            needsStencil = false;
          }
        }
      }

      // parse attachments
      var colorAttachments = null;
      var depthAttachment = null;
      var stencilAttachment = null;
      var depthStencilAttachment = null;

      // Set up color attachments
      if (Array.isArray(colorBuffer)) {
        colorAttachments = colorBuffer.map(parseAttachment);
      } else if (colorBuffer) {
        colorAttachments = [parseAttachment(colorBuffer)];
      } else {
        colorAttachments = new Array(colorCount);
        for (i = 0; i < colorCount; ++i) {
          colorAttachments[i] = allocAttachment(
            width,
            height,
            colorTexture,
            colorFormat,
            colorType);
        }
      }

      check$1(extensions.webgl_draw_buffers || colorAttachments.length <= 1,
        'you must enable the WEBGL_draw_buffers extension in order to use multiple color buffers.');
      check$1(colorAttachments.length <= limits.maxColorAttachments,
        'too many color attachments, not supported');

      width = width || colorAttachments[0].width;
      height = height || colorAttachments[0].height;

      if (depthBuffer) {
        depthAttachment = parseAttachment(depthBuffer);
      } else if (needsDepth && !needsStencil) {
        depthAttachment = allocAttachment(
          width,
          height,
          depthStencilTexture,
          'depth',
          'uint32');
      }

      if (stencilBuffer) {
        stencilAttachment = parseAttachment(stencilBuffer);
      } else if (needsStencil && !needsDepth) {
        stencilAttachment = allocAttachment(
          width,
          height,
          false,
          'stencil',
          'uint8');
      }

      if (depthStencilBuffer) {
        depthStencilAttachment = parseAttachment(depthStencilBuffer);
      } else if (!depthBuffer && !stencilBuffer && needsStencil && needsDepth) {
        depthStencilAttachment = allocAttachment(
          width,
          height,
          depthStencilTexture,
          'depth stencil',
          'depth stencil');
      }

      check$1(
        (!!depthBuffer) + (!!stencilBuffer) + (!!depthStencilBuffer) <= 1,
        'invalid framebuffer configuration, can specify exactly one depth/stencil attachment');

      var commonColorAttachmentSize = null;

      for (i = 0; i < colorAttachments.length; ++i) {
        incRefAndCheckShape(colorAttachments[i], width, height);
        check$1(!colorAttachments[i] ||
          (colorAttachments[i].texture &&
            colorTextureFormatEnums.indexOf(colorAttachments[i].texture._texture.format) >= 0) ||
          (colorAttachments[i].renderbuffer &&
            colorRenderbufferFormatEnums.indexOf(colorAttachments[i].renderbuffer._renderbuffer.format) >= 0),
        'framebuffer color attachment ' + i + ' is invalid');

        if (colorAttachments[i] && colorAttachments[i].texture) {
          var colorAttachmentSize =
              textureFormatChannels[colorAttachments[i].texture._texture.format] *
              textureTypeSizes[colorAttachments[i].texture._texture.type];

          if (commonColorAttachmentSize === null) {
            commonColorAttachmentSize = colorAttachmentSize;
          } else {
            // We need to make sure that all color attachments have the same number of bitplanes
            // (that is, the same numer of bits per pixel)
            // This is required by the GLES2.0 standard. See the beginning of Chapter 4 in that document.
            check$1(commonColorAttachmentSize === colorAttachmentSize,
              'all color attachments much have the same number of bits per pixel.');
          }
        }
      }
      incRefAndCheckShape(depthAttachment, width, height);
      check$1(!depthAttachment ||
        (depthAttachment.texture &&
          depthAttachment.texture._texture.format === GL_DEPTH_COMPONENT$1) ||
        (depthAttachment.renderbuffer &&
          depthAttachment.renderbuffer._renderbuffer.format === GL_DEPTH_COMPONENT16$1),
      'invalid depth attachment for framebuffer object');
      incRefAndCheckShape(stencilAttachment, width, height);
      check$1(!stencilAttachment ||
        (stencilAttachment.renderbuffer &&
          stencilAttachment.renderbuffer._renderbuffer.format === GL_STENCIL_INDEX8$1),
      'invalid stencil attachment for framebuffer object');
      incRefAndCheckShape(depthStencilAttachment, width, height);
      check$1(!depthStencilAttachment ||
        (depthStencilAttachment.texture &&
          depthStencilAttachment.texture._texture.format === GL_DEPTH_STENCIL$2) ||
        (depthStencilAttachment.renderbuffer &&
          depthStencilAttachment.renderbuffer._renderbuffer.format === GL_DEPTH_STENCIL$2),
      'invalid depth-stencil attachment for framebuffer object');

      // decrement references
      decFBORefs(framebuffer);

      framebuffer.width = width;
      framebuffer.height = height;

      framebuffer.colorAttachments = colorAttachments;
      framebuffer.depthAttachment = depthAttachment;
      framebuffer.stencilAttachment = stencilAttachment;
      framebuffer.depthStencilAttachment = depthStencilAttachment;

      reglFramebuffer.color = colorAttachments.map(unwrapAttachment);
      reglFramebuffer.depth = unwrapAttachment(depthAttachment);
      reglFramebuffer.stencil = unwrapAttachment(stencilAttachment);
      reglFramebuffer.depthStencil = unwrapAttachment(depthStencilAttachment);

      reglFramebuffer.width = framebuffer.width;
      reglFramebuffer.height = framebuffer.height;

      updateFramebuffer(framebuffer);

      return reglFramebuffer
    }

    function resize (w_, h_) {
      check$1(framebufferState.next !== framebuffer,
        'can not resize a framebuffer which is currently in use');

      var w = Math.max(w_ | 0, 1);
      var h = Math.max((h_ | 0) || w, 1);
      if (w === framebuffer.width && h === framebuffer.height) {
        return reglFramebuffer
      }

      // resize all buffers
      var colorAttachments = framebuffer.colorAttachments;
      for (var i = 0; i < colorAttachments.length; ++i) {
        resizeAttachment(colorAttachments[i], w, h);
      }
      resizeAttachment(framebuffer.depthAttachment, w, h);
      resizeAttachment(framebuffer.stencilAttachment, w, h);
      resizeAttachment(framebuffer.depthStencilAttachment, w, h);

      framebuffer.width = reglFramebuffer.width = w;
      framebuffer.height = reglFramebuffer.height = h;

      updateFramebuffer(framebuffer);

      return reglFramebuffer
    }

    reglFramebuffer(a0, a1);

    return extend(reglFramebuffer, {
      resize: resize,
      _reglType: 'framebuffer',
      _framebuffer: framebuffer,
      destroy: function () {
        destroy(framebuffer);
        decFBORefs(framebuffer);
      },
      use: function (block) {
        framebufferState.setFBO({
          framebuffer: reglFramebuffer
        }, block);
      }
    })
  }

  function createCubeFBO (options) {
    var faces = Array(6);

    function reglFramebufferCube (a) {
      var i;

      check$1(faces.indexOf(framebufferState.next) < 0,
        'can not update framebuffer which is currently in use');

      var params = {
        color: null
      };

      var radius = 0;

      var colorBuffer = null;
      var colorFormat = 'rgba';
      var colorType = 'uint8';
      var colorCount = 1;

      if (typeof a === 'number') {
        radius = a | 0;
      } else if (!a) {
        radius = 1;
      } else {
        check$1.type(a, 'object', 'invalid arguments for framebuffer');
        var options = a;

        if ('shape' in options) {
          var shape = options.shape;
          check$1(
            Array.isArray(shape) && shape.length >= 2,
            'invalid shape for framebuffer');
          check$1(
            shape[0] === shape[1],
            'cube framebuffer must be square');
          radius = shape[0];
        } else {
          if ('radius' in options) {
            radius = options.radius | 0;
          }
          if ('width' in options) {
            radius = options.width | 0;
            if ('height' in options) {
              check$1(options.height === radius, 'must be square');
            }
          } else if ('height' in options) {
            radius = options.height | 0;
          }
        }

        if ('color' in options ||
            'colors' in options) {
          colorBuffer =
            options.color ||
            options.colors;
          if (Array.isArray(colorBuffer)) {
            check$1(
              colorBuffer.length === 1 || extensions.webgl_draw_buffers,
              'multiple render targets not supported');
          }
        }

        if (!colorBuffer) {
          if ('colorCount' in options) {
            colorCount = options.colorCount | 0;
            check$1(colorCount > 0, 'invalid color buffer count');
          }

          if ('colorType' in options) {
            check$1.oneOf(
              options.colorType, colorTypes,
              'invalid color type');
            colorType = options.colorType;
          }

          if ('colorFormat' in options) {
            colorFormat = options.colorFormat;
            check$1.oneOf(
              options.colorFormat, colorTextureFormats,
              'invalid color format for texture');
          }
        }

        if ('depth' in options) {
          params.depth = options.depth;
        }

        if ('stencil' in options) {
          params.stencil = options.stencil;
        }

        if ('depthStencil' in options) {
          params.depthStencil = options.depthStencil;
        }
      }

      var colorCubes;
      if (colorBuffer) {
        if (Array.isArray(colorBuffer)) {
          colorCubes = [];
          for (i = 0; i < colorBuffer.length; ++i) {
            colorCubes[i] = colorBuffer[i];
          }
        } else {
          colorCubes = [ colorBuffer ];
        }
      } else {
        colorCubes = Array(colorCount);
        var cubeMapParams = {
          radius: radius,
          format: colorFormat,
          type: colorType
        };
        for (i = 0; i < colorCount; ++i) {
          colorCubes[i] = textureState.createCube(cubeMapParams);
        }
      }

      // Check color cubes
      params.color = Array(colorCubes.length);
      for (i = 0; i < colorCubes.length; ++i) {
        var cube = colorCubes[i];
        check$1(
          typeof cube === 'function' && cube._reglType === 'textureCube',
          'invalid cube map');
        radius = radius || cube.width;
        check$1(
          cube.width === radius && cube.height === radius,
          'invalid cube map shape');
        params.color[i] = {
          target: GL_TEXTURE_CUBE_MAP_POSITIVE_X$2,
          data: colorCubes[i]
        };
      }

      for (i = 0; i < 6; ++i) {
        for (var j = 0; j < colorCubes.length; ++j) {
          params.color[j].target = GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 + i;
        }
        // reuse depth-stencil attachments across all cube maps
        if (i > 0) {
          params.depth = faces[0].depth;
          params.stencil = faces[0].stencil;
          params.depthStencil = faces[0].depthStencil;
        }
        if (faces[i]) {
          (faces[i])(params);
        } else {
          faces[i] = createFBO(params);
        }
      }

      return extend(reglFramebufferCube, {
        width: radius,
        height: radius,
        color: colorCubes
      })
    }

    function resize (radius_) {
      var i;
      var radius = radius_ | 0;
      check$1(radius > 0 && radius <= limits.maxCubeMapSize,
        'invalid radius for cube fbo');

      if (radius === reglFramebufferCube.width) {
        return reglFramebufferCube
      }

      var colors = reglFramebufferCube.color;
      for (i = 0; i < colors.length; ++i) {
        colors[i].resize(radius);
      }

      for (i = 0; i < 6; ++i) {
        faces[i].resize(radius);
      }

      reglFramebufferCube.width = reglFramebufferCube.height = radius;

      return reglFramebufferCube
    }

    reglFramebufferCube(options);

    return extend(reglFramebufferCube, {
      faces: faces,
      resize: resize,
      _reglType: 'framebufferCube',
      destroy: function () {
        faces.forEach(function (f) {
          f.destroy();
        });
      }
    })
  }

  function restoreFramebuffers () {
    framebufferState.cur = null;
    framebufferState.next = null;
    framebufferState.dirty = true;
    values(framebufferSet).forEach(function (fb) {
      fb.framebuffer = gl.createFramebuffer();
      updateFramebuffer(fb);
    });
  }

  return extend(framebufferState, {
    getFramebuffer: function (object) {
      if (typeof object === 'function' && object._reglType === 'framebuffer') {
        var fbo = object._framebuffer;
        if (fbo instanceof REGLFramebuffer) {
          return fbo
        }
      }
      return null
    },
    create: createFBO,
    createCube: createCubeFBO,
    clear: function () {
      values(framebufferSet).forEach(destroy);
    },
    restore: restoreFramebuffers
  })
}

var GL_FLOAT$6 = 5126;
var GL_ARRAY_BUFFER$1 = 34962;
var GL_ELEMENT_ARRAY_BUFFER$1 = 34963;

var VAO_OPTIONS = [
  'attributes',
  'elements',
  'offset',
  'count',
  'primitive',
  'instances'
];

function AttributeRecord () {
  this.state = 0;

  this.x = 0.0;
  this.y = 0.0;
  this.z = 0.0;
  this.w = 0.0;

  this.buffer = null;
  this.size = 0;
  this.normalized = false;
  this.type = GL_FLOAT$6;
  this.offset = 0;
  this.stride = 0;
  this.divisor = 0;
}

function wrapAttributeState (
  gl,
  extensions,
  limits,
  stats,
  bufferState,
  elementState,
  drawState) {
  var NUM_ATTRIBUTES = limits.maxAttributes;
  var attributeBindings = new Array(NUM_ATTRIBUTES);
  for (var i = 0; i < NUM_ATTRIBUTES; ++i) {
    attributeBindings[i] = new AttributeRecord();
  }
  var vaoCount = 0;
  var vaoSet = {};

  var state = {
    Record: AttributeRecord,
    scope: {},
    state: attributeBindings,
    currentVAO: null,
    targetVAO: null,
    restore: extVAO() ? restoreVAO : function () {},
    createVAO: createVAO,
    getVAO: getVAO,
    destroyBuffer: destroyBuffer,
    setVAO: extVAO() ? setVAOEXT : setVAOEmulated,
    clear: extVAO() ? destroyVAOEXT : function () {}
  };

  function destroyBuffer (buffer) {
    for (var i = 0; i < attributeBindings.length; ++i) {
      var record = attributeBindings[i];
      if (record.buffer === buffer) {
        gl.disableVertexAttribArray(i);
        record.buffer = null;
      }
    }
  }

  function extVAO () {
    return extensions.oes_vertex_array_object
  }

  function extInstanced () {
    return extensions.angle_instanced_arrays
  }

  function getVAO (vao) {
    if (typeof vao === 'function' && vao._vao) {
      return vao._vao
    }
    return null
  }

  function setVAOEXT (vao) {
    if (vao === state.currentVAO) {
      return
    }
    var ext = extVAO();
    if (vao) {
      ext.bindVertexArrayOES(vao.vao);
    } else {
      ext.bindVertexArrayOES(null);
    }
    state.currentVAO = vao;
  }

  function setVAOEmulated (vao) {
    if (vao === state.currentVAO) {
      return
    }
    if (vao) {
      vao.bindAttrs();
    } else {
      var exti = extInstanced();
      for (var i = 0; i < attributeBindings.length; ++i) {
        var binding = attributeBindings[i];
        if (binding.buffer) {
          gl.enableVertexAttribArray(i);
          binding.buffer.bind();
          gl.vertexAttribPointer(i, binding.size, binding.type, binding.normalized, binding.stride, binding.offfset);
          if (exti && binding.divisor) {
            exti.vertexAttribDivisorANGLE(i, binding.divisor);
          }
        } else {
          gl.disableVertexAttribArray(i);
          gl.vertexAttrib4f(i, binding.x, binding.y, binding.z, binding.w);
        }
      }
      if (drawState.elements) {
        gl.bindBuffer(GL_ELEMENT_ARRAY_BUFFER$1, drawState.elements.buffer.buffer);
      } else {
        gl.bindBuffer(GL_ELEMENT_ARRAY_BUFFER$1, null);
      }
    }
    state.currentVAO = vao;
  }

  function destroyVAOEXT () {
    values(vaoSet).forEach(function (vao) {
      vao.destroy();
    });
  }

  function REGLVAO () {
    this.id = ++vaoCount;
    this.attributes = [];
    this.elements = null;
    this.ownsElements = false;
    this.count = 0;
    this.offset = 0;
    this.instances = -1;
    this.primitive = 4;
    var extension = extVAO();
    if (extension) {
      this.vao = extension.createVertexArrayOES();
    } else {
      this.vao = null;
    }
    vaoSet[this.id] = this;
    this.buffers = [];
  }

  REGLVAO.prototype.bindAttrs = function () {
    var exti = extInstanced();
    var attributes = this.attributes;
    for (var i = 0; i < attributes.length; ++i) {
      var attr = attributes[i];
      if (attr.buffer) {
        gl.enableVertexAttribArray(i);
        gl.bindBuffer(GL_ARRAY_BUFFER$1, attr.buffer.buffer);
        gl.vertexAttribPointer(i, attr.size, attr.type, attr.normalized, attr.stride, attr.offset);
        if (exti && attr.divisor) {
          exti.vertexAttribDivisorANGLE(i, attr.divisor);
        }
      } else {
        gl.disableVertexAttribArray(i);
        gl.vertexAttrib4f(i, attr.x, attr.y, attr.z, attr.w);
      }
    }
    for (var j = attributes.length; j < NUM_ATTRIBUTES; ++j) {
      gl.disableVertexAttribArray(j);
    }
    var elements = elementState.getElements(this.elements);
    if (elements) {
      gl.bindBuffer(GL_ELEMENT_ARRAY_BUFFER$1, elements.buffer.buffer);
    } else {
      gl.bindBuffer(GL_ELEMENT_ARRAY_BUFFER$1, null);
    }
  };

  REGLVAO.prototype.refresh = function () {
    var ext = extVAO();
    if (ext) {
      ext.bindVertexArrayOES(this.vao);
      this.bindAttrs();
      state.currentVAO = null;
      ext.bindVertexArrayOES(null);
    }
  };

  REGLVAO.prototype.destroy = function () {
    if (this.vao) {
      var extension = extVAO();
      if (this === state.currentVAO) {
        state.currentVAO = null;
        extension.bindVertexArrayOES(null);
      }
      extension.deleteVertexArrayOES(this.vao);
      this.vao = null;
    }
    if (this.ownsElements) {
      this.elements.destroy();
      this.elements = null;
      this.ownsElements = false;
    }
    if (vaoSet[this.id]) {
      delete vaoSet[this.id];
      stats.vaoCount -= 1;
    }
  };

  function restoreVAO () {
    var ext = extVAO();
    if (ext) {
      values(vaoSet).forEach(function (vao) {
        vao.refresh();
      });
    }
  }

  function createVAO (_attr) {
    var vao = new REGLVAO();
    stats.vaoCount += 1;

    function updateVAO (options) {
      var attributes;
      if (Array.isArray(options)) {
        attributes = options;
        if (vao.elements && vao.ownsElements) {
          vao.elements.destroy();
        }
        vao.elements = null;
        vao.ownsElements = false;
        vao.offset = 0;
        vao.count = 0;
        vao.instances = -1;
        vao.primitive = 4;
      } else {
        check$1(typeof options === 'object', 'invalid arguments for create vao');
        check$1('attributes' in options, 'must specify attributes for vao');
        if (options.elements) {
          var elements = options.elements;
          if (vao.ownsElements) {
            if (typeof elements === 'function' && elements._reglType === 'elements') {
              vao.elements.destroy();
              vao.ownsElements = false;
            } else {
              vao.elements(elements);
              vao.ownsElements = false;
            }
          } else if (elementState.getElements(options.elements)) {
            vao.elements = options.elements;
            vao.ownsElements = false;
          } else {
            vao.elements = elementState.create(options.elements);
            vao.ownsElements = true;
          }
        } else {
          vao.elements = null;
          vao.ownsElements = false;
        }
        attributes = options.attributes;

        // set default vao
        vao.offset = 0;
        vao.count = -1;
        vao.instances = -1;
        vao.primitive = 4;

        // copy element properties
        if (vao.elements) {
          vao.count = vao.elements._elements.vertCount;
          vao.primitive = vao.elements._elements.primType;
        }

        if ('offset' in options) {
          vao.offset = options.offset | 0;
        }
        if ('count' in options) {
          vao.count = options.count | 0;
        }
        if ('instances' in options) {
          vao.instances = options.instances | 0;
        }
        if ('primitive' in options) {
          check$1(options.primitive in primTypes, 'bad primitive type: ' + options.primitive);
          vao.primitive = primTypes[options.primitive];
        }

        check$1.optional(() => {
          var keys = Object.keys(options);
          for (var i = 0; i < keys.length; ++i) {
            check$1(VAO_OPTIONS.indexOf(keys[i]) >= 0, 'invalid option for vao: "' + keys[i] + '" valid options are ' + VAO_OPTIONS);
          }
        });
        check$1(Array.isArray(attributes), 'attributes must be an array');
      }

      check$1(attributes.length < NUM_ATTRIBUTES, 'too many attributes');
      check$1(attributes.length > 0, 'must specify at least one attribute');

      var bufUpdated = {};
      var nattributes = vao.attributes;
      nattributes.length = attributes.length;
      for (var i = 0; i < attributes.length; ++i) {
        var spec = attributes[i];
        var rec = nattributes[i] = new AttributeRecord();
        var data = spec.data || spec;
        if (Array.isArray(data) || isTypedArray(data) || isNDArrayLike(data)) {
          var buf;
          if (vao.buffers[i]) {
            buf = vao.buffers[i];
            if (isTypedArray(data) && buf._buffer.byteLength >= data.byteLength) {
              buf.subdata(data);
            } else {
              buf.destroy();
              vao.buffers[i] = null;
            }
          }
          if (!vao.buffers[i]) {
            buf = vao.buffers[i] = bufferState.create(spec, GL_ARRAY_BUFFER$1, false, true);
          }
          rec.buffer = bufferState.getBuffer(buf);
          rec.size = rec.buffer.dimension | 0;
          rec.normalized = false;
          rec.type = rec.buffer.dtype;
          rec.offset = 0;
          rec.stride = 0;
          rec.divisor = 0;
          rec.state = 1;
          bufUpdated[i] = 1;
        } else if (bufferState.getBuffer(spec)) {
          rec.buffer = bufferState.getBuffer(spec);
          rec.size = rec.buffer.dimension | 0;
          rec.normalized = false;
          rec.type = rec.buffer.dtype;
          rec.offset = 0;
          rec.stride = 0;
          rec.divisor = 0;
          rec.state = 1;
        } else if (bufferState.getBuffer(spec.buffer)) {
          rec.buffer = bufferState.getBuffer(spec.buffer);
          rec.size = ((+spec.size) || rec.buffer.dimension) | 0;
          rec.normalized = !!spec.normalized || false;
          if ('type' in spec) {
            check$1.parameter(spec.type, glTypes, 'invalid buffer type');
            rec.type = glTypes[spec.type];
          } else {
            rec.type = rec.buffer.dtype;
          }
          rec.offset = (spec.offset || 0) | 0;
          rec.stride = (spec.stride || 0) | 0;
          rec.divisor = (spec.divisor || 0) | 0;
          rec.state = 1;

          check$1(rec.size >= 1 && rec.size <= 4, 'size must be between 1 and 4');
          check$1(rec.offset >= 0, 'invalid offset');
          check$1(rec.stride >= 0 && rec.stride <= 255, 'stride must be between 0 and 255');
          check$1(rec.divisor >= 0, 'divisor must be positive');
          check$1(!rec.divisor || !!extensions.angle_instanced_arrays, 'ANGLE_instanced_arrays must be enabled to use divisor');
        } else if ('x' in spec) {
          check$1(i > 0, 'first attribute must not be a constant');
          rec.x = +spec.x || 0;
          rec.y = +spec.y || 0;
          rec.z = +spec.z || 0;
          rec.w = +spec.w || 0;
          rec.state = 2;
        } else {
          check$1(false, 'invalid attribute spec for location ' + i);
        }
      }

      // retire unused buffers
      for (var j = 0; j < vao.buffers.length; ++j) {
        if (!bufUpdated[j] && vao.buffers[j]) {
          vao.buffers[j].destroy();
          vao.buffers[j] = null;
        }
      }

      vao.refresh();
      return updateVAO
    }

    updateVAO.destroy = function () {
      for (var j = 0; j < vao.buffers.length; ++j) {
        if (vao.buffers[j]) {
          vao.buffers[j].destroy();
        }
      }
      vao.buffers.length = 0;

      if (vao.ownsElements) {
        vao.elements.destroy();
        vao.elements = null;
        vao.ownsElements = false;
      }

      vao.destroy();
    };

    updateVAO._vao = vao;
    updateVAO._reglType = 'vao';

    return updateVAO(_attr)
  }

  return state
}

var GL_FRAGMENT_SHADER = 35632;
var GL_VERTEX_SHADER = 35633;

var GL_ACTIVE_UNIFORMS = 0x8B86;
var GL_ACTIVE_ATTRIBUTES = 0x8B89;

function wrapShaderState (gl, stringStore, stats, config) {
  // ===================================================
  // glsl compilation and linking
  // ===================================================
  var fragShaders = {};
  var vertShaders = {};

  function ActiveInfo (name, id, location, info) {
    this.name = name;
    this.id = id;
    this.location = location;
    this.info = info;
  }

  function insertActiveInfo (list, info) {
    for (var i = 0; i < list.length; ++i) {
      if (list[i].id === info.id) {
        list[i].location = info.location;
        return
      }
    }
    list.push(info);
  }

  function getShader (type, id, command) {
    var cache = type === GL_FRAGMENT_SHADER ? fragShaders : vertShaders;
    var shader = cache[id];

    if (!shader) {
      var source = stringStore.str(id);
      shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      check$1.shaderError(gl, shader, source, type, command);
      cache[id] = shader;
    }

    return shader
  }

  // ===================================================
  // program linking
  // ===================================================
  var programCache = {};
  var programList = [];

  var PROGRAM_COUNTER = 0;

  function REGLProgram (fragId, vertId) {
    this.id = PROGRAM_COUNTER++;
    this.fragId = fragId;
    this.vertId = vertId;
    this.program = null;
    this.uniforms = [];
    this.attributes = [];
    this.refCount = 1;

    if (config.profile) {
      this.stats = {
        uniformsCount: 0,
        attributesCount: 0
      };
    }
  }

  function linkProgram (desc, command, attributeLocations) {
    var i, info;

    // -------------------------------
    // compile & link
    // -------------------------------
    var fragShader = getShader(GL_FRAGMENT_SHADER, desc.fragId);
    var vertShader = getShader(GL_VERTEX_SHADER, desc.vertId);

    var program = desc.program = gl.createProgram();
    gl.attachShader(program, fragShader);
    gl.attachShader(program, vertShader);
    if (attributeLocations) {
      for (i = 0; i < attributeLocations.length; ++i) {
        var binding = attributeLocations[i];
        gl.bindAttribLocation(program, binding[0], binding[1]);
      }
    }

    gl.linkProgram(program);
    check$1.linkError(
      gl,
      program,
      stringStore.str(desc.fragId),
      stringStore.str(desc.vertId),
      command);

    // -------------------------------
    // grab uniforms
    // -------------------------------
    var numUniforms = gl.getProgramParameter(program, GL_ACTIVE_UNIFORMS);
    if (config.profile) {
      desc.stats.uniformsCount = numUniforms;
    }
    var uniforms = desc.uniforms;
    for (i = 0; i < numUniforms; ++i) {
      info = gl.getActiveUniform(program, i);
      if (info) {
        if (info.size > 1) {
          for (var j = 0; j < info.size; ++j) {
            var name = info.name.replace('[0]', '[' + j + ']');
            insertActiveInfo(uniforms, new ActiveInfo(
              name,
              stringStore.id(name),
              gl.getUniformLocation(program, name),
              info));
          }
        }
        var uniName = info.name;
        if (info.size > 1) {
          uniName = uniName.replace('[0]', '');
        }
        insertActiveInfo(uniforms, new ActiveInfo(
          uniName,
          stringStore.id(uniName),
          gl.getUniformLocation(program, uniName),
          info));
      }
    }

    // -------------------------------
    // grab attributes
    // -------------------------------
    var numAttributes = gl.getProgramParameter(program, GL_ACTIVE_ATTRIBUTES);
    if (config.profile) {
      desc.stats.attributesCount = numAttributes;
    }

    var attributes = desc.attributes;
    for (i = 0; i < numAttributes; ++i) {
      info = gl.getActiveAttrib(program, i);
      if (info) {
        insertActiveInfo(attributes, new ActiveInfo(
          info.name,
          stringStore.id(info.name),
          gl.getAttribLocation(program, info.name),
          info));
      }
    }
  }

  if (config.profile) {
    stats.getMaxUniformsCount = function () {
      var m = 0;
      programList.forEach(function (desc) {
        if (desc.stats.uniformsCount > m) {
          m = desc.stats.uniformsCount;
        }
      });
      return m
    };

    stats.getMaxAttributesCount = function () {
      var m = 0;
      programList.forEach(function (desc) {
        if (desc.stats.attributesCount > m) {
          m = desc.stats.attributesCount;
        }
      });
      return m
    };
  }

  function restoreShaders () {
    fragShaders = {};
    vertShaders = {};
    for (var i = 0; i < programList.length; ++i) {
      linkProgram(programList[i], null, programList[i].attributes.map(function (info) {
        return [info.location, info.name]
      }));
    }
  }

  return {
    clear: function () {
      var deleteShader = gl.deleteShader.bind(gl);
      values(fragShaders).forEach(deleteShader);
      fragShaders = {};
      values(vertShaders).forEach(deleteShader);
      vertShaders = {};

      programList.forEach(function (desc) {
        gl.deleteProgram(desc.program);
      });
      programList.length = 0;
      programCache = {};

      stats.shaderCount = 0;
    },

    program: function (vertId, fragId, command, attribLocations) {
      check$1.command(vertId >= 0, 'missing vertex shader', command);
      check$1.command(fragId >= 0, 'missing fragment shader', command);

      var cache = programCache[fragId];
      if (!cache) {
        cache = programCache[fragId] = {};
      }
      var prevProgram = cache[vertId];
      if (prevProgram) {
        prevProgram.refCount++;
        if (!attribLocations) {
          return prevProgram
        }
      }
      var program = new REGLProgram(fragId, vertId);
      stats.shaderCount++;
      linkProgram(program, command, attribLocations);
      if (!prevProgram) {
        cache[vertId] = program;
      }
      programList.push(program);
      return extend(program, {
        destroy: function () {
          program.refCount--;
          if (program.refCount <= 0) {
            gl.deleteProgram(program.program);
            var idx = programList.indexOf(program);
            programList.splice(idx, 1);
            stats.shaderCount--;
          }
          // no program is linked to this vert anymore
          if (cache[program.vertId].refCount <= 0) {
            gl.deleteShader(vertShaders[program.vertId]);
            delete vertShaders[program.vertId];
            delete programCache[program.fragId][program.vertId];
          }
          // no program is linked to this frag anymore
          if (!Object.keys(programCache[program.fragId]).length) {
            gl.deleteShader(fragShaders[program.fragId]);
            delete fragShaders[program.fragId];
            delete programCache[program.fragId];
          }
        }
      })
    },

    restore: restoreShaders,

    shader: getShader,

    frag: -1,
    vert: -1
  }
}

var GL_RGBA$3 = 6408;
var GL_UNSIGNED_BYTE$7 = 5121;
var GL_PACK_ALIGNMENT = 0x0D05;
var GL_FLOAT$7 = 0x1406; // 5126

function wrapReadPixels (
  gl,
  framebufferState,
  reglPoll,
  context,
  glAttributes,
  extensions,
  limits) {
  function readPixelsImpl (input) {
    var type;
    if (framebufferState.next === null) {
      check$1(
        glAttributes.preserveDrawingBuffer,
        'you must create a webgl context with "preserveDrawingBuffer":true in order to read pixels from the drawing buffer');
      type = GL_UNSIGNED_BYTE$7;
    } else {
      check$1(
        framebufferState.next.colorAttachments[0].texture !== null,
        'You cannot read from a renderbuffer');
      type = framebufferState.next.colorAttachments[0].texture._texture.type;

      check$1.optional(function () {
        if (extensions.oes_texture_float) {
          check$1(
            type === GL_UNSIGNED_BYTE$7 || type === GL_FLOAT$7,
            'Reading from a framebuffer is only allowed for the types \'uint8\' and \'float\'');

          if (type === GL_FLOAT$7) {
            check$1(limits.readFloat, 'Reading \'float\' values is not permitted in your browser. For a fallback, please see: https://www.npmjs.com/package/glsl-read-float');
          }
        } else {
          check$1(
            type === GL_UNSIGNED_BYTE$7,
            'Reading from a framebuffer is only allowed for the type \'uint8\'');
        }
      });
    }

    var x = 0;
    var y = 0;
    var width = context.framebufferWidth;
    var height = context.framebufferHeight;
    var data = null;

    if (isTypedArray(input)) {
      data = input;
    } else if (input) {
      check$1.type(input, 'object', 'invalid arguments to regl.read()');
      x = input.x | 0;
      y = input.y | 0;
      check$1(
        x >= 0 && x < context.framebufferWidth,
        'invalid x offset for regl.read');
      check$1(
        y >= 0 && y < context.framebufferHeight,
        'invalid y offset for regl.read');
      width = (input.width || (context.framebufferWidth - x)) | 0;
      height = (input.height || (context.framebufferHeight - y)) | 0;
      data = input.data || null;
    }

    // sanity check input.data
    if (data) {
      if (type === GL_UNSIGNED_BYTE$7) {
        check$1(
          data instanceof Uint8Array,
          'buffer must be \'Uint8Array\' when reading from a framebuffer of type \'uint8\'');
      } else if (type === GL_FLOAT$7) {
        check$1(
          data instanceof Float32Array,
          'buffer must be \'Float32Array\' when reading from a framebuffer of type \'float\'');
      }
    }

    check$1(
      width > 0 && width + x <= context.framebufferWidth,
      'invalid width for read pixels');
    check$1(
      height > 0 && height + y <= context.framebufferHeight,
      'invalid height for read pixels');

    // Update WebGL state
    reglPoll();

    // Compute size
    var size = width * height * 4;

    // Allocate data
    if (!data) {
      if (type === GL_UNSIGNED_BYTE$7) {
        data = new Uint8Array(size);
      } else if (type === GL_FLOAT$7) {
        data = data || new Float32Array(size);
      }
    }

    // Type check
    check$1.isTypedArray(data, 'data buffer for regl.read() must be a typedarray');
    check$1(data.byteLength >= size, 'data buffer for regl.read() too small');

    // Run read pixels
    gl.pixelStorei(GL_PACK_ALIGNMENT, 4);
    gl.readPixels(x, y, width, height, GL_RGBA$3,
      type,
      data);

    return data
  }

  function readPixelsFBO (options) {
    var result;
    framebufferState.setFBO({
      framebuffer: options.framebuffer
    }, function () {
      result = readPixelsImpl(options);
    });
    return result
  }

  function readPixels (options) {
    if (!options || !('framebuffer' in options)) {
      return readPixelsImpl(options)
    } else {
      return readPixelsFBO(options)
    }
  }

  return readPixels
}

function slice (x) {
  return Array.prototype.slice.call(x)
}

function join (x) {
  return slice(x).join('')
}

function createEnvironment () {
  // Unique variable id counter
  var varCounter = 0;

  // Linked values are passed from this scope into the generated code block
  // Calling link() passes a value into the generated scope and returns
  // the variable name which it is bound to
  var linkedNames = [];
  var linkedValues = [];
  function link (value) {
    for (var i = 0; i < linkedValues.length; ++i) {
      if (linkedValues[i] === value) {
        return linkedNames[i]
      }
    }

    var name = 'g' + (varCounter++);
    linkedNames.push(name);
    linkedValues.push(value);
    return name
  }

  // create a code block
  function block () {
    var code = [];
    function push () {
      code.push.apply(code, slice(arguments));
    }

    var vars = [];
    function def () {
      var name = 'v' + (varCounter++);
      vars.push(name);

      if (arguments.length > 0) {
        code.push(name, '=');
        code.push.apply(code, slice(arguments));
        code.push(';');
      }

      return name
    }

    return extend(push, {
      def: def,
      toString: function () {
        return join([
          (vars.length > 0 ? 'var ' + vars.join(',') + ';' : ''),
          join(code)
        ])
      }
    })
  }

  function scope () {
    var entry = block();
    var exit = block();

    var entryToString = entry.toString;
    var exitToString = exit.toString;

    function save (object, prop) {
      exit(object, prop, '=', entry.def(object, prop), ';');
    }

    return extend(function () {
      entry.apply(entry, slice(arguments));
    }, {
      def: entry.def,
      entry: entry,
      exit: exit,
      save: save,
      set: function (object, prop, value) {
        save(object, prop);
        entry(object, prop, '=', value, ';');
      },
      toString: function () {
        return entryToString() + exitToString()
      }
    })
  }

  function conditional () {
    var pred = join(arguments);
    var thenBlock = scope();
    var elseBlock = scope();

    var thenToString = thenBlock.toString;
    var elseToString = elseBlock.toString;

    return extend(thenBlock, {
      then: function () {
        thenBlock.apply(thenBlock, slice(arguments));
        return this
      },
      else: function () {
        elseBlock.apply(elseBlock, slice(arguments));
        return this
      },
      toString: function () {
        var elseClause = elseToString();
        if (elseClause) {
          elseClause = 'else{' + elseClause + '}';
        }
        return join([
          'if(', pred, '){',
          thenToString(),
          '}', elseClause
        ])
      }
    })
  }

  // procedure list
  var globalBlock = block();
  var procedures = {};
  function proc (name, count) {
    var args = [];
    function arg () {
      var name = 'a' + args.length;
      args.push(name);
      return name
    }

    count = count || 0;
    for (var i = 0; i < count; ++i) {
      arg();
    }

    var body = scope();
    var bodyToString = body.toString;

    var result = procedures[name] = extend(body, {
      arg: arg,
      toString: function () {
        return join([
          'function(', args.join(), '){',
          bodyToString(),
          '}'
        ])
      }
    });

    return result
  }

  function compile () {
    var code = ['"use strict";',
      globalBlock,
      'return {'];
    Object.keys(procedures).forEach(function (name) {
      code.push('"', name, '":', procedures[name].toString(), ',');
    });
    code.push('}');
    var src = join(code)
      .replace(/;/g, ';\n')
      .replace(/}/g, '}\n')
      .replace(/{/g, '{\n');
    var proc = Function.apply(null, linkedNames.concat(src));
    return proc.apply(null, linkedValues)
  }

  return {
    global: globalBlock,
    link: link,
    block: block,
    proc: proc,
    scope: scope,
    cond: conditional,
    compile: compile
  }
}

// "cute" names for vector components
var CUTE_COMPONENTS = 'xyzw'.split('');

var GL_UNSIGNED_BYTE$8 = 5121;

var ATTRIB_STATE_POINTER = 1;
var ATTRIB_STATE_CONSTANT = 2;

var DYN_FUNC$1 = 0;
var DYN_PROP$1 = 1;
var DYN_CONTEXT$1 = 2;
var DYN_STATE$1 = 3;
var DYN_THUNK = 4;
var DYN_CONSTANT$1 = 5;
var DYN_ARRAY$1 = 6;

var S_DITHER = 'dither';
var S_BLEND_ENABLE = 'blend.enable';
var S_BLEND_COLOR = 'blend.color';
var S_BLEND_EQUATION = 'blend.equation';
var S_BLEND_FUNC = 'blend.func';
var S_DEPTH_ENABLE = 'depth.enable';
var S_DEPTH_FUNC = 'depth.func';
var S_DEPTH_RANGE = 'depth.range';
var S_DEPTH_MASK = 'depth.mask';
var S_COLOR_MASK = 'colorMask';
var S_CULL_ENABLE = 'cull.enable';
var S_CULL_FACE = 'cull.face';
var S_FRONT_FACE = 'frontFace';
var S_LINE_WIDTH = 'lineWidth';
var S_POLYGON_OFFSET_ENABLE = 'polygonOffset.enable';
var S_POLYGON_OFFSET_OFFSET = 'polygonOffset.offset';
var S_SAMPLE_ALPHA = 'sample.alpha';
var S_SAMPLE_ENABLE = 'sample.enable';
var S_SAMPLE_COVERAGE = 'sample.coverage';
var S_STENCIL_ENABLE = 'stencil.enable';
var S_STENCIL_MASK = 'stencil.mask';
var S_STENCIL_FUNC = 'stencil.func';
var S_STENCIL_OPFRONT = 'stencil.opFront';
var S_STENCIL_OPBACK = 'stencil.opBack';
var S_SCISSOR_ENABLE = 'scissor.enable';
var S_SCISSOR_BOX = 'scissor.box';
var S_VIEWPORT = 'viewport';

var S_PROFILE = 'profile';

var S_FRAMEBUFFER = 'framebuffer';
var S_VERT = 'vert';
var S_FRAG = 'frag';
var S_ELEMENTS = 'elements';
var S_PRIMITIVE = 'primitive';
var S_COUNT = 'count';
var S_OFFSET = 'offset';
var S_INSTANCES = 'instances';
var S_VAO = 'vao';

var SUFFIX_WIDTH = 'Width';
var SUFFIX_HEIGHT = 'Height';

var S_FRAMEBUFFER_WIDTH = S_FRAMEBUFFER + SUFFIX_WIDTH;
var S_FRAMEBUFFER_HEIGHT = S_FRAMEBUFFER + SUFFIX_HEIGHT;
var S_VIEWPORT_WIDTH = S_VIEWPORT + SUFFIX_WIDTH;
var S_VIEWPORT_HEIGHT = S_VIEWPORT + SUFFIX_HEIGHT;
var S_DRAWINGBUFFER = 'drawingBuffer';
var S_DRAWINGBUFFER_WIDTH = S_DRAWINGBUFFER + SUFFIX_WIDTH;
var S_DRAWINGBUFFER_HEIGHT = S_DRAWINGBUFFER + SUFFIX_HEIGHT;

var NESTED_OPTIONS = [
  S_BLEND_FUNC,
  S_BLEND_EQUATION,
  S_STENCIL_FUNC,
  S_STENCIL_OPFRONT,
  S_STENCIL_OPBACK,
  S_SAMPLE_COVERAGE,
  S_VIEWPORT,
  S_SCISSOR_BOX,
  S_POLYGON_OFFSET_OFFSET
];

var GL_ARRAY_BUFFER$2 = 34962;
var GL_ELEMENT_ARRAY_BUFFER$2 = 34963;

var GL_FRAGMENT_SHADER$1 = 35632;
var GL_VERTEX_SHADER$1 = 35633;

var GL_TEXTURE_2D$3 = 0x0DE1;
var GL_TEXTURE_CUBE_MAP$2 = 0x8513;

var GL_CULL_FACE = 0x0B44;
var GL_BLEND = 0x0BE2;
var GL_DITHER = 0x0BD0;
var GL_STENCIL_TEST = 0x0B90;
var GL_DEPTH_TEST = 0x0B71;
var GL_SCISSOR_TEST = 0x0C11;
var GL_POLYGON_OFFSET_FILL = 0x8037;
var GL_SAMPLE_ALPHA_TO_COVERAGE = 0x809E;
var GL_SAMPLE_COVERAGE = 0x80A0;

var GL_FLOAT$8 = 5126;
var GL_FLOAT_VEC2 = 35664;
var GL_FLOAT_VEC3 = 35665;
var GL_FLOAT_VEC4 = 35666;
var GL_INT$3 = 5124;
var GL_INT_VEC2 = 35667;
var GL_INT_VEC3 = 35668;
var GL_INT_VEC4 = 35669;
var GL_BOOL = 35670;
var GL_BOOL_VEC2 = 35671;
var GL_BOOL_VEC3 = 35672;
var GL_BOOL_VEC4 = 35673;
var GL_FLOAT_MAT2 = 35674;
var GL_FLOAT_MAT3 = 35675;
var GL_FLOAT_MAT4 = 35676;
var GL_SAMPLER_2D = 35678;
var GL_SAMPLER_CUBE = 35680;

var GL_TRIANGLES$1 = 4;

var GL_FRONT = 1028;
var GL_BACK = 1029;
var GL_CW = 0x0900;
var GL_CCW = 0x0901;
var GL_MIN_EXT = 0x8007;
var GL_MAX_EXT = 0x8008;
var GL_ALWAYS = 519;
var GL_KEEP = 7680;
var GL_ZERO = 0;
var GL_ONE = 1;
var GL_FUNC_ADD = 0x8006;
var GL_LESS = 513;

var GL_FRAMEBUFFER$2 = 0x8D40;
var GL_COLOR_ATTACHMENT0$2 = 0x8CE0;

var blendFuncs = {
  '0': 0,
  '1': 1,
  'zero': 0,
  'one': 1,
  'src color': 768,
  'one minus src color': 769,
  'src alpha': 770,
  'one minus src alpha': 771,
  'dst color': 774,
  'one minus dst color': 775,
  'dst alpha': 772,
  'one minus dst alpha': 773,
  'constant color': 32769,
  'one minus constant color': 32770,
  'constant alpha': 32771,
  'one minus constant alpha': 32772,
  'src alpha saturate': 776
};

// There are invalid values for srcRGB and dstRGB. See:
// https://www.khronos.org/registry/webgl/specs/1.0/#6.13
// https://github.com/KhronosGroup/WebGL/blob/0d3201f5f7ec3c0060bc1f04077461541f1987b9/conformance-suites/1.0.3/conformance/misc/webgl-specific.html#L56
var invalidBlendCombinations = [
  'constant color, constant alpha',
  'one minus constant color, constant alpha',
  'constant color, one minus constant alpha',
  'one minus constant color, one minus constant alpha',
  'constant alpha, constant color',
  'constant alpha, one minus constant color',
  'one minus constant alpha, constant color',
  'one minus constant alpha, one minus constant color'
];

var compareFuncs = {
  'never': 512,
  'less': 513,
  '<': 513,
  'equal': 514,
  '=': 514,
  '==': 514,
  '===': 514,
  'lequal': 515,
  '<=': 515,
  'greater': 516,
  '>': 516,
  'notequal': 517,
  '!=': 517,
  '!==': 517,
  'gequal': 518,
  '>=': 518,
  'always': 519
};

var stencilOps = {
  '0': 0,
  'zero': 0,
  'keep': 7680,
  'replace': 7681,
  'increment': 7682,
  'decrement': 7683,
  'increment wrap': 34055,
  'decrement wrap': 34056,
  'invert': 5386
};

var shaderType = {
  'frag': GL_FRAGMENT_SHADER$1,
  'vert': GL_VERTEX_SHADER$1
};

var orientationType = {
  'cw': GL_CW,
  'ccw': GL_CCW
};

function isBufferArgs (x) {
  return Array.isArray(x) ||
    isTypedArray(x) ||
    isNDArrayLike(x)
}

// Make sure viewport is processed first
function sortState (state) {
  return state.sort(function (a, b) {
    if (a === S_VIEWPORT) {
      return -1
    } else if (b === S_VIEWPORT) {
      return 1
    }
    return (a < b) ? -1 : 1
  })
}

function Declaration (thisDep, contextDep, propDep, append) {
  this.thisDep = thisDep;
  this.contextDep = contextDep;
  this.propDep = propDep;
  this.append = append;
}

function isStatic (decl) {
  return decl && !(decl.thisDep || decl.contextDep || decl.propDep)
}

function createStaticDecl (append) {
  return new Declaration(false, false, false, append)
}

function createDynamicDecl (dyn, append) {
  var type = dyn.type;
  if (type === DYN_FUNC$1) {
    var numArgs = dyn.data.length;
    return new Declaration(
      true,
      numArgs >= 1,
      numArgs >= 2,
      append)
  } else if (type === DYN_THUNK) {
    var data = dyn.data;
    return new Declaration(
      data.thisDep,
      data.contextDep,
      data.propDep,
      append)
  } else if (type === DYN_CONSTANT$1) {
    return new Declaration(
      false,
      false,
      false,
      append)
  } else if (type === DYN_ARRAY$1) {
    var thisDep = false;
    var contextDep = false;
    var propDep = false;
    for (var i = 0; i < dyn.data.length; ++i) {
      var subDyn = dyn.data[i];
      if (subDyn.type === DYN_PROP$1) {
        propDep = true;
      } else if (subDyn.type === DYN_CONTEXT$1) {
        contextDep = true;
      } else if (subDyn.type === DYN_STATE$1) {
        thisDep = true;
      } else if (subDyn.type === DYN_FUNC$1) {
        thisDep = true;
        var subArgs = subDyn.data;
        if (subArgs >= 1) {
          contextDep = true;
        }
        if (subArgs >= 2) {
          propDep = true;
        }
      } else if (subDyn.type === DYN_THUNK) {
        thisDep = thisDep || subDyn.data.thisDep;
        contextDep = contextDep || subDyn.data.contextDep;
        propDep = propDep || subDyn.data.propDep;
      }
    }
    return new Declaration(
      thisDep,
      contextDep,
      propDep,
      append)
  } else {
    return new Declaration(
      type === DYN_STATE$1,
      type === DYN_CONTEXT$1,
      type === DYN_PROP$1,
      append)
  }
}

var SCOPE_DECL = new Declaration(false, false, false, function () {});

function reglCore (
  gl,
  stringStore,
  extensions,
  limits,
  bufferState,
  elementState,
  textureState,
  framebufferState,
  uniformState,
  attributeState,
  shaderState,
  drawState,
  contextState,
  timer,
  config) {
  var AttributeRecord = attributeState.Record;

  var blendEquations = {
    'add': 32774,
    'subtract': 32778,
    'reverse subtract': 32779
  };
  if (extensions.ext_blend_minmax) {
    blendEquations.min = GL_MIN_EXT;
    blendEquations.max = GL_MAX_EXT;
  }

  var extInstancing = extensions.angle_instanced_arrays;
  var extDrawBuffers = extensions.webgl_draw_buffers;
  var extVertexArrays = extensions.oes_vertex_array_object;

  // ===================================================
  // ===================================================
  // WEBGL STATE
  // ===================================================
  // ===================================================
  var currentState = {
    dirty: true,
    profile: config.profile
  };
  var nextState = {};
  var GL_STATE_NAMES = [];
  var GL_FLAGS = {};
  var GL_VARIABLES = {};

  function propName (name) {
    return name.replace('.', '_')
  }

  function stateFlag (sname, cap, init) {
    var name = propName(sname);
    GL_STATE_NAMES.push(sname);
    nextState[name] = currentState[name] = !!init;
    GL_FLAGS[name] = cap;
  }

  function stateVariable (sname, func, init) {
    var name = propName(sname);
    GL_STATE_NAMES.push(sname);
    if (Array.isArray(init)) {
      currentState[name] = init.slice();
      nextState[name] = init.slice();
    } else {
      currentState[name] = nextState[name] = init;
    }
    GL_VARIABLES[name] = func;
  }

  // Dithering
  stateFlag(S_DITHER, GL_DITHER);

  // Blending
  stateFlag(S_BLEND_ENABLE, GL_BLEND);
  stateVariable(S_BLEND_COLOR, 'blendColor', [0, 0, 0, 0]);
  stateVariable(S_BLEND_EQUATION, 'blendEquationSeparate',
    [GL_FUNC_ADD, GL_FUNC_ADD]);
  stateVariable(S_BLEND_FUNC, 'blendFuncSeparate',
    [GL_ONE, GL_ZERO, GL_ONE, GL_ZERO]);

  // Depth
  stateFlag(S_DEPTH_ENABLE, GL_DEPTH_TEST, true);
  stateVariable(S_DEPTH_FUNC, 'depthFunc', GL_LESS);
  stateVariable(S_DEPTH_RANGE, 'depthRange', [0, 1]);
  stateVariable(S_DEPTH_MASK, 'depthMask', true);

  // Color mask
  stateVariable(S_COLOR_MASK, S_COLOR_MASK, [true, true, true, true]);

  // Face culling
  stateFlag(S_CULL_ENABLE, GL_CULL_FACE);
  stateVariable(S_CULL_FACE, 'cullFace', GL_BACK);

  // Front face orientation
  stateVariable(S_FRONT_FACE, S_FRONT_FACE, GL_CCW);

  // Line width
  stateVariable(S_LINE_WIDTH, S_LINE_WIDTH, 1);

  // Polygon offset
  stateFlag(S_POLYGON_OFFSET_ENABLE, GL_POLYGON_OFFSET_FILL);
  stateVariable(S_POLYGON_OFFSET_OFFSET, 'polygonOffset', [0, 0]);

  // Sample coverage
  stateFlag(S_SAMPLE_ALPHA, GL_SAMPLE_ALPHA_TO_COVERAGE);
  stateFlag(S_SAMPLE_ENABLE, GL_SAMPLE_COVERAGE);
  stateVariable(S_SAMPLE_COVERAGE, 'sampleCoverage', [1, false]);

  // Stencil
  stateFlag(S_STENCIL_ENABLE, GL_STENCIL_TEST);
  stateVariable(S_STENCIL_MASK, 'stencilMask', -1);
  stateVariable(S_STENCIL_FUNC, 'stencilFunc', [GL_ALWAYS, 0, -1]);
  stateVariable(S_STENCIL_OPFRONT, 'stencilOpSeparate',
    [GL_FRONT, GL_KEEP, GL_KEEP, GL_KEEP]);
  stateVariable(S_STENCIL_OPBACK, 'stencilOpSeparate',
    [GL_BACK, GL_KEEP, GL_KEEP, GL_KEEP]);

  // Scissor
  stateFlag(S_SCISSOR_ENABLE, GL_SCISSOR_TEST);
  stateVariable(S_SCISSOR_BOX, 'scissor',
    [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight]);

  // Viewport
  stateVariable(S_VIEWPORT, S_VIEWPORT,
    [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight]);

  // ===================================================
  // ===================================================
  // ENVIRONMENT
  // ===================================================
  // ===================================================
  var sharedState = {
    gl: gl,
    context: contextState,
    strings: stringStore,
    next: nextState,
    current: currentState,
    draw: drawState,
    elements: elementState,
    buffer: bufferState,
    shader: shaderState,
    attributes: attributeState.state,
    vao: attributeState,
    uniforms: uniformState,
    framebuffer: framebufferState,
    extensions: extensions,

    timer: timer,
    isBufferArgs: isBufferArgs
  };

  var sharedConstants = {
    primTypes: primTypes,
    compareFuncs: compareFuncs,
    blendFuncs: blendFuncs,
    blendEquations: blendEquations,
    stencilOps: stencilOps,
    glTypes: glTypes,
    orientationType: orientationType
  };

  check$1.optional(function () {
    sharedState.isArrayLike = isArrayLike;
  });

  if (extDrawBuffers) {
    sharedConstants.backBuffer = [GL_BACK];
    sharedConstants.drawBuffer = loop(limits.maxDrawbuffers, function (i) {
      if (i === 0) {
        return [0]
      }
      return loop(i, function (j) {
        return GL_COLOR_ATTACHMENT0$2 + j
      })
    });
  }

  var drawCallCounter = 0;
  function createREGLEnvironment () {
    var env = createEnvironment();
    var link = env.link;
    var global = env.global;
    env.id = drawCallCounter++;

    env.batchId = '0';

    // link shared state
    var SHARED = link(sharedState);
    var shared = env.shared = {
      props: 'a0'
    };
    Object.keys(sharedState).forEach(function (prop) {
      shared[prop] = global.def(SHARED, '.', prop);
    });

    // Inject runtime assertion stuff for debug builds
    check$1.optional(function () {
      env.CHECK = link(check$1);
      env.commandStr = check$1.guessCommand();
      env.command = link(env.commandStr);
      env.assert = function (block, pred, message) {
        block(
          'if(!(', pred, '))',
          this.CHECK, '.commandRaise(', link(message), ',', this.command, ');');
      };

      sharedConstants.invalidBlendCombinations = invalidBlendCombinations;
    });

    // Copy GL state variables over
    var nextVars = env.next = {};
    var currentVars = env.current = {};
    Object.keys(GL_VARIABLES).forEach(function (variable) {
      if (Array.isArray(currentState[variable])) {
        nextVars[variable] = global.def(shared.next, '.', variable);
        currentVars[variable] = global.def(shared.current, '.', variable);
      }
    });

    // Initialize shared constants
    var constants = env.constants = {};
    Object.keys(sharedConstants).forEach(function (name) {
      constants[name] = global.def(JSON.stringify(sharedConstants[name]));
    });

    // Helper function for calling a block
    env.invoke = function (block, x) {
      switch (x.type) {
        case DYN_FUNC$1:
          var argList = [
            'this',
            shared.context,
            shared.props,
            env.batchId
          ];
          return block.def(
            link(x.data), '.call(',
            argList.slice(0, Math.max(x.data.length + 1, 4)),
            ')')
        case DYN_PROP$1:
          return block.def(shared.props, x.data)
        case DYN_CONTEXT$1:
          return block.def(shared.context, x.data)
        case DYN_STATE$1:
          return block.def('this', x.data)
        case DYN_THUNK:
          x.data.append(env, block);
          return x.data.ref
        case DYN_CONSTANT$1:
          return x.data.toString()
        case DYN_ARRAY$1:
          return x.data.map(function (y) {
            return env.invoke(block, y)
          })
      }
    };

    env.attribCache = {};

    var scopeAttribs = {};
    env.scopeAttrib = function (name) {
      var id = stringStore.id(name);
      if (id in scopeAttribs) {
        return scopeAttribs[id]
      }
      var binding = attributeState.scope[id];
      if (!binding) {
        binding = attributeState.scope[id] = new AttributeRecord();
      }
      var result = scopeAttribs[id] = link(binding);
      return result
    };

    return env
  }

  // ===================================================
  // ===================================================
  // PARSING
  // ===================================================
  // ===================================================
  function parseProfile (options) {
    var staticOptions = options.static;
    var dynamicOptions = options.dynamic;

    var profileEnable;
    if (S_PROFILE in staticOptions) {
      var value = !!staticOptions[S_PROFILE];
      profileEnable = createStaticDecl(function (env, scope) {
        return value
      });
      profileEnable.enable = value;
    } else if (S_PROFILE in dynamicOptions) {
      var dyn = dynamicOptions[S_PROFILE];
      profileEnable = createDynamicDecl(dyn, function (env, scope) {
        return env.invoke(scope, dyn)
      });
    }

    return profileEnable
  }

  function parseFramebuffer (options, env) {
    var staticOptions = options.static;
    var dynamicOptions = options.dynamic;

    if (S_FRAMEBUFFER in staticOptions) {
      var framebuffer = staticOptions[S_FRAMEBUFFER];
      if (framebuffer) {
        framebuffer = framebufferState.getFramebuffer(framebuffer);
        check$1.command(framebuffer, 'invalid framebuffer object');
        return createStaticDecl(function (env, block) {
          var FRAMEBUFFER = env.link(framebuffer);
          var shared = env.shared;
          block.set(
            shared.framebuffer,
            '.next',
            FRAMEBUFFER);
          var CONTEXT = shared.context;
          block.set(
            CONTEXT,
            '.' + S_FRAMEBUFFER_WIDTH,
            FRAMEBUFFER + '.width');
          block.set(
            CONTEXT,
            '.' + S_FRAMEBUFFER_HEIGHT,
            FRAMEBUFFER + '.height');
          return FRAMEBUFFER
        })
      } else {
        return createStaticDecl(function (env, scope) {
          var shared = env.shared;
          scope.set(
            shared.framebuffer,
            '.next',
            'null');
          var CONTEXT = shared.context;
          scope.set(
            CONTEXT,
            '.' + S_FRAMEBUFFER_WIDTH,
            CONTEXT + '.' + S_DRAWINGBUFFER_WIDTH);
          scope.set(
            CONTEXT,
            '.' + S_FRAMEBUFFER_HEIGHT,
            CONTEXT + '.' + S_DRAWINGBUFFER_HEIGHT);
          return 'null'
        })
      }
    } else if (S_FRAMEBUFFER in dynamicOptions) {
      var dyn = dynamicOptions[S_FRAMEBUFFER];
      return createDynamicDecl(dyn, function (env, scope) {
        var FRAMEBUFFER_FUNC = env.invoke(scope, dyn);
        var shared = env.shared;
        var FRAMEBUFFER_STATE = shared.framebuffer;
        var FRAMEBUFFER = scope.def(
          FRAMEBUFFER_STATE, '.getFramebuffer(', FRAMEBUFFER_FUNC, ')');

        check$1.optional(function () {
          env.assert(scope,
            '!' + FRAMEBUFFER_FUNC + '||' + FRAMEBUFFER,
            'invalid framebuffer object');
        });

        scope.set(
          FRAMEBUFFER_STATE,
          '.next',
          FRAMEBUFFER);
        var CONTEXT = shared.context;
        scope.set(
          CONTEXT,
          '.' + S_FRAMEBUFFER_WIDTH,
          FRAMEBUFFER + '?' + FRAMEBUFFER + '.width:' +
          CONTEXT + '.' + S_DRAWINGBUFFER_WIDTH);
        scope.set(
          CONTEXT,
          '.' + S_FRAMEBUFFER_HEIGHT,
          FRAMEBUFFER +
          '?' + FRAMEBUFFER + '.height:' +
          CONTEXT + '.' + S_DRAWINGBUFFER_HEIGHT);
        return FRAMEBUFFER
      })
    } else {
      return null
    }
  }

  function parseViewportScissor (options, framebuffer, env) {
    var staticOptions = options.static;
    var dynamicOptions = options.dynamic;

    function parseBox (param) {
      if (param in staticOptions) {
        var box = staticOptions[param];
        check$1.commandType(box, 'object', 'invalid ' + param, env.commandStr);

        var isStatic = true;
        var x = box.x | 0;
        var y = box.y | 0;
        var w, h;
        if ('width' in box) {
          w = box.width | 0;
          check$1.command(w >= 0, 'invalid ' + param, env.commandStr);
        } else {
          isStatic = false;
        }
        if ('height' in box) {
          h = box.height | 0;
          check$1.command(h >= 0, 'invalid ' + param, env.commandStr);
        } else {
          isStatic = false;
        }

        return new Declaration(
          !isStatic && framebuffer && framebuffer.thisDep,
          !isStatic && framebuffer && framebuffer.contextDep,
          !isStatic && framebuffer && framebuffer.propDep,
          function (env, scope) {
            var CONTEXT = env.shared.context;
            var BOX_W = w;
            if (!('width' in box)) {
              BOX_W = scope.def(CONTEXT, '.', S_FRAMEBUFFER_WIDTH, '-', x);
            }
            var BOX_H = h;
            if (!('height' in box)) {
              BOX_H = scope.def(CONTEXT, '.', S_FRAMEBUFFER_HEIGHT, '-', y);
            }
            return [x, y, BOX_W, BOX_H]
          })
      } else if (param in dynamicOptions) {
        var dynBox = dynamicOptions[param];
        var result = createDynamicDecl(dynBox, function (env, scope) {
          var BOX = env.invoke(scope, dynBox);

          check$1.optional(function () {
            env.assert(scope,
              BOX + '&&typeof ' + BOX + '==="object"',
              'invalid ' + param);
          });

          var CONTEXT = env.shared.context;
          var BOX_X = scope.def(BOX, '.x|0');
          var BOX_Y = scope.def(BOX, '.y|0');
          var BOX_W = scope.def(
            '"width" in ', BOX, '?', BOX, '.width|0:',
            '(', CONTEXT, '.', S_FRAMEBUFFER_WIDTH, '-', BOX_X, ')');
          var BOX_H = scope.def(
            '"height" in ', BOX, '?', BOX, '.height|0:',
            '(', CONTEXT, '.', S_FRAMEBUFFER_HEIGHT, '-', BOX_Y, ')');

          check$1.optional(function () {
            env.assert(scope,
              BOX_W + '>=0&&' +
              BOX_H + '>=0',
              'invalid ' + param);
          });

          return [BOX_X, BOX_Y, BOX_W, BOX_H]
        });
        if (framebuffer) {
          result.thisDep = result.thisDep || framebuffer.thisDep;
          result.contextDep = result.contextDep || framebuffer.contextDep;
          result.propDep = result.propDep || framebuffer.propDep;
        }
        return result
      } else if (framebuffer) {
        return new Declaration(
          framebuffer.thisDep,
          framebuffer.contextDep,
          framebuffer.propDep,
          function (env, scope) {
            var CONTEXT = env.shared.context;
            return [
              0, 0,
              scope.def(CONTEXT, '.', S_FRAMEBUFFER_WIDTH),
              scope.def(CONTEXT, '.', S_FRAMEBUFFER_HEIGHT)]
          })
      } else {
        return null
      }
    }

    var viewport = parseBox(S_VIEWPORT);

    if (viewport) {
      var prevViewport = viewport;
      viewport = new Declaration(
        viewport.thisDep,
        viewport.contextDep,
        viewport.propDep,
        function (env, scope) {
          var VIEWPORT = prevViewport.append(env, scope);
          var CONTEXT = env.shared.context;
          scope.set(
            CONTEXT,
            '.' + S_VIEWPORT_WIDTH,
            VIEWPORT[2]);
          scope.set(
            CONTEXT,
            '.' + S_VIEWPORT_HEIGHT,
            VIEWPORT[3]);
          return VIEWPORT
        });
    }

    return {
      viewport: viewport,
      scissor_box: parseBox(S_SCISSOR_BOX)
    }
  }

  function parseAttribLocations (options, attributes) {
    var staticOptions = options.static;
    var staticProgram =
      typeof staticOptions[S_FRAG] === 'string' &&
      typeof staticOptions[S_VERT] === 'string';
    if (staticProgram) {
      if (Object.keys(attributes.dynamic).length > 0) {
        return null
      }
      var staticAttributes = attributes.static;
      var sAttributes = Object.keys(staticAttributes);
      if (sAttributes.length > 0 && typeof staticAttributes[sAttributes[0]] === 'number') {
        var bindings = [];
        for (var i = 0; i < sAttributes.length; ++i) {
          check$1(typeof staticAttributes[sAttributes[i]] === 'number', 'must specify all vertex attribute locations when using vaos');
          bindings.push([staticAttributes[sAttributes[i]] | 0, sAttributes[i]]);
        }
        return bindings
      }
    }
    return null
  }

  function parseProgram (options, env, attribLocations) {
    var staticOptions = options.static;
    var dynamicOptions = options.dynamic;

    function parseShader (name) {
      if (name in staticOptions) {
        var id = stringStore.id(staticOptions[name]);
        check$1.optional(function () {
          shaderState.shader(shaderType[name], id, check$1.guessCommand());
        });
        var result = createStaticDecl(function () {
          return id
        });
        result.id = id;
        return result
      } else if (name in dynamicOptions) {
        var dyn = dynamicOptions[name];
        return createDynamicDecl(dyn, function (env, scope) {
          var str = env.invoke(scope, dyn);
          var id = scope.def(env.shared.strings, '.id(', str, ')');
          check$1.optional(function () {
            scope(
              env.shared.shader, '.shader(',
              shaderType[name], ',',
              id, ',',
              env.command, ');');
          });
          return id
        })
      }
      return null
    }

    var frag = parseShader(S_FRAG);
    var vert = parseShader(S_VERT);

    var program = null;
    var progVar;
    if (isStatic(frag) && isStatic(vert)) {
      program = shaderState.program(vert.id, frag.id, null, attribLocations);
      progVar = createStaticDecl(function (env, scope) {
        return env.link(program)
      });
    } else {
      progVar = new Declaration(
        (frag && frag.thisDep) || (vert && vert.thisDep),
        (frag && frag.contextDep) || (vert && vert.contextDep),
        (frag && frag.propDep) || (vert && vert.propDep),
        function (env, scope) {
          var SHADER_STATE = env.shared.shader;
          var fragId;
          if (frag) {
            fragId = frag.append(env, scope);
          } else {
            fragId = scope.def(SHADER_STATE, '.', S_FRAG);
          }
          var vertId;
          if (vert) {
            vertId = vert.append(env, scope);
          } else {
            vertId = scope.def(SHADER_STATE, '.', S_VERT);
          }
          var progDef = SHADER_STATE + '.program(' + vertId + ',' + fragId;
          check$1.optional(function () {
            progDef += ',' + env.command;
          });
          return scope.def(progDef + ')')
        });
    }

    return {
      frag: frag,
      vert: vert,
      progVar: progVar,
      program: program
    }
  }

  function parseDraw (options, env) {
    var staticOptions = options.static;
    var dynamicOptions = options.dynamic;

    // TODO: should use VAO to get default values for offset properties
    // should move vao parse into here and out of the old stuff

    var staticDraw = {};
    var vaoActive = false;

    function parseVAO () {
      if (S_VAO in staticOptions) {
        var vao = staticOptions[S_VAO];
        if (vao !== null && attributeState.getVAO(vao) === null) {
          vao = attributeState.createVAO(vao);
        }

        vaoActive = true;
        staticDraw.vao = vao;

        return createStaticDecl(function (env) {
          var vaoRef = attributeState.getVAO(vao);
          if (vaoRef) {
            return env.link(vaoRef)
          } else {
            return 'null'
          }
        })
      } else if (S_VAO in dynamicOptions) {
        vaoActive = true;
        var dyn = dynamicOptions[S_VAO];
        return createDynamicDecl(dyn, function (env, scope) {
          var vaoRef = env.invoke(scope, dyn);
          return scope.def(env.shared.vao + '.getVAO(' + vaoRef + ')')
        })
      }
      return null
    }

    var vao = parseVAO();

    var elementsActive = false;

    function parseElements () {
      if (S_ELEMENTS in staticOptions) {
        var elements = staticOptions[S_ELEMENTS];
        staticDraw.elements = elements;
        if (isBufferArgs(elements)) {
          var e = staticDraw.elements = elementState.create(elements, true);
          elements = elementState.getElements(e);
          elementsActive = true;
        } else if (elements) {
          elements = elementState.getElements(elements);
          elementsActive = true;
          check$1.command(elements, 'invalid elements', env.commandStr);
        }

        var result = createStaticDecl(function (env, scope) {
          if (elements) {
            var result = env.link(elements);
            env.ELEMENTS = result;
            return result
          }
          env.ELEMENTS = null;
          return null
        });
        result.value = elements;
        return result
      } else if (S_ELEMENTS in dynamicOptions) {
        elementsActive = true;

        var dyn = dynamicOptions[S_ELEMENTS];
        return createDynamicDecl(dyn, function (env, scope) {
          var shared = env.shared;

          var IS_BUFFER_ARGS = shared.isBufferArgs;
          var ELEMENT_STATE = shared.elements;

          var elementDefn = env.invoke(scope, dyn);
          var elements = scope.def('null');
          var elementStream = scope.def(IS_BUFFER_ARGS, '(', elementDefn, ')');

          var ifte = env.cond(elementStream)
            .then(elements, '=', ELEMENT_STATE, '.createStream(', elementDefn, ');')
            .else(elements, '=', ELEMENT_STATE, '.getElements(', elementDefn, ');');

          check$1.optional(function () {
            env.assert(ifte.else,
              '!' + elementDefn + '||' + elements,
              'invalid elements');
          });

          scope.entry(ifte);
          scope.exit(
            env.cond(elementStream)
              .then(ELEMENT_STATE, '.destroyStream(', elements, ');'));

          env.ELEMENTS = elements;

          return elements
        })
      } else if (vaoActive) {
        return new Declaration(
          vao.thisDep,
          vao.contextDep,
          vao.propDep,
          function (env, scope) {
            return scope.def(env.shared.vao + '.currentVAO?' + env.shared.elements + '.getElements(' + env.shared.vao + '.currentVAO.elements):null')
          })
      }
      return null
    }

    var elements = parseElements();

    function parsePrimitive () {
      if (S_PRIMITIVE in staticOptions) {
        var primitive = staticOptions[S_PRIMITIVE];
        staticDraw.primitive = primitive;
        check$1.commandParameter(primitive, primTypes, 'invalid primitve', env.commandStr);
        return createStaticDecl(function (env, scope) {
          return primTypes[primitive]
        })
      } else if (S_PRIMITIVE in dynamicOptions) {
        var dynPrimitive = dynamicOptions[S_PRIMITIVE];
        return createDynamicDecl(dynPrimitive, function (env, scope) {
          var PRIM_TYPES = env.constants.primTypes;
          var prim = env.invoke(scope, dynPrimitive);
          check$1.optional(function () {
            env.assert(scope,
              prim + ' in ' + PRIM_TYPES,
              'invalid primitive, must be one of ' + Object.keys(primTypes));
          });
          return scope.def(PRIM_TYPES, '[', prim, ']')
        })
      } else if (elementsActive) {
        if (isStatic(elements)) {
          if (elements.value) {
            return createStaticDecl(function (env, scope) {
              return scope.def(env.ELEMENTS, '.primType')
            })
          } else {
            return createStaticDecl(function () {
              return GL_TRIANGLES$1
            })
          }
        } else {
          return new Declaration(
            elements.thisDep,
            elements.contextDep,
            elements.propDep,
            function (env, scope) {
              var elements = env.ELEMENTS;
              return scope.def(elements, '?', elements, '.primType:', GL_TRIANGLES$1)
            })
        }
      } else if (vaoActive) {
        return new Declaration(
          vao.thisDep,
          vao.contextDep,
          vao.propDep,
          function (env, scope) {
            return scope.def(env.shared.vao + '.currentVAO?' + env.shared.vao + '.currentVAO.primitive:' + GL_TRIANGLES$1)
          })
      }
      return null
    }

    function parseParam (param, isOffset) {
      if (param in staticOptions) {
        var value = staticOptions[param] | 0;
        if (isOffset) {
          staticDraw.offset = value;
        } else {
          staticDraw.instances = value;
        }
        check$1.command(!isOffset || value >= 0, 'invalid ' + param, env.commandStr);
        return createStaticDecl(function (env, scope) {
          if (isOffset) {
            env.OFFSET = value;
          }
          return value
        })
      } else if (param in dynamicOptions) {
        var dynValue = dynamicOptions[param];
        return createDynamicDecl(dynValue, function (env, scope) {
          var result = env.invoke(scope, dynValue);
          if (isOffset) {
            env.OFFSET = result;
            check$1.optional(function () {
              env.assert(scope,
                result + '>=0',
                'invalid ' + param);
            });
          }
          return result
        })
      } else if (isOffset) {
        if (elementsActive) {
          return createStaticDecl(function (env, scope) {
            env.OFFSET = 0;
            return 0
          })
        } else if (vaoActive) {
          return new Declaration(
            vao.thisDep,
            vao.contextDep,
            vao.propDep,
            function (env, scope) {
              return scope.def(env.shared.vao + '.currentVAO?' + env.shared.vao + '.currentVAO.offset:0')
            })
        }
      } else if (vaoActive) {
        return new Declaration(
          vao.thisDep,
          vao.contextDep,
          vao.propDep,
          function (env, scope) {
            return scope.def(env.shared.vao + '.currentVAO?' + env.shared.vao + '.currentVAO.instances:-1')
          })
      }
      return null
    }

    var OFFSET = parseParam(S_OFFSET, true);

    function parseVertCount () {
      if (S_COUNT in staticOptions) {
        var count = staticOptions[S_COUNT] | 0;
        staticDraw.count = count;
        check$1.command(
          typeof count === 'number' && count >= 0, 'invalid vertex count', env.commandStr);
        return createStaticDecl(function () {
          return count
        })
      } else if (S_COUNT in dynamicOptions) {
        var dynCount = dynamicOptions[S_COUNT];
        return createDynamicDecl(dynCount, function (env, scope) {
          var result = env.invoke(scope, dynCount);
          check$1.optional(function () {
            env.assert(scope,
              'typeof ' + result + '==="number"&&' +
              result + '>=0&&' +
              result + '===(' + result + '|0)',
              'invalid vertex count');
          });
          return result
        })
      } else if (elementsActive) {
        if (isStatic(elements)) {
          if (elements) {
            if (OFFSET) {
              return new Declaration(
                OFFSET.thisDep,
                OFFSET.contextDep,
                OFFSET.propDep,
                function (env, scope) {
                  var result = scope.def(
                    env.ELEMENTS, '.vertCount-', env.OFFSET);

                  check$1.optional(function () {
                    env.assert(scope,
                      result + '>=0',
                      'invalid vertex offset/element buffer too small');
                  });

                  return result
                })
            } else {
              return createStaticDecl(function (env, scope) {
                return scope.def(env.ELEMENTS, '.vertCount')
              })
            }
          } else {
            var result = createStaticDecl(function () {
              return -1
            });
            check$1.optional(function () {
              result.MISSING = true;
            });
            return result
          }
        } else {
          var variable = new Declaration(
            elements.thisDep || OFFSET.thisDep,
            elements.contextDep || OFFSET.contextDep,
            elements.propDep || OFFSET.propDep,
            function (env, scope) {
              var elements = env.ELEMENTS;
              if (env.OFFSET) {
                return scope.def(elements, '?', elements, '.vertCount-',
                  env.OFFSET, ':-1')
              }
              return scope.def(elements, '?', elements, '.vertCount:-1')
            });
          check$1.optional(function () {
            variable.DYNAMIC = true;
          });
          return variable
        }
      } else if (vaoActive) {
        var countVariable = new Declaration(
          vao.thisDep,
          vao.contextDep,
          vao.propDep,
          function (env, scope) {
            return scope.def(env.shared.vao, '.currentVAO?', env.shared.vao, '.currentVAO.count:-1')
          });
        return countVariable
      }
      return null
    }

    var primitive = parsePrimitive();
    var count = parseVertCount();
    var instances = parseParam(S_INSTANCES, false);

    return {
      elements: elements,
      primitive: primitive,
      count: count,
      instances: instances,
      offset: OFFSET,
      vao: vao,

      vaoActive: vaoActive,
      elementsActive: elementsActive,

      // static draw props
      static: staticDraw
    }
  }

  function parseGLState (options, env) {
    var staticOptions = options.static;
    var dynamicOptions = options.dynamic;

    var STATE = {};

    GL_STATE_NAMES.forEach(function (prop) {
      var param = propName(prop);

      function parseParam (parseStatic, parseDynamic) {
        if (prop in staticOptions) {
          var value = parseStatic(staticOptions[prop]);
          STATE[param] = createStaticDecl(function () {
            return value
          });
        } else if (prop in dynamicOptions) {
          var dyn = dynamicOptions[prop];
          STATE[param] = createDynamicDecl(dyn, function (env, scope) {
            return parseDynamic(env, scope, env.invoke(scope, dyn))
          });
        }
      }

      switch (prop) {
        case S_CULL_ENABLE:
        case S_BLEND_ENABLE:
        case S_DITHER:
        case S_STENCIL_ENABLE:
        case S_DEPTH_ENABLE:
        case S_SCISSOR_ENABLE:
        case S_POLYGON_OFFSET_ENABLE:
        case S_SAMPLE_ALPHA:
        case S_SAMPLE_ENABLE:
        case S_DEPTH_MASK:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'boolean', prop, env.commandStr);
              return value
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  'typeof ' + value + '==="boolean"',
                  'invalid flag ' + prop, env.commandStr);
              });
              return value
            })

        case S_DEPTH_FUNC:
          return parseParam(
            function (value) {
              check$1.commandParameter(value, compareFuncs, 'invalid ' + prop, env.commandStr);
              return compareFuncs[value]
            },
            function (env, scope, value) {
              var COMPARE_FUNCS = env.constants.compareFuncs;
              check$1.optional(function () {
                env.assert(scope,
                  value + ' in ' + COMPARE_FUNCS,
                  'invalid ' + prop + ', must be one of ' + Object.keys(compareFuncs));
              });
              return scope.def(COMPARE_FUNCS, '[', value, ']')
            })

        case S_DEPTH_RANGE:
          return parseParam(
            function (value) {
              check$1.command(
                isArrayLike(value) &&
                value.length === 2 &&
                typeof value[0] === 'number' &&
                typeof value[1] === 'number' &&
                value[0] <= value[1],
                'depth range is 2d array',
                env.commandStr);
              return value
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  env.shared.isArrayLike + '(' + value + ')&&' +
                  value + '.length===2&&' +
                  'typeof ' + value + '[0]==="number"&&' +
                  'typeof ' + value + '[1]==="number"&&' +
                  value + '[0]<=' + value + '[1]',
                  'depth range must be a 2d array');
              });

              var Z_NEAR = scope.def('+', value, '[0]');
              var Z_FAR = scope.def('+', value, '[1]');
              return [Z_NEAR, Z_FAR]
            })

        case S_BLEND_FUNC:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'object', 'blend.func', env.commandStr);
              var srcRGB = ('srcRGB' in value ? value.srcRGB : value.src);
              var srcAlpha = ('srcAlpha' in value ? value.srcAlpha : value.src);
              var dstRGB = ('dstRGB' in value ? value.dstRGB : value.dst);
              var dstAlpha = ('dstAlpha' in value ? value.dstAlpha : value.dst);
              check$1.commandParameter(srcRGB, blendFuncs, param + '.srcRGB', env.commandStr);
              check$1.commandParameter(srcAlpha, blendFuncs, param + '.srcAlpha', env.commandStr);
              check$1.commandParameter(dstRGB, blendFuncs, param + '.dstRGB', env.commandStr);
              check$1.commandParameter(dstAlpha, blendFuncs, param + '.dstAlpha', env.commandStr);

              check$1.command(
                (invalidBlendCombinations.indexOf(srcRGB + ', ' + dstRGB) === -1),
                'unallowed blending combination (srcRGB, dstRGB) = (' + srcRGB + ', ' + dstRGB + ')', env.commandStr);

              return [
                blendFuncs[srcRGB],
                blendFuncs[dstRGB],
                blendFuncs[srcAlpha],
                blendFuncs[dstAlpha]
              ]
            },
            function (env, scope, value) {
              var BLEND_FUNCS = env.constants.blendFuncs;

              check$1.optional(function () {
                env.assert(scope,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid blend func, must be an object');
              });

              function read (prefix, suffix) {
                var func = scope.def(
                  '"', prefix, suffix, '" in ', value,
                  '?', value, '.', prefix, suffix,
                  ':', value, '.', prefix);

                check$1.optional(function () {
                  env.assert(scope,
                    func + ' in ' + BLEND_FUNCS,
                    'invalid ' + prop + '.' + prefix + suffix + ', must be one of ' + Object.keys(blendFuncs));
                });

                return func
              }

              var srcRGB = read('src', 'RGB');
              var dstRGB = read('dst', 'RGB');

              check$1.optional(function () {
                var INVALID_BLEND_COMBINATIONS = env.constants.invalidBlendCombinations;

                env.assert(scope,
                  INVALID_BLEND_COMBINATIONS +
                           '.indexOf(' + srcRGB + '+", "+' + dstRGB + ') === -1 ',
                  'unallowed blending combination for (srcRGB, dstRGB)'
                );
              });

              var SRC_RGB = scope.def(BLEND_FUNCS, '[', srcRGB, ']');
              var SRC_ALPHA = scope.def(BLEND_FUNCS, '[', read('src', 'Alpha'), ']');
              var DST_RGB = scope.def(BLEND_FUNCS, '[', dstRGB, ']');
              var DST_ALPHA = scope.def(BLEND_FUNCS, '[', read('dst', 'Alpha'), ']');

              return [SRC_RGB, DST_RGB, SRC_ALPHA, DST_ALPHA]
            })

        case S_BLEND_EQUATION:
          return parseParam(
            function (value) {
              if (typeof value === 'string') {
                check$1.commandParameter(value, blendEquations, 'invalid ' + prop, env.commandStr);
                return [
                  blendEquations[value],
                  blendEquations[value]
                ]
              } else if (typeof value === 'object') {
                check$1.commandParameter(
                  value.rgb, blendEquations, prop + '.rgb', env.commandStr);
                check$1.commandParameter(
                  value.alpha, blendEquations, prop + '.alpha', env.commandStr);
                return [
                  blendEquations[value.rgb],
                  blendEquations[value.alpha]
                ]
              } else {
                check$1.commandRaise('invalid blend.equation', env.commandStr);
              }
            },
            function (env, scope, value) {
              var BLEND_EQUATIONS = env.constants.blendEquations;

              var RGB = scope.def();
              var ALPHA = scope.def();

              var ifte = env.cond('typeof ', value, '==="string"');

              check$1.optional(function () {
                function checkProp (block, name, value) {
                  env.assert(block,
                    value + ' in ' + BLEND_EQUATIONS,
                    'invalid ' + name + ', must be one of ' + Object.keys(blendEquations));
                }
                checkProp(ifte.then, prop, value);

                env.assert(ifte.else,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid ' + prop);
                checkProp(ifte.else, prop + '.rgb', value + '.rgb');
                checkProp(ifte.else, prop + '.alpha', value + '.alpha');
              });

              ifte.then(
                RGB, '=', ALPHA, '=', BLEND_EQUATIONS, '[', value, '];');
              ifte.else(
                RGB, '=', BLEND_EQUATIONS, '[', value, '.rgb];',
                ALPHA, '=', BLEND_EQUATIONS, '[', value, '.alpha];');

              scope(ifte);

              return [RGB, ALPHA]
            })

        case S_BLEND_COLOR:
          return parseParam(
            function (value) {
              check$1.command(
                isArrayLike(value) &&
                value.length === 4,
                'blend.color must be a 4d array', env.commandStr);
              return loop(4, function (i) {
                return +value[i]
              })
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  env.shared.isArrayLike + '(' + value + ')&&' +
                  value + '.length===4',
                  'blend.color must be a 4d array');
              });
              return loop(4, function (i) {
                return scope.def('+', value, '[', i, ']')
              })
            })

        case S_STENCIL_MASK:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'number', param, env.commandStr);
              return value | 0
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  'typeof ' + value + '==="number"',
                  'invalid stencil.mask');
              });
              return scope.def(value, '|0')
            })

        case S_STENCIL_FUNC:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'object', param, env.commandStr);
              var cmp = value.cmp || 'keep';
              var ref = value.ref || 0;
              var mask = 'mask' in value ? value.mask : -1;
              check$1.commandParameter(cmp, compareFuncs, prop + '.cmp', env.commandStr);
              check$1.commandType(ref, 'number', prop + '.ref', env.commandStr);
              check$1.commandType(mask, 'number', prop + '.mask', env.commandStr);
              return [
                compareFuncs[cmp],
                ref,
                mask
              ]
            },
            function (env, scope, value) {
              var COMPARE_FUNCS = env.constants.compareFuncs;
              check$1.optional(function () {
                function assert () {
                  env.assert(scope,
                    Array.prototype.join.call(arguments, ''),
                    'invalid stencil.func');
                }
                assert(value + '&&typeof ', value, '==="object"');
                assert('!("cmp" in ', value, ')||(',
                  value, '.cmp in ', COMPARE_FUNCS, ')');
              });
              var cmp = scope.def(
                '"cmp" in ', value,
                '?', COMPARE_FUNCS, '[', value, '.cmp]',
                ':', GL_KEEP);
              var ref = scope.def(value, '.ref|0');
              var mask = scope.def(
                '"mask" in ', value,
                '?', value, '.mask|0:-1');
              return [cmp, ref, mask]
            })

        case S_STENCIL_OPFRONT:
        case S_STENCIL_OPBACK:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'object', param, env.commandStr);
              var fail = value.fail || 'keep';
              var zfail = value.zfail || 'keep';
              var zpass = value.zpass || 'keep';
              check$1.commandParameter(fail, stencilOps, prop + '.fail', env.commandStr);
              check$1.commandParameter(zfail, stencilOps, prop + '.zfail', env.commandStr);
              check$1.commandParameter(zpass, stencilOps, prop + '.zpass', env.commandStr);
              return [
                prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT,
                stencilOps[fail],
                stencilOps[zfail],
                stencilOps[zpass]
              ]
            },
            function (env, scope, value) {
              var STENCIL_OPS = env.constants.stencilOps;

              check$1.optional(function () {
                env.assert(scope,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid ' + prop);
              });

              function read (name) {
                check$1.optional(function () {
                  env.assert(scope,
                    '!("' + name + '" in ' + value + ')||' +
                    '(' + value + '.' + name + ' in ' + STENCIL_OPS + ')',
                    'invalid ' + prop + '.' + name + ', must be one of ' + Object.keys(stencilOps));
                });

                return scope.def(
                  '"', name, '" in ', value,
                  '?', STENCIL_OPS, '[', value, '.', name, ']:',
                  GL_KEEP)
              }

              return [
                prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT,
                read('fail'),
                read('zfail'),
                read('zpass')
              ]
            })

        case S_POLYGON_OFFSET_OFFSET:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'object', param, env.commandStr);
              var factor = value.factor | 0;
              var units = value.units | 0;
              check$1.commandType(factor, 'number', param + '.factor', env.commandStr);
              check$1.commandType(units, 'number', param + '.units', env.commandStr);
              return [factor, units]
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid ' + prop);
              });

              var FACTOR = scope.def(value, '.factor|0');
              var UNITS = scope.def(value, '.units|0');

              return [FACTOR, UNITS]
            })

        case S_CULL_FACE:
          return parseParam(
            function (value) {
              var face = 0;
              if (value === 'front') {
                face = GL_FRONT;
              } else if (value === 'back') {
                face = GL_BACK;
              }
              check$1.command(!!face, param, env.commandStr);
              return face
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  value + '==="front"||' +
                  value + '==="back"',
                  'invalid cull.face');
              });
              return scope.def(value, '==="front"?', GL_FRONT, ':', GL_BACK)
            })

        case S_LINE_WIDTH:
          return parseParam(
            function (value) {
              check$1.command(
                typeof value === 'number' &&
                value >= limits.lineWidthDims[0] &&
                value <= limits.lineWidthDims[1],
                'invalid line width, must be a positive number between ' +
                limits.lineWidthDims[0] + ' and ' + limits.lineWidthDims[1], env.commandStr);
              return value
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  'typeof ' + value + '==="number"&&' +
                  value + '>=' + limits.lineWidthDims[0] + '&&' +
                  value + '<=' + limits.lineWidthDims[1],
                  'invalid line width');
              });

              return value
            })

        case S_FRONT_FACE:
          return parseParam(
            function (value) {
              check$1.commandParameter(value, orientationType, param, env.commandStr);
              return orientationType[value]
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  value + '==="cw"||' +
                  value + '==="ccw"',
                  'invalid frontFace, must be one of cw,ccw');
              });
              return scope.def(value + '==="cw"?' + GL_CW + ':' + GL_CCW)
            })

        case S_COLOR_MASK:
          return parseParam(
            function (value) {
              check$1.command(
                isArrayLike(value) && value.length === 4,
                'color.mask must be length 4 array', env.commandStr);
              return value.map(function (v) { return !!v })
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  env.shared.isArrayLike + '(' + value + ')&&' +
                  value + '.length===4',
                  'invalid color.mask');
              });
              return loop(4, function (i) {
                return '!!' + value + '[' + i + ']'
              })
            })

        case S_SAMPLE_COVERAGE:
          return parseParam(
            function (value) {
              check$1.command(typeof value === 'object' && value, param, env.commandStr);
              var sampleValue = 'value' in value ? value.value : 1;
              var sampleInvert = !!value.invert;
              check$1.command(
                typeof sampleValue === 'number' &&
                sampleValue >= 0 && sampleValue <= 1,
                'sample.coverage.value must be a number between 0 and 1', env.commandStr);
              return [sampleValue, sampleInvert]
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid sample.coverage');
              });
              var VALUE = scope.def(
                '"value" in ', value, '?+', value, '.value:1');
              var INVERT = scope.def('!!', value, '.invert');
              return [VALUE, INVERT]
            })
      }
    });

    return STATE
  }

  function parseUniforms (uniforms, env) {
    var staticUniforms = uniforms.static;
    var dynamicUniforms = uniforms.dynamic;

    var UNIFORMS = {};

    Object.keys(staticUniforms).forEach(function (name) {
      var value = staticUniforms[name];
      var result;
      if (typeof value === 'number' ||
          typeof value === 'boolean') {
        result = createStaticDecl(function () {
          return value
        });
      } else if (typeof value === 'function') {
        var reglType = value._reglType;
        if (reglType === 'texture2d' ||
            reglType === 'textureCube') {
          result = createStaticDecl(function (env) {
            return env.link(value)
          });
        } else if (reglType === 'framebuffer' ||
                   reglType === 'framebufferCube') {
          check$1.command(value.color.length > 0,
            'missing color attachment for framebuffer sent to uniform "' + name + '"', env.commandStr);
          result = createStaticDecl(function (env) {
            return env.link(value.color[0])
          });
        } else {
          check$1.commandRaise('invalid data for uniform "' + name + '"', env.commandStr);
        }
      } else if (isArrayLike(value)) {
        result = createStaticDecl(function (env) {
          var ITEM = env.global.def('[',
            loop(value.length, function (i) {
              check$1.command(
                typeof value[i] === 'number' ||
                typeof value[i] === 'boolean',
                'invalid uniform ' + name, env.commandStr);
              return value[i]
            }), ']');
          return ITEM
        });
      } else {
        check$1.commandRaise('invalid or missing data for uniform "' + name + '"', env.commandStr);
      }
      result.value = value;
      UNIFORMS[name] = result;
    });

    Object.keys(dynamicUniforms).forEach(function (key) {
      var dyn = dynamicUniforms[key];
      UNIFORMS[key] = createDynamicDecl(dyn, function (env, scope) {
        return env.invoke(scope, dyn)
      });
    });

    return UNIFORMS
  }

  function parseAttributes (attributes, env) {
    var staticAttributes = attributes.static;
    var dynamicAttributes = attributes.dynamic;

    var attributeDefs = {};

    Object.keys(staticAttributes).forEach(function (attribute) {
      var value = staticAttributes[attribute];
      var id = stringStore.id(attribute);

      var record = new AttributeRecord();
      if (isBufferArgs(value)) {
        record.state = ATTRIB_STATE_POINTER;
        record.buffer = bufferState.getBuffer(
          bufferState.create(value, GL_ARRAY_BUFFER$2, false, true));
        record.type = 0;
      } else {
        var buffer = bufferState.getBuffer(value);
        if (buffer) {
          record.state = ATTRIB_STATE_POINTER;
          record.buffer = buffer;
          record.type = 0;
        } else {
          check$1.command(typeof value === 'object' && value,
            'invalid data for attribute ' + attribute, env.commandStr);
          if ('constant' in value) {
            var constant = value.constant;
            record.buffer = 'null';
            record.state = ATTRIB_STATE_CONSTANT;
            if (typeof constant === 'number') {
              record.x = constant;
            } else {
              check$1.command(
                isArrayLike(constant) &&
                constant.length > 0 &&
                constant.length <= 4,
                'invalid constant for attribute ' + attribute, env.commandStr);
              CUTE_COMPONENTS.forEach(function (c, i) {
                if (i < constant.length) {
                  record[c] = constant[i];
                }
              });
            }
          } else {
            if (isBufferArgs(value.buffer)) {
              buffer = bufferState.getBuffer(
                bufferState.create(value.buffer, GL_ARRAY_BUFFER$2, false, true));
            } else {
              buffer = bufferState.getBuffer(value.buffer);
            }
            check$1.command(!!buffer, 'missing buffer for attribute "' + attribute + '"', env.commandStr);

            var offset = value.offset | 0;
            check$1.command(offset >= 0,
              'invalid offset for attribute "' + attribute + '"', env.commandStr);

            var stride = value.stride | 0;
            check$1.command(stride >= 0 && stride < 256,
              'invalid stride for attribute "' + attribute + '", must be integer betweeen [0, 255]', env.commandStr);

            var size = value.size | 0;
            check$1.command(!('size' in value) || (size > 0 && size <= 4),
              'invalid size for attribute "' + attribute + '", must be 1,2,3,4', env.commandStr);

            var normalized = !!value.normalized;

            var type = 0;
            if ('type' in value) {
              check$1.commandParameter(
                value.type, glTypes,
                'invalid type for attribute ' + attribute, env.commandStr);
              type = glTypes[value.type];
            }

            var divisor = value.divisor | 0;
            check$1.optional(function () {
              if ('divisor' in value) {
                check$1.command(divisor === 0 || extInstancing,
                  'cannot specify divisor for attribute "' + attribute + '", instancing not supported', env.commandStr);
                check$1.command(divisor >= 0,
                  'invalid divisor for attribute "' + attribute + '"', env.commandStr);
              }

              var command = env.commandStr;

              var VALID_KEYS = [
                'buffer',
                'offset',
                'divisor',
                'normalized',
                'type',
                'size',
                'stride'
              ];

              Object.keys(value).forEach(function (prop) {
                check$1.command(
                  VALID_KEYS.indexOf(prop) >= 0,
                  'unknown parameter "' + prop + '" for attribute pointer "' + attribute + '" (valid parameters are ' + VALID_KEYS + ')',
                  command);
              });
            });

            record.buffer = buffer;
            record.state = ATTRIB_STATE_POINTER;
            record.size = size;
            record.normalized = normalized;
            record.type = type || buffer.dtype;
            record.offset = offset;
            record.stride = stride;
            record.divisor = divisor;
          }
        }
      }

      attributeDefs[attribute] = createStaticDecl(function (env, scope) {
        var cache = env.attribCache;
        if (id in cache) {
          return cache[id]
        }
        var result = {
          isStream: false
        };
        Object.keys(record).forEach(function (key) {
          result[key] = record[key];
        });
        if (record.buffer) {
          result.buffer = env.link(record.buffer);
          result.type = result.type || (result.buffer + '.dtype');
        }
        cache[id] = result;
        return result
      });
    });

    Object.keys(dynamicAttributes).forEach(function (attribute) {
      var dyn = dynamicAttributes[attribute];

      function appendAttributeCode (env, block) {
        var VALUE = env.invoke(block, dyn);

        var shared = env.shared;
        var constants = env.constants;

        var IS_BUFFER_ARGS = shared.isBufferArgs;
        var BUFFER_STATE = shared.buffer;

        // Perform validation on attribute
        check$1.optional(function () {
          env.assert(block,
            VALUE + '&&(typeof ' + VALUE + '==="object"||typeof ' +
            VALUE + '==="function")&&(' +
            IS_BUFFER_ARGS + '(' + VALUE + ')||' +
            BUFFER_STATE + '.getBuffer(' + VALUE + ')||' +
            BUFFER_STATE + '.getBuffer(' + VALUE + '.buffer)||' +
            IS_BUFFER_ARGS + '(' + VALUE + '.buffer)||' +
            '("constant" in ' + VALUE +
            '&&(typeof ' + VALUE + '.constant==="number"||' +
            shared.isArrayLike + '(' + VALUE + '.constant))))',
            'invalid dynamic attribute "' + attribute + '"');
        });

        // allocate names for result
        var result = {
          isStream: block.def(false)
        };
        var defaultRecord = new AttributeRecord();
        defaultRecord.state = ATTRIB_STATE_POINTER;
        Object.keys(defaultRecord).forEach(function (key) {
          result[key] = block.def('' + defaultRecord[key]);
        });

        var BUFFER = result.buffer;
        var TYPE = result.type;
        block(
          'if(', IS_BUFFER_ARGS, '(', VALUE, ')){',
          result.isStream, '=true;',
          BUFFER, '=', BUFFER_STATE, '.createStream(', GL_ARRAY_BUFFER$2, ',', VALUE, ');',
          TYPE, '=', BUFFER, '.dtype;',
          '}else{',
          BUFFER, '=', BUFFER_STATE, '.getBuffer(', VALUE, ');',
          'if(', BUFFER, '){',
          TYPE, '=', BUFFER, '.dtype;',
          '}else if("constant" in ', VALUE, '){',
          result.state, '=', ATTRIB_STATE_CONSTANT, ';',
          'if(typeof ' + VALUE + '.constant === "number"){',
          result[CUTE_COMPONENTS[0]], '=', VALUE, '.constant;',
          CUTE_COMPONENTS.slice(1).map(function (n) {
            return result[n]
          }).join('='), '=0;',
          '}else{',
          CUTE_COMPONENTS.map(function (name, i) {
            return (
              result[name] + '=' + VALUE + '.constant.length>' + i +
              '?' + VALUE + '.constant[' + i + ']:0;'
            )
          }).join(''),
          '}}else{',
          'if(', IS_BUFFER_ARGS, '(', VALUE, '.buffer)){',
          BUFFER, '=', BUFFER_STATE, '.createStream(', GL_ARRAY_BUFFER$2, ',', VALUE, '.buffer);',
          '}else{',
          BUFFER, '=', BUFFER_STATE, '.getBuffer(', VALUE, '.buffer);',
          '}',
          TYPE, '="type" in ', VALUE, '?',
          constants.glTypes, '[', VALUE, '.type]:', BUFFER, '.dtype;',
          result.normalized, '=!!', VALUE, '.normalized;');
        function emitReadRecord (name) {
          block(result[name], '=', VALUE, '.', name, '|0;');
        }
        emitReadRecord('size');
        emitReadRecord('offset');
        emitReadRecord('stride');
        emitReadRecord('divisor');

        block('}}');

        block.exit(
          'if(', result.isStream, '){',
          BUFFER_STATE, '.destroyStream(', BUFFER, ');',
          '}');

        return result
      }

      attributeDefs[attribute] = createDynamicDecl(dyn, appendAttributeCode);
    });

    return attributeDefs
  }

  function parseContext (context) {
    var staticContext = context.static;
    var dynamicContext = context.dynamic;
    var result = {};

    Object.keys(staticContext).forEach(function (name) {
      var value = staticContext[name];
      result[name] = createStaticDecl(function (env, scope) {
        if (typeof value === 'number' || typeof value === 'boolean') {
          return '' + value
        } else {
          return env.link(value)
        }
      });
    });

    Object.keys(dynamicContext).forEach(function (name) {
      var dyn = dynamicContext[name];
      result[name] = createDynamicDecl(dyn, function (env, scope) {
        return env.invoke(scope, dyn)
      });
    });

    return result
  }

  function parseArguments (options, attributes, uniforms, context, env) {
    var staticOptions = options.static;
    var dynamicOptions = options.dynamic;

    check$1.optional(function () {
      var KEY_NAMES = [
        S_FRAMEBUFFER,
        S_VERT,
        S_FRAG,
        S_ELEMENTS,
        S_PRIMITIVE,
        S_OFFSET,
        S_COUNT,
        S_INSTANCES,
        S_PROFILE,
        S_VAO
      ].concat(GL_STATE_NAMES);

      function checkKeys (dict) {
        Object.keys(dict).forEach(function (key) {
          check$1.command(
            KEY_NAMES.indexOf(key) >= 0,
            'unknown parameter "' + key + '"',
            env.commandStr);
        });
      }

      checkKeys(staticOptions);
      checkKeys(dynamicOptions);
    });

    var attribLocations = parseAttribLocations(options, attributes);

    var framebuffer = parseFramebuffer(options);
    var viewportAndScissor = parseViewportScissor(options, framebuffer, env);
    var draw = parseDraw(options, env);
    var state = parseGLState(options, env);
    var shader = parseProgram(options, env, attribLocations);

    function copyBox (name) {
      var defn = viewportAndScissor[name];
      if (defn) {
        state[name] = defn;
      }
    }
    copyBox(S_VIEWPORT);
    copyBox(propName(S_SCISSOR_BOX));

    var dirty = Object.keys(state).length > 0;

    var result = {
      framebuffer: framebuffer,
      draw: draw,
      shader: shader,
      state: state,
      dirty: dirty,
      scopeVAO: null,
      drawVAO: null,
      useVAO: false,
      attributes: {}
    };

    result.profile = parseProfile(options);
    result.uniforms = parseUniforms(uniforms, env);
    result.drawVAO = result.scopeVAO = draw.vao;
    // special case: check if we can statically allocate a vertex array object for this program
    if (!result.drawVAO &&
      shader.program &&
      !attribLocations &&
      extensions.angle_instanced_arrays &&
      draw.static.elements) {
      var useVAO = true;
      var staticBindings = shader.program.attributes.map(function (attr) {
        var binding = attributes.static[attr];
        useVAO = useVAO && !!binding;
        return binding
      });
      if (useVAO && staticBindings.length > 0) {
        var vao = attributeState.getVAO(attributeState.createVAO({
          attributes: staticBindings,
          elements: draw.static.elements
        }));
        result.drawVAO = new Declaration(null, null, null, function (env, scope) {
          return env.link(vao)
        });
        result.useVAO = true;
      }
    }
    if (attribLocations) {
      result.useVAO = true;
    } else {
      result.attributes = parseAttributes(attributes, env);
    }
    result.context = parseContext(context);
    return result
  }

  // ===================================================
  // ===================================================
  // COMMON UPDATE FUNCTIONS
  // ===================================================
  // ===================================================
  function emitContext (env, scope, context) {
    var shared = env.shared;
    var CONTEXT = shared.context;

    var contextEnter = env.scope();

    Object.keys(context).forEach(function (name) {
      scope.save(CONTEXT, '.' + name);
      var defn = context[name];
      var value = defn.append(env, scope);
      if (Array.isArray(value)) {
        contextEnter(CONTEXT, '.', name, '=[', value.join(), '];');
      } else {
        contextEnter(CONTEXT, '.', name, '=', value, ';');
      }
    });

    scope(contextEnter);
  }

  // ===================================================
  // ===================================================
  // COMMON DRAWING FUNCTIONS
  // ===================================================
  // ===================================================
  function emitPollFramebuffer (env, scope, framebuffer, skipCheck) {
    var shared = env.shared;

    var GL = shared.gl;
    var FRAMEBUFFER_STATE = shared.framebuffer;
    var EXT_DRAW_BUFFERS;
    if (extDrawBuffers) {
      EXT_DRAW_BUFFERS = scope.def(shared.extensions, '.webgl_draw_buffers');
    }

    var constants = env.constants;

    var DRAW_BUFFERS = constants.drawBuffer;
    var BACK_BUFFER = constants.backBuffer;

    var NEXT;
    if (framebuffer) {
      NEXT = framebuffer.append(env, scope);
    } else {
      NEXT = scope.def(FRAMEBUFFER_STATE, '.next');
    }

    if (!skipCheck) {
      scope('if(', NEXT, '!==', FRAMEBUFFER_STATE, '.cur){');
    }
    scope(
      'if(', NEXT, '){',
      GL, '.bindFramebuffer(', GL_FRAMEBUFFER$2, ',', NEXT, '.framebuffer);');
    if (extDrawBuffers) {
      scope(EXT_DRAW_BUFFERS, '.drawBuffersWEBGL(',
        DRAW_BUFFERS, '[', NEXT, '.colorAttachments.length]);');
    }
    scope('}else{',
      GL, '.bindFramebuffer(', GL_FRAMEBUFFER$2, ',null);');
    if (extDrawBuffers) {
      scope(EXT_DRAW_BUFFERS, '.drawBuffersWEBGL(', BACK_BUFFER, ');');
    }
    scope(
      '}',
      FRAMEBUFFER_STATE, '.cur=', NEXT, ';');
    if (!skipCheck) {
      scope('}');
    }
  }

  function emitPollState (env, scope, args) {
    var shared = env.shared;

    var GL = shared.gl;

    var CURRENT_VARS = env.current;
    var NEXT_VARS = env.next;
    var CURRENT_STATE = shared.current;
    var NEXT_STATE = shared.next;

    var block = env.cond(CURRENT_STATE, '.dirty');

    GL_STATE_NAMES.forEach(function (prop) {
      var param = propName(prop);
      if (param in args.state) {
        return
      }

      var NEXT, CURRENT;
      if (param in NEXT_VARS) {
        NEXT = NEXT_VARS[param];
        CURRENT = CURRENT_VARS[param];
        var parts = loop(currentState[param].length, function (i) {
          return block.def(NEXT, '[', i, ']')
        });
        block(env.cond(parts.map(function (p, i) {
          return p + '!==' + CURRENT + '[' + i + ']'
        }).join('||'))
          .then(
            GL, '.', GL_VARIABLES[param], '(', parts, ');',
            parts.map(function (p, i) {
              return CURRENT + '[' + i + ']=' + p
            }).join(';'), ';'));
      } else {
        NEXT = block.def(NEXT_STATE, '.', param);
        var ifte = env.cond(NEXT, '!==', CURRENT_STATE, '.', param);
        block(ifte);
        if (param in GL_FLAGS) {
          ifte(
            env.cond(NEXT)
              .then(GL, '.enable(', GL_FLAGS[param], ');')
              .else(GL, '.disable(', GL_FLAGS[param], ');'),
            CURRENT_STATE, '.', param, '=', NEXT, ';');
        } else {
          ifte(
            GL, '.', GL_VARIABLES[param], '(', NEXT, ');',
            CURRENT_STATE, '.', param, '=', NEXT, ';');
        }
      }
    });
    if (Object.keys(args.state).length === 0) {
      block(CURRENT_STATE, '.dirty=false;');
    }
    scope(block);
  }

  function emitSetOptions (env, scope, options, filter) {
    var shared = env.shared;
    var CURRENT_VARS = env.current;
    var CURRENT_STATE = shared.current;
    var GL = shared.gl;
    sortState(Object.keys(options)).forEach(function (param) {
      var defn = options[param];
      if (filter && !filter(defn)) {
        return
      }
      var variable = defn.append(env, scope);
      if (GL_FLAGS[param]) {
        var flag = GL_FLAGS[param];
        if (isStatic(defn)) {
          if (variable) {
            scope(GL, '.enable(', flag, ');');
          } else {
            scope(GL, '.disable(', flag, ');');
          }
        } else {
          scope(env.cond(variable)
            .then(GL, '.enable(', flag, ');')
            .else(GL, '.disable(', flag, ');'));
        }
        scope(CURRENT_STATE, '.', param, '=', variable, ';');
      } else if (isArrayLike(variable)) {
        var CURRENT = CURRENT_VARS[param];
        scope(
          GL, '.', GL_VARIABLES[param], '(', variable, ');',
          variable.map(function (v, i) {
            return CURRENT + '[' + i + ']=' + v
          }).join(';'), ';');
      } else {
        scope(
          GL, '.', GL_VARIABLES[param], '(', variable, ');',
          CURRENT_STATE, '.', param, '=', variable, ';');
      }
    });
  }

  function injectExtensions (env, scope) {
    if (extInstancing) {
      env.instancing = scope.def(
        env.shared.extensions, '.angle_instanced_arrays');
    }
  }

  function emitProfile (env, scope, args, useScope, incrementCounter) {
    var shared = env.shared;
    var STATS = env.stats;
    var CURRENT_STATE = shared.current;
    var TIMER = shared.timer;
    var profileArg = args.profile;

    function perfCounter () {
      if (typeof performance === 'undefined') {
        return 'Date.now()'
      } else {
        return 'performance.now()'
      }
    }

    var CPU_START, QUERY_COUNTER;
    function emitProfileStart (block) {
      CPU_START = scope.def();
      block(CPU_START, '=', perfCounter(), ';');
      if (typeof incrementCounter === 'string') {
        block(STATS, '.count+=', incrementCounter, ';');
      } else {
        block(STATS, '.count++;');
      }
      if (timer) {
        if (useScope) {
          QUERY_COUNTER = scope.def();
          block(QUERY_COUNTER, '=', TIMER, '.getNumPendingQueries();');
        } else {
          block(TIMER, '.beginQuery(', STATS, ');');
        }
      }
    }

    function emitProfileEnd (block) {
      block(STATS, '.cpuTime+=', perfCounter(), '-', CPU_START, ';');
      if (timer) {
        if (useScope) {
          block(TIMER, '.pushScopeStats(',
            QUERY_COUNTER, ',',
            TIMER, '.getNumPendingQueries(),',
            STATS, ');');
        } else {
          block(TIMER, '.endQuery();');
        }
      }
    }

    function scopeProfile (value) {
      var prev = scope.def(CURRENT_STATE, '.profile');
      scope(CURRENT_STATE, '.profile=', value, ';');
      scope.exit(CURRENT_STATE, '.profile=', prev, ';');
    }

    var USE_PROFILE;
    if (profileArg) {
      if (isStatic(profileArg)) {
        if (profileArg.enable) {
          emitProfileStart(scope);
          emitProfileEnd(scope.exit);
          scopeProfile('true');
        } else {
          scopeProfile('false');
        }
        return
      }
      USE_PROFILE = profileArg.append(env, scope);
      scopeProfile(USE_PROFILE);
    } else {
      USE_PROFILE = scope.def(CURRENT_STATE, '.profile');
    }

    var start = env.block();
    emitProfileStart(start);
    scope('if(', USE_PROFILE, '){', start, '}');
    var end = env.block();
    emitProfileEnd(end);
    scope.exit('if(', USE_PROFILE, '){', end, '}');
  }

  function emitAttributes (env, scope, args, attributes, filter) {
    var shared = env.shared;

    function typeLength (x) {
      switch (x) {
        case GL_FLOAT_VEC2:
        case GL_INT_VEC2:
        case GL_BOOL_VEC2:
          return 2
        case GL_FLOAT_VEC3:
        case GL_INT_VEC3:
        case GL_BOOL_VEC3:
          return 3
        case GL_FLOAT_VEC4:
        case GL_INT_VEC4:
        case GL_BOOL_VEC4:
          return 4
        default:
          return 1
      }
    }

    function emitBindAttribute (ATTRIBUTE, size, record) {
      var GL = shared.gl;

      var LOCATION = scope.def(ATTRIBUTE, '.location');
      var BINDING = scope.def(shared.attributes, '[', LOCATION, ']');

      var STATE = record.state;
      var BUFFER = record.buffer;
      var CONST_COMPONENTS = [
        record.x,
        record.y,
        record.z,
        record.w
      ];

      var COMMON_KEYS = [
        'buffer',
        'normalized',
        'offset',
        'stride'
      ];

      function emitBuffer () {
        scope(
          'if(!', BINDING, '.buffer){',
          GL, '.enableVertexAttribArray(', LOCATION, ');}');

        var TYPE = record.type;
        var SIZE;
        if (!record.size) {
          SIZE = size;
        } else {
          SIZE = scope.def(record.size, '||', size);
        }

        scope('if(',
          BINDING, '.type!==', TYPE, '||',
          BINDING, '.size!==', SIZE, '||',
          COMMON_KEYS.map(function (key) {
            return BINDING + '.' + key + '!==' + record[key]
          }).join('||'),
          '){',
          GL, '.bindBuffer(', GL_ARRAY_BUFFER$2, ',', BUFFER, '.buffer);',
          GL, '.vertexAttribPointer(', [
            LOCATION,
            SIZE,
            TYPE,
            record.normalized,
            record.stride,
            record.offset
          ], ');',
          BINDING, '.type=', TYPE, ';',
          BINDING, '.size=', SIZE, ';',
          COMMON_KEYS.map(function (key) {
            return BINDING + '.' + key + '=' + record[key] + ';'
          }).join(''),
          '}');

        if (extInstancing) {
          var DIVISOR = record.divisor;
          scope(
            'if(', BINDING, '.divisor!==', DIVISOR, '){',
            env.instancing, '.vertexAttribDivisorANGLE(', [LOCATION, DIVISOR], ');',
            BINDING, '.divisor=', DIVISOR, ';}');
        }
      }

      function emitConstant () {
        scope(
          'if(', BINDING, '.buffer){',
          GL, '.disableVertexAttribArray(', LOCATION, ');',
          BINDING, '.buffer=null;',
          '}if(', CUTE_COMPONENTS.map(function (c, i) {
            return BINDING + '.' + c + '!==' + CONST_COMPONENTS[i]
          }).join('||'), '){',
          GL, '.vertexAttrib4f(', LOCATION, ',', CONST_COMPONENTS, ');',
          CUTE_COMPONENTS.map(function (c, i) {
            return BINDING + '.' + c + '=' + CONST_COMPONENTS[i] + ';'
          }).join(''),
          '}');
      }

      if (STATE === ATTRIB_STATE_POINTER) {
        emitBuffer();
      } else if (STATE === ATTRIB_STATE_CONSTANT) {
        emitConstant();
      } else {
        scope('if(', STATE, '===', ATTRIB_STATE_POINTER, '){');
        emitBuffer();
        scope('}else{');
        emitConstant();
        scope('}');
      }
    }

    attributes.forEach(function (attribute) {
      var name = attribute.name;
      var arg = args.attributes[name];
      var record;
      if (arg) {
        if (!filter(arg)) {
          return
        }
        record = arg.append(env, scope);
      } else {
        if (!filter(SCOPE_DECL)) {
          return
        }
        var scopeAttrib = env.scopeAttrib(name);
        check$1.optional(function () {
          env.assert(scope,
            scopeAttrib + '.state',
            'missing attribute ' + name);
        });
        record = {};
        Object.keys(new AttributeRecord()).forEach(function (key) {
          record[key] = scope.def(scopeAttrib, '.', key);
        });
      }
      emitBindAttribute(
        env.link(attribute), typeLength(attribute.info.type), record);
    });
  }

  function emitUniforms (env, scope, args, uniforms, filter, isBatchInnerLoop) {
    var shared = env.shared;
    var GL = shared.gl;

    var definedArrUniforms = {};
    var infix;
    for (var i = 0; i < uniforms.length; ++i) {
      var uniform = uniforms[i];
      var name = uniform.name;
      var type = uniform.info.type;
      var size = uniform.info.size;
      var arg = args.uniforms[name];
      if (size > 1) {
        // either foo[n] or foos, avoid define both
        if (!arg) {
          continue
        }
        var arrUniformName = name.replace('[0]', '');
        if (definedArrUniforms[arrUniformName]) {
          continue
        }
        definedArrUniforms[arrUniformName] = 1;
      }
      var UNIFORM = env.link(uniform);
      var LOCATION = UNIFORM + '.location';

      var VALUE;
      if (arg) {
        if (!filter(arg)) {
          continue
        }
        if (isStatic(arg)) {
          var value = arg.value;
          check$1.command(
            value !== null && typeof value !== 'undefined',
            'missing uniform "' + name + '"', env.commandStr);
          if (type === GL_SAMPLER_2D || type === GL_SAMPLER_CUBE) {
            check$1.command(
              typeof value === 'function' &&
              ((type === GL_SAMPLER_2D &&
                (value._reglType === 'texture2d' ||
                value._reglType === 'framebuffer')) ||
              (type === GL_SAMPLER_CUBE &&
                (value._reglType === 'textureCube' ||
                value._reglType === 'framebufferCube'))),
              'invalid texture for uniform ' + name, env.commandStr);
            var TEX_VALUE = env.link(value._texture || value.color[0]._texture);
            scope(GL, '.uniform1i(', LOCATION, ',', TEX_VALUE + '.bind());');
            scope.exit(TEX_VALUE, '.unbind();');
          } else if (
            type === GL_FLOAT_MAT2 ||
            type === GL_FLOAT_MAT3 ||
            type === GL_FLOAT_MAT4) {
            check$1.optional(function () {
              check$1.command(isArrayLike(value),
                'invalid matrix for uniform ' + name, env.commandStr);
              check$1.command(
                (type === GL_FLOAT_MAT2 && value.length === 4) ||
                (type === GL_FLOAT_MAT3 && value.length === 9) ||
                (type === GL_FLOAT_MAT4 && value.length === 16),
                'invalid length for matrix uniform ' + name, env.commandStr);
            });
            var MAT_VALUE = env.global.def('new Float32Array([' +
              Array.prototype.slice.call(value) + '])');
            var dim = 2;
            if (type === GL_FLOAT_MAT3) {
              dim = 3;
            } else if (type === GL_FLOAT_MAT4) {
              dim = 4;
            }
            scope(
              GL, '.uniformMatrix', dim, 'fv(',
              LOCATION, ',false,', MAT_VALUE, ');');
          } else {
            switch (type) {
              case GL_FLOAT$8:
                if (size === 1) {
                  check$1.commandType(value, 'number', 'uniform ' + name, env.commandStr);
                } else {
                  check$1.command(
                    isArrayLike(value) && (value.length === size),
                    'uniform ' + name, env.commandStr);
                }
                infix = '1f';
                break
              case GL_FLOAT_VEC2:
                check$1.command(
                  isArrayLike(value) && (value.length && value.length % 2 === 0 && value.length <= size * 2),
                  'uniform ' + name, env.commandStr);
                infix = '2f';
                break
              case GL_FLOAT_VEC3:
                check$1.command(
                  isArrayLike(value) && (value.length && value.length % 3 === 0 && value.length <= size * 3),
                  'uniform ' + name, env.commandStr);
                infix = '3f';
                break
              case GL_FLOAT_VEC4:
                check$1.command(
                  isArrayLike(value) && (value.length && value.length % 4 === 0 && value.length <= size * 4),
                  'uniform ' + name, env.commandStr);
                infix = '4f';
                break
              case GL_BOOL:
                if (size === 1) {
                  check$1.commandType(value, 'boolean', 'uniform ' + name, env.commandStr);
                } else {
                  check$1.command(
                    isArrayLike(value) && (value.length === size),
                    'uniform ' + name, env.commandStr);
                }
                infix = '1i';
                break
              case GL_INT$3:
                if (size === 1) {
                  check$1.commandType(value, 'number', 'uniform ' + name, env.commandStr);
                } else {
                  check$1.command(
                    isArrayLike(value) && (value.length === size),
                    'uniform ' + name, env.commandStr);
                }
                infix = '1i';
                break
              case GL_BOOL_VEC2:
                check$1.command(
                  isArrayLike(value) && (value.length && value.length % 2 === 0 && value.length <= size * 2),
                  'uniform ' + name, env.commandStr);
                infix = '2i';
                break
              case GL_INT_VEC2:
                check$1.command(
                  isArrayLike(value) && (value.length && value.length % 2 === 0 && value.length <= size * 2),
                  'uniform ' + name, env.commandStr);
                infix = '2i';
                break
              case GL_BOOL_VEC3:
                check$1.command(
                  isArrayLike(value) && (value.length && value.length % 3 === 0 && value.length <= size * 3),
                  'uniform ' + name, env.commandStr);
                infix = '3i';
                break
              case GL_INT_VEC3:
                check$1.command(
                  isArrayLike(value) && (value.length && value.length % 3 === 0 && value.length <= size * 3),
                  'uniform ' + name, env.commandStr);
                infix = '3i';
                break
              case GL_BOOL_VEC4:
                check$1.command(
                  isArrayLike(value) && (value.length && value.length % 4 === 0 && value.length <= size * 4),
                  'uniform ' + name, env.commandStr);
                infix = '4i';
                break
              case GL_INT_VEC4:
                check$1.command(
                  isArrayLike(value) && (value.length && value.length % 4 === 0 && value.length <= size * 4),
                  'uniform ' + name, env.commandStr);
                infix = '4i';
                break
            }
            if (size > 1) {
              infix += 'v';
              value = env.global.def('[' +
              Array.prototype.slice.call(value) + ']');
            } else {
              value = isArrayLike(value) ? Array.prototype.slice.call(value) : value;
            }
            scope(GL, '.uniform', infix, '(', LOCATION, ',',
              value,
              ');');
          }
          continue
        } else {
          VALUE = arg.append(env, scope);
        }
      } else {
        if (!filter(SCOPE_DECL)) {
          continue
        }
        VALUE = scope.def(shared.uniforms, '[', stringStore.id(name), ']');
      }

      if (type === GL_SAMPLER_2D) {
        check$1(!Array.isArray(VALUE), 'must specify a scalar prop for textures');
        scope(
          'if(', VALUE, '&&', VALUE, '._reglType==="framebuffer"){',
          VALUE, '=', VALUE, '.color[0];',
          '}');
      } else if (type === GL_SAMPLER_CUBE) {
        check$1(!Array.isArray(VALUE), 'must specify a scalar prop for cube maps');
        scope(
          'if(', VALUE, '&&', VALUE, '._reglType==="framebufferCube"){',
          VALUE, '=', VALUE, '.color[0];',
          '}');
      }

      // perform type validation
      check$1.optional(function () {
        function emitCheck (pred, message) {
          env.assert(scope, pred,
            'bad data or missing for uniform "' + name + '".  ' + message);
        }

        function checkType (type, size) {
          if (size === 1) {
            check$1(!Array.isArray(VALUE), 'must not specify an array type for uniform');
          }
          emitCheck(
            'Array.isArray(' + VALUE + ') && typeof ' + VALUE + '[0]===" ' + type + '"' +
            ' || typeof ' + VALUE + '==="' + type + '"',
            'invalid type, expected ' + type);
        }

        function checkVector (n, type, size) {
          if (Array.isArray(VALUE)) {
            check$1(VALUE.length && VALUE.length % n === 0 && VALUE.length <= n * size, 'must have length of ' + (size === 1 ? '' : 'n * ') + n);
          } else {
            emitCheck(
              shared.isArrayLike + '(' + VALUE + ')&&' + VALUE + '.length && ' + VALUE + '.length % ' + n + ' === 0' +
              ' && ' + VALUE + '.length<=' + n * size,
              'invalid vector, should have length of ' + (size === 1 ? '' : 'n * ') + n, env.commandStr);
          }
        }

        function checkTexture (target) {
          check$1(!Array.isArray(VALUE), 'must not specify a value type');
          emitCheck(
            'typeof ' + VALUE + '==="function"&&' +
            VALUE + '._reglType==="texture' +
            (target === GL_TEXTURE_2D$3 ? '2d' : 'Cube') + '"',
            'invalid texture type', env.commandStr);
        }

        switch (type) {
          case GL_INT$3:
            checkType('number', size);
            break
          case GL_INT_VEC2:
            checkVector(2, 'number', size);
            break
          case GL_INT_VEC3:
            checkVector(3, 'number', size);
            break
          case GL_INT_VEC4:
            checkVector(4, 'number', size);
            break
          case GL_FLOAT$8:
            checkType('number', size);
            break
          case GL_FLOAT_VEC2:
            checkVector(2, 'number', size);
            break
          case GL_FLOAT_VEC3:
            checkVector(3, 'number', size);
            break
          case GL_FLOAT_VEC4:
            checkVector(4, 'number', size);
            break
          case GL_BOOL:
            checkType('boolean', size);
            break
          case GL_BOOL_VEC2:
            checkVector(2, 'boolean', size);
            break
          case GL_BOOL_VEC3:
            checkVector(3, 'boolean', size);
            break
          case GL_BOOL_VEC4:
            checkVector(4, 'boolean', size);
            break
          case GL_FLOAT_MAT2:
            checkVector(4, 'number', size);
            break
          case GL_FLOAT_MAT3:
            checkVector(9, 'number', size);
            break
          case GL_FLOAT_MAT4:
            checkVector(16, 'number', size);
            break
          case GL_SAMPLER_2D:
            checkTexture(GL_TEXTURE_2D$3);
            break
          case GL_SAMPLER_CUBE:
            checkTexture(GL_TEXTURE_CUBE_MAP$2);
            break
        }
      });

      var unroll = 1;
      switch (type) {
        case GL_SAMPLER_2D:
        case GL_SAMPLER_CUBE:
          var TEX = scope.def(VALUE, '._texture');
          scope(GL, '.uniform1i(', LOCATION, ',', TEX, '.bind());');
          scope.exit(TEX, '.unbind();');
          continue

        case GL_INT$3:
        case GL_BOOL:
          infix = '1i';
          break

        case GL_INT_VEC2:
        case GL_BOOL_VEC2:
          infix = '2i';
          unroll = 2;
          break

        case GL_INT_VEC3:
        case GL_BOOL_VEC3:
          infix = '3i';
          unroll = 3;
          break

        case GL_INT_VEC4:
        case GL_BOOL_VEC4:
          infix = '4i';
          unroll = 4;
          break

        case GL_FLOAT$8:
          infix = '1f';
          break

        case GL_FLOAT_VEC2:
          infix = '2f';
          unroll = 2;
          break

        case GL_FLOAT_VEC3:
          infix = '3f';
          unroll = 3;
          break

        case GL_FLOAT_VEC4:
          infix = '4f';
          unroll = 4;
          break

        case GL_FLOAT_MAT2:
          infix = 'Matrix2fv';
          break

        case GL_FLOAT_MAT3:
          infix = 'Matrix3fv';
          break

        case GL_FLOAT_MAT4:
          infix = 'Matrix4fv';
          break
      }

      if (infix.indexOf('Matrix') === -1 && size > 1) {
        infix += 'v';
        unroll = 1;
      }

      if (infix.charAt(0) === 'M') {
        scope(GL, '.uniform', infix, '(', LOCATION, ',');
        var matSize = Math.pow(type - GL_FLOAT_MAT2 + 2, 2);
        var STORAGE = env.global.def('new Float32Array(', matSize, ')');
        if (Array.isArray(VALUE)) {
          scope(
            'false,(',
            loop(matSize, function (i) {
              return STORAGE + '[' + i + ']=' + VALUE[i]
            }), ',', STORAGE, ')');
        } else {
          scope(
            'false,(Array.isArray(', VALUE, ')||', VALUE, ' instanceof Float32Array)?', VALUE, ':(',
            loop(matSize, function (i) {
              return STORAGE + '[' + i + ']=' + VALUE + '[' + i + ']'
            }), ',', STORAGE, ')');
        }
        scope(');');
      } else if (unroll > 1) {
        var prev = [];
        var cur = [];
        for (var j = 0; j < unroll; ++j) {
          if (Array.isArray(VALUE)) {
            cur.push(VALUE[j]);
          } else {
            cur.push(scope.def(VALUE + '[' + j + ']'));
          }
          if (isBatchInnerLoop) {
            prev.push(scope.def());
          }
        }
        if (isBatchInnerLoop) {
          scope('if(!', env.batchId, '||', prev.map(function (p, i) {
            return p + '!==' + cur[i]
          }).join('||'), '){', prev.map(function (p, i) {
            return p + '=' + cur[i] + ';'
          }).join(''));
        }
        scope(GL, '.uniform', infix, '(', LOCATION, ',', cur.join(','), ');');
        if (isBatchInnerLoop) {
          scope('}');
        }
      } else {
        check$1(!Array.isArray(VALUE), 'uniform value must not be an array');
        if (isBatchInnerLoop) {
          var prevS = scope.def();
          scope('if(!', env.batchId, '||', prevS, '!==', VALUE, '){',
            prevS, '=', VALUE, ';');
        }
        scope(GL, '.uniform', infix, '(', LOCATION, ',', VALUE, ');');
        if (isBatchInnerLoop) {
          scope('}');
        }
      }
    }
  }

  function emitDraw (env, outer, inner, args) {
    var shared = env.shared;
    var GL = shared.gl;
    var DRAW_STATE = shared.draw;

    var drawOptions = args.draw;

    function emitElements () {
      var defn = drawOptions.elements;
      var ELEMENTS;
      var scope = outer;
      if (defn) {
        if ((defn.contextDep && args.contextDynamic) || defn.propDep) {
          scope = inner;
        }
        ELEMENTS = defn.append(env, scope);
        if (drawOptions.elementsActive) {
          scope(
            'if(' + ELEMENTS + ')' +
            GL + '.bindBuffer(' + GL_ELEMENT_ARRAY_BUFFER$2 + ',' + ELEMENTS + '.buffer.buffer);');
        }
      } else {
        ELEMENTS = scope.def();
        scope(
          ELEMENTS, '=', DRAW_STATE, '.', S_ELEMENTS, ';',
          'if(', ELEMENTS, '){',
          GL, '.bindBuffer(', GL_ELEMENT_ARRAY_BUFFER$2, ',', ELEMENTS, '.buffer.buffer);}',
          'else if(', shared.vao, '.currentVAO){',
          ELEMENTS, '=', env.shared.elements + '.getElements(' + shared.vao, '.currentVAO.elements);',
          (!extVertexArrays ? 'if(' + ELEMENTS + ')' + GL + '.bindBuffer(' + GL_ELEMENT_ARRAY_BUFFER$2 + ',' + ELEMENTS + '.buffer.buffer);' : ''),
          '}');
      }
      return ELEMENTS
    }

    function emitCount () {
      var defn = drawOptions.count;
      var COUNT;
      var scope = outer;
      if (defn) {
        if ((defn.contextDep && args.contextDynamic) || defn.propDep) {
          scope = inner;
        }
        COUNT = defn.append(env, scope);
        check$1.optional(function () {
          if (defn.MISSING) {
            env.assert(outer, 'false', 'missing vertex count');
          }
          if (defn.DYNAMIC) {
            env.assert(scope, COUNT + '>=0', 'missing vertex count');
          }
        });
      } else {
        COUNT = scope.def(DRAW_STATE, '.', S_COUNT);
        check$1.optional(function () {
          env.assert(scope, COUNT + '>=0', 'missing vertex count');
        });
      }
      return COUNT
    }

    var ELEMENTS = emitElements();
    function emitValue (name) {
      var defn = drawOptions[name];
      if (defn) {
        if ((defn.contextDep && args.contextDynamic) || defn.propDep) {
          return defn.append(env, inner)
        } else {
          return defn.append(env, outer)
        }
      } else {
        return outer.def(DRAW_STATE, '.', name)
      }
    }

    var PRIMITIVE = emitValue(S_PRIMITIVE);
    var OFFSET = emitValue(S_OFFSET);

    var COUNT = emitCount();
    if (typeof COUNT === 'number') {
      if (COUNT === 0) {
        return
      }
    } else {
      inner('if(', COUNT, '){');
      inner.exit('}');
    }

    var INSTANCES, EXT_INSTANCING;
    if (extInstancing) {
      INSTANCES = emitValue(S_INSTANCES);
      EXT_INSTANCING = env.instancing;
    }

    var ELEMENT_TYPE = ELEMENTS + '.type';

    var elementsStatic = drawOptions.elements && isStatic(drawOptions.elements) && !drawOptions.vaoActive;

    function emitInstancing () {
      function drawElements () {
        inner(EXT_INSTANCING, '.drawElementsInstancedANGLE(', [
          PRIMITIVE,
          COUNT,
          ELEMENT_TYPE,
          OFFSET + '<<((' + ELEMENT_TYPE + '-' + GL_UNSIGNED_BYTE$8 + ')>>1)',
          INSTANCES
        ], ');');
      }

      function drawArrays () {
        inner(EXT_INSTANCING, '.drawArraysInstancedANGLE(',
          [PRIMITIVE, OFFSET, COUNT, INSTANCES], ');');
      }

      if (ELEMENTS && ELEMENTS !== 'null') {
        if (!elementsStatic) {
          inner('if(', ELEMENTS, '){');
          drawElements();
          inner('}else{');
          drawArrays();
          inner('}');
        } else {
          drawElements();
        }
      } else {
        drawArrays();
      }
    }

    function emitRegular () {
      function drawElements () {
        inner(GL + '.drawElements(' + [
          PRIMITIVE,
          COUNT,
          ELEMENT_TYPE,
          OFFSET + '<<((' + ELEMENT_TYPE + '-' + GL_UNSIGNED_BYTE$8 + ')>>1)'
        ] + ');');
      }

      function drawArrays () {
        inner(GL + '.drawArrays(' + [PRIMITIVE, OFFSET, COUNT] + ');');
      }

      if (ELEMENTS && ELEMENTS !== 'null') {
        if (!elementsStatic) {
          inner('if(', ELEMENTS, '){');
          drawElements();
          inner('}else{');
          drawArrays();
          inner('}');
        } else {
          drawElements();
        }
      } else {
        drawArrays();
      }
    }

    if (extInstancing && (typeof INSTANCES !== 'number' || INSTANCES >= 0)) {
      if (typeof INSTANCES === 'string') {
        inner('if(', INSTANCES, '>0){');
        emitInstancing();
        inner('}else if(', INSTANCES, '<0){');
        emitRegular();
        inner('}');
      } else {
        emitInstancing();
      }
    } else {
      emitRegular();
    }
  }

  function createBody (emitBody, parentEnv, args, program, count) {
    var env = createREGLEnvironment();
    var scope = env.proc('body', count);
    check$1.optional(function () {
      env.commandStr = parentEnv.commandStr;
      env.command = env.link(parentEnv.commandStr);
    });
    if (extInstancing) {
      env.instancing = scope.def(
        env.shared.extensions, '.angle_instanced_arrays');
    }
    emitBody(env, scope, args, program);
    return env.compile().body
  }

  // ===================================================
  // ===================================================
  // DRAW PROC
  // ===================================================
  // ===================================================
  function emitDrawBody (env, draw, args, program) {
    injectExtensions(env, draw);
    if (args.useVAO) {
      if (args.drawVAO) {
        draw(env.shared.vao, '.setVAO(', args.drawVAO.append(env, draw), ');');
      } else {
        draw(env.shared.vao, '.setVAO(', env.shared.vao, '.targetVAO);');
      }
    } else {
      draw(env.shared.vao, '.setVAO(null);');
      emitAttributes(env, draw, args, program.attributes, function () {
        return true
      });
    }
    emitUniforms(env, draw, args, program.uniforms, function () {
      return true
    }, false);
    emitDraw(env, draw, draw, args);
  }

  function emitDrawProc (env, args) {
    var draw = env.proc('draw', 1);

    injectExtensions(env, draw);

    emitContext(env, draw, args.context);
    emitPollFramebuffer(env, draw, args.framebuffer);

    emitPollState(env, draw, args);
    emitSetOptions(env, draw, args.state);

    emitProfile(env, draw, args, false, true);

    var program = args.shader.progVar.append(env, draw);
    draw(env.shared.gl, '.useProgram(', program, '.program);');

    if (args.shader.program) {
      emitDrawBody(env, draw, args, args.shader.program);
    } else {
      draw(env.shared.vao, '.setVAO(null);');
      var drawCache = env.global.def('{}');
      var PROG_ID = draw.def(program, '.id');
      var CACHED_PROC = draw.def(drawCache, '[', PROG_ID, ']');
      draw(
        env.cond(CACHED_PROC)
          .then(CACHED_PROC, '.call(this,a0);')
          .else(
            CACHED_PROC, '=', drawCache, '[', PROG_ID, ']=',
            env.link(function (program) {
              return createBody(emitDrawBody, env, args, program, 1)
            }), '(', program, ');',
            CACHED_PROC, '.call(this,a0);'));
    }

    if (Object.keys(args.state).length > 0) {
      draw(env.shared.current, '.dirty=true;');
    }
    if (env.shared.vao) {
      draw(env.shared.vao, '.setVAO(null);');
    }
  }

  // ===================================================
  // ===================================================
  // BATCH PROC
  // ===================================================
  // ===================================================

  function emitBatchDynamicShaderBody (env, scope, args, program) {
    env.batchId = 'a1';

    injectExtensions(env, scope);

    function all () {
      return true
    }

    emitAttributes(env, scope, args, program.attributes, all);
    emitUniforms(env, scope, args, program.uniforms, all, false);
    emitDraw(env, scope, scope, args);
  }

  function emitBatchBody (env, scope, args, program) {
    injectExtensions(env, scope);

    var contextDynamic = args.contextDep;

    var BATCH_ID = scope.def();
    var PROP_LIST = 'a0';
    var NUM_PROPS = 'a1';
    var PROPS = scope.def();
    env.shared.props = PROPS;
    env.batchId = BATCH_ID;

    var outer = env.scope();
    var inner = env.scope();

    scope(
      outer.entry,
      'for(', BATCH_ID, '=0;', BATCH_ID, '<', NUM_PROPS, ';++', BATCH_ID, '){',
      PROPS, '=', PROP_LIST, '[', BATCH_ID, '];',
      inner,
      '}',
      outer.exit);

    function isInnerDefn (defn) {
      return ((defn.contextDep && contextDynamic) || defn.propDep)
    }

    function isOuterDefn (defn) {
      return !isInnerDefn(defn)
    }

    if (args.needsContext) {
      emitContext(env, inner, args.context);
    }
    if (args.needsFramebuffer) {
      emitPollFramebuffer(env, inner, args.framebuffer);
    }
    emitSetOptions(env, inner, args.state, isInnerDefn);

    if (args.profile && isInnerDefn(args.profile)) {
      emitProfile(env, inner, args, false, true);
    }

    if (!program) {
      var progCache = env.global.def('{}');
      var PROGRAM = args.shader.progVar.append(env, inner);
      var PROG_ID = inner.def(PROGRAM, '.id');
      var CACHED_PROC = inner.def(progCache, '[', PROG_ID, ']');
      inner(
        env.shared.gl, '.useProgram(', PROGRAM, '.program);',
        'if(!', CACHED_PROC, '){',
        CACHED_PROC, '=', progCache, '[', PROG_ID, ']=',
        env.link(function (program) {
          return createBody(
            emitBatchDynamicShaderBody, env, args, program, 2)
        }), '(', PROGRAM, ');}',
        CACHED_PROC, '.call(this,a0[', BATCH_ID, '],', BATCH_ID, ');');
    } else {
      if (args.useVAO) {
        if (args.drawVAO) {
          if (isInnerDefn(args.drawVAO)) {
            // vao is a prop
            inner(env.shared.vao, '.setVAO(', args.drawVAO.append(env, inner), ');');
          } else {
            // vao is invariant
            outer(env.shared.vao, '.setVAO(', args.drawVAO.append(env, outer), ');');
          }
        } else {
          // scoped vao binding
          outer(env.shared.vao, '.setVAO(', env.shared.vao, '.targetVAO);');
        }
      } else {
        outer(env.shared.vao, '.setVAO(null);');
        emitAttributes(env, outer, args, program.attributes, isOuterDefn);
        emitAttributes(env, inner, args, program.attributes, isInnerDefn);
      }
      emitUniforms(env, outer, args, program.uniforms, isOuterDefn, false);
      emitUniforms(env, inner, args, program.uniforms, isInnerDefn, true);
      emitDraw(env, outer, inner, args);
    }
  }

  function emitBatchProc (env, args) {
    var batch = env.proc('batch', 2);
    env.batchId = '0';

    injectExtensions(env, batch);

    // Check if any context variables depend on props
    var contextDynamic = false;
    var needsContext = true;
    Object.keys(args.context).forEach(function (name) {
      contextDynamic = contextDynamic || args.context[name].propDep;
    });
    if (!contextDynamic) {
      emitContext(env, batch, args.context);
      needsContext = false;
    }

    // framebuffer state affects framebufferWidth/height context vars
    var framebuffer = args.framebuffer;
    var needsFramebuffer = false;
    if (framebuffer) {
      if (framebuffer.propDep) {
        contextDynamic = needsFramebuffer = true;
      } else if (framebuffer.contextDep && contextDynamic) {
        needsFramebuffer = true;
      }
      if (!needsFramebuffer) {
        emitPollFramebuffer(env, batch, framebuffer);
      }
    } else {
      emitPollFramebuffer(env, batch, null);
    }

    // viewport is weird because it can affect context vars
    if (args.state.viewport && args.state.viewport.propDep) {
      contextDynamic = true;
    }

    function isInnerDefn (defn) {
      return (defn.contextDep && contextDynamic) || defn.propDep
    }

    // set webgl options
    emitPollState(env, batch, args);
    emitSetOptions(env, batch, args.state, function (defn) {
      return !isInnerDefn(defn)
    });

    if (!args.profile || !isInnerDefn(args.profile)) {
      emitProfile(env, batch, args, false, 'a1');
    }

    // Save these values to args so that the batch body routine can use them
    args.contextDep = contextDynamic;
    args.needsContext = needsContext;
    args.needsFramebuffer = needsFramebuffer;

    // determine if shader is dynamic
    var progDefn = args.shader.progVar;
    if ((progDefn.contextDep && contextDynamic) || progDefn.propDep) {
      emitBatchBody(
        env,
        batch,
        args,
        null);
    } else {
      var PROGRAM = progDefn.append(env, batch);
      batch(env.shared.gl, '.useProgram(', PROGRAM, '.program);');
      if (args.shader.program) {
        emitBatchBody(
          env,
          batch,
          args,
          args.shader.program);
      } else {
        batch(env.shared.vao, '.setVAO(null);');
        var batchCache = env.global.def('{}');
        var PROG_ID = batch.def(PROGRAM, '.id');
        var CACHED_PROC = batch.def(batchCache, '[', PROG_ID, ']');
        batch(
          env.cond(CACHED_PROC)
            .then(CACHED_PROC, '.call(this,a0,a1);')
            .else(
              CACHED_PROC, '=', batchCache, '[', PROG_ID, ']=',
              env.link(function (program) {
                return createBody(emitBatchBody, env, args, program, 2)
              }), '(', PROGRAM, ');',
              CACHED_PROC, '.call(this,a0,a1);'));
      }
    }

    if (Object.keys(args.state).length > 0) {
      batch(env.shared.current, '.dirty=true;');
    }

    if (env.shared.vao) {
      batch(env.shared.vao, '.setVAO(null);');
    }
  }

  // ===================================================
  // ===================================================
  // SCOPE COMMAND
  // ===================================================
  // ===================================================
  function emitScopeProc (env, args) {
    var scope = env.proc('scope', 3);
    env.batchId = 'a2';

    var shared = env.shared;
    var CURRENT_STATE = shared.current;

    emitContext(env, scope, args.context);

    if (args.framebuffer) {
      args.framebuffer.append(env, scope);
    }

    sortState(Object.keys(args.state)).forEach(function (name) {
      var defn = args.state[name];
      var value = defn.append(env, scope);
      if (isArrayLike(value)) {
        value.forEach(function (v, i) {
          scope.set(env.next[name], '[' + i + ']', v);
        });
      } else {
        scope.set(shared.next, '.' + name, value);
      }
    });

    emitProfile(env, scope, args, true, true)

    ;[S_ELEMENTS, S_OFFSET, S_COUNT, S_INSTANCES, S_PRIMITIVE].forEach(
      function (opt) {
        var variable = args.draw[opt];
        if (!variable) {
          return
        }
        scope.set(shared.draw, '.' + opt, '' + variable.append(env, scope));
      });

    Object.keys(args.uniforms).forEach(function (opt) {
      var value = args.uniforms[opt].append(env, scope);
      if (Array.isArray(value)) {
        value = '[' + value.join() + ']';
      }
      scope.set(
        shared.uniforms,
        '[' + stringStore.id(opt) + ']',
        value);
    });

    Object.keys(args.attributes).forEach(function (name) {
      var record = args.attributes[name].append(env, scope);
      var scopeAttrib = env.scopeAttrib(name);
      Object.keys(new AttributeRecord()).forEach(function (prop) {
        scope.set(scopeAttrib, '.' + prop, record[prop]);
      });
    });

    if (args.scopeVAO) {
      scope.set(shared.vao, '.targetVAO', args.scopeVAO.append(env, scope));
    }

    function saveShader (name) {
      var shader = args.shader[name];
      if (shader) {
        scope.set(shared.shader, '.' + name, shader.append(env, scope));
      }
    }
    saveShader(S_VERT);
    saveShader(S_FRAG);

    if (Object.keys(args.state).length > 0) {
      scope(CURRENT_STATE, '.dirty=true;');
      scope.exit(CURRENT_STATE, '.dirty=true;');
    }

    scope('a1(', env.shared.context, ',a0,', env.batchId, ');');
  }

  function isDynamicObject (object) {
    if (typeof object !== 'object' || isArrayLike(object)) {
      return
    }
    var props = Object.keys(object);
    for (var i = 0; i < props.length; ++i) {
      if (dynamic.isDynamic(object[props[i]])) {
        return true
      }
    }
    return false
  }

  function splatObject (env, options, name) {
    var object = options.static[name];
    if (!object || !isDynamicObject(object)) {
      return
    }

    var globals = env.global;
    var keys = Object.keys(object);
    var thisDep = false;
    var contextDep = false;
    var propDep = false;
    var objectRef = env.global.def('{}');
    keys.forEach(function (key) {
      var value = object[key];
      if (dynamic.isDynamic(value)) {
        if (typeof value === 'function') {
          value = object[key] = dynamic.unbox(value);
        }
        var deps = createDynamicDecl(value, null);
        thisDep = thisDep || deps.thisDep;
        propDep = propDep || deps.propDep;
        contextDep = contextDep || deps.contextDep;
      } else {
        globals(objectRef, '.', key, '=');
        switch (typeof value) {
          case 'number':
            globals(value);
            break
          case 'string':
            globals('"', value, '"');
            break
          case 'object':
            if (Array.isArray(value)) {
              globals('[', value.join(), ']');
            }
            break
          default:
            globals(env.link(value));
            break
        }
        globals(';');
      }
    });

    function appendBlock (env, block) {
      keys.forEach(function (key) {
        var value = object[key];
        if (!dynamic.isDynamic(value)) {
          return
        }
        var ref = env.invoke(block, value);
        block(objectRef, '.', key, '=', ref, ';');
      });
    }

    options.dynamic[name] = new dynamic.DynamicVariable(DYN_THUNK, {
      thisDep: thisDep,
      contextDep: contextDep,
      propDep: propDep,
      ref: objectRef,
      append: appendBlock
    });
    delete options.static[name];
  }

  // ===========================================================================
  // ===========================================================================
  // MAIN DRAW COMMAND
  // ===========================================================================
  // ===========================================================================
  function compileCommand (options, attributes, uniforms, context, stats) {
    var env = createREGLEnvironment();

    // link stats, so that we can easily access it in the program.
    env.stats = env.link(stats);

    // splat options and attributes to allow for dynamic nested properties
    Object.keys(attributes.static).forEach(function (key) {
      splatObject(env, attributes, key);
    });
    NESTED_OPTIONS.forEach(function (name) {
      splatObject(env, options, name);
    });

    var args = parseArguments(options, attributes, uniforms, context, env);

    emitDrawProc(env, args);
    emitScopeProc(env, args);
    emitBatchProc(env, args);

    return extend(env.compile(), {
      destroy: function () {
        args.shader.program.destroy();
      }
    })
  }

  // ===========================================================================
  // ===========================================================================
  // POLL / REFRESH
  // ===========================================================================
  // ===========================================================================
  return {
    next: nextState,
    current: currentState,
    procs: (function () {
      var env = createREGLEnvironment();
      var poll = env.proc('poll');
      var refresh = env.proc('refresh');
      var common = env.block();
      poll(common);
      refresh(common);

      var shared = env.shared;
      var GL = shared.gl;
      var NEXT_STATE = shared.next;
      var CURRENT_STATE = shared.current;

      common(CURRENT_STATE, '.dirty=false;');

      emitPollFramebuffer(env, poll);
      emitPollFramebuffer(env, refresh, null, true);

      // Refresh updates all attribute state changes
      var INSTANCING;
      if (extInstancing) {
        INSTANCING = env.link(extInstancing);
      }

      // update vertex array bindings
      if (extensions.oes_vertex_array_object) {
        refresh(env.link(extensions.oes_vertex_array_object), '.bindVertexArrayOES(null);');
      }
      for (var i = 0; i < limits.maxAttributes; ++i) {
        var BINDING = refresh.def(shared.attributes, '[', i, ']');
        var ifte = env.cond(BINDING, '.buffer');
        ifte.then(
          GL, '.enableVertexAttribArray(', i, ');',
          GL, '.bindBuffer(',
          GL_ARRAY_BUFFER$2, ',',
          BINDING, '.buffer.buffer);',
          GL, '.vertexAttribPointer(',
          i, ',',
          BINDING, '.size,',
          BINDING, '.type,',
          BINDING, '.normalized,',
          BINDING, '.stride,',
          BINDING, '.offset);'
        ).else(
          GL, '.disableVertexAttribArray(', i, ');',
          GL, '.vertexAttrib4f(',
          i, ',',
          BINDING, '.x,',
          BINDING, '.y,',
          BINDING, '.z,',
          BINDING, '.w);',
          BINDING, '.buffer=null;');
        refresh(ifte);
        if (extInstancing) {
          refresh(
            INSTANCING, '.vertexAttribDivisorANGLE(',
            i, ',',
            BINDING, '.divisor);');
        }
      }
      refresh(
        env.shared.vao, '.currentVAO=null;',
        env.shared.vao, '.setVAO(', env.shared.vao, '.targetVAO);');

      Object.keys(GL_FLAGS).forEach(function (flag) {
        var cap = GL_FLAGS[flag];
        var NEXT = common.def(NEXT_STATE, '.', flag);
        var block = env.block();
        block('if(', NEXT, '){',
          GL, '.enable(', cap, ')}else{',
          GL, '.disable(', cap, ')}',
          CURRENT_STATE, '.', flag, '=', NEXT, ';');
        refresh(block);
        poll(
          'if(', NEXT, '!==', CURRENT_STATE, '.', flag, '){',
          block,
          '}');
      });

      Object.keys(GL_VARIABLES).forEach(function (name) {
        var func = GL_VARIABLES[name];
        var init = currentState[name];
        var NEXT, CURRENT;
        var block = env.block();
        block(GL, '.', func, '(');
        if (isArrayLike(init)) {
          var n = init.length;
          NEXT = env.global.def(NEXT_STATE, '.', name);
          CURRENT = env.global.def(CURRENT_STATE, '.', name);
          block(
            loop(n, function (i) {
              return NEXT + '[' + i + ']'
            }), ');',
            loop(n, function (i) {
              return CURRENT + '[' + i + ']=' + NEXT + '[' + i + '];'
            }).join(''));
          poll(
            'if(', loop(n, function (i) {
              return NEXT + '[' + i + ']!==' + CURRENT + '[' + i + ']'
            }).join('||'), '){',
            block,
            '}');
        } else {
          NEXT = common.def(NEXT_STATE, '.', name);
          CURRENT = common.def(CURRENT_STATE, '.', name);
          block(
            NEXT, ');',
            CURRENT_STATE, '.', name, '=', NEXT, ';');
          poll(
            'if(', NEXT, '!==', CURRENT, '){',
            block,
            '}');
        }
        refresh(block);
      });

      return env.compile()
    })(),
    compile: compileCommand
  }
}

function stats () {
  return {
    vaoCount: 0,
    bufferCount: 0,
    elementsCount: 0,
    framebufferCount: 0,
    shaderCount: 0,
    textureCount: 0,
    cubeCount: 0,
    renderbufferCount: 0,
    maxTextureUnits: 0
  }
}

var GL_QUERY_RESULT_EXT = 0x8866;
var GL_QUERY_RESULT_AVAILABLE_EXT = 0x8867;
var GL_TIME_ELAPSED_EXT = 0x88BF;

var createTimer = function (gl, extensions) {
  if (!extensions.ext_disjoint_timer_query) {
    return null
  }

  // QUERY POOL BEGIN
  var queryPool = [];
  function allocQuery () {
    return queryPool.pop() || extensions.ext_disjoint_timer_query.createQueryEXT()
  }
  function freeQuery (query) {
    queryPool.push(query);
  }
  // QUERY POOL END

  var pendingQueries = [];
  function beginQuery (stats) {
    var query = allocQuery();
    extensions.ext_disjoint_timer_query.beginQueryEXT(GL_TIME_ELAPSED_EXT, query);
    pendingQueries.push(query);
    pushScopeStats(pendingQueries.length - 1, pendingQueries.length, stats);
  }

  function endQuery () {
    extensions.ext_disjoint_timer_query.endQueryEXT(GL_TIME_ELAPSED_EXT);
  }

  //
  // Pending stats pool.
  //
  function PendingStats () {
    this.startQueryIndex = -1;
    this.endQueryIndex = -1;
    this.sum = 0;
    this.stats = null;
  }
  var pendingStatsPool = [];
  function allocPendingStats () {
    return pendingStatsPool.pop() || new PendingStats()
  }
  function freePendingStats (pendingStats) {
    pendingStatsPool.push(pendingStats);
  }
  // Pending stats pool end

  var pendingStats = [];
  function pushScopeStats (start, end, stats) {
    var ps = allocPendingStats();
    ps.startQueryIndex = start;
    ps.endQueryIndex = end;
    ps.sum = 0;
    ps.stats = stats;
    pendingStats.push(ps);
  }

  // we should call this at the beginning of the frame,
  // in order to update gpuTime
  var timeSum = [];
  var queryPtr = [];
  function update () {
    var ptr, i;

    var n = pendingQueries.length;
    if (n === 0) {
      return
    }

    // Reserve space
    queryPtr.length = Math.max(queryPtr.length, n + 1);
    timeSum.length = Math.max(timeSum.length, n + 1);
    timeSum[0] = 0;
    queryPtr[0] = 0;

    // Update all pending timer queries
    var queryTime = 0;
    ptr = 0;
    for (i = 0; i < pendingQueries.length; ++i) {
      var query = pendingQueries[i];
      if (extensions.ext_disjoint_timer_query.getQueryObjectEXT(query, GL_QUERY_RESULT_AVAILABLE_EXT)) {
        queryTime += extensions.ext_disjoint_timer_query.getQueryObjectEXT(query, GL_QUERY_RESULT_EXT);
        freeQuery(query);
      } else {
        pendingQueries[ptr++] = query;
      }
      timeSum[i + 1] = queryTime;
      queryPtr[i + 1] = ptr;
    }
    pendingQueries.length = ptr;

    // Update all pending stat queries
    ptr = 0;
    for (i = 0; i < pendingStats.length; ++i) {
      var stats = pendingStats[i];
      var start = stats.startQueryIndex;
      var end = stats.endQueryIndex;
      stats.sum += timeSum[end] - timeSum[start];
      var startPtr = queryPtr[start];
      var endPtr = queryPtr[end];
      if (endPtr === startPtr) {
        stats.stats.gpuTime += stats.sum / 1e6;
        freePendingStats(stats);
      } else {
        stats.startQueryIndex = startPtr;
        stats.endQueryIndex = endPtr;
        pendingStats[ptr++] = stats;
      }
    }
    pendingStats.length = ptr;
  }

  return {
    beginQuery: beginQuery,
    endQuery: endQuery,
    pushScopeStats: pushScopeStats,
    update: update,
    getNumPendingQueries: function () {
      return pendingQueries.length
    },
    clear: function () {
      queryPool.push.apply(queryPool, pendingQueries);
      for (var i = 0; i < queryPool.length; i++) {
        extensions.ext_disjoint_timer_query.deleteQueryEXT(queryPool[i]);
      }
      pendingQueries.length = 0;
      queryPool.length = 0;
    },
    restore: function () {
      pendingQueries.length = 0;
      queryPool.length = 0;
    }
  }
};

var GL_COLOR_BUFFER_BIT = 16384;
var GL_DEPTH_BUFFER_BIT = 256;
var GL_STENCIL_BUFFER_BIT = 1024;

var GL_ARRAY_BUFFER = 34962;

var CONTEXT_LOST_EVENT = 'webglcontextlost';
var CONTEXT_RESTORED_EVENT = 'webglcontextrestored';

var DYN_PROP = 1;
var DYN_CONTEXT = 2;
var DYN_STATE = 3;

function find (haystack, needle) {
  for (var i = 0; i < haystack.length; ++i) {
    if (haystack[i] === needle) {
      return i
    }
  }
  return -1
}

function wrapREGL (args) {
  var config = parseArgs(args);
  if (!config) {
    return null
  }

  var gl = config.gl;
  var glAttributes = gl.getContextAttributes();
  var contextLost = gl.isContextLost();

  var extensionState = createExtensionCache(gl, config);
  if (!extensionState) {
    return null
  }

  var stringStore = createStringStore();
  var stats$$1 = stats();
  var extensions = extensionState.extensions;
  var timer = createTimer(gl, extensions);

  var START_TIME = clock();
  var WIDTH = gl.drawingBufferWidth;
  var HEIGHT = gl.drawingBufferHeight;

  var contextState = {
    tick: 0,
    time: 0,
    viewportWidth: WIDTH,
    viewportHeight: HEIGHT,
    framebufferWidth: WIDTH,
    framebufferHeight: HEIGHT,
    drawingBufferWidth: WIDTH,
    drawingBufferHeight: HEIGHT,
    pixelRatio: config.pixelRatio
  };
  var uniformState = {};
  var drawState = {
    elements: null,
    primitive: 4, // GL_TRIANGLES
    count: -1,
    offset: 0,
    instances: -1
  };

  var limits = wrapLimits(gl, extensions);
  var bufferState = wrapBufferState(
    gl,
    stats$$1,
    config,
    destroyBuffer);
  var elementState = wrapElementsState(gl, extensions, bufferState, stats$$1);
  var attributeState = wrapAttributeState(
    gl,
    extensions,
    limits,
    stats$$1,
    bufferState,
    elementState,
    drawState);
  function destroyBuffer (buffer) {
    return attributeState.destroyBuffer(buffer)
  }
  var shaderState = wrapShaderState(gl, stringStore, stats$$1, config);
  var textureState = createTextureSet(
    gl,
    extensions,
    limits,
    function () { core.procs.poll(); },
    contextState,
    stats$$1,
    config);
  var renderbufferState = wrapRenderbuffers(gl, extensions, limits, stats$$1, config);
  var framebufferState = wrapFBOState(
    gl,
    extensions,
    limits,
    textureState,
    renderbufferState,
    stats$$1);
  var core = reglCore(
    gl,
    stringStore,
    extensions,
    limits,
    bufferState,
    elementState,
    textureState,
    framebufferState,
    uniformState,
    attributeState,
    shaderState,
    drawState,
    contextState,
    timer,
    config);
  var readPixels = wrapReadPixels(
    gl,
    framebufferState,
    core.procs.poll,
    contextState,
    glAttributes, extensions, limits);

  var nextState = core.next;
  var canvas = gl.canvas;

  var rafCallbacks = [];
  var lossCallbacks = [];
  var restoreCallbacks = [];
  var destroyCallbacks = [config.onDestroy];

  var activeRAF = null;
  function handleRAF () {
    if (rafCallbacks.length === 0) {
      if (timer) {
        timer.update();
      }
      activeRAF = null;
      return
    }

    // schedule next animation frame
    activeRAF = raf.next(handleRAF);

    // poll for changes
    poll();

    // fire a callback for all pending rafs
    for (var i = rafCallbacks.length - 1; i >= 0; --i) {
      var cb = rafCallbacks[i];
      if (cb) {
        cb(contextState, null, 0);
      }
    }

    // flush all pending webgl calls
    gl.flush();

    // poll GPU timers *after* gl.flush so we don't delay command dispatch
    if (timer) {
      timer.update();
    }
  }

  function startRAF () {
    if (!activeRAF && rafCallbacks.length > 0) {
      activeRAF = raf.next(handleRAF);
    }
  }

  function stopRAF () {
    if (activeRAF) {
      raf.cancel(handleRAF);
      activeRAF = null;
    }
  }

  function handleContextLoss (event) {
    event.preventDefault();

    // set context lost flag
    contextLost = true;

    // pause request animation frame
    stopRAF();

    // lose context
    lossCallbacks.forEach(function (cb) {
      cb();
    });
  }

  function handleContextRestored (event) {
    // clear error code
    gl.getError();

    // clear context lost flag
    contextLost = false;

    // refresh state
    extensionState.restore();
    shaderState.restore();
    bufferState.restore();
    textureState.restore();
    renderbufferState.restore();
    framebufferState.restore();
    attributeState.restore();
    if (timer) {
      timer.restore();
    }

    // refresh state
    core.procs.refresh();

    // restart RAF
    startRAF();

    // restore context
    restoreCallbacks.forEach(function (cb) {
      cb();
    });
  }

  if (canvas) {
    canvas.addEventListener(CONTEXT_LOST_EVENT, handleContextLoss, false);
    canvas.addEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored, false);
  }

  function destroy () {
    rafCallbacks.length = 0;
    stopRAF();

    if (canvas) {
      canvas.removeEventListener(CONTEXT_LOST_EVENT, handleContextLoss);
      canvas.removeEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored);
    }

    shaderState.clear();
    framebufferState.clear();
    renderbufferState.clear();
    attributeState.clear();
    textureState.clear();
    elementState.clear();
    bufferState.clear();

    if (timer) {
      timer.clear();
    }

    destroyCallbacks.forEach(function (cb) {
      cb();
    });
  }

  function compileProcedure (options) {
    check$1(!!options, 'invalid args to regl({...})');
    check$1.type(options, 'object', 'invalid args to regl({...})');

    function flattenNestedOptions (options) {
      var result = extend({}, options);
      delete result.uniforms;
      delete result.attributes;
      delete result.context;
      delete result.vao;

      if ('stencil' in result && result.stencil.op) {
        result.stencil.opBack = result.stencil.opFront = result.stencil.op;
        delete result.stencil.op;
      }

      function merge (name) {
        if (name in result) {
          var child = result[name];
          delete result[name];
          Object.keys(child).forEach(function (prop) {
            result[name + '.' + prop] = child[prop];
          });
        }
      }
      merge('blend');
      merge('depth');
      merge('cull');
      merge('stencil');
      merge('polygonOffset');
      merge('scissor');
      merge('sample');

      if ('vao' in options) {
        result.vao = options.vao;
      }

      return result
    }

    function separateDynamic (object, useArrays) {
      var staticItems = {};
      var dynamicItems = {};
      Object.keys(object).forEach(function (option) {
        var value = object[option];
        if (dynamic.isDynamic(value)) {
          dynamicItems[option] = dynamic.unbox(value, option);
          return
        } else if (useArrays && Array.isArray(value)) {
          for (var i = 0; i < value.length; ++i) {
            if (dynamic.isDynamic(value[i])) {
              dynamicItems[option] = dynamic.unbox(value, option);
              return
            }
          }
        }
        staticItems[option] = value;
      });
      return {
        dynamic: dynamicItems,
        static: staticItems
      }
    }

    // Treat context variables separate from other dynamic variables
    var context = separateDynamic(options.context || {}, true);
    var uniforms = separateDynamic(options.uniforms || {}, true);
    var attributes = separateDynamic(options.attributes || {}, false);
    var opts = separateDynamic(flattenNestedOptions(options), false);

    var stats$$1 = {
      gpuTime: 0.0,
      cpuTime: 0.0,
      count: 0
    };

    var compiled = core.compile(opts, attributes, uniforms, context, stats$$1);

    var draw = compiled.draw;
    var batch = compiled.batch;
    var scope = compiled.scope;

    // FIXME: we should modify code generation for batch commands so this
    // isn't necessary
    var EMPTY_ARRAY = [];
    function reserve (count) {
      while (EMPTY_ARRAY.length < count) {
        EMPTY_ARRAY.push(null);
      }
      return EMPTY_ARRAY
    }

    function REGLCommand (args, body) {
      var i;
      if (contextLost) {
        check$1.raise('context lost');
      }
      if (typeof args === 'function') {
        return scope.call(this, null, args, 0)
      } else if (typeof body === 'function') {
        if (typeof args === 'number') {
          for (i = 0; i < args; ++i) {
            scope.call(this, null, body, i);
          }
        } else if (Array.isArray(args)) {
          for (i = 0; i < args.length; ++i) {
            scope.call(this, args[i], body, i);
          }
        } else {
          return scope.call(this, args, body, 0)
        }
      } else if (typeof args === 'number') {
        if (args > 0) {
          return batch.call(this, reserve(args | 0), args | 0)
        }
      } else if (Array.isArray(args)) {
        if (args.length) {
          return batch.call(this, args, args.length)
        }
      } else {
        return draw.call(this, args)
      }
    }

    return extend(REGLCommand, {
      stats: stats$$1,
      destroy: function () {
        compiled.destroy();
      }
    })
  }

  var setFBO = framebufferState.setFBO = compileProcedure({
    framebuffer: dynamic.define.call(null, DYN_PROP, 'framebuffer')
  });

  function clearImpl (_, options) {
    var clearFlags = 0;
    core.procs.poll();

    var c = options.color;
    if (c) {
      gl.clearColor(+c[0] || 0, +c[1] || 0, +c[2] || 0, +c[3] || 0);
      clearFlags |= GL_COLOR_BUFFER_BIT;
    }
    if ('depth' in options) {
      gl.clearDepth(+options.depth);
      clearFlags |= GL_DEPTH_BUFFER_BIT;
    }
    if ('stencil' in options) {
      gl.clearStencil(options.stencil | 0);
      clearFlags |= GL_STENCIL_BUFFER_BIT;
    }

    check$1(!!clearFlags, 'called regl.clear with no buffer specified');
    gl.clear(clearFlags);
  }

  function clear (options) {
    check$1(
      typeof options === 'object' && options,
      'regl.clear() takes an object as input');
    if ('framebuffer' in options) {
      if (options.framebuffer &&
          options.framebuffer_reglType === 'framebufferCube') {
        for (var i = 0; i < 6; ++i) {
          setFBO(extend({
            framebuffer: options.framebuffer.faces[i]
          }, options), clearImpl);
        }
      } else {
        setFBO(options, clearImpl);
      }
    } else {
      clearImpl(null, options);
    }
  }

  function frame (cb) {
    check$1.type(cb, 'function', 'regl.frame() callback must be a function');
    rafCallbacks.push(cb);

    function cancel () {
      // FIXME:  should we check something other than equals cb here?
      // what if a user calls frame twice with the same callback...
      //
      var i = find(rafCallbacks, cb);
      check$1(i >= 0, 'cannot cancel a frame twice');
      function pendingCancel () {
        var index = find(rafCallbacks, pendingCancel);
        rafCallbacks[index] = rafCallbacks[rafCallbacks.length - 1];
        rafCallbacks.length -= 1;
        if (rafCallbacks.length <= 0) {
          stopRAF();
        }
      }
      rafCallbacks[i] = pendingCancel;
    }

    startRAF();

    return {
      cancel: cancel
    }
  }

  // poll viewport
  function pollViewport () {
    var viewport = nextState.viewport;
    var scissorBox = nextState.scissor_box;
    viewport[0] = viewport[1] = scissorBox[0] = scissorBox[1] = 0;
    contextState.viewportWidth =
      contextState.framebufferWidth =
      contextState.drawingBufferWidth =
      viewport[2] =
      scissorBox[2] = gl.drawingBufferWidth;
    contextState.viewportHeight =
      contextState.framebufferHeight =
      contextState.drawingBufferHeight =
      viewport[3] =
      scissorBox[3] = gl.drawingBufferHeight;
  }

  function poll () {
    contextState.tick += 1;
    contextState.time = now();
    pollViewport();
    core.procs.poll();
  }

  function refresh () {
    textureState.refresh();
    pollViewport();
    core.procs.refresh();
    if (timer) {
      timer.update();
    }
  }

  function now () {
    return (clock() - START_TIME) / 1000.0
  }

  refresh();

  function addListener (event, callback) {
    check$1.type(callback, 'function', 'listener callback must be a function');

    var callbacks;
    switch (event) {
      case 'frame':
        return frame(callback)
      case 'lost':
        callbacks = lossCallbacks;
        break
      case 'restore':
        callbacks = restoreCallbacks;
        break
      case 'destroy':
        callbacks = destroyCallbacks;
        break
      default:
        check$1.raise('invalid event, must be one of frame,lost,restore,destroy');
    }

    callbacks.push(callback);
    return {
      cancel: function () {
        for (var i = 0; i < callbacks.length; ++i) {
          if (callbacks[i] === callback) {
            callbacks[i] = callbacks[callbacks.length - 1];
            callbacks.pop();
            return
          }
        }
      }
    }
  }

  var regl = extend(compileProcedure, {
    // Clear current FBO
    clear: clear,

    // Short cuts for dynamic variables
    prop: dynamic.define.bind(null, DYN_PROP),
    context: dynamic.define.bind(null, DYN_CONTEXT),
    this: dynamic.define.bind(null, DYN_STATE),

    // executes an empty draw command
    draw: compileProcedure({}),

    // Resources
    buffer: function (options) {
      return bufferState.create(options, GL_ARRAY_BUFFER, false, false)
    },
    elements: function (options) {
      return elementState.create(options, false)
    },
    texture: textureState.create2D,
    cube: textureState.createCube,
    renderbuffer: renderbufferState.create,
    framebuffer: framebufferState.create,
    framebufferCube: framebufferState.createCube,
    vao: attributeState.createVAO,

    // Expose context attributes
    attributes: glAttributes,

    // Frame rendering
    frame: frame,
    on: addListener,

    // System limits
    limits: limits,
    hasExtension: function (name) {
      return limits.extensions.indexOf(name.toLowerCase()) >= 0
    },

    // Read pixels
    read: readPixels,

    // Destroy regl and all associated resources
    destroy: destroy,

    // Direct GL state manipulation
    _gl: gl,
    _refresh: refresh,

    poll: function () {
      poll();
      if (timer) {
        timer.update();
      }
    },

    // Current time
    now: now,

    // regl Statistics Information
    stats: stats$$1
  });

  config.onDone(null, regl);

  return regl
}

return wrapREGL;

})));

});

/* src/pages/index.svelte generated by Svelte v3.31.0 */

function add_css$5() {
	var style = element("style");
	style.id = "svelte-11pit5o-style";
	style.textContent = ".container-logo.svelte-11pit5o{width:100%;z-index:1000;position:absolute;display:grid;grid-template-rows:65vh 15vh 5vh auto;overflow-y:hidden}.container-svg.svelte-11pit5o{width:40vw;height:40vh;padding:0em 0em 1em 2em;margin-left:auto;margin-right:auto;margin-top:4em;position:relative;bottom:0}.container-social-links.svelte-11pit5o{display:flex;justify-items:center;justify-content:space-around;margin-left:auto;margin-right:auto;margin-top:auto}path.svelte-11pit5o{fill:white}.type-logo.svelte-11pit5o{color:white}h1.svelte-11pit5o{font-size:7vw;margin:0px;font-family:'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;text-align:center}h2.svelte-11pit5o{font-size:1.1rem;margin:0px;text-align:center}.title.svelte-11pit5o{grid-row:2/2;min-height:100px}.subtitle.svelte-11pit5o{grid-row:3/3;min-height:100px}.canvas-logo.svelte-11pit5o{background-color:rgb(16, 16, 16);height:100% !important;width:100% !important;visibility:visible;border-radius:2px}";
	append(document.head, style);
}

function create_fragment$c(ctx) {
	let div5;

	return {
		c() {
			div5 = element("div");

			div5.innerHTML = `<div class="container-logo svelte-11pit5o"><div class="container-svg svelte-11pit5o"><svg xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns="http://www.w3.org/2000/svg" xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:ns1="http://sozi.baierouge.fr" xmlns:cc="http://creativecommons.org/ns#" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:dc="http://purl.org/dc/elements/1.1/" id="svg2" viewBox="0 0 500 395.89" version="1.1" style="margin-top:auto;" inkscape:version="0.48.3.1 r9886" class="spiral-logo"><sodipodi:namedview id="base" fit-margin-left="0" inkscape:showpageshadow="false" inkscape:zoom="0.32091642" borderopacity="1.0" inkscape:current-layer="layer1" inkscape:cx="145.05777" inkscape:cy="-369.87653" inkscape:window-maximized="1" showgrid="false" fit-margin-right="0" showguides="true" bordercolor="#666666" inkscape:window-x="0" inkscape:guide-bbox="true" inkscape:window-y="654" fit-margin-bottom="0" inkscape:window-width="1680" inkscape:pageopacity="0.0" inkscape:pageshadow="2" pagecolor="#ffffff" inkscape:document-units="px" inkscape:window-height="1026" showborder="false" fit-margin-top="0"></sodipodi:namedview><g id="layer1" inkscape:label="Layer 1" inkscape:groupmode="layer" transform="translate(9056 -2892.1)"><g id="g5848" transform="matrix(.41395 0 0 .41395 -6675.3 1897.4)"><path id="path4912" sodipodi:nodetypes="sssssssssssssscsssssssssssssscscs" inkscape:connector-curvature="0" d="m-4879.2 2526.8c28.931-26.554 34.045-73.521 6.7362-103.15-22.385-24.288-61.908-28.559-86.795-5.5254-20.32 18.807-23.873 51.956-4.5097 72.785 15.749 16.938 43.453 19.885 60.824 3.6611 14.068-13.138 16.5-36.211 2.9553-50.645-10.921-11.638-30.063-13.638-42.01-2.3709-9.5888 9.0427-11.225 24.862-1.8897 34.709 7.4578 7.8667 20.477 9.2007 28.56 1.4956 6.4251-6.1245 7.507-16.794 1.1744-23.4-5.0075-5.2238-13.712-6.0964-19.086-0.9146-4.2268 4.0756-4.927 11.144-0.7059 15.494 3.3012 3.4021 9.0128 3.9611 12.517 0.5389 2.7241-2.6598 3.1673-7.252 0.407-10.059-2.1329-2.1691-5.8044-2.5189-7.8963-0.2069 1.997-1.738 5.0383-1.4474 6.8043 0.3481 2.2861 2.3251 1.9189 6.1284-0.3372 8.3314-2.9016 2.8344-7.6326 2.3713-10.366-0.4463-3.4958-3.6032-2.9158-9.4571 0.5846-12.832 4.4507-4.2914 11.659-3.5688 15.807 0.7575 5.2443 5.4712 4.3487 14.307-0.9728 19.379-6.6948 6.3814-17.477 5.2765-23.653-1.2385-7.732-8.1558-6.3762-21.257 1.5649-28.746 9.8944-9.3309 25.748-7.675 34.792 1.9633 11.218 11.954 9.2037 31.063-2.4472 41.944-14.387 13.436-37.333 10.996-50.375-3.0324-16.039-17.25-13.094-44.705 3.735-60.28 20.611-19.077 53.344-15.539 71.883 4.5762 22.617 24.541 18.382 63.439-5.5788 85.43-1.9553 1.7948-4.5226 3.813-6.7213 5.3658 1.7499 1.8673 3.4068 3.9086 4.9153 6.1209 1.2189 1.7866 2.2945 3.6485 3.2408 5.5593 2.3899-1.7475 4.6718-3.6184 6.8421-5.6111z" class="svelte-11pit5o"></path><path id="path4916" d="m-5349.6 2631c-5.0428-20.848-26.139-35.708-47.521-30.49-17.526 4.2776-30.016 22.039-25.587 40.022 3.6165 14.684 18.52 25.146 33.595 21.398 12.259-3.0483 20.992-15.512 17.83-28.103-2.5604-10.197-12.945-17.459-23.424-14.802-8.4492 2.1432-14.466 10.763-12.239 19.452 1.7872 6.9735 8.9146 11.938 16.09 10.079 5.7313-1.485 9.8108-7.3545 8.2653-13.255-1.2285-4.69-6.0417-8.0276-10.873-6.7475-3.821 1.0119-6.5389 4.9419-5.4828 8.8802 0.8304 3.0974 4.0234 5.3008 7.2188 4.4334 2.498-0.6807 4.2757-3.2604 3.5663-5.8398-0.5506-2.0056-2.6285-3.4312-4.6997-2.8545-1.6007 0.445-2.7382 2.1086-2.1869 3.719-0.3027-1.4137 0.64-2.7906 1.9652-3.1596 1.7158-0.4781 3.4361 0.7025 3.8927 2.3638 0.5876 2.136-0.8842 4.2744-2.9536 4.8364-2.6458 0.7204-5.2908-1.1064-5.9785-3.6715-0.8745-3.2619 1.377-6.5161 4.5409-7.3547 4.0013-1.0601 7.988 1.704 9.0052 5.5883 1.2801 4.8867-2.0987 9.7484-6.8454 10.978-5.9419 1.5395-11.845-2.5725-13.326-8.3477-1.8437-7.1957 3.1388-14.335 10.137-16.11 8.6787-2.2011 17.279 3.8134 19.4 12.259 2.6183 10.428-4.6143 20.75-14.767 23.275-12.485 3.1041-24.828-5.5608-27.823-17.722-3.6688-14.894 6.6758-29.604 21.191-33.146 17.709-4.3219 35.18 7.9855 39.356 25.252 0.3409 1.4092 0.6271 3.1697 0.7877 4.631 1.3559-0.3399 2.769-0.595 4.2249-0.731 1.176-0.11 2.3503-0.1323 3.5139-0.079-0.2036-1.6043-0.4945-3.1899-0.873-4.7538z" sodipodi:nodetypes="sssssssssssssscsssssssssssssscscs" inkscape:connector-curvature="0" class="svelte-11pit5o"></path><path id="path4920" sodipodi:nodetypes="sssssssssssssscsssssssssssssscscs" inkscape:connector-curvature="0" d="m-4657.5 2644.3c5.8673 21.76 28.432 36.791 50.749 30.725 18.292-4.9726 30.925-23.97 25.78-42.738-4.2007-15.324-20.142-25.906-35.873-21.556-12.793 3.5369-21.624 16.867-17.959 30.006 2.9683 10.64 14.074 17.984 25.009 14.906 8.816-2.4821 14.9-11.701 12.323-20.766-2.0679-7.2757-9.6908-12.295-17.176-10.146-5.9795 1.7163-10.104 7.9934-8.3188 14.149 1.419 4.8925 6.566 8.2665 11.606 6.7897 3.9853-1.1678 6.7329-5.3698 5.5158-9.4775-0.9571-3.2309-4.3711-5.4577-7.7036-4.4592-2.6063 0.7807-4.4021 3.5415-3.5866 6.2317 0.6342 2.0909 2.8552 3.5317 5.0152 2.8688 1.6686-0.5126 2.8183-2.2895 2.1945-3.9665 0.3565 1.4769-0.5957 2.949-1.9777 3.373-1.7889 0.5495-3.6286-0.6442-4.1535-2.3763-0.6758-2.2277 0.8116-4.5142 2.9703-5.1609 2.7596-0.8276 5.5876 1.0175 6.38 3.6932 1.0081 3.402-1.2676 6.8819-4.5681 7.8492-4.174 1.223-8.4367-1.5712-9.6117-5.6232-1.4783-5.098 1.9373-10.296 6.8894-11.718 6.1994-1.7793 12.513 2.3778 14.225 8.4036 2.1339 7.5074-2.9045 15.143-10.206 17.198-9.0562 2.5499-18.254-3.5326-20.713-12.345-3.0359-10.882 4.2783-21.922 14.873-24.851 13.029-3.6023 26.231 5.1609 29.71 17.853 4.2608 15.544-6.2019 31.278-21.351 35.396-18.482 5.0241-37.171-7.4249-42.03-25.446-0.3963-1.4708-0.7458-3.3119-0.9541-4.8427-1.4151 0.3938-2.892 0.7008-4.4178 0.8838-1.2326 0.145-2.465 0.203-3.6885 0.1789 0.2577 1.6795 0.607 3.3367 1.047 4.9694z" class="svelte-11pit5o"></path><path id="path4922" sodipodi:nodetypes="sssssssssssssscsssssssssssssscscs" inkscape:connector-curvature="0" d="m-4938.5 2875.9c-80.161-114.31-62.018-281.3 55.45-363.31 96.285-67.225 236.78-51.847 305.59 47.151 56.18 80.831 43.185 198.65-39.97 256.17-67.623 46.779-166.07 35.833-213.99-33.776-38.804-56.37-29.616-138.34 28.446-178.11 46.814-32.061 114.81-24.375 147.68 23.876 26.381 38.727 19.975 94.904-19.967 121.96-31.907 21.614-78.131 16.295-100.31-16.636-17.629-26.176-13.23-64.048 13.806-82.146 21.38-14.311 52.269-10.688 66.968 11.412 11.56 17.381 8.5898 42.458-9.3914 54.338-14.062 9.2901-34.321 6.8653-43.873-7.6947-7.4253-11.319-5.4554-27.601 6.2748-35.24 9.0625-5.901 22.079-4.3088 27.576 5.318-5.6068-7.5597-16.387-8.8784-23.892-3.9911-9.7151 6.326-11.346 19.811-5.1969 29.185 7.9105 12.058 24.689 14.067 36.335 6.3728 14.892-9.8385 17.352-30.607 7.7779-45.002-12.173-18.303-37.756-21.303-55.463-9.4508-22.392 14.988-26.035 46.354-11.434 68.033 18.368 27.273 56.651 31.679 83.076 13.778 33.08-22.409 38.386-68.935 16.537-101.01-27.222-39.961-83.534-46.327-122.31-19.774-48.087 32.933-55.697 100.82-23.559 147.51 39.685 57.65 121.22 66.715 177.23 27.973 68.869-47.641 79.632-145.22 33.104-212.16-56.986-81.989-173.35-94.726-253.09-39.05-97.287 67.925-112.31 206.22-45.924 300.9 5.4183 7.7264 12.789 16.695 19.237 23.768-7.4941 5.1586-14.816 10.968-21.745 17.496-5.5964 5.2728-10.755 10.914-15.501 16.826-6.9633-7.8941-13.455-16.136-19.47-24.712z" class="svelte-11pit5o"></path><path id="path4926" d="m-5210.6 2748.7c-83.601-3.5091-156.45-72.986-152.67-158.76 3.0955-70.309 61.606-131.56 133.78-128.23 58.932 2.72 110.26 51.832 107.33 112.36-2.3806 49.222-43.462 92.08-94.043 89.516-40.961-2.0752-76.618-36.315-74.383-78.432 1.802-33.958 30.234-63.51 65.169-61.569 28.04 1.5577 52.436 25.075 50.758 53.94-1.3411 23.058-20.714 43.114-44.465 41.668-18.879-1.1494-35.296-17.042-34.057-36.501 0.9806-15.388 13.96-28.766 29.831-27.707 12.483 0.8324 23.333 11.383 22.434 24.268-0.7033 10.076-9.2388 18.833-19.647 18.072-8.0914-0.5911-15.121-7.4612-14.482-15.826 0.4942-6.4625 5.9946-12.076 12.578-11.184-5.64-0.087-10.195 4.5622-10.605 9.9144-0.5298 6.9276 5.2922 12.617 11.994 13.107 8.6201 0.6296 15.689-6.6221 16.272-14.967 0.7448-10.671-8.2413-19.409-18.579-20.098-13.145-0.8766-23.894 10.203-24.706 22.947-1.0269 16.116 12.57 29.278 28.206 30.23 19.67 1.1975 35.715-15.413 36.826-34.51 1.3904-23.906-18.815-43.383-42.037-44.673-28.933-1.6075-52.481 22.868-53.973 50.992-1.8511 34.881 27.68 63.238 61.604 64.957 41.892 2.1225 75.915-33.372 77.886-74.138 2.4245-50.129-40.083-90.803-88.89-93.056-59.776-2.759-108.23 47.968-110.8 106.2-3.1276 71.042 57.203 128.58 126.44 131.49 5.6508 0.2371 12.604 0 18.319-0.4931-0.2762 5.4456-0.18 11.046 0.4018 16.722 0.4697 4.5843 1.2746 9.0946 2.3584 13.507-6.2934 0.437-12.58 0.523-18.853 0.2598z" sodipodi:nodetypes="sssssssssssssscsssssssssssssscscs" inkscape:connector-curvature="0" class="svelte-11pit5o"></path><g id="g4928" style="fill:#000000" transform="matrix(-.013055 .099846 .099846 .013055 -5221.8 2466.8)"><path id="path4930" inkscape:connector-curvature="0" d="m1100 252.1c-38.582-5.0193-71.655-28.564-88.698-63.144-13.064-26.507-15.479-57.006-6.7207-84.88 3.4376-10.94 7.5514-19.486 14.247-29.596 6.1465-9.2808 11.637-15.576 19.717-22.605 12.521-10.893 25.403-18.105 41.405-23.181 19.708-6.252 41.942-6.9335 61.744-1.8924 9.1446 2.3281 18.849 6.0402 26.659 10.198 6.7541 3.5957 17.813 11.197 14.27 9.8081-3.7223-1.4589-13.367-3.9653-19.48-5.0623-10.763-1.9314-27.667-2.3031-37.837-0.83196-28.658 4.1454-52.123 15.814-71.818 35.715-31.192 31.516-43.548 77.168-31.048 114.71 8.0684 24.235 25.64 42.29 48.587 49.924 17.279 5.7486 35.216 4.6663 51.146-3.0861 17.77-8.6479 30.052-24.393 34.071-43.68 1.044-5.01 1.1472-15.932 0.2003-21.208-2.0065-11.181-6.9794-20.781-15.161-29.269-10.973-11.384-24.569-17.144-40.559-17.184-3.4463-0.008-6.8524 0.13881-7.569 0.32717-1.2043 0.31652-1.3277 0.21087-1.6288-1.3939-0.6188-3.2984 0.1393-16.572 1.1676-20.443 3.2487-12.229 8.3824-20.963 17.303-29.438 11.958-11.361 27.245-17.312 44.47-17.312 26.745 0 51.255 15.462 64.354 40.596 13.607 26.109 13.1 58.996-1.3683 88.767-17.246 35.486-49.965 58.974-89.345 64.139-6.7396 0.88387-21.387 0.89435-28.107 0.0201v0.00002z" class="svelte-11pit5o"></path><path id="path4932" inkscape:connector-curvature="0" d="m1140 173.74c-18.736-2.3106-34.722-13.517-43.08-30.199-1.9142-3.8208-3.9735-9.6041-4.5847-12.876l-0.3923-2.0999 1.7357-0.28711c3.2107-0.5311 12.421-0.3036 16.499 0.40756 20.2 3.5226 36.747 17.773 43.077 37.099 1.8297 5.5857 2.0524 7.261 1.0179 7.6579-1.3815 0.53013-10.795 0.72609-14.273 0.29712z" class="svelte-11pit5o"></path></g><path id="path4940" sodipodi:nodetypes="sssssssssssssscsssssssssssssscscs" inkscape:connector-curvature="0" d="m-5539.7 3053.6c-21.276 8.9965-33.387 34.008-24.111 55.821 7.6039 17.879 28.658 28.053 46.997 20.208 14.973-6.4054 23.491-24.07 16.878-39.436-5.3781-12.496-20.146-19.602-32.976-14.045-10.39 4.4997-16.296 16.803-11.643 27.476 3.7513 8.6051 13.962 13.495 22.806 9.6139 7.0991-3.1161 11.131-11.557 7.9052-18.857-2.5778-5.8318-9.5272-9.1428-15.528-6.4709-4.7698 2.1243-7.4768 7.8215-5.2757 12.732 1.7424 3.8834 6.3929 6.0867 10.39 4.2862 3.1472-1.4233 4.9313-5.2008 3.4552-8.4438-1.1568-2.5371-4.2108-3.9754-6.8325-2.7612-2.0347 0.9357-3.1878 3.3924-2.213 5.4926 0.7528 1.6236 2.7183 2.5422 4.334 1.6741-1.4496 0.5688-3.0774-0.1928-3.6968-1.5473-0.8075-1.74 0.1477-3.7744 1.8278-4.5512 2.1679-0.9974 4.6971 0.1936 5.6607 2.2818 1.2252 2.6867-0.2528 5.8158-2.8615 6.9929-3.3137 1.4986-7.1649-0.326-8.6028-3.5549-1.8249-4.0672 0.4169-8.7861 4.367-10.545 4.9699-2.2132 10.726 0.5293 12.86 5.3586 2.6728 6.0465-0.6669 13.038-6.5484 15.617-7.3247 3.2151-15.781-0.8345-18.888-7.9624-3.8539-8.8396 1.0376-19.029 9.6415-22.756 10.626-4.6022 22.857 1.283 27.311 11.632 5.4774 12.726-1.5769 27.355-13.978 32.66-15.188 6.4973-32.625-1.9293-38.922-16.736-7.6828-18.065 2.3479-38.78 19.968-46.231 1.438-0.6082 3.2587-1.2199 4.7841-1.6453-0.5984-1.3814-1.1154-2.8383-1.5143-4.3621-0.322-1.2308-0.5503-2.4748-0.697-3.7205-1.6693 0.496-3.303 1.0822-4.8995 1.7572z" class="svelte-11pit5o"></path><path id="path4942" d="m-4660.7 3028.9c-28.931-26.554-34.045-73.521-6.7362-103.15 22.385-24.288 61.908-28.559 86.795-5.5254 20.32 18.807 23.873 51.956 4.5097 72.785-15.749 16.938-43.453 19.885-60.824 3.6611-14.068-13.138-16.5-36.211-2.9553-50.645 10.921-11.638 30.063-13.638 42.01-2.3709 9.5888 9.0427 11.225 24.862 1.8897 34.709-7.4578 7.8667-20.477 9.2007-28.56 1.4956-6.4251-6.1245-7.507-16.794-1.1744-23.4 5.0075-5.2238 13.712-6.0964 19.086-0.9146 4.2268 4.0756 4.927 11.144 0.7059 15.494-3.3012 3.4021-9.0128 3.9611-12.517 0.5389-2.7241-2.6598-3.1673-7.252-0.407-10.059 2.1329-2.1691 5.8044-2.5189 7.8963-0.2069-1.997-1.738-5.0383-1.4474-6.8043 0.3481-2.2861 2.3251-1.9189 6.1284 0.3372 8.3314 2.9016 2.8344 7.6326 2.3713 10.366-0.4463 3.4958-3.6032 2.9158-9.4571-0.5846-12.832-4.4507-4.2914-11.659-3.5688-15.807 0.7575-5.2443 5.4712-4.3487 14.307 0.9728 19.379 6.6948 6.3814 17.477 5.2765 23.653-1.2385 7.732-8.1558 6.3762-21.257-1.5649-28.746-9.8944-9.3309-25.748-7.675-34.792 1.9633-11.218 11.954-9.2037 31.063 2.4472 41.944 14.387 13.436 37.333 10.996 50.375-3.0324 16.039-17.25 13.094-44.705-3.735-60.28-20.611-19.077-53.344-15.539-71.883 4.5762-22.617 24.541-18.382 63.439 5.5788 85.43 1.9553 1.7948 4.5226 3.813 6.7213 5.3658-1.7499 1.8673-3.4068 3.9086-4.9153 6.1209-1.2189 1.7866-2.2945 3.6485-3.2408 5.5593-2.3899-1.7475-4.6718-3.6184-6.8421-5.6111z" sodipodi:nodetypes="sssssssssssssscsssssssssssssscscs" inkscape:connector-curvature="0" class="svelte-11pit5o"></path><path id="path4944" d="m-5405.7 2930.8c-28.962 96.118-131.39 160.1-229.96 130.18-80.794-24.525-134.56-110.76-109.21-193.65 20.702-67.682 93.058-112.71 162.53-91.296 56.498 17.418 94.08 77.919 76.046 135.94-14.604 46.988-65.012 78.238-113.3 63.104-38.93-12.201-64.814-54.042-52.16-94.067 10.157-32.125 44.75-53.479 77.798-42.936 26.399 8.4215 43.943 36.908 35.193 64.081-6.9551 21.599-30.312 35.95-52.559 28.717-17.591-5.7198-29.277-24.786-23.323-42.917 4.6829-14.26 20.175-23.73 34.882-18.85 11.501 3.8167 19.137 16.343 15.156 28.213-3.0956 9.2281-13.172 15.353-22.704 12.121-7.3637-2.4979-12.25-10.562-9.254-17.947-1.7792 6.5291 2.2679 13.207 8.3661 15.276 7.8936 2.6781 16.24-2.3955 18.803-10.038 3.2977-9.8309-3.0263-20.205-12.552-23.366-12.18-4.0415-25.011 3.8011-28.889 15.611-4.9311 15.016 4.7466 30.807 19.316 35.544 18.425 5.9902 37.769-5.895 43.529-23.783 7.2466-22.505-7.2831-46.097-29.146-53.072-27.37-8.7313-56.02 8.954-64.432 35.56-10.48 33.149 10.957 67.801 43.198 77.906 39.988 12.534 81.736-13.347 93.831-52.263 14.936-48.056-16.19-98.162-62.981-112.59-57.539-17.739-117.46 19.557-134.61 75.612-20.999 68.652 23.533 140.07 90.446 160.38 81.635 24.78 166.47-28.21 190.45-107.81 1.9575-6.497 3.7489-14.649 4.8796-21.437 6.2467 1.9418 12.784 3.4971 19.554 4.5102 5.4675 0.8184 10.949 1.2257 16.4 1.2791-1.3658 7.4445-3.1367 14.777-5.3097 21.989z" sodipodi:nodetypes="sssssssssssssscsssssssssssssscscs" inkscape:connector-curvature="0" class="svelte-11pit5o"></path><g id="g4946" transform="matrix(.083095 .056876 .056876 -.083095 -5706.3 2844)"><path id="path4948" d="m1100 252.1c-38.582-5.0193-71.655-28.564-88.698-63.144-13.064-26.507-15.479-57.006-6.7207-84.88 3.4376-10.94 7.5514-19.486 14.247-29.596 6.1465-9.2808 11.637-15.576 19.717-22.605 12.521-10.893 25.403-18.105 41.405-23.181 19.708-6.252 41.942-6.9335 61.744-1.8924 9.1446 2.3281 18.849 6.0402 26.659 10.198 6.7541 3.5957 17.813 11.197 14.27 9.8081-3.7223-1.4589-13.367-3.9653-19.48-5.0623-10.763-1.9314-27.667-2.3031-37.837-0.83196-28.658 4.1454-52.123 15.814-71.818 35.715-31.192 31.516-43.548 77.168-31.048 114.71 8.0684 24.235 25.64 42.29 48.587 49.924 17.279 5.7486 35.216 4.6663 51.146-3.0861 17.77-8.6479 30.052-24.393 34.071-43.68 1.044-5.01 1.1472-15.932 0.2003-21.208-2.0065-11.181-6.9794-20.781-15.161-29.269-10.973-11.384-24.569-17.144-40.559-17.184-3.4463-0.008-6.8524 0.13881-7.569 0.32717-1.2043 0.31652-1.3277 0.21087-1.6288-1.3939-0.6188-3.2984 0.1393-16.572 1.1676-20.443 3.2487-12.229 8.3824-20.963 17.303-29.438 11.958-11.361 27.245-17.312 44.47-17.312 26.745 0 51.255 15.462 64.354 40.596 13.607 26.109 13.1 58.996-1.3683 88.767-17.246 35.486-49.965 58.974-89.345 64.139-6.7396 0.88387-21.387 0.89435-28.107 0.0201v0.00002z" inkscape:connector-curvature="0" class="svelte-11pit5o"></path><path id="path4950" d="m1140 173.74c-18.736-2.3106-34.722-13.517-43.08-30.199-1.9142-3.8208-3.9735-9.6041-4.5847-12.876l-0.3923-2.0999 1.7357-0.28711c3.2107-0.5311 12.421-0.3036 16.499 0.40756 20.2 3.5226 36.747 17.773 43.077 37.099 1.8297 5.5857 2.0524 7.261 1.0179 7.6579-1.3815 0.53013-10.795 0.72609-14.273 0.29712z" inkscape:connector-curvature="0" class="svelte-11pit5o"></path></g><path id="path4952" d="m-5168.8 2961.6c-13.099-4.1108-21.688-18.218-17.442-31.65 3.4802-11.01 15.356-18.228 26.652-14.631 9.2231 2.9368 15.268 12.902 12.231 22.369-2.47 7.6987-10.802 12.744-18.709 10.187-6.4028-2.0705-10.597-9.0125-8.4524-15.592 1.7294-5.3044 7.4915-8.7786 12.945-6.9856 4.3771 1.4391 7.2432 6.2032 5.7498 10.706-1.1929 3.5969-5.1158 5.9514-8.818 4.7124-2.9427-0.985-4.8687-4.2014-3.8448-7.2323 0.8096-2.3967 3.4352-3.9649 5.9053-3.1222 1.9427 0.6627 3.2134 2.7959 2.5231 4.7994-0.54 1.5669-2.2648 2.5916-3.8819 2.0285-1.257-0.4377-2.0789-1.8254-1.6218-3.1236 0.353-1.0032 1.4634-1.6587 2.4687-1.2374-0.89-0.2537-1.8097 0.2894-2.1021 1.1201-0.3785 1.0753 0.3022 2.2245 1.3434 2.587 1.3392 0.4664 2.7677-0.3821 3.2149-1.6799 0.5718-1.6593-0.4808-3.4262-2.0897-3.9749-2.0457-0.6979-4.2202 0.6009-4.8908 2.5858-0.8479 2.5102 0.7471 5.174 3.1843 5.9897 3.0662 1.0262 6.3151-0.9238 7.3031-3.9027 1.2368-3.7292-1.1369-7.6748-4.7621-8.8667-4.5165-1.485-9.2888 1.3923-10.721 5.7855-1.7766 5.4488 1.6975 11.198 7.0002 12.913 6.5481 2.1176 13.449-2.0605 15.495-8.4366 2.5157-7.8407-2.4908-16.094-10.129-18.526-9.3552-2.9788-19.191 2.9993-22.073 12.118-3.5163 11.125 3.5975 22.808 14.446 26.213 0.8853 0.2779 1.9973 0.536 2.9239 0.7008-0.2753 0.8513-0.4983 1.7428-0.6474 2.667-0.1205 0.7464-0.1847 1.4953-0.2005 2.2406-1.0159-0.1983-2.0158-0.4521-2.9987-0.7605z" sodipodi:nodetypes="sssssssssssssscsssssssssssssscscs" inkscape:connector-curvature="0" class="svelte-11pit5o"></path><path id="path4954" sodipodi:nodetypes="sssssssssssssscsssssssssssssscscs" inkscape:connector-curvature="0" d="m-5276.3 2925.8c-20.171 13.512-49.135 9.7375-62.958-10.99-11.33-16.989-8.1344-41.358 9.3321-52.953 14.261-9.467 34.696-6.7703 44.388 7.9003 7.8816 11.93 5.6131 29.006-6.6667 37.078-9.9443 6.5369-24.161 4.635-30.859-5.607-5.4001-8.2578-3.8113-20.05 4.6994-25.586 6.8307-4.4426 16.574-3.1203 21.129 3.9243 3.6392 5.6275 2.5428 13.644-3.2648 17.377-4.6163 2.9676-11.184 2.0623-14.23-2.7053-2.4087-3.7701-1.6641-9.127 2.2326-11.6 3.0647-1.9453 7.4134-1.3357 9.412 1.8345 1.5628 2.4793 1.0661 5.9924-1.5008 7.5988-1.9954 1.249-4.8188 0.846-6.1031-1.2217-0.9924-1.5975-0.6671-3.8545 1.0269-4.7744-1.3351 0.9465-1.6044 2.816-0.7826 4.1389 1.0637 1.7125 3.4021 2.0463 5.0547 1.0118 2.1258-1.3304 2.5373-4.2398 1.2429-6.2932-1.6552-2.6256-5.2569-3.1304-7.795-1.5194-3.2272 2.0484-3.8438 6.485-1.8491 9.6073 2.5227 3.9486 7.9621 4.6984 11.785 2.2406 4.8098-3.092 5.7179-9.7314 2.7039-14.392-3.7731-5.8343-11.842-6.9295-17.499-3.25-7.0484 4.5841-8.3643 14.351-3.8919 21.19 5.5469 8.4824 17.322 10.058 25.557 4.6437 10.17-6.6853 12.049-20.827 5.5214-30.708-8.027-12.15-24.951-14.384-36.762-6.5431-14.466 9.6027-17.112 29.785-7.7289 43.855 11.448 17.166 35.435 20.292 52.141 9.1015 1.3634-0.9133 2.9505-2.1609 4.2037-3.2561 0.8689 1.3221 1.8516 2.6166 2.9609 3.8454 0.8959 0.9925 1.8576 1.9104 2.8677 2.7573-1.3982 1.1813-2.8552 2.2793-4.3686 3.2932z" class="svelte-11pit5o"></path><path id="path4956" sodipodi:nodetypes="sssssssssssssscsssssssssssssscscs" inkscape:connector-curvature="0" d="m-4840.4 2949.7c-55.946-169.8-241.22-279.04-415.34-221.27-142.72 47.348-234.51 203.32-185.59 349.74 39.944 119.55 170.81 196.42 293.53 155.12 99.79-33.586 163.94-143.01 129.19-245.49-28.143-82.988-119.31-136.32-204.58-107.18-68.751 23.499-112.92 99.169-88.57 169.85 19.547 56.729 82.11 93.169 140.46 72.892 46.614-16.198 76.549-67.712 59.732-115.69-13.367-38.136-55.605-62.62-94.881-48.728-31.058 10.985-50.992 45.463-39.565 77.47 8.9876 25.174 37 41.326 62.96 31.967 20.302-7.3195 33.326-29.969 25.695-50.92-5.9318-16.288-24.152-26.733-40.973-20.542-12.996 4.7829-21.328 19.361-15.656 32.374-3.4658-11.543 3.4347-23.616 14.198-27.578 13.931-5.1273 29.021 3.5236 33.934 17.013 6.3192 17.352-4.4665 36.11-21.281 42.172-21.5 7.7513-44.7-5.6263-52.144-26.475-9.4642-26.508 7.0452-55.063 32.768-64.161 32.529-11.505 67.509 8.7719 78.58 40.356 13.928 39.735-10.864 82.4-49.47 95.814-48.329 16.793-100.14-13.386-116.33-60.369-20.17-58.537 16.414-121.21 73.353-140.67 70.62-24.138 146.13 20.034 169.43 88.765 28.783 84.873-24.346 175.5-106.99 203.32-101.63 34.205-210.02-29.46-243.1-128.47-40.516-121.27 35.507-250.44 153.71-289.66 144.21-47.841 297.65 42.63 343.99 183.26 3.7813 11.477 7.3428 25.91 9.6651 37.943 11.033-3.7421 22.601-6.8089 34.606-8.9217 9.697-1.7065 19.438-2.6816 29.138-3.0255-2.7705-13.191-6.2584-26.165-10.456-38.905z" class="svelte-11pit5o"></path><g id="g4958" transform="matrix(-.047197 -.088950 .088950 -.047197 -5163.1 3130.4)"><path id="path4960" inkscape:connector-curvature="0" d="m1100 252.1c-38.582-5.0193-71.655-28.564-88.698-63.144-13.064-26.507-15.479-57.006-6.7207-84.88 3.4376-10.94 7.5514-19.486 14.247-29.596 6.1465-9.2808 11.637-15.576 19.717-22.605 12.521-10.893 25.403-18.105 41.405-23.181 19.708-6.252 41.942-6.9335 61.744-1.8924 9.1446 2.3281 18.849 6.0402 26.659 10.198 6.7541 3.5957 17.813 11.197 14.27 9.8081-3.7223-1.4589-13.367-3.9653-19.48-5.0623-10.763-1.9314-27.667-2.3031-37.837-0.83196-28.658 4.1454-52.123 15.814-71.818 35.715-31.192 31.516-43.548 77.168-31.048 114.71 8.0684 24.235 25.64 42.29 48.587 49.924 17.279 5.7486 35.216 4.6663 51.146-3.0861 17.77-8.6479 30.052-24.393 34.071-43.68 1.044-5.01 1.1472-15.932 0.2003-21.208-2.0065-11.181-6.9794-20.781-15.161-29.269-10.973-11.384-24.569-17.144-40.559-17.184-3.4463-0.008-6.8524 0.13881-7.569 0.32717-1.2043 0.31652-1.3277 0.21087-1.6288-1.3939-0.6188-3.2984 0.1393-16.572 1.1676-20.443 3.2487-12.229 8.3824-20.963 17.303-29.438 11.958-11.361 27.245-17.312 44.47-17.312 26.745 0 51.255 15.462 64.354 40.596 13.607 26.109 13.1 58.996-1.3683 88.767-17.246 35.486-49.965 58.974-89.345 64.139-6.7396 0.88387-21.387 0.89435-28.107 0.0201v0.00002z" class="svelte-11pit5o"></path><path id="path4962" inkscape:connector-curvature="0" d="m1140 173.74c-18.736-2.3106-34.722-13.517-43.08-30.199-1.9142-3.8208-3.9735-9.6041-4.5847-12.876l-0.3923-2.0999 1.7357-0.28711c3.2107-0.5311 12.421-0.3036 16.499 0.40756 20.2 3.5226 36.747 17.773 43.077 37.099 1.8297 5.5857 2.0524 7.261 1.0179 7.6579-1.3815 0.53013-10.795 0.72609-14.273 0.29712z" class="svelte-11pit5o"></path></g><path id="path4964" d="m-4602.8 3332.3c64.66-123.74 25.016-286.96-102.1-353.05-104.19-54.171-241.51-20.703-296.89 86.381-45.224 87.434-17.06 202.57 72.853 248.82 73.118 37.615 169.32 13.994 207.8-61.241 31.166-60.926 11.425-141.01-51.303-172.91-50.576-25.72-117-9.2809-143.33 42.825-21.136 41.821-7.4993 96.693 35.614 118.34 34.44 17.294 79.584 6.0256 97.305-29.504 14.086-28.241 4.813-65.222-24.342-79.661-23.055-11.418-53.214-3.8197-64.923 20-9.2088 18.734-3.0112 43.214 16.359 52.661 15.148 7.388 34.922 2.3566 42.504-13.319 5.895-12.186 1.83-28.076-10.792-34.128-9.7512-4.6761-22.451-1.4093-26.653 8.8491 4.579-8.2229 15.097-10.929 23.173-7.0559 10.454 5.0127 13.82 18.172 8.9378 28.265-6.28 12.982-22.656 17.15-35.202 11.031-16.042-7.8242-21.175-28.099-13.548-43.614 9.6968-19.727 34.675-26.02 53.769-16.564 24.146 11.958 31.826 42.586 20.161 65.976-14.676 29.425-52.064 38.758-80.588 24.435-35.707-17.93-47.001-63.375-29.496-98.011 21.81-43.154 76.821-56.768 118.71-35.467 51.952 26.419 68.301 92.748 42.489 143.21-31.874 62.31-111.55 81.872-172.1 50.72-74.466-38.308-97.791-133.66-60.337-206.08 45.872-88.687 159.6-116.41 245.89-71.541 105.27 54.735 138.11 189.92 84.556 292.4-4.3706 8.3638-10.516 18.213-15.992 26.062 8.0998 4.1434 16.113 8.9535 23.83 14.528 6.233 4.5024 12.08 9.4276 17.552 14.674 5.8809-8.7305 11.249-17.744 16.101-27.028z" sodipodi:nodetypes="sssssssssssssscsssssssssssssscscs" inkscape:connector-curvature="0" class="svelte-11pit5o"></path><g id="g4966" transform="matrix(-.014112 .010669 .010669 .014112 -5294.4 2874.1)"><path id="path4968" inkscape:connector-curvature="0" d="m1100 252.1c-38.582-5.0193-71.655-28.564-88.698-63.144-13.064-26.507-15.479-57.006-6.7207-84.88 3.4376-10.94 7.5514-19.486 14.247-29.596 6.1465-9.2808 11.637-15.576 19.717-22.605 12.521-10.893 25.403-18.105 41.405-23.181 19.708-6.252 41.942-6.9335 61.744-1.8924 9.1446 2.3281 18.849 6.0402 26.659 10.198 6.7541 3.5957 17.813 11.197 14.27 9.8081-3.7223-1.4589-13.367-3.9653-19.48-5.0623-10.763-1.9314-27.667-2.3031-37.837-0.83196-28.658 4.1454-52.123 15.814-71.818 35.715-31.192 31.516-43.548 77.168-31.048 114.71 8.0684 24.235 25.64 42.29 48.587 49.924 17.279 5.7486 35.216 4.6663 51.146-3.0861 17.77-8.6479 30.052-24.393 34.071-43.68 1.044-5.01 1.1472-15.932 0.2003-21.208-2.0065-11.181-6.9794-20.781-15.161-29.269-10.973-11.384-24.569-17.144-40.559-17.184-3.4463-0.008-6.8524 0.13881-7.569 0.32717-1.2043 0.31652-1.3277 0.21087-1.6288-1.3939-0.6188-3.2984 0.1393-16.572 1.1676-20.443 3.2487-12.229 8.3824-20.963 17.303-29.438 11.958-11.361 27.245-17.312 44.47-17.312 26.745 0 51.255 15.462 64.354 40.596 13.607 26.109 13.1 58.996-1.3683 88.767-17.246 35.486-49.965 58.974-89.345 64.139-6.7396 0.88387-21.387 0.89435-28.107 0.0201v0.00002z" class="svelte-11pit5o"></path><path id="path4970" inkscape:connector-curvature="0" d="m1140 173.74c-18.736-2.3106-34.722-13.517-43.08-30.199-1.9142-3.8208-3.9735-9.6041-4.5847-12.876l-0.3923-2.0999 1.7357-0.28711c3.2107-0.5311 12.421-0.3036 16.499 0.40756 20.2 3.5226 36.747 17.773 43.077 37.099 1.8297 5.5857 2.0524 7.261 1.0179 7.6579-1.3815 0.53013-10.795 0.72609-14.273 0.29712z" class="svelte-11pit5o"></path></g><g id="g4972" style="fill:#000000" transform="matrix(-.015818 .0079232 -.0079232 -.015818 -5507.7 3092.4)"><path id="path4974" d="m1100 252.1c-38.582-5.0193-71.655-28.564-88.698-63.144-13.064-26.507-15.479-57.006-6.7207-84.88 3.4376-10.94 7.5514-19.486 14.247-29.596 6.1465-9.2808 11.637-15.576 19.717-22.605 12.521-10.893 25.403-18.105 41.405-23.181 19.708-6.252 41.942-6.9335 61.744-1.8924 9.1446 2.3281 18.849 6.0402 26.659 10.198 6.7541 3.5957 17.813 11.197 14.27 9.8081-3.7223-1.4589-13.367-3.9653-19.48-5.0623-10.763-1.9314-27.667-2.3031-37.837-0.83196-28.658 4.1454-52.123 15.814-71.818 35.715-31.192 31.516-43.548 77.168-31.048 114.71 8.0684 24.235 25.64 42.29 48.587 49.924 17.279 5.7486 35.216 4.6663 51.146-3.0861 17.77-8.6479 30.052-24.393 34.071-43.68 1.044-5.01 1.1472-15.932 0.2003-21.208-2.0065-11.181-6.9794-20.781-15.161-29.269-10.973-11.384-24.569-17.144-40.559-17.184-3.4463-0.008-6.8524 0.13881-7.569 0.32717-1.2043 0.31652-1.3277 0.21087-1.6288-1.3939-0.6188-3.2984 0.1393-16.572 1.1676-20.443 3.2487-12.229 8.3824-20.963 17.303-29.438 11.958-11.361 27.245-17.312 44.47-17.312 26.745 0 51.255 15.462 64.354 40.596 13.607 26.109 13.1 58.996-1.3683 88.767-17.246 35.486-49.965 58.974-89.345 64.139-6.7396 0.88387-21.387 0.89435-28.107 0.0201v0.00002z" style="fill:#000000" inkscape:connector-curvature="0" class="svelte-11pit5o"></path><path id="path4976" d="m1140 173.74c-18.736-2.3106-34.722-13.517-43.08-30.199-1.9142-3.8208-3.9735-9.6041-4.5847-12.876l-0.3923-2.0999 1.7357-0.28711c3.2107-0.5311 12.421-0.3036 16.499 0.40756 20.2 3.5226 36.747 17.773 43.077 37.099 1.8297 5.5857 2.0524 7.261 1.0179 7.6579-1.3815 0.53013-10.795 0.72609-14.273 0.29712z" style="fill:#000000" inkscape:connector-curvature="0" class="svelte-11pit5o"></path></g><g id="g4978" style="fill:#000000" transform="matrix(-.0070262 -.016236 .016236 -.0070262 -5387.5 2655.3)"><path id="path4980" inkscape:connector-curvature="0" d="m1100 252.1c-38.582-5.0193-71.655-28.564-88.698-63.144-13.064-26.507-15.479-57.006-6.7207-84.88 3.4376-10.94 7.5514-19.486 14.247-29.596 6.1465-9.2808 11.637-15.576 19.717-22.605 12.521-10.893 25.403-18.105 41.405-23.181 19.708-6.252 41.942-6.9335 61.744-1.8924 9.1446 2.3281 18.849 6.0402 26.659 10.198 6.7541 3.5957 17.813 11.197 14.27 9.8081-3.7223-1.4589-13.367-3.9653-19.48-5.0623-10.763-1.9314-27.667-2.3031-37.837-0.83196-28.658 4.1454-52.123 15.814-71.818 35.715-31.192 31.516-43.548 77.168-31.048 114.71 8.0684 24.235 25.64 42.29 48.587 49.924 17.279 5.7486 35.216 4.6663 51.146-3.0861 17.77-8.6479 30.052-24.393 34.071-43.68 1.044-5.01 1.1472-15.932 0.2003-21.208-2.0065-11.181-6.9794-20.781-15.161-29.269-10.973-11.384-24.569-17.144-40.559-17.184-3.4463-0.008-6.8524 0.13881-7.569 0.32717-1.2043 0.31652-1.3277 0.21087-1.6288-1.3939-0.6188-3.2984 0.1393-16.572 1.1676-20.443 3.2487-12.229 8.3824-20.963 17.303-29.438 11.958-11.361 27.245-17.312 44.47-17.312 26.745 0 51.255 15.462 64.354 40.596 13.607 26.109 13.1 58.996-1.3683 88.767-17.246 35.486-49.965 58.974-89.345 64.139-6.7396 0.88387-21.387 0.89435-28.107 0.0201v0.00002z" class="svelte-11pit5o"></path><path id="path4982" inkscape:connector-curvature="0" d="m1140 173.74c-18.736-2.3106-34.722-13.517-43.08-30.199-1.9142-3.8208-3.9735-9.6041-4.5847-12.876l-0.3923-2.0999 1.7357-0.28711c3.2107-0.5311 12.421-0.3036 16.499 0.40756 20.2 3.5226 36.747 17.773 43.077 37.099 1.8297 5.5857 2.0524 7.261 1.0179 7.6579-1.3815 0.53013-10.795 0.72609-14.273 0.29712z" class="svelte-11pit5o"></path></g><g id="g4984" style="fill:#000000" transform="matrix(.013851 -.015717 .015717 .013851 -4944.7 2476.4)"><path id="path4986" d="m1100 252.1c-38.582-5.0193-71.655-28.564-88.698-63.144-13.064-26.507-15.479-57.006-6.7207-84.88 3.4376-10.94 7.5514-19.486 14.247-29.596 6.1465-9.2808 11.637-15.576 19.717-22.605 12.521-10.893 25.403-18.105 41.405-23.181 19.708-6.252 41.942-6.9335 61.744-1.8924 9.1446 2.3281 18.849 6.0402 26.659 10.198 6.7541 3.5957 17.813 11.197 14.27 9.8081-3.7223-1.4589-13.367-3.9653-19.48-5.0623-10.763-1.9314-27.667-2.3031-37.837-0.83196-28.658 4.1454-52.123 15.814-71.818 35.715-31.192 31.516-43.548 77.168-31.048 114.71 8.0684 24.235 25.64 42.29 48.587 49.924 17.279 5.7486 35.216 4.6663 51.146-3.0861 17.77-8.6479 30.052-24.393 34.071-43.68 1.044-5.01 1.1472-15.932 0.2003-21.208-2.0065-11.181-6.9794-20.781-15.161-29.269-10.973-11.384-24.569-17.144-40.559-17.184-3.4463-0.008-6.8524 0.13881-7.569 0.32717-1.2043 0.31652-1.3277 0.21087-1.6288-1.3939-0.6188-3.2984 0.1393-16.572 1.1676-20.443 3.2487-12.229 8.3824-20.963 17.303-29.438 11.958-11.361 27.245-17.312 44.47-17.312 26.745 0 51.255 15.462 64.354 40.596 13.607 26.109 13.1 58.996-1.3683 88.767-17.246 35.486-49.965 58.974-89.345 64.139-6.7396 0.88387-21.387 0.89435-28.107 0.0201v0.00002z" inkscape:connector-curvature="0" class="svelte-11pit5o"></path><path id="path4988" d="m1140 173.74c-18.736-2.3106-34.722-13.517-43.08-30.199-1.9142-3.8208-3.9735-9.6041-4.5847-12.876l-0.3923-2.0999 1.7357-0.28711c3.2107-0.5311 12.421-0.3036 16.499 0.40756 20.2 3.5226 36.747 17.773 43.077 37.099 1.8297 5.5857 2.0524 7.261 1.0179 7.6579-1.3815 0.53013-10.795 0.72609-14.273 0.29712z" inkscape:connector-curvature="0" class="svelte-11pit5o"></path></g><g id="g4990" style="fill:#000000" transform="matrix(-.039369 -.092681 -.092681 .039369 -4667.5 2782.9)"><path id="path4992" inkscape:connector-curvature="0" d="m1100 252.1c-38.582-5.0193-71.655-28.564-88.698-63.144-13.064-26.507-15.479-57.006-6.7207-84.88 3.4376-10.94 7.5514-19.486 14.247-29.596 6.1465-9.2808 11.637-15.576 19.717-22.605 12.521-10.893 25.403-18.105 41.405-23.181 19.708-6.252 41.942-6.9335 61.744-1.8924 9.1446 2.3281 18.849 6.0402 26.659 10.198 6.7541 3.5957 17.813 11.197 14.27 9.8081-3.7223-1.4589-13.367-3.9653-19.48-5.0623-10.763-1.9314-27.667-2.3031-37.837-0.83196-28.658 4.1454-52.123 15.814-71.818 35.715-31.192 31.516-43.548 77.168-31.048 114.71 8.0684 24.235 25.64 42.29 48.587 49.924 17.279 5.7486 35.216 4.6663 51.146-3.0861 17.77-8.6479 30.052-24.393 34.071-43.68 1.044-5.01 1.1472-15.932 0.2003-21.208-2.0065-11.181-6.9794-20.781-15.161-29.269-10.973-11.384-24.569-17.144-40.559-17.184-3.4463-0.008-6.8524 0.13881-7.569 0.32717-1.2043 0.31652-1.3277 0.21087-1.6288-1.3939-0.6188-3.2984 0.1393-16.572 1.1676-20.443 3.2487-12.229 8.3824-20.963 17.303-29.438 11.958-11.361 27.245-17.312 44.47-17.312 26.745 0 51.255 15.462 64.354 40.596 13.607 26.109 13.1 58.996-1.3683 88.767-17.246 35.486-49.965 58.974-89.345 64.139-6.7396 0.88387-21.387 0.89435-28.107 0.0201v0.00002z" class="svelte-11pit5o"></path><path id="path4994" inkscape:connector-curvature="0" d="m1140 173.74c-18.736-2.3106-34.722-13.517-43.08-30.199-1.9142-3.8208-3.9735-9.6041-4.5847-12.876l-0.3923-2.0999 1.7357-0.28711c3.2107-0.5311 12.421-0.3036 16.499 0.40756 20.2 3.5226 36.747 17.773 43.077 37.099 1.8297 5.5857 2.0524 7.261 1.0179 7.6579-1.3815 0.53013-10.795 0.72609-14.273 0.29712z" class="svelte-11pit5o"></path></g><g id="g4996" style="fill:#000000" transform="matrix(.0060549 .019502 -.019502 .0060549 -4616.2 2615)"><path id="path4998" d="m1100 252.1c-38.582-5.0193-71.655-28.564-88.698-63.144-13.064-26.507-15.479-57.006-6.7207-84.88 3.4376-10.94 7.5514-19.486 14.247-29.596 6.1465-9.2808 11.637-15.576 19.717-22.605 12.521-10.893 25.403-18.105 41.405-23.181 19.708-6.252 41.942-6.9335 61.744-1.8924 9.1446 2.3281 18.849 6.0402 26.659 10.198 6.7541 3.5957 17.813 11.197 14.27 9.8081-3.7223-1.4589-13.367-3.9653-19.48-5.0623-10.763-1.9314-27.667-2.3031-37.837-0.83196-28.658 4.1454-52.123 15.814-71.818 35.715-31.192 31.516-43.548 77.168-31.048 114.71 8.0684 24.235 25.64 42.29 48.587 49.924 17.279 5.7486 35.216 4.6663 51.146-3.0861 17.77-8.6479 30.052-24.393 34.071-43.68 1.044-5.01 1.1472-15.932 0.2003-21.208-2.0065-11.181-6.9794-20.781-15.161-29.269-10.973-11.384-24.569-17.144-40.559-17.184-3.4463-0.008-6.8524 0.13881-7.569 0.32717-1.2043 0.31652-1.3277 0.21087-1.6288-1.3939-0.6188-3.2984 0.1393-16.572 1.1676-20.443 3.2487-12.229 8.3824-20.963 17.303-29.438 11.958-11.361 27.245-17.312 44.47-17.312 26.745 0 51.255 15.462 64.354 40.596 13.607 26.109 13.1 58.996-1.3683 88.767-17.246 35.486-49.965 58.974-89.345 64.139-6.7396 0.88387-21.387 0.89435-28.107 0.0201v0.00002z" inkscape:connector-curvature="0" class="svelte-11pit5o"></path><path id="path5000" d="m1140 173.74c-18.736-2.3106-34.722-13.517-43.08-30.199-1.9142-3.8208-3.9735-9.6041-4.5847-12.876l-0.3923-2.0999 1.7357-0.28711c3.2107-0.5311 12.421-0.3036 16.499 0.40756 20.2 3.5226 36.747 17.773 43.077 37.099 1.8297 5.5857 2.0524 7.261 1.0179 7.6579-1.3815 0.53013-10.795 0.72609-14.273 0.29712z" inkscape:connector-curvature="0" class="svelte-11pit5o"></path></g><g id="g5002" style="fill:#000000" transform="matrix(.040611 -.092143 .092143 .040611 -4897.8 3267.7)"><path id="path5004" d="m1100 252.1c-38.582-5.0193-71.655-28.564-88.698-63.144-13.064-26.507-15.479-57.006-6.7207-84.88 3.4376-10.94 7.5514-19.486 14.247-29.596 6.1465-9.2808 11.637-15.576 19.717-22.605 12.521-10.893 25.403-18.105 41.405-23.181 19.708-6.252 41.942-6.9335 61.744-1.8924 9.1446 2.3281 18.849 6.0402 26.659 10.198 6.7541 3.5957 17.813 11.197 14.27 9.8081-3.7223-1.4589-13.367-3.9653-19.48-5.0623-10.763-1.9314-27.667-2.3031-37.837-0.83196-28.658 4.1454-52.123 15.814-71.818 35.715-31.192 31.516-43.548 77.168-31.048 114.71 8.0684 24.235 25.64 42.29 48.587 49.924 17.279 5.7486 35.216 4.6663 51.146-3.0861 17.77-8.6479 30.052-24.393 34.071-43.68 1.044-5.01 1.1472-15.932 0.2003-21.208-2.0065-11.181-6.9794-20.781-15.161-29.269-10.973-11.384-24.569-17.144-40.559-17.184-3.4463-0.008-6.8524 0.13881-7.569 0.32717-1.2043 0.31652-1.3277 0.21087-1.6288-1.3939-0.6188-3.2984 0.1393-16.572 1.1676-20.443 3.2487-12.229 8.3824-20.963 17.303-29.438 11.958-11.361 27.245-17.312 44.47-17.312 26.745 0 51.255 15.462 64.354 40.596 13.607 26.109 13.1 58.996-1.3683 88.767-17.246 35.486-49.965 58.974-89.345 64.139-6.7396 0.88387-21.387 0.89435-28.107 0.0201v0.00002z" inkscape:connector-curvature="0" class="svelte-11pit5o"></path><path id="path5006" d="m1140 173.74c-18.736-2.3106-34.722-13.517-43.08-30.199-1.9142-3.8208-3.9735-9.6041-4.5847-12.876l-0.3923-2.0999 1.7357-0.28711c3.2107-0.5311 12.421-0.3036 16.499 0.40756 20.2 3.5226 36.747 17.773 43.077 37.099 1.8297 5.5857 2.0524 7.261 1.0179 7.6579-1.3815 0.53013-10.795 0.72609-14.273 0.29712z" inkscape:connector-curvature="0" class="svelte-11pit5o"></path></g><g id="g5008" style="fill:#000000" transform="matrix(-.012081 .00090683 .00090683 .012081 -5150.2 2931.4)"><path id="path5010" d="m1100 252.1c-38.582-5.0193-71.655-28.564-88.698-63.144-13.064-26.507-15.479-57.006-6.7207-84.88 3.4376-10.94 7.5514-19.486 14.247-29.596 6.1465-9.2808 11.637-15.576 19.717-22.605 12.521-10.893 25.403-18.105 41.405-23.181 19.708-6.252 41.942-6.9335 61.744-1.8924 9.1446 2.3281 18.849 6.0402 26.659 10.198 6.7541 3.5957 17.813 11.197 14.27 9.8081-3.7223-1.4589-13.367-3.9653-19.48-5.0623-10.763-1.9314-27.667-2.3031-37.837-0.83196-28.658 4.1454-52.123 15.814-71.818 35.715-31.192 31.516-43.548 77.168-31.048 114.71 8.0684 24.235 25.64 42.29 48.587 49.924 17.279 5.7486 35.216 4.6663 51.146-3.0861 17.77-8.6479 30.052-24.393 34.071-43.68 1.044-5.01 1.1472-15.932 0.2003-21.208-2.0065-11.181-6.9794-20.781-15.161-29.269-10.973-11.384-24.569-17.144-40.559-17.184-3.4463-0.008-6.8524 0.13881-7.569 0.32717-1.2043 0.31652-1.3277 0.21087-1.6288-1.3939-0.6188-3.2984 0.1393-16.572 1.1676-20.443 3.2487-12.229 8.3824-20.963 17.303-29.438 11.958-11.361 27.245-17.312 44.47-17.312 26.745 0 51.255 15.462 64.354 40.596 13.607 26.109 13.1 58.996-1.3683 88.767-17.246 35.486-49.965 58.974-89.345 64.139-6.7396 0.88387-21.387 0.89435-28.107 0.0201v0.00002z" inkscape:connector-curvature="0" class="svelte-11pit5o"></path><path id="path5012" d="m1140 173.74c-18.736-2.3106-34.722-13.517-43.08-30.199-1.9142-3.8208-3.9735-9.6041-4.5847-12.876l-0.3923-2.0999 1.7357-0.28711c3.2107-0.5311 12.421-0.3036 16.499 0.40756 20.2 3.5226 36.747 17.773 43.077 37.099 1.8297 5.5857 2.0524 7.261 1.0179 7.6579-1.3815 0.53013-10.795 0.72609-14.273 0.29712z" inkscape:connector-curvature="0" class="svelte-11pit5o"></path></g><g id="g5014" style="fill:#000000" transform="matrix(-.014158 -.015441 -.015441 .014158 -4594.9 2978)"><path id="path5016" inkscape:connector-curvature="0" d="m1100 252.1c-38.582-5.0193-71.655-28.564-88.698-63.144-13.064-26.507-15.479-57.006-6.7207-84.88 3.4376-10.94 7.5514-19.486 14.247-29.596 6.1465-9.2808 11.637-15.576 19.717-22.605 12.521-10.893 25.403-18.105 41.405-23.181 19.708-6.252 41.942-6.9335 61.744-1.8924 9.1446 2.3281 18.849 6.0402 26.659 10.198 6.7541 3.5957 17.813 11.197 14.27 9.8081-3.7223-1.4589-13.367-3.9653-19.48-5.0623-10.763-1.9314-27.667-2.3031-37.837-0.83196-28.658 4.1454-52.123 15.814-71.818 35.715-31.192 31.516-43.548 77.168-31.048 114.71 8.0684 24.235 25.64 42.29 48.587 49.924 17.279 5.7486 35.216 4.6663 51.146-3.0861 17.77-8.6479 30.052-24.393 34.071-43.68 1.044-5.01 1.1472-15.932 0.2003-21.208-2.0065-11.181-6.9794-20.781-15.161-29.269-10.973-11.384-24.569-17.144-40.559-17.184-3.4463-0.008-6.8524 0.13881-7.569 0.32717-1.2043 0.31652-1.3277 0.21087-1.6288-1.3939-0.6188-3.2984 0.1393-16.572 1.1676-20.443 3.2487-12.229 8.3824-20.963 17.303-29.438 11.958-11.361 27.245-17.312 44.47-17.312 26.745 0 51.255 15.462 64.354 40.596 13.607 26.109 13.1 58.996-1.3683 88.767-17.246 35.486-49.965 58.974-89.345 64.139-6.7396 0.88387-21.387 0.89435-28.107 0.0201v0.00002z" class="svelte-11pit5o"></path><path id="path5018" inkscape:connector-curvature="0" d="m1140 173.74c-18.736-2.3106-34.722-13.517-43.08-30.199-1.9142-3.8208-3.9735-9.6041-4.5847-12.876l-0.3923-2.0999 1.7357-0.28711c3.2107-0.5311 12.421-0.3036 16.499 0.40756 20.2 3.5226 36.747 17.773 43.077 37.099 1.8297 5.5857 2.0524 7.261 1.0179 7.6579-1.3815 0.53013-10.795 0.72609-14.273 0.29712z" class="svelte-11pit5o"></path></g></g></g><metadata><rdf:RDF><cc:Work><dc:format>image/svg+xml</dc:format><dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage"></dc:type><cc:license rdf:resource="http://creativecommons.org/licenses/publicdomain/"></cc:license><dc:publisher><cc:Agent rdf:about="http://openclipart.org/"><dc:title>Openclipart</dc:title></cc:Agent></dc:publisher></cc:Work><cc:License rdf:about="http://creativecommons.org/licenses/publicdomain/"><cc:permits rdf:resource="http://creativecommons.org/ns#Reproduction"></cc:permits><cc:permits rdf:resource="http://creativecommons.org/ns#Distribution"></cc:permits><cc:permits rdf:resource="http://creativecommons.org/ns#DerivativeWorks"></cc:permits></cc:License></rdf:RDF></metadata></svg></div> 
    <div class="title type-logo svelte-11pit5o"><h1 class="svelte-11pit5o">sema</h1></div> 
    <div class="subtitle type-logo svelte-11pit5o"><h2 class="svelte-11pit5o">a playground for livecoding Music and AI</h2></div> 
    <div class="container-social-links svelte-11pit5o"><a href="https://github.com/mimic-sussex/sema" target="_blank"><svg class="octicon octicon-mark-github color-text-white" viewBox="0 0 16 16" version="1.1" width="22" aria-hidden="true" style="margin: 0em 2em 0em 1em"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z" class="svelte-11pit5o"></path></svg></a> 
      <a href="https://www.youtube.com/channel/UCMJVYzJaZBNnKP6f0le7Lxg" target="_blank"><svg version="1.0" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 158 110" width="34" xml:space="preserve" style="margin: 0em 1em 0em 1em"><path fill="#FFFFFF" d="M154.4,17.5c-1.8-6.7-7.1-12-13.9-13.8C128.2,0.5,79,0.5,79,0.5s-48.3-0.2-60.6,3c-6.8,1.8-13.3,7.3-15.1,14 C0,29.7,0.3,55,0.3,55S0,80.3,3.3,92.5c1.8,6.7,8.4,12.2,15.1,14c12.3,3.3,60.6,3,60.6,3s48.3,0.2,60.6-3c6.8-1.8,13.1-7.3,14.9-14c3.3-12.1,3.3-37.5,3.3-37.5S157.7,29.7,154.4,17.5z M63.9,79.2V30.8L103.2,55L63.9,79.2z" class="svelte-11pit5o"></path></svg></a> 
      <a href="https://discord.gg/nNZMJfUHrS" target="_blank"><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 245 240" width="32" style="margin: 0em 1em 0em 2em"><style>.st0{fill:#FFFFFF;}</style><path class="st0 svelte-11pit5o" d="M104.4 103.9c-5.7 0-10.2 5-10.2 11.1s4.6 11.1 10.2 11.1c5.7 0 10.2-5 10.2-11.1.1-6.1-4.5-11.1-10.2-11.1zM140.9 103.9c-5.7 0-10.2 5-10.2 11.1s4.6 11.1 10.2 11.1c5.7 0 10.2-5 10.2-11.1s-4.5-11.1-10.2-11.1z"></path><path class="st0 svelte-11pit5o" d="M189.5 20h-134C44.2 20 35 29.2 35 40.6v135.2c0 11.4 9.2 20.6 20.5 20.6h113.4l-5.3-18.5 12.8 11.9 12.1 11.2 21.5 19V40.6c0-11.4-9.2-20.6-20.5-20.6zm-38.6 130.6s-3.6-4.3-6.6-8.1c13.1-3.7 18.1-11.9 18.1-11.9-4.1 2.7-8 4.6-11.5 5.9-5 2.1-9.8 3.5-14.5 4.3-9.6 1.8-18.4 1.3-25.9-.1-5.7-1.1-10.6-2.7-14.7-4.3-2.3-.9-4.8-2-7.3-3.4-.3-.2-.6-.3-.9-.5-.2-.1-.3-.2-.4-.3-1.8-1-2.8-1.7-2.8-1.7s4.8 8 17.5 11.8c-3 3.8-6.7 8.3-6.7 8.3-22.1-.7-30.5-15.2-30.5-15.2 0-32.2 14.4-58.3 14.4-58.3 14.4-10.8 28.1-10.5 28.1-10.5l1 1.2c-18 5.2-26.3 13.1-26.3 13.1s2.2-1.2 5.9-2.9c10.7-4.7 19.2-6 22.7-6.3.6-.1 1.1-.2 1.7-.2 6.1-.8 13-1 20.2-.2 9.5 1.1 19.7 3.9 30.1 9.6 0 0-7.9-7.5-24.9-12.7l1.4-1.6s13.7-.3 28.1 10.5c0 0 14.4 26.1 14.4 58.3 0 0-8.5 14.5-30.6 15.2z"></path></svg></a></div></div> 
  <canvas id="canvas" class="canvas-logo svelte-11pit5o"></canvas>`;

			attr(div5, "class", "center-all");
		},
		m(target, anchor) {
			insert(target, div5, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div5);
		}
	};
}

function instance$b($$self) {
	metatags.title = "Sema";
	metatags.description = "Description coming soon...";

	// const setupReGL = () => {
	//   var c = document.getElementById("canvas");
	//   c.width = window.innerWidth;
	//   c.height = window.innerHeight
	//   rgl = ReGL(c);
	//   m = mouse();
	//   const pixels = rgl.texture()
	//   const drawFeedback = rgl({
	//     frag: `
	//       precision mediump float;
	//       uniform sampler2D texture;
	//       uniform vec2 mouse;
	//       uniform float t;
	//       varying vec2 uv;
	//       void main () {
	//         float dist = length(gl_FragCoord.xy - mouse);
	//         gl_FragColor = vec4(0.98 * texture2D(texture,
	//           uv + cos(t) * vec2(0.5 - uv.y, uv.x - 0.5) - sin(2.0 * t) * (uv - 0.5)).rgb, 1) +
	//           exp(-0.01 * dist) * vec4(
	//             1.0 + cos(2.0 * t),
	//             1.0 + cos(2.0 * t + 1.5),
	//             1.0 + cos(2.0 * t + 3.0),
	//             0.0);
	//       }`,
	//     vert: `
	//       precision mediump float;
	//       attribute vec2 position;
	//       varying vec2 uv;
	//       void main () {
	//         uv = position;
	//         gl_Position = vec4(2.0 * position - 1.0, 0, 1);
	//       }`,
	//     attributes: {
	//       position: [
	//         -2, 0,
	//         0, -2,
	//         2, 2]
	//     },
	//     uniforms: {
	//       texture: pixels,
	//       mouse: ({ pixelRatio, viewportHeight}) => [
	//         m.x * pixelRatio,
	//         viewportHeight - m.y * pixelRatio
	//       ],
	//       t: ({tick}) => 0.01 * tick
	//     },
	//     count: 3
	//   })
	//   tick = rgl.frame(function () {
	//     rgl.clear({
	//       color: [0, 0, 0, 1]
	//     })
	//     drawFeedback()
	//     pixels({
	//       copy: true
	//     })
	//   })
	// }
	onMount(async () => {
		
	}); // setupReGL();

	/**
 * TODO delete objects
*/
	onDestroy(async () => {
		
	}); // tick.cancel();     // unsubscribe by calling cancel on the callback
	// rgl.destroy()

	return [];
}

class Pages extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-11pit5o-style")) add_css$5();
		init(this, options, instance$b, create_fragment$c, safe_not_equal, {});
	}
}

/* src/pages/login/_layout.svelte generated by Svelte v3.31.0 */

function create_fragment$d(ctx) {
	let t0;
	let form;
	let div0;
	let label0;
	let t2;
	let input0;
	let input0_value_value;
	let t3;
	let div1;
	let label1;
	let t5;
	let input1;
	let t6;
	let div2;
	let label2;
	let t8;
	let input2;
	let t9;
	let div3;
	let input3;
	let input3_value_value;
	let t10;
	let div4;
	let button;
	let t11;
	let getProfile_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	return {
		c() {
			if (default_slot) default_slot.c();
			t0 = space();
			form = element("form");
			div0 = element("div");
			label0 = element("label");
			label0.textContent = "Email";
			t2 = space();
			input0 = element("input");
			t3 = space();
			div1 = element("div");
			label1 = element("label");
			label1.textContent = "Name";
			t5 = space();
			input1 = element("input");
			t6 = space();
			div2 = element("div");
			label2 = element("label");
			label2.textContent = "Website";
			t8 = space();
			input2 = element("input");
			t9 = space();
			div3 = element("div");
			input3 = element("input");
			t10 = space();
			div4 = element("div");
			button = element("button");
			t11 = text$1("Sign Out");
			attr(label0, "for", "email");
			attr(input0, "id", "email");
			attr(input0, "type", "text");
			input0.value = input0_value_value = /*$username*/ ctx[0].email;
			input0.disabled = true;
			attr(label1, "for", "username");
			attr(input1, "id", "username");
			attr(input1, "type", "text");
			attr(label2, "for", "website");
			attr(input2, "id", "website");
			attr(input2, "type", "website");
			attr(input3, "type", "submit");
			attr(input3, "class", "button block primary");
			input3.value = input3_value_value = loading ? "Loading ..." : "Update";
			input3.disabled = loading;
			attr(button, "class", "button block");
			button.disabled = loading;
			attr(form, "class", "form-widget");
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			insert(target, t0, anchor);
			insert(target, form, anchor);
			append(form, div0);
			append(div0, label0);
			append(div0, t2);
			append(div0, input0);
			append(form, t3);
			append(form, div1);
			append(div1, label1);
			append(div1, t5);
			append(div1, input1);
			set_input_value(input1, /*$username*/ ctx[0]);
			append(form, t6);
			append(form, div2);
			append(div2, label2);
			append(div2, t8);
			append(div2, input2);
			set_input_value(input2, /*$website*/ ctx[1]);
			append(form, t9);
			append(form, div3);
			append(div3, input3);
			append(form, t10);
			append(form, div4);
			append(div4, button);
			append(button, t11);
			current = true;

			if (!mounted) {
				dispose = [
					listen(input1, "input", /*input1_input_handler*/ ctx[5]),
					listen(input2, "input", /*input2_input_handler*/ ctx[6]),
					listen(button, "click", signOut),
					action_destroyer(getProfile_action = getProfile.call(null, form)),
					listen(form, "submit", prevent_default(updateProfile))
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			if (!current || dirty & /*$username*/ 1 && input0_value_value !== (input0_value_value = /*$username*/ ctx[0].email) && input0.value !== input0_value_value) {
				input0.value = input0_value_value;
			}

			if (dirty & /*$username*/ 1 && input1.value !== /*$username*/ ctx[0]) {
				set_input_value(input1, /*$username*/ ctx[0]);
			}

			if (dirty & /*$website*/ 2) {
				set_input_value(input2, /*$website*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(form);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$c($$self, $$props, $$invalidate) {
	let $username;
	let $redirect;
	let $website;
	component_subscribe($$self, username, $$value => $$invalidate(0, $username = $$value));
	component_subscribe($$self, redirect, $$value => $$invalidate(2, $redirect = $$value));
	component_subscribe($$self, website, $$value => $$invalidate(1, $website = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;

	function input1_input_handler() {
		$username = this.value;
		username.set($username);
	}

	function input2_input_handler() {
		$website = this.value;
		website.set($website);
	}

	$$self.$$set = $$props => {
		if ("$$scope" in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$username, $redirect*/ 5) {
			/**
 *  We don't want the login page to visible to logged in user, so we redirect them
 **/
			 if ($username) $redirect("/");
		}
	};

	return [
		$username,
		$website,
		$redirect,
		$$scope,
		slots,
		input1_input_handler,
		input2_input_handler
	];
}

class Layout$3 extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$c, create_fragment$d, safe_not_equal, {});
	}
}

/**
 * PubSub is a singleton class that implements the Pub/Sub or Observer pattern
 * for decoupled communication
 * @class PubSub
 */
class PubSub {
	/**
	 * @constructor
	 */
	constructor() {
		if (PubSub.instance) return PubSub.instance; // Singleton pattern
		PubSub.instance = this;

		this.topics = {
			any: [] //  default topic 'any' keeps subscribers' callbacks
		};
		this.subId = -1;
	}

	/**
	 * Subscribe topic of interest with topic name and callback for deferred execution
	 * Returns tokens for un-subscription
	 */
	subscribe(topic, callback) {
		if (!this.topics[topic]) {
			this.topics[topic] = [];
		}
		let token = (++this.subId).toString();
		this.topics[topic].push({
			token: token,
			callback: callback
		});
		return token;
	}

	/**
	 * Unsubscribe from topic with token
	 */
	unsubscribe(token) {
		for (let topic in this.topics) {
			if (this.topics[topic]) {
				for (let i = 0, j = this.topics[topic].length; i < j; i++) {
					if (this.topics[topic][i].token === token) {
						this.topics[topic].splice(i, 1); // Remove 1 callback at index i
						return token;
					}
				}
			}
		}
		return this;
	}

	/**
	 * Publish to all subscribers
	 */
	publish(topic, data) {
		if (this.topics[topic]) {
			this.topics[topic].map(subscriber => subscriber.callback(data));
		}
		return this;
	}
}

class RingBuffer{static getStorageForCapacity(e,t){if(!t.BYTES_PER_ELEMENT)throw "Pass in a ArrayBuffer subclass";var o=8+(e+1)*t.BYTES_PER_ELEMENT;return new SharedArrayBuffer(o)}constructor(e,t){if(!ArrayBuffer.__proto__.isPrototypeOf(t)&&void 0!==t.BYTES_PER_ELEMENT)throw "Pass a concrete typed array class as second argument";this._type=t,this.capacity=(e.byteLength-8)/t.BYTES_PER_ELEMENT,this.buf=e,this.write_ptr=new Uint32Array(this.buf,0,1),this.read_ptr=new Uint32Array(this.buf,4,1),this.storage=new t(this.buf,8,this.capacity);}type(){return this._type.name}push(e){var t=Atomics.load(this.read_ptr,0),o=Atomics.load(this.write_ptr,0);if((o+1)%this._storage_capacity()==t)return 0;let r=Math.min(this._available_write(t,o),e.length),n=Math.min(this._storage_capacity()-o,r),s=r-n;return this._copy(e,0,this.storage,o,n),this._copy(e,n,this.storage,0,s),Atomics.store(this.write_ptr,0,(o+r)%this._storage_capacity()),r}pop(e){var t=Atomics.load(this.read_ptr,0),o=Atomics.load(this.write_ptr,0);if(o==t)return 0;let r=Math.min(this._available_read(t,o),e.length),n=Math.min(this._storage_capacity()-t,e.length),s=r-n;return this._copy(this.storage,t,e,0,n),this._copy(this.storage,0,e,n,s),Atomics.store(this.read_ptr,0,(t+r)%this._storage_capacity()),r}empty(){var e=Atomics.load(this.read_ptr,0);return Atomics.load(this.write_ptr,0)==e}full(){var e=Atomics.load(this.read_ptr,0);return (Atomics.load(this.write_ptr,0)+1)%this.capacity!=e}capacity(){return this.capacity-1}available_read(){var e=Atomics.load(this.read_ptr,0),t=Atomics.load(this.write_ptr,0);return this._available_read(e,t)}available_write(){var e=Atomics.load(this.read_ptr,0),t=Atomics.load(this.write_ptr,0);return this._available_write(e,t)}_available_read(e,t){return t>e?t-e:t+this._storage_capacity()-e}_available_write(e,t){let o=e-t-1;return t>=e&&(o+=this._storage_capacity()),o}_storage_capacity(){return this.capacity}_copy(e,t,o,r,n){for(var s=0;s<n;s++)o[r+s]=e[t+s];}}const getBase64=e=>{if(-1!==e.indexOf(";base64,")){var t=e.indexOf(";base64,")+8;return !!e.slice(t).match(/^([A-Za-z0-9+\/]{4})*([A-Za-z0-9+\/]{4}|[A-Za-z0-9+\/]{3}=|[A-Za-z0-9+\/]{2}==)$/)&&e.slice(t)}return !1},_keyStr="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",removePaddingFromBase64=e=>64===Module.maxiTools._keyStr.indexOf(e.charAt(e.length-1))?e.substring(0,e.length-1):e,loadSampleToArray=(e,t,o,r)=>{var n=[],s=getBase64(o);if(s){var a=s.length/4*3,i=new ArrayBuffer(a);s=removePaddingFromBase64(removePaddingFromBase64(s));var l,p,u,c,d,h,m,f=parseInt(s.length/4*3,10),y=0,g=0;for(l=new Uint8Array(i),s=s.replace(/[^A-Za-z0-9\+\/\=]/g,""),y=0;y<f;y+=3)p=_keyStr.indexOf(s.charAt(g++))<<2|(d=_keyStr.indexOf(s.charAt(g++)))>>4,u=(15&d)<<4|(h=_keyStr.indexOf(s.charAt(g++)))>>2,c=(3&h)<<6|(m=_keyStr.indexOf(s.charAt(g++))),l[y]=p,64!==h&&(l[y+1]=u),64!==m&&(l[y+2]=c);e.decodeAudioData(i,(function(e){let o=e.getChannelData(0);void 0!==n&&void 0!==r&&r.port.postMessage({sample:t,buffer:o});}),(function(e){console.log("Error decoding source!");}));}else {var b=new XMLHttpRequest;b.addEventListener("load",(()=>console.info(`loading sample '${t}'`))),b.open("GET",o,!0),b.responseType="arraybuffer",b.onload=function(){e.decodeAudioData(b.response,(function(e){let o=e.getChannelData(0);void 0!==n&&void 0!==r&&r.port.postMessage({sample:t,buffer:o});}),(function(e){console.log("Error decoding source!");}));},b.send();}return "Loading module"};class Event$1{constructor(e){this.eventName=e,this.callbacks=[];}registerCallback(e){this.callbacks.push(e);}unregisterCallback(e){const t=this.callbacks.indexOf(e);t>-1&&this.callbacks.splice(t,1);}emit(e){this.callbacks.slice(0).forEach((t=>{t(e);}));}}class Dispatcher{constructor(){this.events={};}dispatch(e,t){const o=this.events[e];o&&o.emit(t);}addEventListener(e,t){let o=this.events[e];o||(o=new Event$1(e),this.events[e]=o),o.registerCallback(t);}removeEventListener(e,t){const o=this.events[e];o&&o.callbacks.indexOf(t)>-1&&(o.unregisterCallback(t),0===o.callbacks.length&&delete this.events[e]);}}class Engine$1{constructor(){if(Engine$1.instance)return Engine$1.instance;Engine$1.instance=this,this.origin="",this.learners={},this.analysers={},this.mediaStreamSource={},this.mediaStream={},this.sharedArrayBuffers={},this.dispatcher=new Dispatcher,this.samplesLoaded=!1,this.isHushed=!1;}async addLearner(e,t){if(!t)throw new Error("Error adding Learner instance to Engine");try{await t.init(this.origin),this.addEventListener("onSharedBuffer",(e=>t.addSharedBuffer(e))),t.addEventListener("onSharedBuffer",(e=>this.addSharedBuffer(e))),this.learners[e]=t;}catch(e){console.error("Error adding Learner to Engine: ",e);}}removeLearner(e){if(!e)throw new Error("Error with learner ID when removing Learner from Engine");if(this.learners&&e in this.learners){let t=this.learners[e];t.removeEventListener("onSharedBuffer",(e=>this.addSharedBuffer(e))),t=null,delete this.learners[e];}}addEventListener(e,t){if(!(this.dispatcher&&e&&t))throw new Error("Error adding event listener to Engine");this.dispatcher.addEventListener(e,t);}createSharedBuffer(e,t,o){let r=RingBuffer.getStorageForCapacity(32*o,Float64Array),n=new RingBuffer(r,Float64Array);return this.audioWorkletNode.port.postMessage({func:"sab",value:r,ttype:t,channelID:e,blocksize:o}),this.sharedArrayBuffers[e]={sab:r,rb:n},r}addSharedBuffer(e){if(!e)throw new Error("Error with onSharedBuffer event");if(e.value&&e.value instanceof SharedArrayBuffer)try{let t=new RingBuffer(e.value,Float64Array);this.audioWorkletNode.port.postMessage({func:"sab",value:e.value,ttype:e.ttype,channelID:e.channelID,blocksize:e.blocksize}),this.sharedArrayBuffers[e.channelID]={sab:e.value,rb:t};}catch(e){console.error("Error pushing SharedBuffer to engine");}else e.name&&e.data&&this.audioWorkletNode.port.postMessage({func:"sendbuf",name:e.name,data:e.data});}pushDataToSharedBuffer(e,t){if(!(e&&t&&(1)))throw new Error("Error in function parameters");this.sharedArrayBuffers&&this.sharedArrayBuffers[e]&&this.sharedArrayBuffers[e].rb.push(t);}pollAnalyserData(e){if(void 0!==e){const t=new Uint8Array(e.fftSize),o=new Uint8Array(e.fftSize);return e.getByteTimeDomainData(t),e.getByteFrequencyData(o),{smoothingTimeConstant:e.smoothingTimeConstant,fftSize:e.fftSize,frequencyDataArray:o,timeDataArray:t}}}createAnalyser(e,t){if(!e||!t)throw new Error("Parameters to createAnalyser incorrect");if(this.audioContext&&this.audioWorkletNode){let o=this.audioContext.createAnalyser();o.smoothingTimeConstant=.25,o.fftSize=256,o.minDecibels=-90,o.maxDecibels=-0,this.audioWorkletNode.connect(o);let r=-1,n={};this.analysers[e]={analyser:o,analyserFrameId:r,callback:t};const s=()=>(n=this.pollAnalyserData(this.analysers[e].analyser),this.analysers[e].callback(n),this.analysers[e].analyserFrameId=requestAnimationFrame(s),r);s();}else this.analysers[e]={callback:t};}connectAnalysers(){Object.keys(this.analysers).map((e=>this.createAnalyser(e,this.analysers[e].callback)));}removeAnalyser(e){if(this.audioContext&&this.audioWorkletNode){void 0!==this.analysers[e.id]&&(cancelAnimationFrame(this.analysers[e.id].analyserFrameId),delete this.analysers[e.id]);}}async init(e){if(e&&new URL(e)){let t;try{this.audioContext,this.origin=e,this.audioWorkletName="maxi-processor",this.audioWorkletUrl=e+"/"+this.audioWorkletName+".js",void 0===this.audioContext&&(this.audioContext=new AudioContext({latencyHint:"playback"})),t=await this.loadWorkletProcessorCode();}catch(e){return !1}return !!t&&(this.connectWorkletNode(),console.log("running %csema-engine v0.1.1","font-weight: bold; color: #ffb7c5"),!0)}throw new Error("Name and valid URL required for AudioWorklet processor")}play(){if(void 0!==this.audioContext)return "suspended"===this.audioContext.state?(this.audioContext.resume(),!0):(this.hush(),!1)}stop(){void 0!==this.audioWorkletNode&&this.hush();}stopAndRelease(){void 0!==this.audioWorkletNode&&(this.audioWorkletNode.disconnect(this.audioContext.destination),this.audioWorkletNode=void 0);}setGain(e){if(void 0!==this.audioWorkletNode&&e>=0&&e<=1){const t=this.audioWorkletNode.parameters.get("gain");return t.value=e,console.log(t.value),!0}return !1}more(){if(void 0!==this.audioWorkletNode){const e=this.audioWorkletNode.parameters.get("gain");return e.value+=.05,console.info(e.value),e.value}throw new Error("error increasing sound level")}less(){if(void 0!==this.audioWorkletNode){const e=this.audioWorkletNode.parameters.get("gain");return e.value-=.05,console.info(e.value),e.value}throw new Error("error decreasing sound level")}hush(){return void 0!==this.audioWorkletNode&&(this.audioWorkletNode.port.postMessage({hush:1}),this.isHushed=!0,!0)}unHush(){return void 0!==this.audioWorkletNode&&(this.audioWorkletNode.port.postMessage({unhush:1}),this.isHushed=!1,!0)}eval(e){return !(!this.audioWorkletNode||!this.audioWorkletNode.port)&&("suspended"===this.audioContext.state&&this.audioContext.resume(),this.audioWorkletNode.port.postMessage({eval:1,setup:e.setup,loop:e.loop}),this.isHushed=!1,!0)}asyncPostToProcessor(e){if(!(e&&this.audioWorkletNode&&this.audioWorkletNode.port))throw new Error("Error async posting to processor");console.log("DEBUG:AudioEngine:onMessagingEventHandler:"),console.log(e),this.audioWorkletNode.port.postMessage(e);}sendClockPhase(e,t){void 0!==this.audioWorkletNode&&this.audioWorkletNode.port.postMessage({phase:e,i:t});}onAudioInputInit(e){try{this.mediaStreamSource=this.audioContext.createMediaStreamSource(e),this.mediaStreamSource.connect(this.audioWorkletNode),this.mediaStream=e,this.mediaStreamSourceConnected=!0;}catch(e){console.error(e);}}onAudioInputFail(e){this.mediaStreamSourceConnected=!1,console.error(`ERROR:Engine:AudioInputFail: ${e.message} ${e.name}`);}onAudioInputDisconnect(){}async connectMediaStream(){const e=window.constraints={audio:{latency:.02,echoCancellation:!1,mozNoiseSuppression:!1,mozAutoGainControl:!1},video:!1};return await navigator.mediaDevices.getUserMedia(e).then((e=>this.onAudioInputInit(e))).catch(this.onAudioInputFail),this.mediaStreamSourceConnected}async disconnectMediaStream(){try{this.mediaStreamSource.disconnect(this.audioWorkletNode),this.mediaStream.getAudioTracks().forEach((e=>e.stop())),this.mediaStreamSource=null,this.mediaStreamSourceConnected=!1;}catch(e){console.error(e);}finally{return this.mediaStreamSourceConnected}}async loadWorkletProcessorCode(){if(void 0===this.audioContext)return !1;try{await this.audioContext.audioWorklet.addModule(this.audioWorkletUrl);}catch(e){return console.error("ERROR:Engine:loadWorkletProcessorCode: AudioWorklet not supported in this browser: ",e.message),!1}try{return this.audioWorkletNode=new AudioWorkletNode(this.audioContext,this.audioWorkletName),this.audioWorkletNode.channelInterpretation="discrete",this.audioWorkletNode.channelCountMode="explicit",this.audioWorkletNode.channelCount=this.audioContext.destination.maxChannelCount,!0}catch(e){return console.error("Error loading worklet processor code: ",e),!1}}connectWorkletNode(){if(void 0!==this.audioWorkletNode)try{this.audioContext.destination.channelInterpretation="discrete",this.audioContext.destination.channelCountMode="explicit",this.audioContext.destination.channelCount=this.audioContext.destination.maxChannelCount,this.audioWorkletNode.connect(this.audioContext.destination),this.audioWorkletNode.onprocessorerror=e=>console.error("Engine processor error detected",e),this.audioWorkletNode.onprocessorstatechange=e=>console.info("Engine processor state change: "+audioWorkletNode.processorState),this.audioWorkletNode.port.onmessageerror=e=>console.error("Engine processor port error: "+e),this.audioWorkletNode.port.onmessage=e=>this.onProcessorMessageHandler(e);}catch(e){console.error("Error connecting WorkletNode: ",e);}}onProcessorMessageHandler(e){if(e&&e.data)if(e.data.rq&&"send"===e.data.rq)switch(e.data.ttype){case"ML":break;case"NET":this.peerNet.send(e.data.ch[0],e.data.value,e.data.ch[1]);}else if(e.data.rq&&"buf"===e.data.rq)switch(e.data.ttype){case"ML":this.dispatcher.dispatch("onSharedBuffer",{sab:e.data.value,channelID:e.data.channelID,blocksize:e.data.blocksize});break;case"scope":let t=new RingBuffer(e.data.value,Float64Array);this.sharedArrayBuffers[e.data.channelID]={sab:e.data.value,rb:t,ttype:e.data.ttype,channelID:e.data.channelID,blocksize:e.data.blocksize};}else e.data.rq&&"rts"===e.data.rq?(this.audioContext.suspend(),this.isHushed=!0):e.data instanceof Error&&console.error(`On Processor Message ${e.data}`);}subscribeProcessorMessage(e){if(!e||!this.audioWorkletNode)throw new Error("Error subscribing processor message");this.audioWorkletNode.port.onmessage=e;}loadSample(e,t){if(!this.audioContext||!this.audioWorkletNode)throw "Engine is not initialised!";if(!(t&&0!==t.length&&this.origin&&0!==this.origin.length&&new URL(this.origin+t)))throw "Problem with sample relative URL";try{loadSampleToArray(this.audioContext,e,this.origin+t,this.audioWorkletNode);}catch(o){console.error(`Error loading sample ${e} from ${t}: `,o);}}}var commonjsGlobal$1="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function createCommonjsModule$1(e){var t={exports:{}};return e(t,t.exports),t.exports}var nearley=createCommonjsModule$1((function(e){var t,o;t=commonjsGlobal$1,o=function(){function e(t,o,r){return this.id=++e.highestId,this.name=t,this.symbols=o,this.postprocess=r,this}function t(e,t,o,r){this.rule=e,this.dot=t,this.reference=o,this.data=[],this.wantedBy=r,this.isComplete=this.dot===e.symbols.length;}function o(e,t){this.grammar=e,this.index=t,this.states=[],this.wants={},this.scannable=[],this.completed={};}function r(e,t){this.rules=e,this.start=t||this.rules[0].name;var o=this.byName={};this.rules.forEach((function(e){o.hasOwnProperty(e.name)||(o[e.name]=[]),o[e.name].push(e);}));}function n(){this.reset("");}function s(e,t,s){if(e instanceof r){var a=e;s=t;}else a=r.fromCompiled(e,t);for(var i in this.grammar=a,this.options={keepHistory:!1,lexer:a.lexer||new n},s||{})this.options[i]=s[i];this.lexer=this.options.lexer,this.lexerState=void 0;var l=new o(a,0);this.table=[l],l.wants[a.start]=[],l.predict(a.start),l.process(),this.current=0;}function a(e){var t=typeof e;if("string"===t)return e;if("object"===t){if(e.literal)return JSON.stringify(e.literal);if(e instanceof RegExp)return e.toString();if(e.type)return "%"+e.type;if(e.test)return "<"+String(e.test)+">";throw new Error("Unknown symbol type: "+e)}}return e.highestId=0,e.prototype.toString=function(e){var t=void 0===e?this.symbols.map(a).join(" "):this.symbols.slice(0,e).map(a).join(" ")+"  "+this.symbols.slice(e).map(a).join(" ");return this.name+"  "+t},t.prototype.toString=function(){return "{"+this.rule.toString(this.dot)+"}, from: "+(this.reference||0)},t.prototype.nextState=function(e){var o=new t(this.rule,this.dot+1,this.reference,this.wantedBy);return o.left=this,o.right=e,o.isComplete&&(o.data=o.build(),o.right=void 0),o},t.prototype.build=function(){var e=[],t=this;do{e.push(t.right.data),t=t.left;}while(t.left);return e.reverse(),e},t.prototype.finish=function(){this.rule.postprocess&&(this.data=this.rule.postprocess(this.data,this.reference,s.fail));},o.prototype.process=function(e){for(var t=this.states,o=this.wants,r=this.completed,n=0;n<t.length;n++){var a=t[n];if(a.isComplete){if(a.finish(),a.data!==s.fail){for(var i=a.wantedBy,l=i.length;l--;){var p=i[l];this.complete(p,a);}if(a.reference===this.index){var u=a.rule.name;(this.completed[u]=this.completed[u]||[]).push(a);}}}else {if("string"!=typeof(u=a.rule.symbols[a.dot])){this.scannable.push(a);continue}if(o[u]){if(o[u].push(a),r.hasOwnProperty(u)){var c=r[u];for(l=0;l<c.length;l++){var d=c[l];this.complete(a,d);}}}else o[u]=[a],this.predict(u);}}},o.prototype.predict=function(e){for(var o=this.grammar.byName[e]||[],r=0;r<o.length;r++){var n=o[r],s=this.wants[e],a=new t(n,0,this.index,s);this.states.push(a);}},o.prototype.complete=function(e,t){var o=e.nextState(t);this.states.push(o);},r.fromCompiled=function(t,o){var n=t.Lexer;t.ParserStart&&(o=t.ParserStart,t=t.ParserRules);var s=new r(t=t.map((function(t){return new e(t.name,t.symbols,t.postprocess)})),o);return s.lexer=n,s},n.prototype.reset=function(e,t){this.buffer=e,this.index=0,this.line=t?t.line:1,this.lastLineBreak=t?-t.col:0;},n.prototype.next=function(){if(this.index<this.buffer.length){var e=this.buffer[this.index++];return "\n"===e&&(this.line+=1,this.lastLineBreak=this.index),{value:e}}},n.prototype.save=function(){return {line:this.line,col:this.index-this.lastLineBreak}},n.prototype.formatError=function(e,t){var o=this.buffer;if("string"==typeof o){var r=o.split("\n").slice(Math.max(0,this.line-5),this.line);o.indexOf("\n",this.index);var n=this.index-this.lastLineBreak,s=String(this.line).length;return t+=" at line "+this.line+" col "+n+":\n\n",t+=r.map((function(e,t){return a(this.line-r.length+t+1,s)+" "+e}),this).join("\n"),t+="\n"+a("",s+n)+"^\n"}return t+" at index "+(this.index-1);function a(e,t){var o=String(e);return Array(t-o.length+1).join(" ")+o}},s.fail={},s.prototype.feed=function(e){var t,r=this.lexer;for(r.reset(e,this.lexerState);;){try{if(!(t=r.next()))break}catch(e){var s=new o(this.grammar,this.current+1);throw this.table.push(s),(l=new Error(this.reportLexerError(e))).offset=this.current,l.token=e.token,l}var a=this.table[this.current];this.options.keepHistory||delete this.table[this.current-1];var i=this.current+1;s=new o(this.grammar,i),this.table.push(s);for(var l,p=void 0!==t.text?t.text:t.value,u=r.constructor===n?t.value:t,c=a.scannable,d=c.length;d--;){var h=c[d],m=h.rule.symbols[h.dot];if(m.test?m.test(u):m.type?m.type===t.type:m.literal===p){var f=h.nextState({data:u,token:t,isToken:!0,reference:i-1});s.states.push(f);}}if(s.process(),0===s.states.length)throw (l=new Error(this.reportError(t))).offset=this.current,l.token=t,l;this.options.keepHistory&&(a.lexerState=r.save()),this.current++;}return a&&(this.lexerState=r.save()),this.results=this.finish(),this},s.prototype.reportLexerError=function(e){var t,o,r=e.token;return r?(t="input "+JSON.stringify(r.text[0])+" (lexer error)",o=this.lexer.formatError(r,"Syntax error")):(t="input (lexer error)",o=e.message),this.reportErrorCommon(o,t)},s.prototype.reportError=function(e){var t=(e.type?e.type+" token: ":"")+JSON.stringify(void 0!==e.value?e.value:e),o=this.lexer.formatError(e,"Syntax error");return this.reportErrorCommon(o,t)},s.prototype.reportErrorCommon=function(e,t){var o=[];o.push(e);var r=this.table.length-2,n=this.table[r],s=n.states.filter((function(e){var t=e.rule.symbols[e.dot];return t&&"string"!=typeof t}));return 0===s.length?(o.push("Unexpected "+t+". I did not expect any more input. Here is the state of my parse table:\n"),this.displayStateStack(n.states,o)):(o.push("Unexpected "+t+". Instead, I was expecting to see one of the following:\n"),s.map((function(e){return this.buildFirstStateStack(e,[])||[e]}),this).forEach((function(e){var t=e[0],r=t.rule.symbols[t.dot],n=this.getSymbolDisplay(r);o.push("A "+n+" based on:"),this.displayStateStack(e,o);}),this)),o.push(""),o.join("\n")},s.prototype.displayStateStack=function(e,t){for(var o,r=0,n=0;n<e.length;n++){var s=e[n],a=s.rule.toString(s.dot);a===o?r++:(r>0&&t.push("    ^ "+r+" more lines identical to this"),r=0,t.push("    "+a)),o=a;}},s.prototype.getSymbolDisplay=function(e){return function(e){var t=typeof e;if("string"===t)return e;if("object"===t){if(e.literal)return JSON.stringify(e.literal);if(e instanceof RegExp)return "character matching "+e;if(e.type)return e.type+" token";if(e.test)return "token matching "+String(e.test);throw new Error("Unknown symbol type: "+e)}}(e)},s.prototype.buildFirstStateStack=function(e,t){if(-1!==t.indexOf(e))return null;if(0===e.wantedBy.length)return [e];var o=e.wantedBy[0],r=[e].concat(t),n=this.buildFirstStateStack(o,r);return null===n?null:[e].concat(n)},s.prototype.save=function(){var e=this.table[this.current];return e.lexerState=this.lexerState,e},s.prototype.restore=function(e){var t=e.index;this.current=t,this.table[t]=e,this.table.splice(t+1),this.lexerState=e.lexerState,this.results=this.finish();},s.prototype.rewind=function(e){if(!this.options.keepHistory)throw new Error("set option `keepHistory` to enable rewinding");this.restore(this.table[e]);},s.prototype.finish=function(){var e=[],t=this.grammar.start;return this.table[this.table.length-1].states.forEach((function(o){o.rule.name===t&&o.dot===o.rule.symbols.length&&0===o.reference&&o.data!==s.fail&&e.push(o);})),e.map((function(e){return e.data}))},{Parser:s,Grammar:r,Rule:e}},e.exports?e.exports=o():t.nearley=o();})),moo=createCommonjsModule$1((function(e){var t,o;t=commonjsGlobal$1,o=function(){var e=Object.prototype.hasOwnProperty,t=Object.prototype.toString,o="boolean"==typeof(new RegExp).sticky;function r(e){return e&&"[object RegExp]"===t.call(e)}function n(e){return e&&"object"==typeof e&&!r(e)&&!Array.isArray(e)}function s(e){return "("+e+")"}function a(e){return e.length?"(?:"+e.map((function(e){return "(?:"+e+")"})).join("|")+")":"(?!)"}function i(e){if("string"==typeof e)return "(?:"+e.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")+")";if(r(e)){if(e.ignoreCase)throw new Error("RegExp /i flag not allowed");if(e.global)throw new Error("RegExp /g flag is implied");if(e.sticky)throw new Error("RegExp /y flag is implied");if(e.multiline)throw new Error("RegExp /m flag is implied");return e.source}throw new Error("Not a pattern: "+e)}function l(t,o){if(n(o)||(o={match:o}),o.include)throw new Error("Matching rules cannot also include states");var s={defaultType:t,lineBreaks:!!o.error||!!o.fallback,pop:!1,next:null,push:null,error:!1,fallback:!1,value:null,type:null,shouldThrow:!1};for(var a in o)e.call(o,a)&&(s[a]=o[a]);if("string"==typeof s.type&&t!==s.type)throw new Error("Type transform cannot be a string (type '"+s.type+"' for token '"+t+"')");var i=s.match;return s.match=Array.isArray(i)?i:i?[i]:[],s.match.sort((function(e,t){return r(e)&&r(t)?0:r(t)?-1:r(e)?1:t.length-e.length})),s}function p(e){return Array.isArray(e)?function(e){for(var t=[],o=0;o<e.length;o++){var r=e[o];if(r.include)for(var n=[].concat(r.include),s=0;s<n.length;s++)t.push({include:n[s]});else {if(!r.type)throw new Error("Rule has no type: "+JSON.stringify(r));t.push(l(r.type,r));}}return t}(e):function(e){for(var t=Object.getOwnPropertyNames(e),o=[],r=0;r<t.length;r++){var s=t[r],a=e[s],i=[].concat(a);if("include"!==s){var p=[];i.forEach((function(e){n(e)?(p.length&&o.push(l(s,p)),o.push(l(s,e)),p=[]):p.push(e);})),p.length&&o.push(l(s,p));}else for(var u=0;u<i.length;u++)o.push({include:i[u]});}return o}(e)}var u=l("error",{lineBreaks:!0,shouldThrow:!0});function c(e,t){for(var n=null,l=Object.create(null),p=!0,c=null,d=[],h=[],m=0;m<e.length;m++)e[m].fallback&&(p=!1);for(m=0;m<e.length;m++){var f=e[m];if(f.include)throw new Error("Inheritance is not allowed in stateless lexers");if(f.error||f.fallback){if(n)throw !f.fallback==!n.fallback?new Error("Multiple "+(f.fallback?"fallback":"error")+" rules not allowed (for token '"+f.defaultType+"')"):new Error("fallback and error are mutually exclusive (for token '"+f.defaultType+"')");n=f;}var y=f.match.slice();if(p)for(;y.length&&"string"==typeof y[0]&&1===y[0].length;)l[y.shift().charCodeAt(0)]=f;if(f.pop||f.push||f.next){if(!t)throw new Error("State-switching options are not allowed in stateless lexers (for token '"+f.defaultType+"')");if(f.fallback)throw new Error("State-switching options are not allowed on fallback tokens (for token '"+f.defaultType+"')")}if(0!==y.length){p=!1,d.push(f);for(var g=0;g<y.length;g++){var b=y[g];if(r(b))if(null===c)c=b.unicode;else if(c!==b.unicode&&!1===f.fallback)throw new Error("If one rule is /u then all must be")}var $=a(y.map(i)),v=new RegExp($);if(v.test(""))throw new Error("RegExp matches empty string: "+v);if(new RegExp("|"+$).exec("").length-1>0)throw new Error("RegExp has capture groups: "+v+"\nUse (?:  ) instead");if(!f.lineBreaks&&v.test("\n"))throw new Error("Rule should declare lineBreaks: "+v);h.push(s($));}}var w=n&&n.fallback,x=o&&!w?"ym":"gm",k=o||w?"":"|";return !0===c&&(x+="u"),{regexp:new RegExp(a(h)+k,x),groups:d,fast:l,error:n||u}}function d(e,t,o){var r=e&&(e.push||e.next);if(r&&!o[r])throw new Error("Missing state '"+r+"' (in token '"+e.defaultType+"' of state '"+t+"')");if(e&&e.pop&&1!=+e.pop)throw new Error("pop must be 1 (in token '"+e.defaultType+"' of state '"+t+"')")}var h=function(e,t){this.startState=t,this.states=e,this.buffer="",this.stack=[],this.reset();};h.prototype.reset=function(e,t){return this.buffer=e||"",this.index=0,this.line=t?t.line:1,this.col=t?t.col:1,this.queuedToken=t?t.queuedToken:null,this.queuedThrow=t?t.queuedThrow:null,this.setState(t?t.state:this.startState),this.stack=t&&t.stack?t.stack.slice():[],this},h.prototype.save=function(){return {line:this.line,col:this.col,state:this.state,stack:this.stack.slice(),queuedToken:this.queuedToken,queuedThrow:this.queuedThrow}},h.prototype.setState=function(e){if(e&&this.state!==e){this.state=e;var t=this.states[e];this.groups=t.groups,this.error=t.error,this.re=t.regexp,this.fast=t.fast;}},h.prototype.popState=function(){this.setState(this.stack.pop());},h.prototype.pushState=function(e){this.stack.push(this.state),this.setState(e);};var m=o?function(e,t){return e.exec(t)}:function(e,t){var o=e.exec(t);return 0===o[0].length?null:o};function f(){return this.value}if(h.prototype._getGroup=function(e){for(var t=this.groups.length,o=0;o<t;o++)if(void 0!==e[o+1])return this.groups[o];throw new Error("Cannot find token type for matched text")},h.prototype.next=function(){var e=this.index;if(this.queuedGroup){var t=this._token(this.queuedGroup,this.queuedText,e);return this.queuedGroup=null,this.queuedText="",t}var o=this.buffer;if(e!==o.length){if(a=this.fast[o.charCodeAt(e)])return this._token(a,o.charAt(e),e);var r=this.re;r.lastIndex=e;var n=m(r,o),s=this.error;if(null==n)return this._token(s,o.slice(e,o.length),e);var a=this._getGroup(n),i=n[0];return s.fallback&&n.index!==e?(this.queuedGroup=a,this.queuedText=i,this._token(s,o.slice(e,n.index),e)):this._token(a,i,e)}},h.prototype._token=function(e,t,o){var r=0;if(e.lineBreaks){var n=/\n/g,s=1;if("\n"===t)r=1;else for(;n.exec(t);)r++,s=n.lastIndex;}var a={type:"function"==typeof e.type&&e.type(t)||e.defaultType,value:"function"==typeof e.value?e.value(t):t,text:t,toString:f,offset:o,lineBreaks:r,line:this.line,col:this.col},i=t.length;if(this.index+=i,this.line+=r,0!==r?this.col=i-s+1:this.col+=i,e.shouldThrow)throw new Error(this.formatError(a,"invalid syntax"));return e.pop?this.popState():e.push?this.pushState(e.push):e.next&&this.setState(e.next),a},"undefined"!=typeof Symbol&&Symbol.iterator){var y=function(e){this.lexer=e;};y.prototype.next=function(){var e=this.lexer.next();return {value:e,done:!e}},y.prototype[Symbol.iterator]=function(){return this},h.prototype[Symbol.iterator]=function(){return new y(this)};}return h.prototype.formatError=function(e,t){if(null==e){var o=this.buffer.slice(this.index);e={text:o,offset:this.index,lineBreaks:-1===o.indexOf("\n")?0:1,line:this.line,col:this.col};}var r=Math.max(0,e.offset-e.col+1),n=e.lineBreaks?e.text.indexOf("\n"):e.text.length,s=this.buffer.substring(r,e.offset+n);return t+=" at line "+e.line+" col "+e.col+":\n\n",t+="  "+s+"\n",t+="  "+Array(e.col).join(" ")+"^"},h.prototype.clone=function(){return new h(this.states,this.state)},h.prototype.has=function(e){return !0},{compile:function(e){var t=c(p(e));return new h({start:t},"start")},states:function(e,t){var o=e.$all?p(e.$all):[];delete e.$all;var r=Object.getOwnPropertyNames(e);t||(t=r[0]);for(var n=Object.create(null),s=0;s<r.length;s++)n[$=r[s]]=p(e[$]).concat(o);for(s=0;s<r.length;s++)for(var a=n[$=r[s]],i=Object.create(null),l=0;l<a.length;l++){var u=a[l];if(u.include){var m=[l,1];if(u.include!==$&&!i[u.include]){i[u.include]=!0;var f=n[u.include];if(!f)throw new Error("Cannot include nonexistent state '"+u.include+"' (in state '"+$+"')");for(var y=0;y<f.length;y++){var g=f[y];-1===a.indexOf(g)&&m.push(g);}}a.splice.apply(a,m),l--;}}var b=Object.create(null);for(s=0;s<r.length;s++){var $;b[$=r[s]]=c(n[$],!0);}for(s=0;s<r.length;s++){var v=r[s],w=b[v],x=w.groups;for(l=0;l<x.length;l++)d(x[l],v,b);var k=Object.getOwnPropertyNames(w.fast);for(l=0;l<k.length;l++)d(w.fast[k[l]],v,b);}return new h(b,t)},error:Object.freeze({error:!0}),fallback:Object.freeze({fallback:!0}),keywords:function(e){for(var t=Object.create(null),o=Object.create(null),r=Object.getOwnPropertyNames(e),n=0;n<r.length;n++){var s=r[n],a=e[s];(Array.isArray(a)?a:[a]).forEach((function(e){if((o[e.length]=o[e.length]||[]).push(e),"string"!=typeof e)throw new Error("keyword must be string (in keyword '"+s+"')");t[e]=s;}));}function i(e){return JSON.stringify(e)}var l="";for(var p in l+="switch (value.length) {\n",o){var u=o[p];l+="case "+p+":\n",l+="switch (value) {\n",u.forEach((function(e){var o=t[e];l+="case "+i(e)+": return "+i(o)+"\n";})),l+="}\n";}return l+="}\n",Function("value",l)}}},e.exports?e.exports=o():t.moo=o();})),nearleyLanguageBootstrapped=createCommonjsModule$1((function(e){!function(){function t(e){return e[0]}function o(e){return e[0].value}var r=moo,n=Object.assign({ws:{match:/\s+/,lineBreaks:!0,next:"main"},comment:/\#.*/,arrow:{match:/[=-]+\>/,next:"main"},js:{match:/\{\%(?:[^%]|\%[^}])*\%\}/,value:e=>e.slice(2,-2),lineBreaks:!0},word:{match:/[\w\?\+]+/,next:"afterWord"},string:{match:/"(?:[^\\"\n]|\\["\\/bfnrt]|\\u[a-fA-F0-9]{4})*"/,value:e=>JSON.parse(e),next:"main"},btstring:{match:/`[^`]*`/,value:e=>e.slice(1,-1),next:"main",lineBreaks:!0}},function(e){var t={};for(var o of e)t[o]={match:o,next:"main"};return t}([",","|","$","%","(",")",":?",":*",":+","@include","@builtin","@","]"])),s=r.states({main:Object.assign({},n,{charclass:{match:/\.|\[(?:\\.|[^\\\n])+?\]/,value:e=>new RegExp(e)}}),afterWord:Object.assign({},n,{"[":{match:"[",next:"main"}})});var a={Lexer:s,ParserRules:[{name:"final$ebnf$1",symbols:[s.has("ws")?{type:"ws"}:ws],postprocess:t},{name:"final$ebnf$1",symbols:[],postprocess:function(e){return null}},{name:"final",symbols:["_","prog","_","final$ebnf$1"],postprocess:function(e){return e[1]}},{name:"prog",symbols:["prod"],postprocess:function(e){return [e[0]]}},{name:"prog",symbols:["prod","ws","prog"],postprocess:function(e){return [e[0]].concat(e[2])}},{name:"prod",symbols:["word","_",s.has("arrow")?{type:"arrow"}:arrow,"_","expression+"],postprocess:function(e){return {name:e[0],rules:e[4]}}},{name:"prod",symbols:["word",{literal:"["},"_","wordlist","_",{literal:"]"},"_",s.has("arrow")?{type:"arrow"}:arrow,"_","expression+"],postprocess:function(e){return {macro:e[0],args:e[3],exprs:e[9]}}},{name:"prod",symbols:[{literal:"@"},"_","js"],postprocess:function(e){return {body:e[2]}}},{name:"prod",symbols:[{literal:"@"},"word","ws","word"],postprocess:function(e){return {config:e[1],value:e[3]}}},{name:"prod",symbols:[{literal:"@include"},"_","string"],postprocess:function(e){return {include:e[2].literal,builtin:!1}}},{name:"prod",symbols:[{literal:"@builtin"},"_","string"],postprocess:function(e){return {include:e[2].literal,builtin:!0}}},{name:"expression+",symbols:["completeexpression"]},{name:"expression+",symbols:["expression+","_",{literal:"|"},"_","completeexpression"],postprocess:function(e){return e[0].concat([e[4]])}},{name:"expressionlist",symbols:["completeexpression"]},{name:"expressionlist",symbols:["expressionlist","_",{literal:","},"_","completeexpression"],postprocess:function(e){return e[0].concat([e[4]])}},{name:"wordlist",symbols:["word"]},{name:"wordlist",symbols:["wordlist","_",{literal:","},"_","word"],postprocess:function(e){return e[0].concat([e[4]])}},{name:"completeexpression",symbols:["expr"],postprocess:function(e){return {tokens:e[0]}}},{name:"completeexpression",symbols:["expr","_","js"],postprocess:function(e){return {tokens:e[0],postprocess:e[2]}}},{name:"expr_member",symbols:["word"],postprocess:t},{name:"expr_member",symbols:[{literal:"$"},"word"],postprocess:function(e){return {mixin:e[1]}}},{name:"expr_member",symbols:["word",{literal:"["},"_","expressionlist","_",{literal:"]"}],postprocess:function(e){return {macrocall:e[0],args:e[3]}}},{name:"expr_member$ebnf$1",symbols:[{literal:"i"}],postprocess:t},{name:"expr_member$ebnf$1",symbols:[],postprocess:function(e){return null}},{name:"expr_member",symbols:["string","expr_member$ebnf$1"],postprocess:function(e){return e[1]?function(e){for(var t=e.literal,o=[],r=0;r<t.length;r++){var n=t.charAt(r);n.toUpperCase()!==n||n.toLowerCase()!==n?o.push(new RegExp("["+n.toLowerCase()+n.toUpperCase()+"]")):o.push({literal:n});}return {subexpression:[{tokens:o,postprocess:function(e){return e.join("")}}]}}(e[0]):e[0]}},{name:"expr_member",symbols:[{literal:"%"},"word"],postprocess:function(e){return {token:e[1]}}},{name:"expr_member",symbols:["charclass"],postprocess:t},{name:"expr_member",symbols:[{literal:"("},"_","expression+","_",{literal:")"}],postprocess:function(e){return {subexpression:e[2]}}},{name:"expr_member",symbols:["expr_member","_","ebnf_modifier"],postprocess:function(e){return {ebnf:e[0],modifier:e[2]}}},{name:"ebnf_modifier",symbols:[{literal:":+"}],postprocess:o},{name:"ebnf_modifier",symbols:[{literal:":*"}],postprocess:o},{name:"ebnf_modifier",symbols:[{literal:":?"}],postprocess:o},{name:"expr",symbols:["expr_member"]},{name:"expr",symbols:["expr","ws","expr_member"],postprocess:function(e){return e[0].concat([e[2]])}},{name:"word",symbols:[s.has("word")?{type:"word"}:word],postprocess:o},{name:"string",symbols:[s.has("string")?{type:"string"}:string],postprocess:e=>({literal:e[0].value})},{name:"string",symbols:[s.has("btstring")?{type:"btstring"}:btstring],postprocess:e=>({literal:e[0].value})},{name:"charclass",symbols:[s.has("charclass")?{type:"charclass"}:charclass],postprocess:o},{name:"js",symbols:[s.has("js")?{type:"js"}:js],postprocess:o},{name:"_$ebnf$1",symbols:["ws"],postprocess:t},{name:"_$ebnf$1",symbols:[],postprocess:function(e){return null}},{name:"_",symbols:["_$ebnf$1"]},{name:"ws",symbols:[s.has("ws")?{type:"ws"}:ws]},{name:"ws$ebnf$1",symbols:[s.has("ws")?{type:"ws"}:ws],postprocess:t},{name:"ws$ebnf$1",symbols:[],postprocess:function(e){return null}},{name:"ws",symbols:["ws$ebnf$1",s.has("comment")?{type:"comment"}:comment,"_"]}],ParserStart:"final"};e.exports=a;}();}));function compileLowLevel(e,t){var o=uniquer();t.alreadycompiled||(t.alreadycompiled=[]);for(var r={rules:[],body:[],config:{},customTokens:[],macros:{},start:""},n=0;n<e.length;n++){var s=e[n];if(c(s.name,s.pos,s.name&&s.name.length),s.body)t.nojs||r.body.push(s.body);else if(s.include){var a;if(a=s.builtin?s.include:require("path").resolve(t.file?require("path").dirname(t.file):process.cwd(),s.include),-1===t.alreadycompiled.indexOf(a)){if(t.alreadycompiled.push(a),"postprocessors.ne"===a)var i=require("nearley/builtin/postprocessors.ne");else if("whitespace.ne"===a)i=require("nearley/builtin/whitespace.ne");else if("string.ne"===a)i=require("nearley/builtin/string.ne");else if("number.ne"===a)i=require("nearley/builtin/number.ne");else if("cow.ne"===a)i=require("nearley/builtin/cow.ne");var l=nearley.Grammar.fromCompiled(nearleyLanguageBootstrapped),p=new nearley.Parser(l);p.feed(i);var u=Compile(p.results[0],{file:a,__proto__:t});r.rules=r.rules.concat(u.rules),r.body=r.body.concat(u.body),Object.keys(u.config).forEach((function(e){r.config[e]=u.config[e];})),Object.keys(u.macros).forEach((function(e){r.macros[e]=u.macros[e];}));}}else s.macro?r.macros[s.macro]={args:s.args,exprs:s.exprs}:s.config?r.config[s.config]=s.value:(d(s.name,s.rules,{}),r.start||(r.start=s.name));}return r;function c(e,o,r){t.rangeCallback&&t.rangeCallback(e,o,o+r);}function d(e,o,n){for(var s=0;s<o.length;s++){var a=h(e,o[s],n);t.nojs&&(a.postprocess=null),r.rules.push(a);}}function h(e,t,o){for(var r=[],n=0;n<t.tokens.length;n++){var s=m(e,t.tokens[n],o);null!==s&&r.push(s);}return new nearley.Rule(e,r,t.postprocess)}function m(e,t,n){if("string"==typeof t)return "null"===t?null:t;if(t instanceof RegExp)return t;if(t.literal)return t.literal.length?1===t.literal.length||r.config.lexer?t:function(e,t,r){var n=o(e+"$string");return c(n,t.pos,JSON.stringify(t.literal).length),d(n,[{tokens:t.literal.split("").map((function(e){return {literal:e}})),postprocess:{builtin:"joiner"}}],r),n}(e,t,n):null;if(t.token){if(r.config.lexer){var s=t.token;return -1===r.customTokens.indexOf(s)&&r.customTokens.push(s),{token:"("+(r.config.lexer+".has("+JSON.stringify(s)+") ? {type: "+JSON.stringify(s)+"} : "+s)+")"}}return t}if(t.subexpression)return function(e,t,r){var n=t.subexpression,s=o(e+"$subexpression");return d(s,n,r),s}(e,t,n);if(t.ebnf)return function(e,t,r){switch(t.modifier){case":+":return function(e,t,r){var n=o(e+"$ebnf");return d(n,[{tokens:[t.ebnf]},{tokens:[t.ebnf,n],postprocess:{builtin:"arrconcat"}}],r),n}(e,t,r);case":*":return function(e,t,r){var n=o(e+"$ebnf");return d(n,[{tokens:[]},{tokens:[t.ebnf,n],postprocess:{builtin:"arrconcat"}}],r),n}(e,t,r);case":?":return function(e,t,r){var n=o(e+"$ebnf");return d(n,[{tokens:[t.ebnf],postprocess:{builtin:"id"}},{tokens:[],postprocess:{builtin:"nuller"}}],r),n}(e,t,r)}}(e,t,n);if(t.macrocall)return function(e,t,n){var s=o(e+"$macrocall"),a=r.macros[t.macrocall];if(!a)throw new Error("Unkown macro: "+t.macrocall);if(a.args.length!==t.args.length)throw new Error("Argument count mismatch.");for(var i={__proto__:n},l=0;l<a.args.length;l++){var p=o(e+"$macrocall");i[a.args[l]]=p,d(p,[t.args[l]],n);}return d(s,a.exprs,i),s}(e,t,n);if(t.mixin){if(n[t.mixin])return m(e,n[t.mixin],n);throw new Error("Unbound variable: "+t.mixin)}throw new Error("unrecognized token: "+JSON.stringify(t))}}function uniquer(){var e={};return function(t){var o=e[t]=(e[t]||0)+1;return t+"$"+o}}var generate=createCommonjsModule$1((function(e){var t,o;t=commonjsGlobal$1,o=function(e){function t(e,t,s){return null==s&&(s=""),"[\n    "+e.map((function(e){return function(e,t){var s="{";return s+='"name": '+JSON.stringify(e.name),s+=', "symbols": ['+e.symbols.map(n).join(", ")+"]",e.postprocess&&(e.postprocess.builtin&&(e.postprocess=t[e.postprocess.builtin]),s+=', "postprocess": '+r(o(e.postprocess),"        ",{indentFirst:!1})),s+="}"}(e,t)})).join(",\n    ")+"\n"+s+"]"}function o(e){var t=e.toString().split(/\n/);if(1===t.length)return [t[0].replace(/^\s+|\s+$/g,"")];for(var o=null,r=t.slice(1),n=0;n<r.length;n++){var s=/^\s*/.exec(r[n]);s&&s[0].length!==r[n].length&&(null===o||s[0].length<o.length)&&(o=s[0]);}return null===o?t:t.map((function(e){return e.slice(0,o.length)===o?e.slice(o.length):e}))}function r(e,t,o){var r;return r=Array.isArray(e)?e:e.toString().split("\n"),o=o||{},r.map((function(e,r){var n=!0;return 0!=r||o.indentFirst||(n=!1),n?t+e:e})).join("\n")}function n(e){return e instanceof RegExp?e.toString():e.token?e.token:JSON.stringify(e)}var s=function(e,t){if(e.config.preprocessor||(e.config.preprocessor="_default"),!s[e.config.preprocessor])throw new Error("No such preprocessor: "+e.config.preprocessor);return s[e.config.preprocessor](e,t)};return s.js=s._default=s.javascript=function(e,o){var r="// Generated automatically by nearley, version "+e.version+"\n";return r+="// http://github.com/Hardmath123/nearley\n",r+="(function () {\n",r+="function id(x) { return x[0]; }\n",r+=e.body.join("\n"),r+="var grammar = {\n",r+="    Lexer: "+e.config.lexer+",\n",r+="    ParserRules: "+t(e.rules,s.javascript.builtinPostprocessors)+"\n",r+="  , ParserStart: "+JSON.stringify(e.start)+"\n",r+="}\n",r+="if (typeof module !== 'undefined'&& typeof module.exports !== 'undefined') {\n",r+="   module.exports = grammar;\n",r+="} else {\n",r+="   window."+o+" = grammar;\n",r+="}\n",r+="})();\n"},s.javascript.builtinPostprocessors={joiner:"function joiner(d) {return d.join('');}",arrconcat:"function arrconcat(d) {return [d[0]].concat(d[1]);}",arrpush:"function arrpush(d) {return d[0].concat([d[1]]);}",nuller:"function(d) {return null;}",id:"id"},s.module=s.esmodule=function(e,o){var r="// Generated automatically by nearley, version "+e.version+"\n";return r+="// http://github.com/Hardmath123/nearley\n",r+="function id(x) { return x[0]; }\n",r+=e.body.join("\n"),r+="let Lexer = "+e.config.lexer+";\n",r+="let ParserRules = "+t(e.rules,s.javascript.builtinPostprocessors)+";\n",r+="let ParserStart = "+JSON.stringify(e.start)+";\n",r+="export default { Lexer, ParserRules, ParserStart };\n"},s.cs=s.coffee=s.coffeescript=function(e,n){var a="# Generated automatically by nearley, version "+e.version+"\n";return a+="# http://github.com/Hardmath123/nearley\n",a+="do ->\n",a+="  id = (d) -> d[0]\n",a+=r(o(e.body.join("\n")),"  ")+"\n",a+="  grammar = {\n",a+="    Lexer: "+e.config.lexer+",\n",a+="    ParserRules: "+r(t(e.rules,s.coffeescript.builtinPostprocessors),"      ",{indentFirst:!1})+",\n",a+="    ParserStart: "+JSON.stringify(e.start)+"\n",a+="  }\n",a+="  if typeof module != 'undefined' && typeof module.exports != 'undefined'\n",a+="    module.exports = grammar;\n",a+="  else\n",a+="    window."+n+" = grammar;\n"},s.coffeescript.builtinPostprocessors={joiner:"(d) -> d.join('')",arrconcat:"(d) -> [d[0]].concat(d[1])",arrpush:"(d) -> d[0].concat([d[1]])",nuller:"() -> null",id:"id"},s.ts=s.typescript=function(e,o){var r="// Generated automatically by nearley, version "+e.version+"\n";return r+="// http://github.com/Hardmath123/nearley\n",r+="// Bypasses TS6133. Allow declared but unused functions.\n",r+="// @ts-ignore\n",r+="function id(d: any[]): any { return d[0]; }\n",r+=e.customTokens.map((function(e){return "declare var "+e+": any;\n"})).join(""),r+=e.body.join("\n"),r+="\n",r+="interface NearleyToken {\n",r+="  value: any;\n",r+="  [key: string]: any;\n",r+="};\n",r+="\n",r+="interface NearleyLexer {\n",r+="  reset: (chunk: string, info: any) => void;\n",r+="  next: () => NearleyToken | undefined;\n",r+="  save: () => any;\n",r+="  formatError: (token: never) => string;\n",r+="  has: (tokenType: string) => boolean;\n",r+="};\n",r+="\n",r+="interface NearleyRule {\n",r+="  name: string;\n",r+="  symbols: NearleySymbol[];\n",r+="  postprocess?: (d: any[], loc?: number, reject?: {}) => any;\n",r+="};\n",r+="\n",r+="type NearleySymbol = string | { literal: any } | { test: (token: any) => boolean };\n",r+="\n",r+="interface Grammar {\n",r+="  Lexer: NearleyLexer | undefined;\n",r+="  ParserRules: NearleyRule[];\n",r+="  ParserStart: string;\n",r+="};\n",r+="\n",r+="const grammar: Grammar = {\n",r+="  Lexer: "+e.config.lexer+",\n",r+="  ParserRules: "+t(e.rules,s.typescript.builtinPostprocessors,"  ")+",\n",r+="  ParserStart: "+JSON.stringify(e.start)+",\n",r+="};\n",r+="\n",r+="export default grammar;\n"},s.typescript.builtinPostprocessors={joiner:"(d) => d.join('')",arrconcat:"(d) => [d[0]].concat(d[1])",arrpush:"(d) => d[0].concat([d[1]])",nuller:"() => null",id:"id"},s},e.exports?e.exports=o():t.generate=o(t.nearley);})),warn=function(e,t){e.out.write("WARN\t"+t+"\n");};function lintNames(e,t){var o=[];e.rules.forEach((function(e){o.push(e.name);})),e.rules.forEach((function(e){e.symbols.forEach((function(e){e.literal||e.token||e.constructor===RegExp||-1===o.indexOf(e)&&warn(t,"Undefined symbol `"+e+"` used.");}));}));}function lint(e,t){t.out||(t.out=process.stderr),lintNames(e,t);}var lint_1=lint,objectID=0,vars={},jsFuncMap={saw:{setup:(e,t)=>`${e} = new Module.maxiOsc();\n                      ${e}.phaseReset(${t.length>1?t[1].loop:0});`,loop:(e,t)=>`${e}.saw(${t[0].loop})`},sin:{setup:(e,t)=>`${e} = new Module.maxiOsc();\n                      ${e}.phaseReset(${t.length>1?t[1].loop:0});`,loop:(e,t)=>`${e}.sinewave(${t[0].loop})`},tri:{setup:(e,t)=>`${e} = new Module.maxiOsc();\n                      ${e}.phaseReset(${t.length>1?t[1].loop:0});`,loop:(e,t)=>`${e}.triangle(${t[0].loop})`},pha:{setup:(e,t)=>`${e} = new Module.maxiOsc();\n                      ${e}.phaseReset(${t.length>1?t[1].loop:0});`,loop:(e,t)=>`${e}.phasor(${t[0].loop})`},ph2:{setup:(e,t)=>`${e} = new Module.maxiOsc();\n                      ${e}.phaseReset(${t.length>3?t[3].loop:0});`,loop:(e,t)=>`${e}.phasorBetween(${t[0].loop},${t[1].loop},${t[2].loop})`},sqr:{setup:(e,t)=>`${e} = new Module.maxiOsc();\n                      ${e}.phaseReset(${t.length>1?t[1].loop:0});`,loop:(e,t)=>`${e}.square(${t[0].loop})`},pul:{setup:(e,t)=>`${e} = new Module.maxiOsc();\n                      ${e}.phaseReset(${t.length>2?t[2].loop:0});`,loop:(e,t)=>`${e}.pulse(${t[0].loop},${t[1].loop})`},imp:{setup:(e,t)=>`${e} = new Module.maxiOsc();\n                      ${e}.phaseReset(${t.length>1?t[1].loop:0});`,loop:(e,t)=>`${e}.impulse(${t[0].loop})`},sawn:{setup:(e,t)=>`${e} = new Module.maxiOsc();\n                      ${e}.phaseReset(${t.length>1?t[1].loop:0});`,loop:(e,t)=>`${e}.sawn(${t[0].loop})`},noiz:{setup:(e,t)=>`${e} = new Module.maxiOsc()`,loop:(e,t)=>`${e}.noise()*${t[0].loop}`},gt:{setup:(e,t)=>"",loop:(e,t)=>`((${t[0].loop} > ${t[1].loop}) ? 1 : 0)`},lt:{setup:(e,t)=>"",loop:(e,t)=>`((${t[0].loop} < ${t[1].loop}) ? 1 : 0)`},mod:{setup:(e,t)=>"",loop:(e,t)=>`(${t[0].loop} % ${t[1].loop})`},add:{setup:(e,t)=>"",loop:(e,t)=>`(${t[0].loop} + ${t[1].loop})`},mul:{setup:(e,t)=>"",loop:(e,t)=>`(${t[0].loop} * ${t[1].loop})`},sub:{setup:(e,t)=>"",loop:(e,t)=>`(${t[0].loop} - ${t[1].loop})`},div:{setup:(e,t)=>"",loop:(e,t)=>`(${t[1].loop} != 0 ? ${t[0].loop}/${t[1].loop} : 0)`},pow:{setup:(e,t)=>"",loop:(e,t)=>`Math.pow(${t[0].loop},${t[1].loop})`},abs:{setup:(e,t)=>"",loop:(e,t)=>`Math.abs(${t[0].loop})`},env:{setup:(e,t)=>`${e} = new Module.maxiEnv();\n                      ${e}.setAttack(${t[1].loop});\n                      ${e}.setDecay(${t[2].loop});\n                      ${e}.setSustain(${t[3].loop});\n                      ${e}.setRelease(${t[4].loop})`,loop:(e,t)=>`${e}.adsr(1,${t[0].loop})`},sum:{setup:(e,t)=>"",loop:(e,t)=>{let o=`(${t[0].loop}`;for(let e=1;e<t.length;e++)o+=`+${t[e].loop}`;return o+")"}},mix:{setup:(e,t)=>"",loop:(e,t)=>{let o=`((${t[0].loop}`;for(let e=1;e<t.length;e++)o+=`+${t[e].loop}`;return o+`)/${t.length})`}},prod:{setup:(e,t)=>"",loop:(e,t)=>{let o=`(${t[0].loop}`;for(let e=1;e<t.length;e++)o+=`*${t[e].loop}`;return o+")"}},blin:{setup:(e,t)=>"",loop:(e,t)=>`Module.maxiMap.linlin(${t[0].loop}, -1, 1, ${t[1].loop}, ${t[2].loop})`},ulin:{setup:(e,t)=>"",loop:(e,t)=>`Module.maxiMap.linlin(${t[0].loop}, 0, 1, ${t[1].loop}, ${t[2].loop})`},bexp:{setup:(e,t)=>"",loop:(e,t)=>`Module.maxiMap.linexp(${t[0].loop}, -1, 1, ${t[1].loop}, ${t[2].loop})`},uexp:{setup:(e,t)=>"",loop:(e,t)=>`Module.maxiMap.linexp(${t[0].loop}, 0.0000001, 1, ${t[1].loop}, ${t[2].loop})`},linlin:{setup:(e,t)=>"",loop:(e,t)=>`Module.maxiMap.linlin(${t[0].loop}, ${t[1].loop}, ${t[2].loop},${t[3].loop}, ${t[4].loop})`},linexp:{setup:(e,t)=>"",loop:(e,t)=>`Module.maxiMap.linexp(${t[0].loop}, ${t[1].loop}, ${t[2].loop}, ${t[3].loop}, ${t[4].loop})`},dist:{setup:(e,t)=>`${e} = new Module.maxiNonlinearity()`,loop:(e,t)=>`${e}.atanDist(${t[0].loop},${t[1].loop})`},softclip:{setup:(e,t)=>`${e} = new Module.maxiNonlinearity()`,loop:(e,t)=>`${e}.softclip(${t[0].loop})`},hardclip:{setup:(e,t)=>`${e} = new Module.maxiNonlinearity()`,loop:(e,t)=>`${e}.hardclip(${t[0].loop})`},asymclip:{setup:(e,t)=>`${e} = new Module.maxiNonlinearity()`,loop:(e,t)=>`${e}.asymclip(${t[0].loop},${t[1].loop},${t[2].loop})`},flange:{setup:(e,t)=>`${e} = new Module.maxiFlanger()`,loop:(e,t)=>`${e}.flange(${t[0].loop},${t[1].loop},${t[2].loop},${t[3].loop},${t[4].loop})`},chor:{setup:(e,t)=>`${e} = new Module.maxiChorus()`,loop:(e,t)=>`${e}.chorus(${t[0].loop},${t[1].loop},${t[2].loop},${t[3].loop},${t[4].loop})`},dl:{setup:(e,t)=>`${e} = new Module.maxiDelayline()`,loop:(e,t)=>`${e}.dl(${t[0].loop},${t[1].loop},${t[2].loop})`},lpf:{setup:(e,t)=>`${e} = new Module.maxiFilter()`,loop:(e,t)=>`${e}.lopass(${t[0].loop},${t[1].loop})`},hpf:{setup:(e,t)=>`${e} = new Module.maxiFilter()`,loop:(e,t)=>`${e}.hipass(${t[0].loop},${t[1].loop})`},lpz:{setup:(e,t)=>`${e} = new Module.maxiFilter()`,loop:(e,t)=>`${e}.lores(${t[0].loop},${t[1].loop},${t[2].loop})`},hpz:{setup:(e,t)=>`${e} = new Module.maxiFilter()`,loop:(e,t)=>`${e}.hires(${t[0].loop},${t[1].loop},${t[2].loop})`},scop:{setup:(e,t)=>`${e} = new SABOutputTransducer(outputSABs,\n                                      this.port,\n                                      'scope',\n                                      ${t[1].loop},\n                                      this.currentSample,\n                                      ${3==t.length?1:t[3].loop})`,loop:(e,t)=>`${e}.send(${t[0].loop}, ${t[2].loop})`},toJS:{setup:(e,t)=>`${e} = new SABOutputTransducer(outputSABs,\n                                      this.port,\n                                      'ML',\n                                      ${t[1].loop},\n                                      this.currentSample,\n                                      ${3==t.length?1:t[3].loop})`,loop:(e,t)=>`${e}.send(${t[0].loop}, ${t[2].loop})`},fromJS:{setup:(e,t)=>`${e} = new SABInputTransducer(${t[0].loop}, ${2==t.length?1:0})`,loop:(e,t)=>`${e}.getSABValue(inputSABs, ${2==t.length?t[1].loop:0})`},mouseX:{setup:(e,t)=>"",loop:(e,t)=>"this.getSABValue('mxy')[0]"},mouseY:{setup:(e,t)=>"",loop:(e,t)=>"this.getSABValue('mxy')[1]"},at:{setup:(e,t)=>"",loop:(e,t)=>`${t[0].loop}[Math.min(${t[1].loop}, ${t[0].loop}.length-1)]`},sah:{setup:(e,t)=>`${e} = new Module.maxiSampleAndHold();`,loop:(e,t)=>`${e}.sah(${t[0].loop},${t[1].loop})`},stretch:{setup:(e,t)=>`${e} = new Module.maxiSample();\n                      ${e}.setSample(this.getSampleBuffer(${t[4].loop}));\n                      ${e}stretch = new Module.maxiStretch();\n                      ${e}stretch.setSample(${e});`,loop:(e,t)=>`(${e}.isReady() ? ${e}stretch.play(${t[0].loop},${t[1].loop},${t[2].loop},${t[3].loop},0.0) : 0.0)`},adc:{setup:(e,t)=>"",loop:(e,t)=>`(inputs * ${t[0].loop})`},sampler:{setup:(e,t)=>`${e} = new Module.maxiSample();\n                      ${e}.setSample(this.getSampleBuffer(${t[t.length-1].loop}));`,loop:(e,t)=>{let o=`${t[0].loop}`;return 3==t.length?o+=`,${t[1].loop}`:4==t.length&&(o+=`,${t[1].loop},${t[2].loop}`),`(${e}.isReady() ? ${e}.playOnZX(${o}) : 0.0)`}},loop:{setup:(e,t)=>`${e} = new Module.maxiSample();\n                      ${e}.setSample(this.getSampleBuffer(${t[1].loop}));`,loop:(e,t)=>`(${e}.isReady() ? ${e}.play(${t[0].loop}) : 0.0)`},slice:{setup:(e,t)=>`${e} = new Module.maxiSample();\n                      ${e}.setSample(this.getSampleBuffer(${t[2].loop}));`,loop:(e,t)=>`(${e}.isReady() ? ${e}.loopSetPosOnZX(${t[0].loop},${t[1].loop}) : 0.0)`},oscin:{setup:(e,t)=>"",loop:(e,t)=>`this.OSCTransducer(${t[0].loop},${t[1].loop})`},oscout:{setup:(e,t)=>"",loop:(e,t)=>`this.OSCTransducer(${t[0].loop},${t[1].loop})`},sah:{setup:(e,t)=>`${e} = new Module.maxiSampleAndHold();`,loop:(e,t)=>`${e}.sah(${t[0].loop},${t[1].loop})`},stretch:{setup:(e,t)=>`${e} = new Module.maxiSample();\n                      ${e}.setSample(this.getSampleBuffer(${t[4].loop}));\n                      ${e}stretch = new Module.maxiStretch();\n                      ${e}stretch.setSample(${e});`,loop:(e,t)=>`(${e}.isReady() ? ${e}stretch.play(${t[0].loop},${t[1].loop},${t[2].loop},${t[3].loop},0.0) : 0.0)`},bitToSig:{setup:(e,t)=>"",loop:(e,t)=>`Module.maxiBits.toSignal(${t[0].loop})`},bitToTrigSig:{setup:(e,t)=>"",loop:(e,t)=>`Module.maxiBits.toTrigSignal(${t[0].loop})`},bitNeg:{setup:(e,t)=>"",loop:(e,t)=>`Module.maxiBits.neg(${t[0].loop})`},bitInc:{setup:(e,t)=>"",loop:(e,t)=>`Module.maxiBits.inc(${t[0].loop})`},bitDec:{setup:(e,t)=>"",loop:(e,t)=>`Module.maxiBits.dec(${t[0].loop})`},bitAnd:{setup:(e,t)=>"",loop:(e,t)=>`Module.maxiBits.land(${t[0].loop},${t[1].loop})`},bitOr:{setup:(e,t)=>"",loop:(e,t)=>`Module.maxiBits.lor(${t[0].loop},${t[1].loop})`},bitXor:{setup:(e,t)=>"",loop:(e,t)=>`Module.maxiBits.lxor(${t[0].loop},${t[1].loop})`},bitShl:{setup:(e,t)=>"",loop:(e,t)=>`Module.maxiBits.shl(${t[0].loop},${t[1].loop})`},bitShr:{setup:(e,t)=>"",loop:(e,t)=>`Module.maxiBits.shr(${t[0].loop},${t[1].loop})`},bitAt:{setup:(e,t)=>"",loop:(e,t)=>`Module.maxiBits.at(${t[0].loop},${t[1].loop})`},bitAdd:{setup:(e,t)=>"",loop:(e,t)=>`Module.maxiBits.add(${t[0].loop},${t[1].loop})`},bitSub:{setup:(e,t)=>"",loop:(e,t)=>`Module.maxiBits.sub(${t[0].loop},${t[1].loop})`},bitMul:{setup:(e,t)=>"",loop:(e,t)=>`Module.maxiBits.mul(${t[0].loop},${t[1].loop})`},bitEq:{setup:(e,t)=>"",loop:(e,t)=>`Module.maxiBits.eq(${t[0].loop},${t[1].loop})`},bitGt:{setup:(e,t)=>"",loop:(e,t)=>`Module.maxiBits.gt(${t[0].loop},${t[1].loop})`},bitGte:{setup:(e,t)=>"",loop:(e,t)=>`Module.maxiBits.gte(${t[0].loop},${t[1].loop})`},bitLte:{setup:(e,t)=>"",loop:(e,t)=>`Module.maxiBits.lte(${t[0].loop},${t[1].loop})`},bitLt:{setup:(e,t)=>"",loop:(e,t)=>`Module.maxiBits.lt(${t[0].loop},${t[1].loop})`},setup:(e,t)=>"",bitDiv:{loop:(e,t)=>`Module.maxiBits.div(${t[0].loop},${t[1].loop})`},bitr:{setup:(e,t)=>"",loop:(e,t)=>`Module.maxiBits.at(${t[0].loop},${t[1].loop},${t[2].loop})`},bitnoise:{setup:(e,t)=>"",loop:(e,t)=>"Module.maxiBits.noise()"},btime:{setup:(e,t)=>"",loop:(e,t)=>"this.bitTime"},bitFromSig:{setup:(e,t)=>"",loop:(e,t)=>`Module.maxiBits.fromSignal(${t[0].loop})`},clp:{setup:(e,t)=>"",loop:(e,t)=>`this.clockPhase(${t[0].loop},${t.length>1?t[1].loop:0})`},clt:{setup:(e,t)=>"",loop:(e,t)=>`this.clockTrig(${t[0].loop},${t.length>1?t[1].loop:0})`},clk:{setup:(e,t)=>"",loop:(e,t)=>`(()=>{this.setBPM(${t[0].loop}); this.setBeatsPerBar(${t[1].loop});})()`},quantise:{setup:(e,t)=>`this.setCodeQuantiseMode(${t[0].loop>0?0:1})`,loop:(e,t)=>""},onzx:{setup:(e,t)=>`${e} = new Module.maxiTrigger();`,loop:(e,t)=>`${e}.onZX(${t[0].loop})`},onchange:{setup:(e,t)=>`${e} = new Module.maxiTrigger();`,loop:(e,t)=>`${e}.onChanged(${t[0].loop},${t[1].loop})`},count:{setup:(e,t)=>`${e} = new Module.maxiCounter();`,loop:(e,t)=>`${e}.count(${t[0].loop},${t[1].loop})`},idx:{setup:(e,t)=>`${e} = new Module.maxiIndex();`,loop:(e,t)=>`${e}.pull(${t[0].loop},${t[1].loop},${t[2].loop})`},svf:{setup:(e,t)=>`${e} = new Module.maxiSVF();\n                      ${e}_p1 = new Module.maxiTrigger();\n                      ${e}_p2 = new Module.maxiTrigger();`,loop:(e,t)=>`( () => { ${e}_cutoff = ${t[1].loop};\n                                if (${e}_p1.onChanged(${e}_cutoff, 1e-5)) {${e}.setCutoff(${e}_cutoff)};\n                                ${e}_res = ${t[2].loop};\n                                if (${e}_p2.onChanged(${e}_res, 1e-5)) {${e}.setResonance(${e}_res)};\n                                return ${e}.play(${t[0].loop},${t[3].loop},${t[4].loop},${t[5].loop},${t[6].loop})})()`},bitclock:{setup:(e,t)=>"",loop:(e,t)=>"this.bitclock"},pvshift:{setup:(e,t)=>`${e} = new pvshift();`,loop:(e,t)=>`${e}.play(${t[0].loop},${t[1].loop})`},rsq:{setup:(e,t)=>`${e} = new Module.maxiRatioSeq();`,loop:(e,t)=>2==t.length?`${e}.playTrig(${t[0].loop},${t[1].loop})`:`${e}.playValues(${t[0].loop},${t[1].loop},${t[2].loop})`},o303:{setup:(e,t)=>`${e} = new Module.Open303();\n                      ${e}.setSampleRate(sampleRate);\n                      ${e}_tnote = new Module.maxiTrigger();\n                      ${e}_twf = new Module.maxiTrigger();\n                      ${e}_tcut = new Module.maxiTrigger();\n                      ${e}_tres = new Module.maxiTrigger();\n                      ${e}_tenvm = new Module.maxiTrigger();\n                      ${e}_tdec = new Module.maxiTrigger();\n                      ${e}_tnoteoff = new Module.maxiTrigger();\n                      ${e}_tatt = new Module.maxiTrigger();`,loop:(e,t)=>`(()=>{\n\t\t\tlet newNote = ${e}_tnote.onZX(${t[0].loop});\n\t\t\tlet accent = ${t[3].loop};\n\t\t\tif (newNote) {\n\t\t\t\tif (${t[2].loop}>0) {\n\t\t\t\t\t${e}.slideToNote(${t[1].loop},accent);\n\t\t\t\t}else{\n\t\t\t\t\t${e}.triggerNote(${t[1].loop},accent);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (${e}_tnoteoff.onChanged(${t[4].loop}, 1e-5)) {${e}.allNotesOff()};\n\t\t\tif (${e}_twf.onChanged(${t[5].loop}, 1e-5)) {${e}.setWaveform(${t[5].loop})};\n\t\t\tif (${e}_tcut.onChanged(${t[6].loop}, 1e-5)) {${e}.setCutoff(${t[6].loop})};\n\t\t\tif (${e}_tres.onChanged(${t[7].loop}, 1e-5)) {${e}.setResonance(${t[7].loop})};\n\t\t\tif (${e}_tenvm.onChanged(${t[8].loop}, 1e-5)) {${e}.setEnvMod(${t[8].loop})};\n\t\t\tif (${e}_tatt.onChanged(${t[9].loop}, 1e-5)) {${e}.setNormalAttack(${t[9].loop})};\n\t\t\tif (${e}_tdec.onChanged(${t[10].loop}, 1e-5)) {${e}.setDecay(${t[10].loop})};\n\t\t\t${e}.setAccent(${t[11].loop});\n\t\t\treturn ${e}.play();})()`},freeverb:{setup:(e,t)=>`${e} = new Module.maxiFreeVerb();`,loop:(e,t)=>`${e}.play(${t[0].loop},${t[1].loop},${t[2].loop})`},line:{setup:(e,t)=>`${e} = new Module.maxiLine(); ${e}.prepare(0,1,${t[1].loop}, false); ${e}.triggerEnable(1);`,loop:(e,t)=>`${e}.play(${t[0].loop})`},const:{setup:(e,t)=>"",loop:(e,t)=>`${t[0].loop}`},poll:{setup:(e,t)=>`${e} = new poll()`,loop:(e,t)=>`${e}.play(${t[0].loop})`},dac:{setup:(e,t)=>"",loop:(e,t)=>1==t.length?`this.dacOutAll(${t[0].loop})`:`this.dacOut(${t[0].loop},${t[1].loop})`},fft:{setup:(e,t)=>`${e} = new fft(${t[1].loop}, ${t[2].loop})`,loop:(e,t)=>`${e}.play(${t[0].loop})`},ifft:{setup:(e,t)=>`${e} = new ifft(${t[3].loop}, ${t[4].loop})`,loop:(e,t)=>`${e}.play(${t[0].loop}, ${t[1].loop}, ${t[2].loop})`},mfcc:{setup:(e,t)=>`${e} = new mfcc(${t[1].loop}, ${t[2].loop}, ${t[3].loop})`,loop:(e,t)=>`${e}.play(${t[0].loop})`}};class ASTreeToJavascript{static getNextID(){return objectID=objectID>9999?0:++objectID}static emptyCode(){return {setup:"",loop:"",paramMarkers:[]}}static traverseTree(e,t,o,r,n){let s={"@lang":(e,t)=>(t.map((t=>{let s=ASTreeToJavascript.traverseTree(t,ASTreeToJavascript.emptyCode(),o,r,n);e.setup+=s.setup,e.loop+=s.loop;})),e),"@spawn":(e,t)=>((e=ASTreeToJavascript.traverseTree(t,e,o,r,n)).loop+=";",e),"@sigp":(e,t)=>{let s=[{s:t.paramBegin,e:t.paramEnd,l:o}];e.paramMarkers=e.paramMarkers.concat(s);let a=t["@func"].value,i=jsFuncMap[a],l="q.b"+n+"u"+ASTreeToJavascript.getNextID(),p=[];for(let e=0;e<t["@params"].length;e++){let s=ASTreeToJavascript.emptyCode();s=ASTreeToJavascript.traverseTree(t["@params"][e],s,o+1,r,n),p[e]=s;}let u="";for(let t in p)u+=p[t].setup,e.paramMarkers=e.paramMarkers.concat(p[t].paramMarkers);return e.setup+=`${u} ${i.setup(l,p)};`,e.loop+=`${i.loop(l,p)}`,e},"@setvar":(e,t)=>{let s=t["@varname"],a=r[s];null==a&&(a=Object.keys(r).length,r[s]=a);let i=ASTreeToJavascript.traverseTree(t["@varvalue"],ASTreeToJavascript.emptyCode(),o+1,r,n);return e.setup+=i.setup,e.loop=`(mem[${a}] = ${i.loop})`,e},"@getvar":(e,t)=>{let o=r[t];return null==o&&(o=Object.keys(r).length,r[t]=o),e.loop+=`(mem[${o}] != undefined ? mem[${o}] : 0)`,e},"@string":(e,t)=>(("string"==typeof t||t instanceof String)&&(e.loop+=`'${t}'`),e),"@num":(e,t)=>(null!=t.value&&(e.loop+=`${t.value}`),e),"@list":(e,t)=>{let s="q.b"+n+"l"+ASTreeToJavascript.getNextID();e.setup+=`${s} = new Float64Array(${t.length});`,e.loop+="(()=>{";let a="";for(let i=0;i<t.length;i++){let l=ASTreeToJavascript.traverseTree(t[i],ASTreeToJavascript.emptyCode(),o,r,n);"@num"==Object.keys(t[i])[0]?e.setup+=`${s}[${i}] = ${l.loop};`:(a+=l.setup,e.loop+=`${s}[${i}] = ${l.loop};`);}return e.loop+=`return ${s}})()`,e.setup+=a,e}};return Array.isArray(e)?e.map((e=>{Object.keys(e).map((o=>{t=s[o](t,e[o]);}));})):Object.keys(e).map((o=>{t=s[o](t,e[o]);})),t}static treeToCode(e,t=0){vars={};let o=ASTreeToJavascript.traverseTree(e,ASTreeToJavascript.emptyCode(),0,vars,t);return o.setup=`() => {let q=this.newq(); ${o.setup}; return q;}`,o.loop=`(q, inputs, mem) => {${o.loop}}`,o}}var IR=Object.freeze({__proto__:null,default:ASTreeToJavascript}),sema=createCommonjsModule$1((function(e){var t;t=commonjsGlobal$1,e.exports?e.exports={num:function(e){return {"@num":{value:e}}},str:function(e){return {"@string":e}},synth:function(e,t){return {"@sigp":{"@params":t,"@func":{value:e}}}},setvar:function(e,t){return {"@setvar":{"@varname":e,"@varvalue":t}}},getvar:function(e){return {"@getvar":e}}}:t.sema={num:function(e){return {"@num":{value:e}}},str:function(e){return {"@string":e}},synth:function(e,t){return {"@sigp":{"@params":t,"@func":{value:e}}}},setvar:function(e,t){return {"@setvar":{"@varname":e,"@varvalue":t}}},getvar:function(e){return {"@getvar":e}}};}));function getParserModuleExports(source){let sema$1=sema;sema$1.num("3");let module={exports:""};return eval(source),module.exports}function compile(e,t){try{let o;const{errors:r,output:n}=compileGrammar(e),s=getParserModuleExports(n),a=new nearley.Parser(s);if(!r&&a){const e=a.feed(t);e&&(o=ASTreeToJavascript.treeToCode(e.results,0));}return {dspCode:o}}catch(e){return {errors:e}}}function parse(e,t){try{const{errors:o,output:r}=compileGrammar(e),n=getParserModuleExports(r),s=new nearley.Parser(n);if(!o&&s){return {livecodeParseTree:s.feed(t).results}}return {errors:o}}catch(e){return {errors:e}}}function ASTreeToDSPcode(e){if(!e)throw new Error("Problem with livecodeParseTree argument passed to ASTreeToDSPCode");try{return {dspCode:ASTreeToJavascript.treeToCode(e,0)}}catch(e){return {errors:e}}}function stream(){let e="";return {write(t){e+=t;},dump:()=>e}}function AnnotatePositions(e){return e.map((e=>new nearley.Rule(e.name,e.symbols,e.postprocess&&((t,o,r)=>{var n=e.postprocess(t,o,r);return null===n?null:("object"!=typeof n||n.slice||(n.pos=o),n)}))))}function compileGrammar(e){let t=new nearley.Parser(AnnotatePositions(nearleyLanguageBootstrapped.ParserRules),nearleyLanguageBootstrapped.ParserStart,{lexer:nearleyLanguageBootstrapped.Lexer}),o=stream(),r="",n={};try{if(t.feed(e),t.results[0]){var s=compileLowLevel(t.results[0],{rangeCallback:function(e,t,o){n[e]=[t,o];}});lint_1(s,{out:o}),r=generate(s,"grammar");}}catch(e){o.write(e);}return {errors:o.dump(),positions:n,output:r}}var WorkerClass=null;try{var WorkerThreads="undefined"!=typeof module&&"function"==typeof module.require&&module.require("worker_threads")||"function"==typeof __non_webpack_require__&&__non_webpack_require__("worker_threads")||"function"==typeof require&&require("worker_threads");WorkerClass=WorkerThreads.Worker;}catch(e){}function decodeBase64$1(e,t){return Buffer.from(e,"base64").toString(t?"utf16":"utf8")}function createBase64WorkerFactory$2(e,t,o){var r=void 0===t?null:t,n=decodeBase64$1(e,void 0!==o&&o),s=n.indexOf("\n",10)+1,a=n.substring(s)+(r?"//# sourceMappingURL="+r:"");return function(e){return new WorkerClass(a,Object.assign({},e,{eval:!0}))}}function decodeBase64(e,t){var o=atob(e);if(t){for(var r=new Uint8Array(o.length),n=0,s=o.length;n<s;++n)r[n]=o.charCodeAt(n);return String.fromCharCode.apply(null,new Uint16Array(r.buffer))}return o}function createURL(e,t,o){var r=void 0===t?null:t,n=decodeBase64(e,void 0!==o&&o),s=n.indexOf("\n",10)+1,a=n.substring(s)+(r?"//# sourceMappingURL="+r:""),i=new Blob([a],{type:"application/javascript"});return URL.createObjectURL(i)}function createBase64WorkerFactory$1(e,t,o){var r;return function(n){return r=r||createURL(e,t,o),new Worker(r,n)}}var kIsNodeJS="[object process]"===Object.prototype.toString.call("undefined"!=typeof process?process:0);function isNodeJS(){return kIsNodeJS}function createBase64WorkerFactory(e,t,o){return isNodeJS()?createBase64WorkerFactory$2(e,t,o):createBase64WorkerFactory$1(e,t,o)}var WorkerFactory=createBase64WorkerFactory("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwohZnVuY3Rpb24oKXsidXNlIHN0cmljdCI7Y2xhc3MgdHtzdGF0aWMgZ2V0U3RvcmFnZUZvckNhcGFjaXR5KHQsZSl7aWYoIWUuQllURVNfUEVSX0VMRU1FTlQpdGhyb3ciUGFzcyBpbiBhIEFycmF5QnVmZmVyIHN1YmNsYXNzIjt2YXIgYT04Kyh0KzEpKmUuQllURVNfUEVSX0VMRU1FTlQ7cmV0dXJuIG5ldyBTaGFyZWRBcnJheUJ1ZmZlcihhKX1jb25zdHJ1Y3Rvcih0LGUpe2lmKCFBcnJheUJ1ZmZlci5fX3Byb3RvX18uaXNQcm90b3R5cGVPZihlKSYmdm9pZCAwIT09ZS5CWVRFU19QRVJfRUxFTUVOVCl0aHJvdyJQYXNzIGEgY29uY3JldGUgdHlwZWQgYXJyYXkgY2xhc3MgYXMgc2Vjb25kIGFyZ3VtZW50Ijt0aGlzLl90eXBlPWUsdGhpcy5jYXBhY2l0eT0odC5ieXRlTGVuZ3RoLTgpL2UuQllURVNfUEVSX0VMRU1FTlQsdGhpcy5idWY9dCx0aGlzLndyaXRlX3B0cj1uZXcgVWludDMyQXJyYXkodGhpcy5idWYsMCwxKSx0aGlzLnJlYWRfcHRyPW5ldyBVaW50MzJBcnJheSh0aGlzLmJ1Ziw0LDEpLHRoaXMuc3RvcmFnZT1uZXcgZSh0aGlzLmJ1Ziw4LHRoaXMuY2FwYWNpdHkpfXR5cGUoKXtyZXR1cm4gdGhpcy5fdHlwZS5uYW1lfXB1c2godCl7dmFyIGU9QXRvbWljcy5sb2FkKHRoaXMucmVhZF9wdHIsMCksYT1BdG9taWNzLmxvYWQodGhpcy53cml0ZV9wdHIsMCk7aWYoKGErMSkldGhpcy5fc3RvcmFnZV9jYXBhY2l0eSgpPT1lKXJldHVybiAwO2xldCBzPU1hdGgubWluKHRoaXMuX2F2YWlsYWJsZV93cml0ZShlLGEpLHQubGVuZ3RoKSxpPU1hdGgubWluKHRoaXMuX3N0b3JhZ2VfY2FwYWNpdHkoKS1hLHMpLHI9cy1pO3JldHVybiB0aGlzLl9jb3B5KHQsMCx0aGlzLnN0b3JhZ2UsYSxpKSx0aGlzLl9jb3B5KHQsaSx0aGlzLnN0b3JhZ2UsMCxyKSxBdG9taWNzLnN0b3JlKHRoaXMud3JpdGVfcHRyLDAsKGErcykldGhpcy5fc3RvcmFnZV9jYXBhY2l0eSgpKSxzfXBvcCh0KXt2YXIgZT1BdG9taWNzLmxvYWQodGhpcy5yZWFkX3B0ciwwKSxhPUF0b21pY3MubG9hZCh0aGlzLndyaXRlX3B0ciwwKTtpZihhPT1lKXJldHVybiAwO2xldCBzPU1hdGgubWluKHRoaXMuX2F2YWlsYWJsZV9yZWFkKGUsYSksdC5sZW5ndGgpLGk9TWF0aC5taW4odGhpcy5fc3RvcmFnZV9jYXBhY2l0eSgpLWUsdC5sZW5ndGgpLHI9cy1pO3JldHVybiB0aGlzLl9jb3B5KHRoaXMuc3RvcmFnZSxlLHQsMCxpKSx0aGlzLl9jb3B5KHRoaXMuc3RvcmFnZSwwLHQsaSxyKSxBdG9taWNzLnN0b3JlKHRoaXMucmVhZF9wdHIsMCwoZStzKSV0aGlzLl9zdG9yYWdlX2NhcGFjaXR5KCkpLHN9ZW1wdHkoKXt2YXIgdD1BdG9taWNzLmxvYWQodGhpcy5yZWFkX3B0ciwwKTtyZXR1cm4gQXRvbWljcy5sb2FkKHRoaXMud3JpdGVfcHRyLDApPT10fWZ1bGwoKXt2YXIgdD1BdG9taWNzLmxvYWQodGhpcy5yZWFkX3B0ciwwKTtyZXR1cm4oQXRvbWljcy5sb2FkKHRoaXMud3JpdGVfcHRyLDApKzEpJXRoaXMuY2FwYWNpdHkhPXR9Y2FwYWNpdHkoKXtyZXR1cm4gdGhpcy5jYXBhY2l0eS0xfWF2YWlsYWJsZV9yZWFkKCl7dmFyIHQ9QXRvbWljcy5sb2FkKHRoaXMucmVhZF9wdHIsMCksZT1BdG9taWNzLmxvYWQodGhpcy53cml0ZV9wdHIsMCk7cmV0dXJuIHRoaXMuX2F2YWlsYWJsZV9yZWFkKHQsZSl9YXZhaWxhYmxlX3dyaXRlKCl7dmFyIHQ9QXRvbWljcy5sb2FkKHRoaXMucmVhZF9wdHIsMCksZT1BdG9taWNzLmxvYWQodGhpcy53cml0ZV9wdHIsMCk7cmV0dXJuIHRoaXMuX2F2YWlsYWJsZV93cml0ZSh0LGUpfV9hdmFpbGFibGVfcmVhZCh0LGUpe3JldHVybiBlPnQ/ZS10OmUrdGhpcy5fc3RvcmFnZV9jYXBhY2l0eSgpLXR9X2F2YWlsYWJsZV93cml0ZSh0LGUpe2xldCBhPXQtZS0xO3JldHVybiBlPj10JiYoYSs9dGhpcy5fc3RvcmFnZV9jYXBhY2l0eSgpKSxhfV9zdG9yYWdlX2NhcGFjaXR5KCl7cmV0dXJuIHRoaXMuY2FwYWNpdHl9X2NvcHkodCxlLGEscyxpKXtmb3IodmFyIHI9MDtyPGk7cisrKWFbcytyXT10W2Urcl19fXNlbGYuUmluZ0J1ZmZlcj10O3ZhciBlPXt9O2NsYXNzIGF7Y29uc3RydWN0b3IoYSxzLGkpe3RoaXMuY2hhbm5lbD1zLHRoaXMuYmxvY2tzaXplPWkscyBpbiBlJiZlW3NdLmJsb2Nrc2l6ZT09aT90aGlzLnJpbmdidWY9ZVtzXS5yYjoodGhpcy5zYWI9dC5nZXRTdG9yYWdlRm9yQ2FwYWNpdHkoMzIqaSxGbG9hdDY0QXJyYXkpLHRoaXMucmluZ2J1Zj1uZXcgdCh0aGlzLnNhYixGbG9hdDY0QXJyYXkpLGVbc109e3JiOnRoaXMucmluZ2J1ZixzYWI6dGhpcy5zYWIsY3JlYXRlZDpEYXRlLm5vdygpLGJsb2Nrc2l6ZTppfSxwb3N0TWVzc2FnZSh7ZnVuYzoic2FiIix2YWx1ZTp0aGlzLnNhYix0dHlwZTphLGNoYW5uZWxJRDpzLGJsb2Nrc2l6ZTppfSkpfXNlbmQodCl7aWYodGhpcy5yaW5nYnVmLmF2YWlsYWJsZV93cml0ZSgpPjEpaWYoIm51bWJlciI9PXR5cGVvZiB0KXRoaXMucmluZ2J1Zi5wdXNoKG5ldyBGbG9hdDY0QXJyYXkoW3RdKSk7ZWxzZSBpZih0Lmxlbmd0aD09dGhpcy5ibG9ja3NpemUpdGhpcy5yaW5nYnVmLnB1c2godCk7ZWxzZSBpZih0Lmxlbmd0aDx0aGlzLmJsb2Nrc2l6ZSl7bGV0IGU9bmV3IEZsb2F0NjRBcnJheSh0aGlzLmJsb2Nrc2l6ZSk7Zm9yKGxldCBhIGluIHQpZVthXT10W2FdO3RoaXMucmluZ2J1Zi5wdXNoKGUpfWVsc2UgdGhpcy5yaW5nYnVmLnB1c2godC5zbGljZSgwLHRoaXMuYmxvY2tzaXplKSl9fXNlbGYuY3JlYXRlT3V0cHV0Q2hhbm5lbD0odCxlKT0+bmV3IGEoIk1MIix0LGUpLHNlbGYuaW5wdXQ9KHQsZSk9Pnt9LHNlbGYub3V0cHV0PSh0LGUpPT57cG9zdE1lc3NhZ2Uoe2Z1bmM6ImRhdGEiLHZhbDp0LGNoOmV9KX0sc2VsZi5sb2FkUmVzcG9uZGVycz17fSxzZWxmLmlucHV0U0FCcz17fSxzZWxmLnNlbWE9e3NhdmVGMzJBcnJheToodCxlKT0+KHBvc3RNZXNzYWdlKHtmdW5jOiJzYXZlIixuYW1lOnQsdmFsOmV9KSwwKSxsb2FkRjMyQXJyYXk6KHQsZSk9Pihwb3N0TWVzc2FnZSh7ZnVuYzoibG9hZCIsbmFtZTp0fSksbG9hZFJlc3BvbmRlcnNbdF09ZSwwKSxkb3dubG9hZDp0PT57cG9zdE1lc3NhZ2Uoe2Z1bmM6ImRvd25sb2FkIixuYW1lOnR9KX0sc2VuZENvZGU6dD0+e3Bvc3RNZXNzYWdlKHtmdW5jOiJzZW5kY29kZSIsY29kZTp0fSl9LHBiY29weTp0PT57cG9zdE1lc3NhZ2Uoe2Z1bmM6InBiY29weSIsbXNnOnR9KX0sc2VuZEJ1ZmZlcjoodCxlKT0+e3Bvc3RNZXNzYWdlKHtmdW5jOiJzZW5kYnVmIixuYW1lOnQsZGF0YTplfSl9LGVudjp7c2F2ZUxvY2FsOnQ9Pntwb3N0TWVzc2FnZSh7ZnVuYzoiZW52c2F2ZSIsbmFtZTp0LHN0b3JhZ2U6ImxvY2FsIn0pfSxsb2FkTG9jYWw6dD0+e3Bvc3RNZXNzYWdlKHtmdW5jOiJlbnZsb2FkIixuYW1lOnQsc3RvcmFnZToibG9jYWwifSl9LHNhdmVUb1BCOigpPT57cG9zdE1lc3NhZ2Uoe2Z1bmM6ImVudnNhdmUiLHN0b3JhZ2U6InBhc3RlYnVmZmVyIn0pfSxsb2FkR2lzdDp0PT57cG9zdE1lc3NhZ2Uoe2Z1bmM6ImVudmxvYWQiLG5hbWU6dCxzdG9yYWdlOiJnaXN0In0pfX0sZG9tZXZhbDp0PT57cG9zdE1lc3NhZ2Uoe2Z1bmM6ImRvbWV2YWwiLGNvZGU6dH0pfSxwZWVyaW5mbzooKT0+e3Bvc3RNZXNzYWdlKHtmdW5jOiJwZWVyaW5mbyJ9KSxjb25zb2xlLmxvZygiWW91ciBwZWVyIElEIGhhcyBiZWVuIGNvcGllZCB0byB0aGUgcGFzdGUgYnVmZmVyIil9fTtmdW5jdGlvbiBzKCl7dHJ5e2ZvcihsZXQgdCBpbiBpbnB1dFNBQnMpe2xldCBlPWlucHV0U0FCc1t0XS5yYi5hdmFpbGFibGVfcmVhZCgpO2lmKGUhPWlucHV0U0FCc1t0XS5yYi5jYXBhY2l0eSYmZT4wKWZvcihsZXQgYT0wO2E8ZTthKz1pbnB1dFNBQnNbdF0uYmxvY2tzaXplKXtsZXQgZT1uZXcgRmxvYXQ2NEFycmF5KGlucHV0U0FCc1t0XS5ibG9ja3NpemUpO2lucHV0U0FCc1t0XS5yYi5wb3AoZSksaW5wdXQodCxlKX19c2V0VGltZW91dChzLDIwKX1jYXRjaCh0KXtzZXRUaW1lb3V0KHMsMTAwKX19b25tZXNzYWdlPWU9PntpZihlLmRhdGEudXJsKSFmdW5jdGlvbih0KXtpZihuZXcgVVJMKHQpKXt0cnl7cygpfWNhdGNoKHQpe2NvbnNvbGUuZXJyb3IoIkVSUk9SOiBzYWJDaGVja2VyIix0KX1wb3N0TWVzc2FnZSh7aW5pdDohMH0pfWVsc2UgY29uc29sZS5lcnJvcigiRVJST1I6IGluaXRXaXRoVVJMIOKAkyBJbnZhbGlkIFVSTCIpfShlLmRhdGEudXJsKTtlbHNlIGlmKGUuZGF0YS5ldmFsKSh0PT57dHJ5e2lmKCFlKXZhciBlPWV2YWw7bGV0IGE9ZSh0KTt2b2lkIDAhPT1hP2NvbnNvbGUuaW5mbyhhKTpjb25zb2xlLmluZm8oImRvbmUiKX1jYXRjaCh0KXtjb25zb2xlLmVycm9yKCJFdmFsIGV4Y2VwdGlvbiBvbiBMZWFybmVyOiAiLHQpfX0pKGUuZGF0YS5ldmFsKTtlbHNlIGlmKCJ2YWwiaW4gZS5kYXRhKXtsZXQgdD1lLmRhdGEudmFsO3Q9SlNPTi5wYXJzZShgWyR7dH1dYCksbG9hZFJlc3BvbmRlcnNbZS5kYXRhLm5hbWVdKHQpLGRlbGV0ZSBsb2FkUmVzcG9uZGVyc1tlLmRhdGEubmFtZV19ZWxzZSBpZigibW9kZWwtaW5wdXQtZGF0YSI9PT1lLmRhdGEudHlwZSlpbnB1dChlLmRhdGEudmFsdWUsZS5kYXRhLmNoKTtlbHNlIGlmKGUuZGF0YS5zYWIpe2NvbnNvbGUuaW5mbygiYnVmZmVyIHJlY2VpdmVkIik7bGV0IGE9ZS5kYXRhLnNhYixzPW5ldyB0KGEsRmxvYXQ2NEFycmF5KTtpbnB1dFNBQnNbZS5kYXRhLmNoYW5uZWxJRF09e3NhYjphLHJiOnMsYmxvY2tzaXplOmUuZGF0YS5ibG9ja3NpemV9fX19KCk7Cgo=",null,!1);class Learner{constructor(){this.dispatcher=new Dispatcher;}addEventListener(e,t){if(!(this.dispatcher&&e&&t))throw new Error("Error adding event listener to Learner");this.dispatcher.addEventListener(e,t);}removeEventListener(e,t){if(!(this.dispatcher&&e&&t))throw new Error("Error removing event listener to Learner");this.dispatcher.removeEventListener(e,t);}async init(e){return this.worker=new WorkerFactory,new Promise(((t,o)=>{let r={};this.worker&&new URL(e)&&(this.worker.postMessage({url:e}),this.worker.onerror=e=>{console.log("onError"),o(e);},this.worker.onmessage=e=>{r=e.data.init,console.info("running Learner"),t(r),this.worker.onmessage=this.onMessageHandler.bind(this);});}))}onMessageHandler(e){if(e&&e.data&&e.data.func){({sab:e=>{this.dispatcher.dispatch("onSharedBuffer",e);},sendbuf:e=>{this.dispatcher.dispatch("onSharedBuffer",e);},save:e=>{window.localStorage.setItem(e.name,e.val);},load:e=>{let t={name:e.name,val:window.localStorage.getItem(e.name)};modelWorker.postMessage(t);},download:e=>{let t=window.localStorage.getItem(e.name),o=new Blob([t],{type:"text/plain;charset=utf-8"});saveData(o,`${e.name}.data`);},sendcode:e=>{},data:()=>{},pbcopy:e=>{copyToPasteBuffer(e.msg);},envsave:e=>{messaging.publish("env-save",e);},envload:e=>{messaging.publish("env-load",e);},domeval:e=>{evalDOMCode(e.code);},peerinfo:e=>{messaging.publish("peerinfo-request",{});}})[e.data.func](e.data);}else void 0!==e.data&&0!=e.data.length&&res(e.data);}eval(e){this.worker&&e&&this.worker.postMessage({eval:e});}addSharedBuffer(e){if(!(this.worker&&e&&e.sab&&e.sab instanceof SharedArrayBuffer))throw new Error("Error pushing SharedBuffer in Learner");this.worker.postMessage({sab:e.sab,blocksize:e.blocksize,channelID:e.channelID});}evalBlock(e){let t=e.indexOf("\n");"//--DOM"==e.substr(0,t)?(e=e.substr(t),evalDomCode(e),addToHistory("dom-history-",e)):(this.worker.postMessage({eval:e}),window.localStorage.setItem("modelEditorValue",codeMirror.getValue()),addToHistory("model-history-",e));}terminate(){this.worker.onmessage=null,this.worker.terminate(),this.worker=null;}}function getBlock(e){if(e){let t=e.getCursor(),o=t.line,r=e.lastLine();for(;o<r;){if(/___+/.test(e.getLine(o))){r=o-1;break}o++;}o=t.line;let n=-1;for(;o>=0;){if(/___+/.test(e.getLine(o))){n=o;break}o--;}return n>-1&&n++,e.getRange({line:n,ch:0},{line:r+1,ch:0})}}class Logger{constructor(){if(Logger.instance)return Logger.instance;Logger.instance=this;}takeOverConsole(e){if(e)try{var t=window.console;function e(e,o){var r=Array.prototype.slice.apply(o).join(" ");t&&t[e]("> "+r);}window.console={log:function(){e("log",arguments);},warn:function(){e("warn",arguments);},error:function(){e("error",arguments);},info:function(){e("info",arguments);}};}catch(e){console.error(e);}}}var mooo=moo.mooo,nearley$1=nearley.nearley,semaa=sema.semaa;

var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ASTreeToDSPcode: ASTreeToDSPcode,
    ASTreeToJavascript: IR,
    Engine: Engine$1,
    Learner: Learner,
    Logger: Logger,
    compile: compile,
    compileGrammar: compileGrammar,
    getBlock: getBlock,
    getParserModuleExports: getParserModuleExports,
    mooo: mooo,
    nearley: nearley$1,
    parse: parse,
    semaa: semaa
});

const id = () =>
	"_" +
	Math.random()
		.toString(36)
		.substr(2, 9);

function nil(e){}
function isEmpty(str){
		return !str || 0 === str.length;
}

async function fetchFrom(url){
  
	if (!isEmpty(url)) {
    try{
      const res = await fetch(url);
      return await res.text();
    }
    catch(error){ 
      throw Error(error);
    }
  } else throw Error("Error fetchFrom: Empty URL");
}

function getRowsCount(items, cols) {
  return Math.max(
    ...items.map((val) => {
      const item = val[cols];
      return (item && item.y) + (item && item.h);
    }),
    1,
  );
}

const makeMatrix = (rows, cols) => Array.from(Array(rows), () => new Array(cols)); // make 2d array

function makeMatrixFromItems(items, _row, _col) {
  let matrix = makeMatrix(_row, _col);

  for (var i = 0; i < items.length; i++) {
    const value = items[i][_col];
    const { x, y, h } = value;
    const id = items[i].id;
    const w = Math.min(_col, value.w);

    for (var j = y; j < y + h; j++) {
      const row = matrix[j];
      for (var k = x; k < x + w; k++) {
        row[k] = { ...value, id };
      }
    }
  }
  return matrix;
}

function findCloseBlocks(items, matrix, curObject) {
  const { h, x, y } = curObject;

  const w = Math.min(matrix[0].length, curObject.w);
  const tempR = matrix.slice(y, y + h);

  let result = [];
  for (var i = 0; i < tempR.length; i++) {
    let tempA = tempR[i].slice(x, x + w);
    result = [...result, ...tempA.map((val) => val.id && val.id !== curObject.id && val.id).filter(Boolean)];
  }

  return [...new Set(result)];
}

function makeMatrixFromItemsIgnore(items, ignoreList, _row, _col) {
  let matrix = makeMatrix(_row, _col);
  for (var i = 0; i < items.length; i++) {
    const value = items[i][_col];
    const id = items[i].id;
    const { x, y, h } = value;
    const w = Math.min(_col, value.w);

    if (ignoreList.indexOf(id) === -1) {
      for (var j = y; j < y + h; j++) {
        const row = matrix[j];
        if (row) {
          for (var k = x; k < x + w; k++) {
            row[k] = { ...value, id };
          }
        }
      }
    }
  }
  return matrix;
}

function findItemsById(closeBlocks, items) {
  return items.filter((value) => closeBlocks.indexOf(value.id) !== -1);
}

function findFreeSpaceForItem(matrix, item) {
  const cols = matrix[0].length;
  const w = Math.min(cols, item.w);
  let xNtime = cols - w;
  let getMatrixRows = matrix.length;

  for (var i = 0; i < getMatrixRows; i++) {
    const row = matrix[i];
    for (var j = 0; j < xNtime + 1; j++) {
      const sliceA = row.slice(j, j + w);
      const empty = sliceA.every((val) => val === undefined);
      if (empty) {
        const isEmpty = matrix.slice(i, i + item.h).every((a) => a.slice(j, j + w).every((n) => n === undefined));

        if (isEmpty) {
          return { y: i, x: j };
        }
      }
    }
  }

  return {
    y: getMatrixRows,
    x: 0,
  };
}

const getItem = (item, col) => {
  return { ...item[col], id: item.id };
};

const updateItem = (elements, active, position, col) => {
  return elements.map((value) => {
    if (value.id === active.id) {
      return { ...value, [col]: { ...value[col], ...position } };
    }
    return value;
  });
};

function moveItem(active, items, cols, original) {
  // Get current item from the breakpoint
  const item = getItem(active, cols);

  // Create matrix from the items expect the active
  let matrix = makeMatrixFromItemsIgnore(items, [item.id], getRowsCount(items, cols), cols);
  // Getting the ids of items under active Array<String>
  const closeBlocks = findCloseBlocks(items, matrix, item);
  // Getting the objects of items under active Array<Object>
  let closeObj = findItemsById(closeBlocks, items);
  // Getting whenever of these items is fixed
  const fixed = closeObj.find((value) => value[cols].fixed);

  // If found fixed, reset the active to its original position
  if (fixed) return items;

  // Update items
  items = updateItem(items, active, item, cols);

  // Create matrix of items expect close elements
  matrix = makeMatrixFromItemsIgnore(items, closeBlocks, getRowsCount(items, cols), cols);

  // Create temp vars
  let tempItems = items;
  let tempCloseBlocks = closeBlocks;

  // Exclude resolved elements ids in array
  let exclude = [];

  // Iterate over close elements under active item
  closeObj.forEach((item) => {
    // Find position for element
    let position = findFreeSpaceForItem(matrix, item[cols]);
    // Exclude item
    exclude.push(item.id);

    // Assign the position to the element in the column
    tempItems = updateItem(tempItems, item, position, cols);

    // Recreate ids of elements
    let getIgnoreItems = tempCloseBlocks.filter((value) => exclude.indexOf(value) === -1);

    // Update matrix for next iteration
    matrix = makeMatrixFromItemsIgnore(tempItems, getIgnoreItems, getRowsCount(tempItems, cols), cols);
  });

  // Return result
  return tempItems;
}

// Helper function
function normalize(items, col) {
  let result = items.slice();

  result.forEach((value) => {
    const getItem = value[col];
    if (!getItem.static) {
      result = moveItem(getItem, result, col);
    }
  });

  return result;
}

// Helper function
function adjust(items, col) {
  let matrix = makeMatrix(getRowsCount(items, col), col);

  let res = [];

  items.forEach((item) => {
    let position = findFreeSpaceForItem(matrix, item[col]);

    res.push({
      ...item,
      [col]: {
        ...item[col],
        ...position,
      },
    });

    matrix = makeMatrixFromItems(res, getRowsCount(res, col), col);
  });

  return res;
}

function makeItem(item) {
  const { min = { w: 1, h: 1 }, max } = item;
  return {
    fixed: false,
    resizable: !item.fixed,
    draggable: !item.fixed,
    customDragger: false,
    customResizer: false,
    min: {
      w: Math.max(1, min.w),
      h: Math.max(1, min.h),
    },
    max: { ...max },
    ...item,
  };
}

const gridHelp = {
  normalize(items, col) {
    const rows = getRowsCount(items, col);
    return normalize(items, col);
  },

  adjust(items, col) {
    return adjust(items, col);
  },

  item(obj) {
    return makeItem(obj);
  },

  findSpace(item, items, cols) {
    let matrix = makeMatrixFromItems(items, getRowsCount(items, cols), cols);

    let position = findFreeSpaceForItem(matrix, item[cols]);
    return position;
  },
};

/* node_modules/svelte-codemirror/src/CodeMirror.svelte generated by Svelte v3.31.0 */

function create_if_block$5(ctx) {
	let pre;
	let t;

	return {
		c() {
			pre = element("pre");
			t = text$1(/*value*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, pre, anchor);
			append(pre, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*value*/ 1) set_data(t, /*value*/ ctx[0]);
		},
		d(detaching) {
			if (detaching) detach(pre);
		}
	};
}

function create_fragment$e(ctx) {
	let textarea;
	let t;
	let if_block_anchor;
	let if_block = !/*CodeMirror*/ ctx[2] && create_if_block$5(ctx);

	return {
		c() {
			textarea = element("textarea");
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			textarea.value = /*value*/ ctx[0];
			attr(textarea, "tabindex", "0");
			textarea.readOnly = true;
		},
		m(target, anchor) {
			insert(target, textarea, anchor);
			/*textarea_binding*/ ctx[40](textarea);
			insert(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*value*/ 1) {
				textarea.value = /*value*/ ctx[0];
			}

			if (!/*CodeMirror*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$5(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(textarea);
			/*textarea_binding*/ ctx[40](null);
			if (detaching) detach(t);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

const is_browser = typeof window !== "undefined";
let codemirror_promise;
let _CodeMirror;

if (is_browser) {
	codemirror_promise = import('./codemirror-47f0ad4d.js').then(function (n) { return n.c; });

	codemirror_promise.then(mod => {
		_CodeMirror = mod.default;
	});
}

function sleep(ms) {
	return new Promise(fulfil => setTimeout(fulfil, ms));
}

function instance$d($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { value = "" } = $$props;
	let { readonly = false } = $$props;
	let { lineNumbers = true } = $$props;
	let { tab = true } = $$props;
	let { cmdEnter = null } = $$props;
	let { ctrlEnter = null } = $$props;
	let { shiftEnter = null } = $$props;
	let { cmdPeriod = null } = $$props;
	let { ctrlPeriod = null } = $$props;
	let { cmdHiffen = null } = $$props;
	let { ctrlHiffen = null } = $$props;
	let { cmdEqual = null } = $$props;
	let { ctrlEqual = null } = $$props;
	let { cmdOpenSquareBracket = null } = $$props;
	let { ctrlOpenSquareBracket = null } = $$props;
	let { cmdCloseSquareBracket = null } = $$props;
	let { ctrlCloseSquareBracket = null } = $$props;
	let { cmdForwardSlash = null } = $$props;
	let { ctrlForwardSlash = null } = $$props;
	let { useAutocomplete = null } = $$props;
	let { snippets = null } = $$props;
	let editor;
	let w;
	let h;
	let mode;
	let theme;
	const refs = {};
	let updating_externally = false;
	let destroyed = false;
	let CodeMirror;

	async function set(new_value, new_mode, new_theme) {
		if (new_mode !== mode || new_theme !== theme) {
			await createEditor(mode = new_mode, theme = new_theme);
		}

		$$invalidate(0, value = new_value);
		updating_externally = true;
		if (editor) editor.setValue(value);
		updating_externally = false;
	}

	function update(new_value) {
		$$invalidate(0, value = new_value);

		if (editor) {
			const { left, top } = editor.getScrollInfo();
			editor.setValue($$invalidate(0, value = new_value));
		} // editor.scrollTo(left, top);
	}

	function getValue() {
		if (editor) {
			return editor.getValue();
		}
	}

	function getLine(lineIndex) {
		if (editor) {
			return editor.getLine(lineIndex);
		}
	}

	function setSize(w, h) {
		if (editor) {
			return editor.setSize(w, h);
		}
	}

	function getSelection() {
		if (editor) {
			let expression = editor.getSelection();

			if (expression == "") {
				let cursorInfo = editor.getCursor();
				expression = editor.getDoc().getLine(cursorInfo.line);
			}

			return expression;
		}
	}

	function getCursorPosition() {
		return editor ? editor.getCursor() : undefined;
	}

	function getRange(from, to) {
		return editor ? editor.getRange(from, to) : undefined;
	}

	function commentSelection() {
		if (editor) {
			let expression = editor.getSelection();

			if (expression == "") {
				let cursorInfo = editor.getCursor();
				expression = editor.getDoc().getLine(cursorInfo.line);
			}

			return expression;
		}
	}

	function getCursor() {
		if (editor) {
			return editor.getDoc().getCursor();
		}
	}

	function selectAll() {
		if (editor) editor.execCommand("selectAll");
	}

	function setCursor(pos) {
		if (editor) {
			editor.setCursor(pos);
		}
	}

	function focus() {
		if (editor) {
			editor.focus();
		}
	}

	function getBlock() {
		if (editor) {
			let cursorInfo = editor.getCursor();

			//find post divider
			let line = cursorInfo.line;

			let linePost = editor.lastLine();

			while (line < linePost) {
				if ((/___+/).test(editor.getLine(line))) {
					// Test RegEx at least 3 underscores
					linePost = line - 1;

					break;
				}

				line++;
			}

			line = cursorInfo.line;
			let linePre = -1;

			while (line >= 0) {
				// console.log(editor2.getLine(line));
				if ((/___+/).test(editor.getLine(line))) {
					linePre = line;
					break;
				}

				line--;
			}

			if (linePre > -1) {
				linePre++;
			}

			let code = editor.getRange({ line: linePre, ch: 0 }, { line: linePost + 1, ch: 0 });
			return code;
		}
	}

	function resize() {
		editor.refresh();
	}

	function autoComplete() {
		if (editor && CodeMirror.showHint && snippets) {
			CodeMirror.showHint(
				editor,
				function () {
					const cursor = editor.getCursor();
					const { start, string: currentWord } = editor.getTokenAt(cursor);
					const { ch: end, line } = cursor;

					const list = snippets.filter(snippet => snippet.text.indexOf(currentWord) >= 0).sort((a, b) => {
						if (a.text > b.text) {
							return 1;
						} else if (a.text < b.text) {
							return -1;
						} else {
							return 0;
						}
					});

					return {
						list: list.length ? list : snippets,
						from: CodeMirror.Pos(line, start),
						to: CodeMirror.Pos(line, end)
					};
				},
				{
					completeSingle: false,
					completeOnSingleClick: false
				}
			);
		}
	}

	const modes = {
		js: { name: "javascript", json: false },
		json: { name: "javascript", json: true },
		ebnf: { name: "ebnf", base: "text/html" },
		svelte: { name: "handlebars", base: "text/html" },
		closure: { name: "clojure", base: "text/x-clojure" },
		asn: { name: "asn.1", base: "text/x-ttcn-asn" },
		sema: { name: "sema", base: "text/html" }
	};

	// $: {
	//   if (marker) marker.clear();
	//   if (errorLoc) {
	//     const line = errorLoc.line - 1;
	//     const ch = errorLoc.column;
	//     marker = editor.markText(
	//       { line, ch },
	//       { line, ch: ch + 1 },
	//       {
	//         className: "error-loc"
	//       }
	//     );
	//     error_line = line;
	//   } else {
	//     error_line = null;
	//   }
	// }
	// $: if (editor) {
	//   if (previous_error_line != null) {
	//     editor.removeLineClass(previous_error_line, "wrap", "error-line");
	//   }
	//   if (error_line && error_line !== previous_error_line) {
	//     editor.addLineClass(error_line, "wrap", "error-line");
	//     previous_error_line = error_line;
	//   }
	// }
	onMount(() => {
		if (_CodeMirror) {
			$$invalidate(2, CodeMirror = _CodeMirror);

			createEditor(mode || "svelte", theme).then(() => {
				if (editor) editor.setValue(value || "");
			});
		} else {
			codemirror_promise.then(async mod => {
				$$invalidate(2, CodeMirror = mod.default);
				await createEditor(mode || "svelte", theme);
				if (editor) editor.setValue(value || "");
			});
		}

		return () => {
			destroyed = true;
			if (editor) editor.toTextArea();
		};
	});

	let first = true;

	async function createEditor(mode, theme) {
		if (destroyed || !CodeMirror) return;
		if (editor) editor.toTextArea();

		// console.log("createEditor:", theme);
		const opts = {
			lineNumbers,
			lineWrapping: true,
			indentWithTabs: true,
			indentUnit: 2,
			tabSize: 2,
			value: "",
			mode: modes[mode] || { name: mode },
			readOnly: readonly,
			autoCloseBrackets: true,
			autoCloseTags: true,
			extraKeys: {}
		};

		if (theme !== undefined) opts.theme = theme;
		if (!tab) opts.extraKeys = { Tab: tab, "Shift-Tab": tab };
		if (cmdEnter) opts.extraKeys["Cmd-Enter"] = cmdEnter;
		if (ctrlEnter) opts.extraKeys["Ctrl-Enter"] = ctrlEnter;
		if (shiftEnter) opts.extraKeys["Shift-Enter"] = shiftEnter;
		if (cmdPeriod) opts.extraKeys["Cmd-."] = cmdPeriod;
		if (ctrlPeriod) opts.extraKeys["Ctrl-."] = ctrlPeriod;
		if (cmdHiffen) opts.extraKeys["Cmd--"] = cmdHiffen;
		if (ctrlHiffen) opts.extraKeys["Ctrl--"] = ctrlHiffen;
		if (cmdEqual) opts.extraKeys["Cmd-="] = cmdEqual;
		if (ctrlEqual) opts.extraKeys["Cmd-="] = ctrlEqual;
		if (cmdCloseSquareBracket) opts.extraKeys["Cmd-]"] = cmdCloseSquareBracket;
		if (cmdOpenSquareBracket) opts.extraKeys["Cmd-["] = cmdOpenSquareBracket;
		if (ctrlCloseSquareBracket) opts.extraKeys["Ctrl-]"] = ctrlCloseSquareBracket;
		if (ctrlOpenSquareBracket) opts.extraKeys["Ctrl-["] = ctrlOpenSquareBracket;
		if (cmdForwardSlash) opts.extraKeys["Cmd-/"] = () => editor.execCommand("toggleComment");
		if (ctrlForwardSlash) opts.extraKeys["Ctrl-/"] = () => editor.execCommand("toggleComment");
		if (useAutocomplete) opts.extraKeys["Ctrl-Space"] = () => autoComplete();

		// if(ctrlForwardSlash)
		//   opts.extraKeys["Ctrl-/"] = (ctrlForwardSlash);
		// if(cmdEnter && !opts.extraKeys["Cmd-Enter"])
		//   opts.extraKeys["Cmd-Enter"] = (cmdEnter);
		// Creating a text editor is a lot of work, so we yield
		// the main thread for a moment. This helps reduce jank
		if (first) await sleep(50);

		if (destroyed) return;
		$$invalidate(39, editor = CodeMirror.fromTextArea(refs.editor, opts));

		editor.on("change", (instance, changeObj) => {
			if (!updating_externally) {
				// const value = instance.getValue();
				dispatch("change", { changeObj });
			}
		});

		editor.on("focus", (instance, event) => {
			if (!updating_externally) {
				dispatch("focus", { event });
			}
		});

		editor.on("blur", (instance, event) => {
			if (!updating_externally) {
				dispatch("blur", { event });
			}
		});

		editor.on("refresh", (instance, event) => {
			if (!updating_externally) {
				dispatch("refresh", { event });
			}
		});

		editor.on("gutterClick", (instance, line, gutter, clickEvent) => {
			if (!updating_externally) {
				dispatch("gutterClick", { line, gutter, clickEvent });
			}
		});

		editor.on("viewportChange", (instance, from, to) => {
			if (!updating_externally) {
				dispatch("viewportChange", { from, to });
			}
		});

		if (first) await sleep(50);
		editor.refresh();
		first = false;
	}

	function textarea_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			refs.editor = $$value;
			$$invalidate(1, refs);
		});
	}

	$$self.$$set = $$props => {
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("readonly" in $$props) $$invalidate(3, readonly = $$props.readonly);
		if ("lineNumbers" in $$props) $$invalidate(4, lineNumbers = $$props.lineNumbers);
		if ("tab" in $$props) $$invalidate(5, tab = $$props.tab);
		if ("cmdEnter" in $$props) $$invalidate(6, cmdEnter = $$props.cmdEnter);
		if ("ctrlEnter" in $$props) $$invalidate(7, ctrlEnter = $$props.ctrlEnter);
		if ("shiftEnter" in $$props) $$invalidate(8, shiftEnter = $$props.shiftEnter);
		if ("cmdPeriod" in $$props) $$invalidate(9, cmdPeriod = $$props.cmdPeriod);
		if ("ctrlPeriod" in $$props) $$invalidate(10, ctrlPeriod = $$props.ctrlPeriod);
		if ("cmdHiffen" in $$props) $$invalidate(11, cmdHiffen = $$props.cmdHiffen);
		if ("ctrlHiffen" in $$props) $$invalidate(12, ctrlHiffen = $$props.ctrlHiffen);
		if ("cmdEqual" in $$props) $$invalidate(13, cmdEqual = $$props.cmdEqual);
		if ("ctrlEqual" in $$props) $$invalidate(14, ctrlEqual = $$props.ctrlEqual);
		if ("cmdOpenSquareBracket" in $$props) $$invalidate(15, cmdOpenSquareBracket = $$props.cmdOpenSquareBracket);
		if ("ctrlOpenSquareBracket" in $$props) $$invalidate(16, ctrlOpenSquareBracket = $$props.ctrlOpenSquareBracket);
		if ("cmdCloseSquareBracket" in $$props) $$invalidate(17, cmdCloseSquareBracket = $$props.cmdCloseSquareBracket);
		if ("ctrlCloseSquareBracket" in $$props) $$invalidate(18, ctrlCloseSquareBracket = $$props.ctrlCloseSquareBracket);
		if ("cmdForwardSlash" in $$props) $$invalidate(19, cmdForwardSlash = $$props.cmdForwardSlash);
		if ("ctrlForwardSlash" in $$props) $$invalidate(20, ctrlForwardSlash = $$props.ctrlForwardSlash);
		if ("useAutocomplete" in $$props) $$invalidate(21, useAutocomplete = $$props.useAutocomplete);
		if ("snippets" in $$props) $$invalidate(22, snippets = $$props.snippets);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[1] & /*editor*/ 256) {
			 if (editor && w && h) {
				editor.refresh();
			}
		}
	};

	return [
		value,
		refs,
		CodeMirror,
		readonly,
		lineNumbers,
		tab,
		cmdEnter,
		ctrlEnter,
		shiftEnter,
		cmdPeriod,
		ctrlPeriod,
		cmdHiffen,
		ctrlHiffen,
		cmdEqual,
		ctrlEqual,
		cmdOpenSquareBracket,
		ctrlOpenSquareBracket,
		cmdCloseSquareBracket,
		ctrlCloseSquareBracket,
		cmdForwardSlash,
		ctrlForwardSlash,
		useAutocomplete,
		snippets,
		set,
		update,
		getValue,
		getLine,
		setSize,
		getSelection,
		getCursorPosition,
		getRange,
		commentSelection,
		getCursor,
		selectAll,
		setCursor,
		focus,
		getBlock,
		resize,
		autoComplete,
		editor,
		textarea_binding
	];
}

class CodeMirror_1 extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$d,
			create_fragment$e,
			safe_not_equal,
			{
				value: 0,
				readonly: 3,
				lineNumbers: 4,
				tab: 5,
				cmdEnter: 6,
				ctrlEnter: 7,
				shiftEnter: 8,
				cmdPeriod: 9,
				ctrlPeriod: 10,
				cmdHiffen: 11,
				ctrlHiffen: 12,
				cmdEqual: 13,
				ctrlEqual: 14,
				cmdOpenSquareBracket: 15,
				ctrlOpenSquareBracket: 16,
				cmdCloseSquareBracket: 17,
				ctrlCloseSquareBracket: 18,
				cmdForwardSlash: 19,
				ctrlForwardSlash: 20,
				useAutocomplete: 21,
				snippets: 22,
				set: 23,
				update: 24,
				getValue: 25,
				getLine: 26,
				setSize: 27,
				getSelection: 28,
				getCursorPosition: 29,
				getRange: 30,
				commentSelection: 31,
				getCursor: 32,
				selectAll: 33,
				setCursor: 34,
				focus: 35,
				getBlock: 36,
				resize: 37,
				autoComplete: 38
			},
			[-1, -1]
		);
	}

	get set() {
		return this.$$.ctx[23];
	}

	get update() {
		return this.$$.ctx[24];
	}

	get getValue() {
		return this.$$.ctx[25];
	}

	get getLine() {
		return this.$$.ctx[26];
	}

	get setSize() {
		return this.$$.ctx[27];
	}

	get getSelection() {
		return this.$$.ctx[28];
	}

	get getCursorPosition() {
		return this.$$.ctx[29];
	}

	get getRange() {
		return this.$$.ctx[30];
	}

	get commentSelection() {
		return this.$$.ctx[31];
	}

	get getCursor() {
		return this.$$.ctx[32];
	}

	get selectAll() {
		return this.$$.ctx[33];
	}

	get setCursor() {
		return this.$$.ctx[34];
	}

	get focus() {
		return this.$$.ctx[35];
	}

	get getBlock() {
		return this.$$.ctx[36];
	}

	get resize() {
		return this.$$.ctx[37];
	}

	get autoComplete() {
		return this.$$.ctx[38];
	}
}

/* src/components/editors/GrammarEditor.svelte generated by Svelte v3.31.0 */

function add_css$6() {
	var style = element("style");
	style.id = "svelte-1a4e6qo-style";
	style.textContent = ".CodeMirror{font-family:monospace;height:300px;color:black;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre.CodeMirror-line,.CodeMirror pre.CodeMirror-line-like{padding:0 4px}.CodeMirror-scrollbar-filler,.CodeMirror-gutter-filler{background-color:white}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:black}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid black;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0 !important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-fat-cursor-mark{background-color:rgba(20, 255, 20, 0.5);-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{0%{}50%{background-color:transparent}100%{}}@-webkit-keyframes blink{0%{}50%{background-color:transparent}100%{}}@keyframes blink{0%{}50%{background-color:transparent}100%{}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:0;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:blue}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:bold}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-variable-3,.cm-s-default .cm-type{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:#f00}.cm-invalidchar{color:#f00}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0b0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#a22}.CodeMirror-matchingtag{background:rgba(255, 150, 0, .3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:white}.CodeMirror-scroll{overflow:scroll !important;margin-bottom:-50px;margin-right:-50px;padding-bottom:50px;height:100%;outline:none;position:relative}.CodeMirror-sizer{position:relative;border-right:50px solid transparent}.CodeMirror-vscrollbar,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-gutter-filler{position:absolute;z-index:6;display:none;outline:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-50px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:none !important;border:none !important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent }.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent }.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre.CodeMirror-line,.CodeMirror pre.CodeMirror-line-like{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:transparent;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre.CodeMirror-line,.CodeMirror-wrap pre.CodeMirror-line-like{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;padding:0.1px}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:none}.CodeMirror-scroll,.CodeMirror-sizer,.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255, 255, 0, .4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:none}.CodeMirror{font-family:monospace;font-size:16px}.CodeMirror-matchingbracket{outline:0 !important;border-radius:3px;background:rgba(0, 0, 0, 0.06);padding:1px 2px;margin:-1px -2px}.cm-keyword{color:#b713a8 !important}.cm-string{font-family:monospace;font-style:italic}.cm-comment-delimit-open{color:#ccc}.cm-comment-delimit-close{color:#676767}.cm-variable{color:#920000 !important}.cm-js-delimit{color:#4624c7 !important}.CodeMirror{font-family:monospace;font-size:12px}.CodeMirror-matchingbracket{outline:0 !important;border-radius:3px;background:rgba(0, 0, 0, 0.06);padding:1px 2px;margin:-1px -2px}.cm-keyword{color:#b713a8 !important}.cm-string{font-style:italic}.cm-comment-delimit-open{color:rgb(137, 24, 24)}.cm-comment-delimit-close{color:#676767}.cm-variable{color:#2981fb !important}.cm-js-delimit{color:#4624c7 !important}.cm-number{color:#ff6a00}.cm-comment{color:#ccc}.cm-variable{color:#f8f8f2}.cm-variable-2{color:#9effff}.cm-variable-3,.cm-s-monokai span.cm-type{color:#66d9ef}.cm-def{color:#fd971f}.cm-bracket{color:#f8f8f2}.cm-tag{color:#f92672}.cm-header{color:#ae81ff}.cm-link{color:#ae81ff}.cm-error{background:#f92672;color:#f8f8f0}.cm-comment.cm-attribute{color:#97b757}.cm-comment.cm-def{color:#bc9262}.cm-comment.cm-tag{color:#bc6283}.cm-comment.cm-type{color:#5998a6}.CodeMirror{background:#272822;color:#f8f8f2}div.CodeMirror-selected{background:#49483E}.CodeMirror-line::selection,.cm-s-monokai .CodeMirror-line>span::selection,.cm-s-monokai .CodeMirror-line>span>span::selection{background:rgba(73, 72, 62, .99)}.CodeMirror-line::-moz-selection,.cm-s-monokai .CodeMirror-line>span::-moz-selection,.cm-s-monokai .CodeMirror-line>span>span::-moz-selection{background:rgba(73, 72, 62, .99)}.CodeMirror-gutters{background:#272822;border-right:0px}.CodeMirror-guttermarker{color:white}.CodeMirror-guttermarker-subtle{color:#d0d0d0}.CodeMirror-linenumber{color:#d0d0d0}.CodeMirror-cursor{border-left:1px solid #f8f8f0}.cm-s-icecoder{color:#666;background:#1d1d1b}.cm-s-icecoder span.cm-keyword{color:#eee;font-weight:bold}.cm-s-icecoder span.cm-atom{color:#e1c76e}.cm-s-icecoder span.cm-number{color:#6cb5d9}.cm-s-icecoder span.cm-def{color:#b9ca4a}.cm-s-icecoder span.cm-variable{color:#6cb5d9}.cm-s-icecoder span.cm-variable-2{color:#cc1e5c}.cm-s-icecoder span.cm-variable-3,.cm-s-icecoder span.cm-type{color:#f9602c}orange\n\n.cm-s-icecoder span.cm-property{color:#eee}.cm-s-icecoder span.cm-operator{color:#9179bb}.cm-s-icecoder span.cm-comment{color:#97a3aa}.cm-s-icecoder span.cm-string{color:#b9ca4a}.cm-s-icecoder span.cm-string-2{color:#6cb5d9}.cm-s-icecoder span.cm-meta{color:#555}.cm-s-icecoder span.cm-qualifier{color:#555}.cm-s-icecoder span.cm-builtin{color:#214e7b}.cm-s-icecoder span.cm-bracket{color:#cc7}.cm-s-icecoder span.cm-tag{color:#e8e8e8}.cm-s-icecoder span.cm-attribute{color:#099}.cm-s-icecoder span.cm-header{color:#6a0d6a}.cm-s-icecoder span.cm-quote{color:#186718}.cm-s-icecoder span.cm-hr{color:#888}.cm-s-icecoder span.cm-link{color:#e1c76e}.cm-s-icecoder span.cm-error{color:#d00}.cm-s-icecoder .CodeMirror-cursor{border-left:1px solid white}.cm-s-icecoder div.CodeMirror-selected{color:#fff;background:#037}.cm-s-icecoder .CodeMirror-gutters{background:#1d1d1b;min-width:41px;border-right:0}.cm-s-icecoder .CodeMirror-linenumber{color:#555;cursor:default}.cm-s-icecoder .CodeMirror-matchingbracket{color:#fff !important;background:#555 !important}.cm-s-icecoder .CodeMirror-activeline-background{background:#000}.cm-s-monokai.CodeMirror{background:#272822;color:#f8f8f2}.cm-s-monokai div.CodeMirror-selected{background:#49483E}.cm-s-monokai .CodeMirror-line::selection,.cm-s-monokai .CodeMirror-line>span::selection,.cm-s-monokai .CodeMirror-line>span>span::selection{background:rgba(73, 72, 62, .99)}.cm-s-monokai .CodeMirror-line::-moz-selection,.cm-s-monokai .CodeMirror-line>span::-moz-selection,.cm-s-monokai .CodeMirror-line>span>span::-moz-selection{background:rgba(73, 72, 62, .99)}.cm-s-monokai .CodeMirror-gutters{background:#272822;border-right:0px}.cm-s-monokai .CodeMirror-guttermarker{color:white}.cm-s-monokai .CodeMirror-guttermarker-subtle{color:#d0d0d0}.cm-s-monokai .CodeMirror-linenumber{color:#d0d0d0}.cm-s-monokai .CodeMirror-cursor{border-left:1px solid #f8f8f0}.cm-s-monokai span.cm-comment{color:#75715e}.cm-s-monokai span.cm-atom{color:#ae81ff}.cm-s-monokai span.cm-number{color:#ae81ff}.cm-s-monokai span.cm-comment.cm-attribute{color:#97b757}.cm-s-monokai span.cm-comment.cm-def{color:#bc9262}.cm-s-monokai span.cm-comment.cm-tag{color:#bc6283}.cm-s-monokai span.cm-comment.cm-type{color:#5998a6}.cm-s-monokai span.cm-property,.cm-s-monokai span.cm-attribute{color:#a6e22e}.cm-s-monokai span.cm-keyword{color:#f92672}.cm-s-monokai span.cm-builtin{color:#66d9ef}.cm-s-monokai span.cm-string{color:#e6db74}.cm-s-monokai span.cm-variable{color:#f8f8f2}.cm-s-monokai span.cm-variable-2{color:#9effff}.cm-s-monokai span.cm-variable-3,.cm-s-monokai span.cm-type{color:#66d9ef}.cm-s-monokai span.cm-def{color:#fd971f}.cm-s-monokai span.cm-bracket{color:#f8f8f2}.cm-s-monokai span.cm-tag{color:#f92672}.cm-s-monokai span.cm-header{color:#ae81ff}.cm-s-monokai span.cm-link{color:#ae81ff}.cm-s-monokai span.cm-error{background:#f92672;color:#f8f8f0}.cm-s-monokai .CodeMirror-activeline-background{background:#373831}.cm-s-monokai .CodeMirror-matchingbracket{text-decoration:underline;color:white !important}.cm-s-shadowfox.CodeMirror{background:#2a2a2e;color:#b1b1b3}.cm-s-shadowfox div.CodeMirror-selected{background:#353B48}.cm-s-shadowfox .CodeMirror-line::selection,.cm-s-shadowfox .CodeMirror-line>span::selection,.cm-s-shadowfox .CodeMirror-line>span>span::selection{background:#353B48}.cm-s-shadowfox .CodeMirror-line::-moz-selection,.cm-s-shadowfox .CodeMirror-line>span::-moz-selection,.cm-s-shadowfox .CodeMirror-line>span>span::-moz-selection{background:#353B48}.cm-s-shadowfox .CodeMirror-gutters{background:#0c0c0d ;border-right:1px solid #0c0c0d}.cm-s-shadowfox .CodeMirror-guttermarker{color:#555}.cm-s-shadowfox .CodeMirror-linenumber{color:#939393}.cm-s-shadowfox .CodeMirror-cursor{border-left:1px solid #fff}.cm-s-shadowfox span.cm-comment{color:#939393}.cm-s-shadowfox span.cm-atom{color:#FF7DE9}.cm-s-shadowfox span.cm-quote{color:#FF7DE9}.cm-s-shadowfox span.cm-builtin{color:#FF7DE9}.cm-s-shadowfox span.cm-attribute{color:#FF7DE9}.cm-s-shadowfox span.cm-keyword{color:#FF7DE9}.cm-s-shadowfox span.cm-error{color:#FF7DE9}.cm-s-shadowfox span.cm-number{color:#6B89FF}.cm-s-shadowfox span.cm-string{color:#6B89FF}.cm-s-shadowfox span.cm-string-2{color:#6B89FF}.cm-s-shadowfox span.cm-meta{color:#939393}.cm-s-shadowfox span.cm-hr{color:#939393}.cm-s-shadowfox span.cm-header{color:#75BFFF}.cm-s-shadowfox span.cm-qualifier{color:#75BFFF}.cm-s-shadowfox span.cm-variable-2{color:#75BFFF}.cm-s-shadowfox span.cm-property{color:#86DE74}.cm-s-shadowfox span.cm-def{color:#75BFFF}.cm-s-shadowfox span.cm-bracket{color:#75BFFF}.cm-s-shadowfox span.cm-tag{color:#75BFFF}.cm-s-shadowfox span.cm-link:visited{color:#75BFFF}.cm-s-shadowfox span.cm-variable{color:#B98EFF}.cm-s-shadowfox span.cm-variable-3{color:#d7d7db}.cm-s-shadowfox span.cm-link{color:#737373}.cm-s-shadowfox span.cm-operator{color:#b1b1b3}.cm-s-shadowfox span.cm-special{color:#d7d7db}.cm-s-shadowfox .CodeMirror-activeline-background{background:rgba(185, 215, 253, .15) }.cm-s-shadowfox .CodeMirror-matchingbracket{outline:solid 1px rgba(255, 255, 255, .25);color:white !important}.layout-template-container{height:100vh}.scrollable{flex:1 1 auto;margin:0 0 0.5em 0;overflow-y:auto}.codemirror-container{position:relative;width:100%;height:100%;border:none;line-height:1.4;overflow:hidden;font-family:monospace}.codemirror-container .CodeMirror{height:100%;background:transparent;font:400 14px/1.7 var(--font-mono)}";
	append(document.head, style);
}

function create_fragment$f(ctx) {
	let div;
	let codemirror;
	let updating_value;
	let current;

	function codemirror_value_binding(value) {
		/*codemirror_value_binding*/ ctx[20].call(null, value);
	}

	let codemirror_props = { tab: true, lineNumbers: true };

	if (/*content*/ ctx[0] !== void 0) {
		codemirror_props.value = /*content*/ ctx[0];
	}

	codemirror = new CodeMirror_1({ props: codemirror_props });
	/*codemirror_binding*/ ctx[19](codemirror);
	binding_callbacks.push(() => bind(codemirror, "value", codemirror_value_binding));
	codemirror.$on("change", /*change_handler*/ ctx[21]);
	codemirror.$on("focus", /*focus_handler*/ ctx[22]);
	codemirror.$on("blur", /*blur_handler*/ ctx[23]);
	codemirror.$on("refresh", /*refresh_handler*/ ctx[24]);
	codemirror.$on("gutterClick", /*gutterClick_handler*/ ctx[25]);
	codemirror.$on("viewportChange", /*viewportChange_handler*/ ctx[26]);

	return {
		c() {
			div = element("div");
			create_component(codemirror.$$.fragment);
			attr(div, "class", "codemirror-container layout-template-container scrollable");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(codemirror, div, null);
			/*div_binding*/ ctx[27](div);
			current = true;
		},
		p(ctx, dirty) {
			const codemirror_changes = {};

			if (!updating_value && dirty[0] & /*content*/ 1) {
				updating_value = true;
				codemirror_changes.value = /*content*/ ctx[0];
				add_flush_callback(() => updating_value = false);
			}

			codemirror.$set(codemirror_changes);
		},
		i(local) {
			if (current) return;
			transition_in(codemirror.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(codemirror.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			/*codemirror_binding*/ ctx[19](null);
			destroy_component(codemirror);
			/*div_binding*/ ctx[27](null);
		}
	};
}

if (typeof window !== "undefined") {
	import('./codeMirrorPlugins-47b81358.js');
}

function instance$e($$self, $$props, $$invalidate) {
	let $grammarEditorValue;
	let $grammarCompiledParser;
	let $grammarCompilationErrors;
	component_subscribe($$self, grammarEditorValue, $$value => $$invalidate(29, $grammarEditorValue = $$value));
	component_subscribe($$self, grammarCompiledParser, $$value => $$invalidate(30, $grammarCompiledParser = $$value));
	component_subscribe($$self, grammarCompilationErrors, $$value => $$invalidate(31, $grammarCompilationErrors = $$value));
	const dispatch = createEventDispatcher();
	let { id } = $$props;
	let { name } = $$props;
	let { type } = $$props;
	let { lineNumbers } = $$props;
	let { hasFocus } = $$props;
	let { theme } = $$props;
	let { background } = $$props;
	let { content } = $$props;
	let { grammarSource } = $$props;
	let { component } = $$props;
	let { class: className } = $$props;
	let codeMirror, container, resizeObserver;

	let log = e => {
		
	}; /* console.log(...e); */

	// let evalModelCode = e => {
	//
	//   if(window.Worker){
	//     let modelWorkerAsync = new Promise( (res, rej) => {
	//
	//       modelWorker.postMessage({
	//         eval: e
	//       });
	//
	//       modelWorker.onmessage = m => {
	//         if(m.data.message !== undefined){
	//           // console.log('DEBUG:ModelEditor:evalModelCode:onmessage')
	//           // console.log(e);
	//           console.log(m.data.message);
	//         }
	//         else if(m.data !== undefined && m.data.length != 0){
	//           res(m.data);
	//         }
	//         clearTimeout(timeout);
	//       }
	//     })
	//     .then(outputs => {
	//
	//     })
	//     .catch(e => {
	//       // console.log('DEBUG:ModelEditor:parserWorkerAsync:catch')
	//       // console.log(e);
	//     });
	//   }
	// }
	//
	let onChange = e => {
		if (e) {
			try {
				let value = codeMirror.getValue();
				set_store_value(grammarEditorValue, $grammarEditorValue = value, $grammarEditorValue);
				let { errors, output } = compileGrammar(value);
				set_store_value(grammarCompiledParser, $grammarCompiledParser = output, $grammarCompiledParser);
				set_store_value(grammarCompilationErrors, $grammarCompilationErrors = errors, $grammarCompilationErrors);
				dispatch("change", { prop: "content", value });
			} catch(error) {
				console.error("Error in automatic grammar evaluation and compilation", error);
			}
		}
	};

	let onFocus = e => {
		$$invalidate(9, hasFocus = true);
		dispatch("change", { prop: "hasFocus", value: true });
	};

	let onBlur = e => {
		$$invalidate(9, hasFocus = false);
		dispatch("change", { prop: "hasFocus", value: false });
	};

	let onRefresh = e => {
		
	}; // console.log("onRefresh")
	// dispatch('change', {
	//   prop:'hasFocus',
	//   value: true

	// });
	let onGutterCick = e => {
		
	}; // console.log("onGutterCick")
	// dispatch('change', {
	//   prop:'hasFocus',
	//   value: true

	// });
	let onViewportChange = e => {
		
	}; // console.log("onViewportChange")
	// dispatch('change', {
	//   prop:'hasFocus',
	//   value: true

	// });
	onMount(async () => {
		try {
			resizeObserver = new ResizeObserver(e => codeMirror.setSize("100%", "100%"));
			resizeObserver.observe(container);
			codeMirror.set(content, "ebnf", "oceanic-next");

			// Using export variables for preventing a warning from Svelte comiler
			log(id, name, type, className, lineNumbers, hasFocus, theme, background, content, grammarSource, component);
		} catch(error) {
			console.error(error);
		}
	});

	onDestroy(async () => {
		$$invalidate(1, codeMirror = null);

		// console.log('DEBUG:GrammarCodeEditor:onDestroy')
		// console.log(data);
		resizeObserver.disconnect();

		resizeObserver = null;
	});

	function codemirror_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			codeMirror = $$value;
			$$invalidate(1, codeMirror);
		});
	}

	function codemirror_value_binding(value) {
		content = value;
		$$invalidate(0, content);
	}

	const change_handler = e => onChange(e);
	const focus_handler = e => onFocus();
	const blur_handler = e => onBlur();
	const refresh_handler = e => onRefresh();
	const gutterClick_handler = e => onGutterCick();
	const viewportChange_handler = e => onViewportChange();

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			container = $$value;
			$$invalidate(2, container);
		});
	}

	$$self.$$set = $$props => {
		if ("id" in $$props) $$invalidate(10, id = $$props.id);
		if ("name" in $$props) $$invalidate(11, name = $$props.name);
		if ("type" in $$props) $$invalidate(12, type = $$props.type);
		if ("lineNumbers" in $$props) $$invalidate(13, lineNumbers = $$props.lineNumbers);
		if ("hasFocus" in $$props) $$invalidate(9, hasFocus = $$props.hasFocus);
		if ("theme" in $$props) $$invalidate(14, theme = $$props.theme);
		if ("background" in $$props) $$invalidate(15, background = $$props.background);
		if ("content" in $$props) $$invalidate(0, content = $$props.content);
		if ("grammarSource" in $$props) $$invalidate(16, grammarSource = $$props.grammarSource);
		if ("component" in $$props) $$invalidate(17, component = $$props.component);
		if ("class" in $$props) $$invalidate(18, className = $$props.class);
	};

	return [
		content,
		codeMirror,
		container,
		onChange,
		onFocus,
		onBlur,
		onRefresh,
		onGutterCick,
		onViewportChange,
		hasFocus,
		id,
		name,
		type,
		lineNumbers,
		theme,
		background,
		grammarSource,
		component,
		className,
		codemirror_binding,
		codemirror_value_binding,
		change_handler,
		focus_handler,
		blur_handler,
		refresh_handler,
		gutterClick_handler,
		viewportChange_handler,
		div_binding
	];
}

class GrammarEditor extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1a4e6qo-style")) add_css$6();

		init(
			this,
			options,
			instance$e,
			create_fragment$f,
			safe_not_equal,
			{
				id: 10,
				name: 11,
				type: 12,
				lineNumbers: 13,
				hasFocus: 9,
				theme: 14,
				background: 15,
				content: 0,
				grammarSource: 16,
				component: 17,
				class: 18
			},
			[-1, -1]
		);
	}
}

const functionDefinitions = [
    {
        "text": ">",
        "description": "Route a single signal to all outputs, by putting an > at the point in the signal chain where you want to output.",
        "category": "Audio Outputs",
        "links": "the--operator"
    },
    {
        "text": "dac",
        "description": "To change channel numbers programmatically, use the dac function.",
        "category": "Audio Outputs",
        "links": "dac"
    },
    {
        "text": "adc",
        "arguments": "Amplitude",
        "category": "Audio Inputs",
        "links": "audio-input"
    },
    {
        "text": "sin",
        "description": "Sine wave",
        "arguments": "Frequency; Phase",
        "category": "Oscillators",
        "links": "sin"
    },
    {
        "text": "saw",
        "description": "Saw wave",
        "arguments": "Frequency; Phase",
        "category": "Oscillators",
        "links": "saw"
    },
    {
        "text": "tri",
        "description": "Triangle wave",
        "arguments": "Frequency; Phase",
        "category": "Oscillators",
        "links": "tri"
    },
    {
        "text": "pha",
        "description": "Phasor (a ramp that rises from 0 to 1)",
        "arguments": "Frequency; Phase",
        "category": "Oscillators",
        "links": "pha"
    },
    {
        "text": "ph2",
        "description": "Phasor with start and end phase",
        "arguments": "Frequency; Phase",
        "category": "Oscillators",
        "links": "ph2"
    },
    {
        "text": "sqr",
        "description": "Square wave",
        "arguments": "Frequency; Phase",
        "category": "Oscillators",
        "links": "sqr"
    },
    {
        "text": "pul",
        "description": "Pulse (the second argument is pulsewidth)",
        "arguments": "Frequency; Phase",
        "category": "Oscillators",
        "links": "pul"
    },
    {
        "text": "imp",
        "description": "Impulse (single impulse, useful for triggering)",
        "arguments": "Frequency; Phase",
        "category": "Oscillators",
        "links": "imp"
    },
    {
        "text": "sawn",
        "description": "Anti-aliased saw wave",
        "arguments": "Frequency; Phase",
        "category": "Oscillators",
        "links": "sawn"
    },
    {
        "text": "noiz",
        "description": "White noise",
        "arguments": "Amplitude",
        "category": "Noise",
        "links": "noiz"
    },
    {
        "text": "sah",
        "description": "Sample and hold",
        "arguments": "Input signal; Sampling period length (ms)",
        "category": "Control",
        "links": "sah"
    },
    {
        "text": "env",
        "description": "The envelope is an adsr envelope, so the arguments are \"input signal\".",
        "arguments": "Attack (in ms); Decay (in ms); Sustain level (0-1); Release (in ms).",
        "category": "Envelopes",
        "links": "envelopes"
    },
    {
        "text": "line",
        "description": "Triggered line generator",
        "arguments": "Trigger; Time (ms) to rise from 0 to 1",
        "category": "Envelopes",
        "links": "line"
    },
    {
        "text": "\\",
        "description": "Samples are preloaded when the audio engine starts up. Play a sample once with a trigger, using \\ followed by the sample name.",
        "arguments": "Trigger (positive zero crossing); Speed (1=normal, 2= double, etc); Offset",
        "category": "Sample Playback",
        "links": "the-operator"
    },
    {
        "text": "|",
        "category": "Sample Slicing",
        "links": "the--operator-1"
    },
    {
        "text": "lpf",
        "description": "One pole low pass",
        "arguments": "Input signal; Cutoff (0-1)",
        "category": "Filters",
        "links": "lpf"
    },
    {
        "text": "hpf",
        "description": "One pole high pass",
        "arguments": "Input signal; Cutoff (0-1)",
        "category": "Filters",
        "links": "hpf"
    },
    {
        "text": "lpz",
        "description": "Low pass with resonance",
        "arguments": "Input signal; Cutoff (20-20000); Resonance (1 upwards)",
        "category": "Filters",
        "links": "lpz"
    },
    {
        "text": "hpz",
        "description": "High pass with resonance",
        "arguments": "Input signal; Cutoff (20-20000); Resonance (1 upwards)",
        "category": "Filters",
        "links": "hpz"
    },
    {
        "text": "svf",
        "description": "State variable filter",
        "arguments": "Input signal; Cutoff frequency (Hz); Resonance; Low pass filter amount (0-1); Band pass filter amount(0-1); High pass filter amount (0-1); Notch filter amount (0-1",
        "category": "Filters",
        "links": "svf"
    },
    {
        "text": "dist",
        "description": "Distortion",
        "arguments": "Input; Shape: from 1 (soft clipping) to infinity (hard clipping) atan distortion",
        "category": "Effects",
        "links": "dist"
    },
    {
        "text": "asymclip",
        "description": "Asymmetric wave shaping",
        "arguments": "Input signal; The curve shape for values below zero (e.g. 2 = squared, 3 = cubed, 0.5 = square root); The curve shape for values above zero",
        "category": "Effects",
        "links": "asymclip"
    },
    {
        "text": "flange",
        "description": "Flanger",
        "arguments": "Input signal; Delay = delay time (ms); Feedback = 0 - 1; Speed = lfo speed in Hz; Depth = 0 - 1",
        "category": "Effects",
        "links": "flange"
    },
    {
        "text": "chor",
        "description": "Chorus",
        "arguments": "Input signal; Delay = delay time (ms); Feedback = 0 - 1; Speed = lfo speed in Hz; Depth = 0 - 2",
        "category": "Effects",
        "links": "chor"
    },
    {
        "text": "dl",
        "description": "Delay line",
        "arguments": "Input signal; Delay time in samples; Amount of feedback (between 0 and 1)",
        "category": "Effects",
        "links": "dl"
    },
    {
        "text": "freeverb",
        "description": "Reverb",
        "arguments": "Input signal; Room size (0-1); Absorption (0-1)",
        "category": "Effects",
        "links": "freeverb"
    },
    {
        "text": "gt",
        "description": "Greater than",
        "category": "Operators",
        "links": "operators"
    },
    {
        "text": "lt",
        "description": "Less than",
        "category": "Operators",
        "links": "operators"
    },
    {
        "text": "mod",
        "description": "Modulo",
        "category": "Operators",
        "links": "operators"
    },
    {
        "text": "add",
        "description": "Add",
        "category": "Operators",
        "links": "operators"
    },
    {
        "text": "mul",
        "description": "Multiply",
        "category": "Operators",
        "links": "operators"
    },
    {
        "text": "sub",
        "description": "Subtract",
        "category": "Operators",
        "links": "operators"
    },
    {
        "text": "div",
        "description": "Divide",
        "category": "Operators",
        "links": "operators"
    },
    {
        "text": "pow",
        "description": "Power of",
        "category": "Operators",
        "links": "operators"
    },
    {
        "text": "abs",
        "description": "Absolute value",
        "category": "Operators",
        "links": "operators"
    },
    {
        "text": "blin",
        "description": "bipolar linear map from range -1,1 to range between arg 2 and arg 3",
        "arguments": "Input signal; Lower bound of destination range; Upper bound of destination range",
        "category": "Mapping Values",
        "links": "mapping-values"
    },
    {
        "text": "ulin",
        "description": "unipolar linear map from range 0,1 to range between arg 2 and arg 3",
        "arguments": "Input signal; Lower bound of destination range; Upper bound of destination range",
        "category": "Mapping Values",
        "links": "mapping-values"
    },
    {
        "text": "bexp",
        "description": "bipolar exponential map from range -1,1 to range between arg 2 and arg 3",
        "arguments": "Input signal; Lower bound of destination range; Upper bound of destination range",
        "category": "Mapping Values",
        "links": "mapping-values"
    },
    {
        "text": "uexp",
        "description": "unipolar exponential map from range 0,1 to range between arg 2 and arg 3",
        "arguments": "Input signal; Lower bound of destination range; Upper bound of destination range",
        "category": "Mapping Values",
        "links": "mapping-values"
    },
    {
        "text": "linlin",
        "description": "arbitrary linear map from range between arg 2 and 3, to range between arg 4 and arg 5",
        "arguments": "Input signal; Lower bound of source range; Upper bound of source range; Lower bound of destination range; Upper bound of destination range",
        "category": "Mapping Values",
        "links": "mapping-values"
    },
    {
        "text": "linexp",
        "description": "arbitrary exponential map from range between arg 2 and 3, to range between arg 4 and arg 5",
        "arguments": "Input signal; Lower bound of source range; Upper bound of source range; Lower bound of destination range; Upper bound of destination range",
        "category": "Mapping Values",
        "links": "mapping-values"
    },
    {
        "text": "fft",
        "description": "Fast fourier transform",
        "arguments": "A signal; The number of bins; Hop size, as a percentage of the FFT period",
        "category": "Machine Listening",
        "outputs": "A trigger signal, which triggers every time the FFT updates; An array of frequency strengths (same size as the number of bins); An array of phases (same size as the number of bins)",
        "links": "fft"
    },
    {
        "text": "onzx",
        "description": "Positive zero-crossing detection",
        "arguments": "A signal",
        "category": "Triggers",
        "links": "onzx"
    },
    {
        "text": "onchange",
        "description": "Create a trigger when a change occurs in the input signal",
        "arguments": "A signal; Tolerance (a trigger will be generated if the change is more than +/- this value)",
        "category": "Triggers",
        "links": "onchange"
    },
    {
        "text": "count",
        "description": "Counts up when receiving a trigger",
        "arguments": "Input trigger; Reset trigger",
        "category": "Triggers",
        "links": "count"
    },
    {
        "text": "idx",
        "description": "Index into a list",
        "arguments": "Trigger input - output a value when triggered; The index of the value to be output when a trigger is received (normalised to between 0 and 1); A list of values",
        "category": "Triggers",
        "links": "idx"
    },
    {
        "text": "quantise",
        "description": "When you evaluate your code, choose whether to bring it in on a new bar or immediately",
        "arguments": "On (1) or off (0)",
        "category": "Sequencing",
        "links": "quantise"
    },
    {
        "text": "clk",
        "description": "Set the clock",
        "arguments": "bpm; number of beats in a bar",
        "category": "Sequencing",
        "links": "clk"
    },
    {
        "text": "clp",
        "description": "Clock phasor, rises from 0 to 1 each period",
        "arguments": "Rise time, in multiples of the bar length; Phase offset (0 - 1)",
        "category": "Sequencing",
        "links": "clp"
    },
    {
        "text": "clt",
        "description": "Clock trigger. This generates a trigger every period.",
        "arguments": "Time between triggers, in multiples of bar length; Phase offset (0 - 1)",
        "category": "Sequencing",
        "links": "clt"
    },
    {
        "text": "rsq",
        "description": "Ratio sequencer",
        "arguments": "A phasor; An array of time ratios. The phasor period is divided into these ratios, and a trigger is emitted at the beginning or each division; (optional) An array of values. At the start of each time division, a value is read from the list. Successive values are read, in a loop.",
        "category": "Sequencing",
        "links": "rsq"
    },
    {
        "text": "const",
        "description": "Assign a value directy to a variable",
        "category": "Data",
        "links": "const"
    },
    {
        "text": "poll",
        "description": "Send a value to the javascript console, once per second",
        "category": "Data",
        "links": "poll"
    }
];

var blockID = 0;
class blockData {
  constructor(startLine) {
    this.startLine = startLine;
    this.blockID = blockID++;
  }
}

class blockTracker {
  constructor(editorToTrack) {
    this.editor = editorToTrack;
    this.blocks = new Array();
    this.blocks.push(new blockData(-1));
  }

  onEditChange(change) {
    //recording where separators are
    let separatorExistsOnLine = (line) => {
      return this.blocks.filter(b => b.startLine == line).length == 1;
    };
    let insertSeparator = (line) => {
      let insertionIndex = this.blocks.findIndex(x => x.startLine > line);
      //console.log("Inserting separator at " + line);
      const newBlock = new blockData(line);
      if (insertionIndex == -1) {
        this.blocks.push(newBlock);
      } else {
        this.blocks.splice(insertionIndex, 0, newBlock);
      }
    };
    let removeSeparator = (lineIndex) => {
      this.blocks = this.blocks.filter(b => b.startLine != lineIndex);
    };

    //testing text changes
    let testIsSeparator = (lineText) => {
      return /^___+$/.test(lineText);
    };
    let testLineChange = (lineIndex, lineText) => {
      let separatorAlreadyHere = separatorExistsOnLine(lineIndex);
      //is the line a separator?
      if (testIsSeparator(lineText)) { // Test RegEx at least 3 underscores and no other characters on the line
        //console.log("Block separator found");
        if (separatorAlreadyHere) ; else {
          //console.log("adding new separator");
          insertSeparator(lineIndex);
          // console.table(this.blocks);
        }
      } else {
        if (separatorAlreadyHere) {
          //remove the separator as it's no longer valid
          removeSeparator(lineIndex);
        }
      }
    };
    let testRemoveLine = (lineIndex, lineText, testTarget) => {
      //test for abscence or presence, depending on testTarget
      if (testIsSeparator(lineText) == testTarget) { // Test RegEx at least 3 underscores
        //console.log("testRemoveLine +ve at " + lineIndex);
        if (separatorExistsOnLine(lineIndex)) {
          //console.log("removing separator");
          removeSeparator(lineIndex);
        }
      }
    };
    let insertNewLines = (atLine, numberofLines) => {
      this.blocks = this.blocks.map(
        (b) => {
          if (b.startLine > atLine) {
            b.startLine += numberofLines;
          }
          return b;
        }
      );
    };
    let removeLines = (atLine, numberofLines) => {
      this.blocks = this.blocks.map(
        (b) => {
          if (b.startLine > atLine) {
            b.startLine -= numberofLines;
          }
          return b;
        }
      );
    };
    //console.log(change);
    switch (change.origin) {
      //same handler for deleting and cutting
      case "+delete":
      case "cut":
        if (change.from.line == change.to.line) {
          let lineToTest = this.editor.getLine(change.from.line);
          //console.log(lineToTest);
          testLineChange(change.from.line, lineToTest);
        } else {
          //TODO this section needs more work to cases where change.from/to.ch>0 and for joining of separators
          //console.log("Source line: " + this.editor.getLine(change.from.line));
          //console.log("Removed: " + change.removed);
          let lastLineIndex = change.from.line + change.text.length - 1;
          let lastLine = this.editor.getLine(lastLineIndex);
          //console.log("Lastline", lastLine);
          //test the first line
          let lineToTest = this.editor.getLine(change.from.line);
          for(let i_line=0; i_line < change.removed.length; i_line++) {
            //console.log("testing multi line " + i_line + ": " + change.removed[i_line]);
            testRemoveLine(change.from.line + i_line, change.removed[i_line], true);
          }
          removeLines(change.from.line, change.removed.length-1);


          // //check the first line (in case of partial removal)
          // let startIdx = 0;
          // let endIdx = change.removed.length;
          // if (change.from.ch > 0) {
          //   //console.log("testing first line");
          //   testRemoveLine(change.from.line, this.editor.getLine(change.from.line), false);
          //   startIdx++;
          // }
          // if (change.to.ch > 0) {
          //   //console.log("testing last line");
          //   let lineToCheck = change.from.line + change.removed.length;
          //   testRemoveLine(lineToCheck, this.editor.getLine(change.from.line), false);
          //   endIdx--;
          // }
          // if (change.removed.length>1) {
          //   for(let i_line=startIdx; i_line < endIdx; i_line++) {
          //     //console.log("testing multi line " + i_line + ": " + change.removed[i_line]);
          //     testRemoveLine(change.from.line + i_line, change.removed[i_line], true);
          //     console.table(this.blocks);
          //   }
          //   removeLines(change.from.line, change.removed.length-1);
          // }
        }
        // console.table(this.blocks);
        break;
      case "+input":
      case "paste":
        // //console.log(change.)
        //console.log("Source line: " + this.editor.getLine(change.from.line));
        //console.log("Added: " + change.text);
        //no new lines?
        if (change.text.length == 1) {
          let lineToTest = this.editor.getLine(change.from.line);
          //console.log(lineToTest);
          testLineChange(change.from.line, lineToTest);
        } else {
          //multiline insert
          //first deal with the possible broken separator
          let lastLineIndex = change.from.line + change.text.length - 1;
          let lastLine = this.editor.getLine(lastLineIndex);
          //console.log("lastline", lastLine);
          //move any separators below
          insertNewLines(change.from.line, change.text.length - 1);

          //did a separator get broken or moved?
          if (separatorExistsOnLine(change.from.line)) {
            if (change.from.ch < 3) { // 3 character min for a separator
              //console.log("ch < 3")
              //look at the last line
              if (testIsSeparator(lastLine)) {
                //console.log("last line is separator")
                //move the separator
                this.blocks = this.blocks.map(b => {
                  //console.log(b.startLine, lastLineIndex);
                  //console.log(change.from);
                  if (b.startLine == change.from.line) {
                    b.startLine = lastLineIndex;
                    //console.log("bs", b.startLine);
                  }
                  return b;
                });
              } else {
                removeSeparator(change.from.line);
              }
            } else {
              //console.log('ch>3');
              //check if the paste has changed any separator on the first line
              testLineChange(change.from.line, this.editor.getLine(change.from.line));
              //possible new separator on the last line
              if (testIsSeparator(lastLine)) {
                //console.log("last line is separator")
                insertSeparator(lastLineIndex);
              }
            }
          } else {
            //the block didn't start with a separator
            // let lineToTest = this.editor.getLine(change.from.line);
            // //console.log('linetotest', lineToTest);
            // testLineChange(change.from.line, lineToTest);
            //look through the inserted text and test for new separators
            for (let line = 0; line < change.text.length; line++) {
              //console.log(line);
              testLineChange(change.from.line + line, change.text[line]);
            }
            //TODO Monday: pasting in at the end of a separator
          }

          // if (change.text.length > 2) {
          //   //move any separators pushed by this insert
          //   insertNewLines(change.from.line, change.text.length-1);
          //   //look through the inserted text and test for new separators
          //   for (let line=1; line < change.text.length-2; line++) {
          //     //console.log(line);
          //     testInsertLine(change.from.line + line, change.text[line]);
          //   }
          // }
        }
        // console.table(this.blocks);
        break;
      case "setValue":
        for (let line in change.text) {
          testLineChange(parseInt(line), change.text[line]);
        }
        // console.table(this.blocks);
        break;
    }  }

  getBlockFromLine(line) {
    let blockIndex=0;
    for(let i=0; i < this.blocks.length-1; i++) {
      if (i==blocks.length-1) {
        blockIndex =i;
      }else {
        if (line > this.blocks[i].startLine && i < this.blocks[i+1].startLine) {
          blockIndex = i;
        }
      }
    }
    let blockID = this.blocks[blockIndex].blockID;
    return {id:blockID, idx:blockIndex};
  }

}

/* src/components/editors/LiveCodeEditor.svelte generated by Svelte v3.31.0 */

function add_css$7() {
	var style = element("style");
	style.id = "svelte-1uozcog-style";
	style.textContent = ".CodeMirror{font-family:monospace;height:300px;color:black;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre.CodeMirror-line,.CodeMirror pre.CodeMirror-line-like{padding:0 4px}.CodeMirror-scrollbar-filler,.CodeMirror-gutter-filler{background-color:white}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:black}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid black;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0 !important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-fat-cursor-mark{background-color:rgba(20, 255, 20, 0.5);-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{0%{}50%{background-color:transparent}100%{}}@-webkit-keyframes blink{0%{}50%{background-color:transparent}100%{}}@keyframes blink{0%{}50%{background-color:transparent}100%{}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:0;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:blue}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:bold}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-variable-3,.cm-s-default .cm-type{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:#f00}.cm-invalidchar{color:#f00}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0b0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#a22}.CodeMirror-matchingtag{background:rgba(255, 150, 0, .3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:white}.CodeMirror-scroll{overflow:scroll !important;margin-bottom:-50px;margin-right:-50px;padding-bottom:50px;height:100%;outline:none;position:relative}.CodeMirror-sizer{position:relative;border-right:50px solid transparent}.CodeMirror-vscrollbar,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-gutter-filler{position:absolute;z-index:6;display:none;outline:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-50px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:none !important;border:none !important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent }.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent }.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre.CodeMirror-line,.CodeMirror pre.CodeMirror-line-like{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:transparent;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre.CodeMirror-line,.CodeMirror-wrap pre.CodeMirror-line-like{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;padding:0.1px}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:none}.CodeMirror-scroll,.CodeMirror-sizer,.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255, 255, 0, .4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:none}.cm-s-idea span.cm-meta{color:#808000}.cm-s-idea span.cm-number{color:#0000FF}.cm-s-idea span.cm-keyword{line-height:1em;font-weight:bold;color:#000080}.cm-s-idea span.cm-atom{font-weight:bold;color:#000080}.cm-s-idea span.cm-def{color:#000000}.cm-s-idea span.cm-variable{color:black}.cm-s-idea span.cm-variable-2{color:black}.cm-s-idea span.cm-variable-3,.cm-s-idea span.cm-type{color:black}.cm-s-idea span.cm-property{color:black}.cm-s-idea span.cm-operator{color:black}.cm-s-idea span.cm-comment{color:#808080}.cm-s-idea span.cm-string{color:#008000}.cm-s-idea span.cm-string-2{color:#008000}.cm-s-idea span.cm-qualifier{color:#555}.cm-s-idea span.cm-error{color:#FF0000}.cm-s-idea span.cm-attribute{color:#0000FF}.cm-s-idea span.cm-tag{color:#000080}.cm-s-idea span.cm-link{color:#0000FF}.cm-s-idea .CodeMirror-activeline-background{background:#FFFAE3}.cm-s-idea span.cm-builtin{color:#30a}.cm-s-idea span.cm-bracket{color:#cc7}.cm-s-idea{font-family:Consolas, Menlo, Monaco, Lucida Console, Liberation Mono, DejaVu Sans Mono, Bitstream Vera Sans Mono, Courier New, monospace, serif}.cm-s-idea .CodeMirror-matchingbracket{outline:1px solid grey;color:black !important}.CodeMirror-hints.idea{font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;color:#616569;background-color:#ebf3fd !important}.CodeMirror-hints.idea .CodeMirror-hint-active{background-color:#a2b8c9 !important;color:#5c6065 !important}.cm-s-monokai.CodeMirror{background:#272822;color:#f8f8f2}.cm-s-monokai div.CodeMirror-selected{background:#49483E}.cm-s-monokai .CodeMirror-line::selection,.cm-s-monokai .CodeMirror-line>span::selection,.cm-s-monokai .CodeMirror-line>span>span::selection{background:rgba(73, 72, 62, .99)}.cm-s-monokai .CodeMirror-line::-moz-selection,.cm-s-monokai .CodeMirror-line>span::-moz-selection,.cm-s-monokai .CodeMirror-line>span>span::-moz-selection{background:rgba(73, 72, 62, .99)}.cm-s-monokai .CodeMirror-gutters{background:#272822;border-right:0px}.cm-s-monokai .CodeMirror-guttermarker{color:white}.cm-s-monokai .CodeMirror-guttermarker-subtle{color:#d0d0d0}.cm-s-monokai .CodeMirror-linenumber{color:#d0d0d0}.cm-s-monokai .CodeMirror-cursor{border-left:1px solid #f8f8f0}.cm-s-monokai span.cm-comment{color:#75715e}.cm-s-monokai span.cm-atom{color:#ae81ff}.cm-s-monokai span.cm-number{color:#ae81ff}.cm-s-monokai span.cm-comment.cm-attribute{color:#97b757}.cm-s-monokai span.cm-comment.cm-def{color:#bc9262}.cm-s-monokai span.cm-comment.cm-tag{color:#bc6283}.cm-s-monokai span.cm-comment.cm-type{color:#5998a6}.cm-s-monokai span.cm-property,.cm-s-monokai span.cm-attribute{color:#a6e22e}.cm-s-monokai span.cm-keyword{color:#f92672}.cm-s-monokai span.cm-builtin{color:#66d9ef}.cm-s-monokai span.cm-string{color:#e6db74}.cm-s-monokai span.cm-variable{color:#f8f8f2}.cm-s-monokai span.cm-variable-2{color:#9effff}.cm-s-monokai span.cm-variable-3,.cm-s-monokai span.cm-type{color:#66d9ef}.cm-s-monokai span.cm-def{color:#fd971f}.cm-s-monokai span.cm-bracket{color:#f8f8f2}.cm-s-monokai span.cm-tag{color:#f92672}.cm-s-monokai span.cm-header{color:#ae81ff}.cm-s-monokai span.cm-link{color:#ae81ff}.cm-s-monokai span.cm-error{background:#f92672;color:#f8f8f0}.cm-s-monokai .CodeMirror-activeline-background{background:#373831}.cm-s-monokai .CodeMirror-matchingbracket{text-decoration:underline;color:white !important}.cm-s-icecoder{color:#666;background:#1d1d1b}.cm-s-icecoder span.cm-keyword{color:#eee;font-weight:bold}.cm-s-icecoder span.cm-atom{color:#e1c76e}.cm-s-icecoder span.cm-number{color:#6cb5d9}.cm-s-icecoder span.cm-def{color:#b9ca4a}.cm-s-icecoder span.cm-variable{color:#6cb5d9}.cm-s-icecoder span.cm-variable-2{color:#cc1e5c}.cm-s-icecoder span.cm-variable-3,.cm-s-icecoder span.cm-type{color:#f9602c}.cm-s-icecoder span.cm-property{color:#eee}.cm-s-icecoder span.cm-operator{color:#9179bb}.cm-s-icecoder span.cm-comment{color:#97a3aa}.cm-s-icecoder span.cm-string{color:#b9ca4a}.cm-s-icecoder span.cm-string-2{color:#6cb5d9}.cm-s-icecoder span.cm-meta{color:#555}.cm-s-icecoder span.cm-qualifier{color:#555}.cm-s-icecoder span.cm-builtin{color:#214e7b}.cm-s-icecoder span.cm-bracket{color:#cc7}.cm-s-icecoder span.cm-tag{color:#e8e8e8}.cm-s-icecoder span.cm-attribute{color:#099}.cm-s-icecoder span.cm-header{color:#6a0d6a}.cm-s-icecoder span.cm-quote{color:#186718}.cm-s-icecoder span.cm-hr{color:#888}.cm-s-icecoder span.cm-link{color:#e1c76e}.cm-s-icecoder span.cm-error{color:#d00}.cm-s-icecoder .CodeMirror-cursor{border-left:1px solid white}.cm-s-icecoder div.CodeMirror-selected{color:#fff;background:#037}.cm-s-icecoder .CodeMirror-gutters{background:#1d1d1b;min-width:41px;border-right:0}.cm-s-icecoder .CodeMirror-linenumber{color:#555;cursor:default}.cm-s-icecoder .CodeMirror-matchingbracket{color:#fff !important;background:#555 !important}.cm-s-icecoder .CodeMirror-activeline-background{background:#000}.cm-s-shadowfox.CodeMirror{background:#2a2a2e;color:#b1b1b3}.cm-s-shadowfox div.CodeMirror-selected{background:#353B48}.cm-s-shadowfox .CodeMirror-line::selection,.cm-s-shadowfox .CodeMirror-line>span::selection,.cm-s-shadowfox .CodeMirror-line>span>span::selection{background:#353B48}.cm-s-shadowfox .CodeMirror-line::-moz-selection,.cm-s-shadowfox .CodeMirror-line>span::-moz-selection,.cm-s-shadowfox .CodeMirror-line>span>span::-moz-selection{background:#353B48}.cm-s-shadowfox .CodeMirror-gutters{background:#0c0c0d ;border-right:1px solid #0c0c0d}.cm-s-shadowfox .CodeMirror-guttermarker{color:#555}.cm-s-shadowfox .CodeMirror-linenumber{color:#939393}.cm-s-shadowfox .CodeMirror-cursor{border-left:1px solid #fff}.cm-s-shadowfox span.cm-comment{color:#939393}.cm-s-shadowfox span.cm-atom{color:#FF7DE9}.cm-s-shadowfox span.cm-quote{color:#FF7DE9}.cm-s-shadowfox span.cm-builtin{color:#FF7DE9}.cm-s-shadowfox span.cm-attribute{color:#FF7DE9}.cm-s-shadowfox span.cm-keyword{color:#FF7DE9}.cm-s-shadowfox span.cm-error{color:#FF7DE9}.cm-s-shadowfox span.cm-number{color:#6B89FF}.cm-s-shadowfox span.cm-string{color:#6B89FF}.cm-s-shadowfox span.cm-string-2{color:#6B89FF}.cm-s-shadowfox span.cm-meta{color:#939393}.cm-s-shadowfox span.cm-hr{color:#939393}.cm-s-shadowfox span.cm-header{color:#75BFFF}.cm-s-shadowfox span.cm-qualifier{color:#75BFFF}.cm-s-shadowfox span.cm-variable-2{color:#75BFFF}.cm-s-shadowfox span.cm-property{color:#86DE74}.cm-s-shadowfox span.cm-def{color:#75BFFF}.cm-s-shadowfox span.cm-bracket{color:#75BFFF}.cm-s-shadowfox span.cm-tag{color:#75BFFF}.cm-s-shadowfox span.cm-link:visited{color:#75BFFF}.cm-s-shadowfox span.cm-variable{color:#B98EFF}.cm-s-shadowfox span.cm-variable-3{color:#d7d7db}.cm-s-shadowfox span.cm-link{color:#737373}.cm-s-shadowfox span.cm-operator{color:#b1b1b3}.cm-s-shadowfox span.cm-special{color:#d7d7db}.cm-s-shadowfox .CodeMirror-activeline-background{background:rgba(185, 215, 253, .15) }.cm-s-shadowfox .CodeMirror-matchingbracket{outline:solid 1px rgba(255, 255, 255, .25);color:white !important}.cm-s-oceanic-next.CodeMirror{background:#304148;color:#f8f8f2}.cm-s-oceanic-next div.CodeMirror-selected{background:rgba(101, 115, 126, 0.33)}.cm-s-oceanic-next .CodeMirror-line::selection,.cm-s-oceanic-next .CodeMirror-line>span::selection,.cm-s-oceanic-next .CodeMirror-line>span>span::selection{background:rgba(101, 115, 126, 0.33)}.cm-s-oceanic-next .CodeMirror-line::-moz-selection,.cm-s-oceanic-next .CodeMirror-line>span::-moz-selection,.cm-s-oceanic-next .CodeMirror-line>span>span::-moz-selection{background:rgba(101, 115, 126, 0.33)}.cm-s-oceanic-next .CodeMirror-gutters{background:#304148;border-right:10px}.cm-s-oceanic-next .CodeMirror-guttermarker{color:white}.cm-s-oceanic-next .CodeMirror-guttermarker-subtle{color:#d0d0d0}.cm-s-oceanic-next .CodeMirror-linenumber{color:#d0d0d0}.cm-s-oceanic-next .CodeMirror-cursor{border-left:1px solid #f8f8f0}.cm-s-oceanic-next span.cm-comment{color:#65737E}.cm-s-oceanic-next span.cm-atom{color:#C594C5}.cm-s-oceanic-next span.cm-number{color:#F99157}.cm-s-oceanic-next span.cm-property{color:#99C794}.cm-s-oceanic-next span.cm-attribute,.cm-s-oceanic-next span.cm-keyword{color:#C594C5}.cm-s-oceanic-next span.cm-builtin{color:#66d9ef}.cm-s-oceanic-next span.cm-string{color:#99C794}.cm-s-oceanic-next span.cm-variable,.cm-s-oceanic-next span.cm-variable-2,.cm-s-oceanic-next span.cm-variable-3{color:#f8f8f2}.cm-s-oceanic-next span.cm-def{color:#6699CC}.cm-s-oceanic-next span.cm-bracket{color:#5FB3B3}.cm-s-oceanic-next span.cm-tag{color:#C594C5}.cm-s-oceanic-next span.cm-header{color:#C594C5}.cm-s-oceanic-next span.cm-link{color:#C594C5}.cm-s-oceanic-next span.cm-error{background:#C594C5;color:#f8f8f0}.cm-s-oceanic-next .CodeMirror-activeline-background{background:rgba(101, 115, 126, 0.33)}.cm-s-oceanic-next .CodeMirror-matchingbracket{text-decoration:underline;color:white !important}.cm-s-railscasts.CodeMirror{background:#2b2b2b;color:#f4f1ed}.cm-s-railscasts div.CodeMirror-selected{background:#272935 !important}.cm-s-railscasts .CodeMirror-gutters{background:#2b2b2b;border-right:0px}.cm-s-railscasts .CodeMirror-linenumber{color:#5a647e}.cm-s-railscasts .CodeMirror-cursor{border-left:1px solid #d4cfc9 !important}.cm-s-railscasts span.cm-comment{color:#bc9458}.cm-s-railscasts span.cm-atom{color:#b6b3eb}.cm-s-railscasts span.cm-number{color:#b6b3eb}.cm-s-railscasts span.cm-property,.cm-s-railscasts span.cm-attribute{color:#a5c261}.cm-s-railscasts span.cm-keyword{color:#da4939}.cm-s-railscasts span.cm-string{color:#ffc66d}.cm-s-railscasts span.cm-variable{color:#a5c261}.cm-s-railscasts span.cm-variable-2{color:#6d9cbe}.cm-s-railscasts span.cm-def{color:#cc7833}.cm-s-railscasts span.cm-error{background:#da4939;color:#d4cfc9}.cm-s-railscasts span.cm-bracket{color:#f4f1ed}.cm-s-railscasts span.cm-tag{color:#da4939}.cm-s-railscasts span.cm-link{color:#b6b3eb}.cm-s-railscasts .CodeMirror-matchingbracket{text-decoration:underline;color:white !important}.cm-s-railscasts .CodeMirror-activeline-background{background:#303040}.cm-s-seti.CodeMirror{background-color:#151718 !important;color:#CFD2D1 !important;border:none}.cm-s-seti .CodeMirror-gutters{color:#404b53;background-color:#0E1112;border:none}.cm-s-seti .CodeMirror-cursor{border-left:solid thin #f8f8f0}.cm-s-seti .CodeMirror-linenumber{color:#6D8A88}.cm-s-seti.CodeMirror-focused div.CodeMirror-selected{background:rgba(255, 255, 255, 0.10)}.cm-s-seti .CodeMirror-line::selection,.cm-s-seti .CodeMirror-line>span::selection,.cm-s-seti .CodeMirror-line>span>span::selection{background:rgba(255, 255, 255, 0.10)}.cm-s-seti .CodeMirror-line::-moz-selection,.cm-s-seti .CodeMirror-line>span::-moz-selection,.cm-s-seti .CodeMirror-line>span>span::-moz-selection{background:rgba(255, 255, 255, 0.10)}.cm-s-seti span.cm-comment{color:#41535b}.cm-s-seti span.cm-string,.cm-s-seti span.cm-string-2{color:#55b5db}.cm-s-seti span.cm-number{color:#cd3f45}.cm-s-seti span.cm-variable{color:#55b5db}.cm-s-seti span.cm-variable-2{color:#a074c4}.cm-s-seti span.cm-def{color:#55b5db}.cm-s-seti span.cm-keyword{color:#ff79c6}.cm-s-seti span.cm-operator{color:#9fca56}.cm-s-seti span.cm-keyword{color:#e6cd69}.cm-s-seti span.cm-atom{color:#cd3f45}.cm-s-seti span.cm-meta{color:#55b5db}.cm-s-seti span.cm-tag{color:#55b5db}.cm-s-seti span.cm-attribute{color:#9fca56}.cm-s-seti span.cm-qualifier{color:#9fca56}.cm-s-seti span.cm-property{color:#a074c4}.cm-s-seti span.cm-variable-3,.cm-s-seti span.cm-type{color:#9fca56}.cm-s-seti span.cm-builtin{color:#9fca56}.cm-s-seti .CodeMirror-activeline-background{background:#101213}.cm-s-seti .CodeMirror-matchingbracket{text-decoration:underline;color:white !important}.cm-s-isotope.CodeMirror{background:#000000;color:#e0e0e0}.cm-s-isotope div.CodeMirror-selected{background:#404040 !important}.cm-s-isotope .CodeMirror-gutters{background:#000000;border-right:0px}.cm-s-isotope .CodeMirror-linenumber{color:#808080}.cm-s-isotope .CodeMirror-cursor{border-left:1px solid #c0c0c0 !important}.cm-s-isotope span.cm-comment{color:#3300ff}.cm-s-isotope span.cm-atom{color:#cc00ff}.cm-s-isotope span.cm-number{color:#cc00ff}.cm-s-isotope span.cm-property,.cm-s-isotope span.cm-attribute{color:#33ff00}.cm-s-isotope span.cm-keyword{color:#ff0000}.cm-s-isotope span.cm-string{color:#ff0099}.cm-s-isotope span.cm-variable{color:#33ff00}.cm-s-isotope span.cm-variable-2{color:#0066ff}.cm-s-isotope span.cm-def{color:#ff9900}.cm-s-isotope span.cm-error{background:#ff0000;color:#c0c0c0}.cm-s-isotope span.cm-bracket{color:#e0e0e0}.cm-s-isotope span.cm-tag{color:#ff0000}.cm-s-isotope span.cm-link{color:#cc00ff}.cm-s-isotope .CodeMirror-matchingbracket{text-decoration:underline;color:white !important}.cm-s-isotope .CodeMirror-activeline-background{background:#202020}.cm-s-liquibyte.CodeMirror{background-color:#000;color:#fff;line-height:1.2em;font-size:1em}.cm-s-liquibyte .CodeMirror-focused .cm-matchhighlight{text-decoration:underline;text-decoration-color:#0f0;text-decoration-style:wavy}.cm-s-liquibyte .cm-trailingspace{text-decoration:line-through;text-decoration-color:#f00;text-decoration-style:dotted}.cm-s-liquibyte .cm-tab{text-decoration:line-through;text-decoration-color:#404040;text-decoration-style:dotted}.cm-s-liquibyte .CodeMirror-gutters{background-color:#262626;border-right:1px solid #505050;padding-right:0.8em}.cm-s-liquibyte .CodeMirror-gutter-elt div{font-size:1.2em}.cm-s-liquibyte .CodeMirror-linenumber{color:#606060;padding-left:0}.cm-s-liquibyte .CodeMirror-cursor{border-left:1px solid #eee}.cm-s-liquibyte span.cm-comment{color:#008000}.cm-s-liquibyte span.cm-def{color:#ffaf40;font-weight:bold}.cm-s-liquibyte span.cm-keyword{color:#c080ff;font-weight:bold}.cm-s-liquibyte span.cm-builtin{color:#ffaf40;font-weight:bold}.cm-s-liquibyte span.cm-variable{color:#5967ff;font-weight:bold}.cm-s-liquibyte span.cm-string{color:#ff8000}.cm-s-liquibyte span.cm-number{color:#0f0;font-weight:bold}.cm-s-liquibyte span.cm-atom{color:#bf3030;font-weight:bold}.cm-s-liquibyte span.cm-variable-2{color:#007f7f;font-weight:bold}.cm-s-liquibyte span.cm-variable-3,.cm-s-liquibyte span.cm-type{color:#c080ff;font-weight:bold}.cm-s-liquibyte span.cm-property{color:#999;font-weight:bold}.cm-s-liquibyte span.cm-operator{color:#fff}.cm-s-liquibyte span.cm-meta{color:#0f0}.cm-s-liquibyte span.cm-qualifier{color:#fff700;font-weight:bold}.cm-s-liquibyte span.cm-bracket{color:#cc7}.cm-s-liquibyte span.cm-tag{color:#ff0;font-weight:bold}.cm-s-liquibyte span.cm-attribute{color:#c080ff;font-weight:bold}.cm-s-liquibyte span.cm-error{color:#f00}.cm-s-liquibyte div.CodeMirror-selected{background-color:rgba(255, 0, 0, 0.25)}.cm-s-liquibyte span.cm-compilation{background-color:rgba(255, 255, 255, 0.12)}.cm-s-liquibyte .CodeMirror-activeline-background{background-color:rgba(0, 255, 0, 0.15)}.cm-s-liquibyte .CodeMirror span.CodeMirror-matchingbracket{color:#0f0;font-weight:bold}.cm-s-liquibyte .CodeMirror span.CodeMirror-nonmatchingbracket{color:#f00;font-weight:bold}.CodeMirror-matchingtag{background-color:rgba(150, 255, 0, .3)}.cm-s-liquibyte div.CodeMirror-simplescroll-horizontal div:hover,.cm-s-liquibyte div.CodeMirror-simplescroll-vertical div:hover{background-color:rgba(80, 80, 80, .7)}.cm-s-liquibyte div.CodeMirror-simplescroll-horizontal div,.cm-s-liquibyte div.CodeMirror-simplescroll-vertical div{background-color:rgba(80, 80, 80, .3);border:1px solid #404040;border-radius:5px}.cm-s-liquibyte div.CodeMirror-simplescroll-vertical div{border-top:1px solid #404040;border-bottom:1px solid #404040}.cm-s-liquibyte div.CodeMirror-simplescroll-horizontal div{border-left:1px solid #404040;border-right:1px solid #404040}.cm-s-liquibyte div.CodeMirror-simplescroll-vertical{background-color:#262626}.cm-s-liquibyte div.CodeMirror-simplescroll-horizontal{background-color:#262626;border-top:1px solid #404040}.cm-s-liquibyte div.CodeMirror-overlayscroll-horizontal div,div.CodeMirror-overlayscroll-vertical div{background-color:#404040;border-radius:5px}.cm-s-liquibyte div.CodeMirror-overlayscroll-vertical div{border:1px solid #404040}.cm-s-liquibyte div.CodeMirror-overlayscroll-horizontal div{border:1px solid #404040}.CodeMirror-dialog{position:absolute;left:0;right:0;background:inherit;z-index:15;padding:.1em .8em;overflow:hidden;color:inherit}.CodeMirror-dialog-top{border-bottom:1px solid #eee;top:0}.CodeMirror-dialog-bottom{border-top:1px solid #eee;bottom:0}.CodeMirror-dialog input{border:none;outline:none;background:transparent;width:20em;color:inherit;font-family:monospace}.CodeMirror-dialog button{font-size:70%}.CodeMirror{font-family:monospace;font-size:12px}.CodeMirror-matchingbracket{outline:0 !important;border-radius:3px;background:rgba(0, 0, 0, 0.06);padding:1px 2px;margin:-1px -2px}.cm-keyword{color:#b713a8 !important}.cm-string{font-style:italic}.cm-comment-delimit-open{color:rgb(137, 24, 24)}.cm-comment-delimit-close{color:#676767}.cm-variable{color:#2981fb !important}.cm-js-delimit{color:#4624c7 !important}.cm-number{color:#ff6a00}.cm-comment{color:#ccc}.cm-variable{color:#f8f8f2}.cm-variable-2{color:#9effff}.cm-variable-3,.cm-s-monokai span.cm-type{color:#66d9ef}.cm-def{color:#fd971f}.cm-bracket{color:#f8f8f2}.cm-tag{color:#f92672}.cm-header{color:#ae81ff}.cm-link{color:#ae81ff}.cm-error{background:#f92672;color:#f8f8f0}.cm-comment.cm-attribute{color:#97b757}.cm-comment.cm-def{color:#bc9262}.cm-comment.cm-tag{color:#bc6283}.cm-comment.cm-type{color:#5998a6}.CodeMirror{background:#272822;color:#f8f8f2}div.CodeMirror-selected{background:#49483E}.CodeMirror-line::selection,.cm-s-monokai .CodeMirror-line>span::selection,.cm-s-monokai .CodeMirror-line>span>span::selection{background:rgba(73, 72, 62, .99)}.CodeMirror-line::-moz-selection,.cm-s-monokai .CodeMirror-line>span::-moz-selection,.cm-s-monokai .CodeMirror-line>span>span::-moz-selection{background:rgba(73, 72, 62, .99)}.CodeMirror-gutters{background:#272822;border-right:0px}.CodeMirror-guttermarker{color:white}.CodeMirror-guttermarker-subtle{color:#d0d0d0}.CodeMirror-linenumber{color:#d0d0d0}.CodeMirror-cursor{border-left:1px solid #f8f8f0}.CodeMirror-hints{position:absolute;z-index:10;overflow:hidden;list-style:none;margin:0;padding:2px;-webkit-box-shadow:2px 3px 5px rgba(0, 0, 0, 0.2);-moz-box-shadow:2px 3px 5px rgba(0, 0, 0, 0.2);box-shadow:2px 3px 5px rgba(0, 0, 0, 0.2);border-radius:3px;border:1px solid silver;background:white;font-size:90%;font-family:monospace;max-height:20em;overflow-y:auto}.CodeMirror-hint{margin:0;padding:0 4px;border-radius:2px;white-space:pre;color:black;cursor:pointer}li.CodeMirror-hint-active{background:#08f;color:white}.layout-template-container{height:100vh}.scrollable{flex:1 1 auto;margin:0 0 0.5em 0}.codemirror-container{position:relative;width:100%;height:100%;border:none;line-height:1.4;overflow:hidden;font-family:monospace;color:white;overflow:hidden !important}.codemirror-container .CodeMirror{height:100%;background:transparent;font:400 14px/1.7 var(--font-mono);color:var(--base)}";
	append(document.head, style);
}

function create_fragment$g(ctx) {
	let div;
	let codemirror;
	let updating_value;
	let current;

	function codemirror_value_binding(value) {
		/*codemirror_value_binding*/ ctx[20].call(null, value);
	}

	let codemirror_props = {
		tab: /*tab*/ ctx[1],
		lineNumbers: /*lineNumbers*/ ctx[2],
		cmdForwardSlash: nil,
		cmdEnter: /*evalLiveCodeOnEditorCommand*/ ctx[7],
		ctrlEnter: /*evalLiveCodeOnEditorCommand*/ ctx[7],
		snippets: functionDefinitions,
		useAutocomplete: true
	};

	if (/*content*/ ctx[0] !== void 0) {
		codemirror_props.value = /*content*/ ctx[0];
	}

	codemirror = new CodeMirror_1({ props: codemirror_props });
	/*codemirror_binding*/ ctx[19](codemirror);
	binding_callbacks.push(() => bind(codemirror, "value", codemirror_value_binding));
	codemirror.$on("change", /*change_handler*/ ctx[21]);
	codemirror.$on("focus", /*focus_handler*/ ctx[22]);
	codemirror.$on("blur", /*blur_handler*/ ctx[23]);
	codemirror.$on("refresh", /*refresh_handler*/ ctx[24]);
	codemirror.$on("gutterClick", /*gutterClick_handler*/ ctx[25]);
	codemirror.$on("viewportChange", /*viewportChange_handler*/ ctx[26]);

	return {
		c() {
			div = element("div");
			create_component(codemirror.$$.fragment);
			attr(div, "class", "codemirror-container layout-template-container scrollable");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(codemirror, div, null);
			/*div_binding*/ ctx[27](div);
			current = true;
		},
		p(ctx, dirty) {
			const codemirror_changes = {};
			if (dirty[0] & /*tab*/ 2) codemirror_changes.tab = /*tab*/ ctx[1];
			if (dirty[0] & /*lineNumbers*/ 4) codemirror_changes.lineNumbers = /*lineNumbers*/ ctx[2];

			if (!updating_value && dirty[0] & /*content*/ 1) {
				updating_value = true;
				codemirror_changes.value = /*content*/ ctx[0];
				add_flush_callback(() => updating_value = false);
			}

			codemirror.$set(codemirror_changes);
		},
		i(local) {
			if (current) return;
			transition_in(codemirror.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(codemirror.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			/*codemirror_binding*/ ctx[19](null);
			destroy_component(codemirror);
			/*div_binding*/ ctx[27](null);
		}
	};
}

if (typeof window !== "undefined") {
	import('./codeMirrorPlugins-47b81358.js');
}

function instance$f($$self, $$props, $$invalidate) {
	let $liveCodeEditorValue;
	let $grammarEditorValue;
	let $liveCodeAbstractSyntaxTree;
	let $DSP;
	let $liveCodeParseErrors;
	component_subscribe($$self, liveCodeEditorValue, $$value => $$invalidate(31, $liveCodeEditorValue = $$value));
	component_subscribe($$self, grammarEditorValue, $$value => $$invalidate(32, $grammarEditorValue = $$value));
	component_subscribe($$self, liveCodeAbstractSyntaxTree, $$value => $$invalidate(33, $liveCodeAbstractSyntaxTree = $$value));
	component_subscribe($$self, dspCode, $$value => $$invalidate(34, $DSP = $$value));
	component_subscribe($$self, liveCodeParseErrors, $$value => $$invalidate(35, $liveCodeParseErrors = $$value));
	const dispatch = createEventDispatcher();
	let { tab = true } = $$props;
	let { id } = $$props; // unused
	let { name } = $$props; // unused
	let { type } = $$props; // unused
	let { lineNumbers } = $$props;
	let { hasFocus } = $$props;
	let { theme } = $$props; // unused
	let { background } = $$props; // unused
	let { content } = $$props; // liveCode Value that is injected and to which CodeMirror is bound
	let { grammarSource } = $$props;
	let { grammar } = $$props;
	let { liveCodeSource } = $$props;
	let { component } = $$props;
	let { class: className } = $$props;

	// messaging = new PubSub(),
	let engine, codeMirror, btrack, container, resizeObserver;

	let onChange = e => {
		btrack.onEditChange(e.detail.changeObj);

		// this event notifies the parent (Dashboard) to update this items on the items collection, because of the 'data' property change
		// CHECK <svelte:component on:change={ e => update(item, e.detail.prop, e.detail.value) }
		try {
			let value = codeMirror.getValue();
			dispatch("change", { prop: "content", value });
		} catch(error) {
			console.error("Error Live Code Editor get value from code Mirror");
		}
	};

	let onFocus = e => {
		$$invalidate(8, hasFocus = true);
		dispatch("change", { prop: "hasFocus", value: true });
	};

	/**
 * editor blink, non-blocking, defers execution for M milliseconds
 * @param editor
 * @param milliseconds
 */
	const blinkEditorSelectionForMilliseconds = async (editor, milliseconds) => {
		if (editor) {
			let pos = editor.getCursor();
			editor.selectAll();
			await new Promise(r => setTimeout(r, milliseconds));
			editor.setCursor(pos);
		}
	};

	const evalLiveCodeOnEditorCommand = async e => {
		if (e) {
			try {
				if (!engine) engine = new Engine$1();
				set_store_value(liveCodeEditorValue, $liveCodeEditorValue = codeMirror.getValue(), $liveCodeEditorValue);

				// const { errors, dspCode } = compile( $grammarEditorValue, $liveCodeEditorValue );
				const { errors, livecodeParseTree } = parse($grammarEditorValue, $liveCodeEditorValue);

				if (livecodeParseTree) {
					set_store_value(liveCodeAbstractSyntaxTree, $liveCodeAbstractSyntaxTree = livecodeParseTree, $liveCodeAbstractSyntaxTree);
					const { dspCode: dspCode$1 } = ASTreeToDSPcode(livecodeParseTree[0]);

					if (dspCode$1) {
						set_store_value(dspCode, $DSP = dspCode$1, $DSP);
						engine.eval(dspCode$1);
						engineStatus.set("running");
						set_store_value(liveCodeParseErrors, $liveCodeParseErrors = "", $liveCodeParseErrors);
					}

					
				}

				if (errors) set_store_value(liveCodeParseErrors, $liveCodeParseErrors = errors, $liveCodeParseErrors);
				await blinkEditorSelectionForMilliseconds(codeMirror, 20);
			} catch(err) {
				console.error("ERROR: Failed to compile and eval: ", err);
			}
		}
	};

	onMount(async () => {
		codeMirror.set(content, "js", "sema");
		resizeObserver = new ResizeObserver(e => codeMirror.setSize("100%", "100%"));
		resizeObserver.observe(container);
		btrack = new blockTracker(codeMirror);
	});

	onDestroy(() => {
		$$invalidate(3, codeMirror = null);
		resizeObserver.disconnect();
		resizeObserver = null;
	});

	function codemirror_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			codeMirror = $$value;
			$$invalidate(3, codeMirror);
		});
	}

	function codemirror_value_binding(value) {
		content = value;
		$$invalidate(0, content);
	}

	const change_handler = e => onChange(e);
	const focus_handler = e => onFocus();
	const blur_handler = e => onFocus();
	const refresh_handler = e => onFocus();
	const gutterClick_handler = e => onFocus();
	const viewportChange_handler = e => onFocus();

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			container = $$value;
			$$invalidate(4, container);
		});
	}

	$$self.$$set = $$props => {
		if ("tab" in $$props) $$invalidate(1, tab = $$props.tab);
		if ("id" in $$props) $$invalidate(9, id = $$props.id);
		if ("name" in $$props) $$invalidate(10, name = $$props.name);
		if ("type" in $$props) $$invalidate(11, type = $$props.type);
		if ("lineNumbers" in $$props) $$invalidate(2, lineNumbers = $$props.lineNumbers);
		if ("hasFocus" in $$props) $$invalidate(8, hasFocus = $$props.hasFocus);
		if ("theme" in $$props) $$invalidate(12, theme = $$props.theme);
		if ("background" in $$props) $$invalidate(13, background = $$props.background);
		if ("content" in $$props) $$invalidate(0, content = $$props.content);
		if ("grammarSource" in $$props) $$invalidate(14, grammarSource = $$props.grammarSource);
		if ("grammar" in $$props) $$invalidate(15, grammar = $$props.grammar);
		if ("liveCodeSource" in $$props) $$invalidate(16, liveCodeSource = $$props.liveCodeSource);
		if ("component" in $$props) $$invalidate(17, component = $$props.component);
		if ("class" in $$props) $$invalidate(18, className = $$props.class);
	};

	return [
		content,
		tab,
		lineNumbers,
		codeMirror,
		container,
		onChange,
		onFocus,
		evalLiveCodeOnEditorCommand,
		hasFocus,
		id,
		name,
		type,
		theme,
		background,
		grammarSource,
		grammar,
		liveCodeSource,
		component,
		className,
		codemirror_binding,
		codemirror_value_binding,
		change_handler,
		focus_handler,
		blur_handler,
		refresh_handler,
		gutterClick_handler,
		viewportChange_handler,
		div_binding
	];
}

class LiveCodeEditor extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1uozcog-style")) add_css$7();

		init(
			this,
			options,
			instance$f,
			create_fragment$g,
			safe_not_equal,
			{
				tab: 1,
				id: 9,
				name: 10,
				type: 11,
				lineNumbers: 2,
				hasFocus: 8,
				theme: 12,
				background: 13,
				content: 0,
				grammarSource: 14,
				grammar: 15,
				liveCodeSource: 16,
				component: 17,
				class: 18
			},
			[-1, -1]
		);
	}
}

const isNil = (value = null) => value === null;

const keyIsIndex = key => String(parseInt(String(key))) === String(key);

const onTick = callback => tick().then(callback);

const getObjectToStringTag = object => Object.prototype.toString.call(object).slice(8, -1);

const getObjectTypeString = object => {
  const hasToStringTag = Symbol.toStringTag in object;
  if (hasToStringTag) {
    return getObjectToStringTag(object);
  }

  const prototype = Object.getPrototypeOf(object);
  const constructorName = prototype && prototype.constructor && prototype.constructor.name;
  const usefulConstructorName = constructorName && constructorName !== 'Object';

  return usefulConstructorName ? constructorName : getObjectToStringTag(object);
};

const getAllProperties = object => {
  const enumerableKeys = [];
  for (const enumerableKey in object) {
    enumerableKeys.push(enumerableKey);
  }
  return [...new Set([
    ...enumerableKeys,
    ...Object.getOwnPropertyNames(object),
    ...Object.getOwnPropertySymbols(object),
    ...(object['__proto__'] ? ['__proto__'] : [])
  ])];
};

const getPropertyDescriptor = (object, prop) => {
  if (!object) {
    return {};
  } else if (prop === '__proto__') {
    return {
      value: Object.getPrototypeOf(object)
    };
  } else {
    const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(object, prop);
    if (ownPropertyDescriptor) {
      return ownPropertyDescriptor;
    } else {
      const prototype = Object.getPrototypeOf(object);
      return getPropertyDescriptor(prototype, prop);
    }
  }
};

const stringEscapeGroups = string => {
  // Split string into array of sequences of characters, with needed escapes broken out
  const characters = string.split(/([\x00-\x1F]+)/);
  return characters.map(char => JSON.stringify(char).slice(1, -1));
};

const backslashCharCode = '\\'.charCodeAt(0);

const isEscapeGroup = string => string.charCodeAt(0) === backslashCharCode;

const groupByRegexes = (regexes) => {
  const keys = Object.keys(regexes);
  return string => {
    const groups = [];
    let source = string;
    while (source.length) {
      let bestKey = null;
      let bestMatch = null;
      let bestIndex = source.length;
      for (const key of keys) {
        const regex = regexes[key];
        const match = source.match(regex);
        if (match && match.index < bestIndex) {
          bestKey = key;
          bestMatch = match[0];
          bestIndex = match.index;
        }
      }
      if (bestIndex > 0) {
        groups.push({key: undefined, match: source.slice(0, bestIndex)});
      }
      if (bestMatch) {
        groups.push({key: bestKey, match: bestMatch});
        source = source.slice(bestIndex + bestMatch.length);
      } else {
        break;
      }
    }
    return groups;
  };
};

let serialCounter = 0;

function target(element) {
  // This should probably not be a global serial, but based instead on the scope.
  element.dataset.focusTarget = serialCounter++;
  element.tabIndex = 0;
  const focusEventListener = () => {
    setFocus(element);
  };
  element.addEventListener('focus', focusEventListener);
  return {
    destroy() {
      element.removeEventListener('focus', focusEventListener);
    }
  };
}

function scope(element) {
  element.dataset.focusScope = '';
}

const createRangeFrom = element => {
  const range = document.createRange();
  range.selectNodeContents(element);
  return range;
};

function getElementBefore(referenceElement, elements) {
  const range = createRangeFrom(referenceElement);
  const lastIndex = elements.length - 1;
  for (let i = lastIndex; i >= 0; i--) {
    if (range.comparePoint(elements[i], 0) === -1) {
      return elements[i];
    }
  }
  return elements[lastIndex];
}

function getElementAfter(referenceElement, elements) {
  const range = createRangeFrom(referenceElement);
  for (let i = 0; i < elements.length; i++) {
    if (range.comparePoint(elements[i], 0) === 1) {
      return elements[i];
    }
  }
  return elements[0];
}

function getTargetBefore(element) {
  return getElementBefore(
    element,
    document.querySelectorAll('[data-focus-target]')
  );
}

function getTargetAfter(element) {
  return getElementAfter(
    element,
    document.querySelectorAll('[data-focus-target]')
  );
}

function getParentScope(element) {
  return element.closest('[data-focus-scope]');
}

function setFocus(targetElement) {
  if (targetElement) {
    const serial = targetElement.dataset.focusTarget;
    if (serial) {
      const scope = getParentScope(targetElement);
      if (scope) {
        scope.dataset.focusScope = serial;
      }
    }
    targetElement.focus();
    return true;
  }
  return false;
}

function focusPrev() {
  return setFocus(getTargetBefore(document.activeElement));
}

function focusNext() {
  return setFocus(getTargetAfter(document.activeElement));
}

function exitFocusScope() {
  const parent = getParentScope(document.activeElement);
  if (parent) {
    return setFocus(getTargetBefore(parent));
  } else {
    document.activeElement.blur();
    return false;
  }
}

function enterFocusScope() {
  const nextScope = getElementAfter(
    document.activeElement,
    document.querySelectorAll('[data-focus-scope]')
  );
  const targetBefore = getTargetBefore(nextScope);
  if (targetBefore !== document.activeElement) {
    // We only want to enter the scope if it is directly after activeElement
    return false;
  }
  const serial = nextScope.dataset.focusScope;
  const selector = serial
    ? `[data-focus-target="${serial}"]`
    : `[data-focus-target]`;
  const target = nextScope.querySelector(selector);
  return setFocus(target);
}

function focusBySearch(string) {
  // Find a focus target that matches the string.
  try {
    const regex = new RegExp(string.split('').join('[^a-z0-9]*.?[^a-z0-9]*'), 'i');
    let scope = (document.activeElement);
    do {
      scope = getParentScope(scope.parentElement);
      const targets = (scope || document).querySelectorAll('[data-focus-target]');
      for (let i = 0; i < targets.length; i++) {
        const target = targets[i];
        const text = target.textContent;
        if (regex.test(text)) {
          return setFocus(target);
        }
      }
    } while (scope);
  } catch (e) {}
  return false;
}

/* node_modules/svelte-inspect/inspect/PropertyList.svelte generated by Svelte v3.31.0 */

function add_css$8() {
	var style = element("style");
	style.id = "svelte-11omaqa-style";
	style.textContent = ".row.svelte-11omaqa.svelte-11omaqa{display:flex}.row.svelte-11omaqa:not(:last-child)>.item.svelte-11omaqa:after{content:' , ';margin-left:-1ex;pointer-events:none;color:var(--color-black)}.indentation.svelte-11omaqa.svelte-11omaqa{margin:0;padding:0;display:inline-block}.empty.svelte-11omaqa.svelte-11omaqa{color:var(--color-gray);font-style:italic}";
	append(document.head, style);
}

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[8] = list[i];
	return child_ctx;
}

function get_each_context_1$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	return child_ctx;
}

// (32:2) {:else}
function create_else_block$1(ctx) {
	let div;
	let pre;
	let t1;
	let span;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);
	const default_slot_or_fallback = default_slot || fallback_block();

	return {
		c() {
			div = element("div");
			pre = element("pre");
			pre.textContent = "";
			t1 = space();
			span = element("span");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			attr(pre, "class", "indentation svelte-11omaqa");
			attr(span, "class", "empty svelte-11omaqa");
			attr(div, "class", "row svelte-11omaqa");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, pre);
			append(div, t1);
			append(div, span);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(span, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 128) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
		}
	};
}

// (35:30) No properties
function fallback_block(ctx) {
	let t;

	return {
		c() {
			t = text$1("No properties");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (19:2) {#each properties.slice(0, maxCount) as property (property)}
function create_each_block_1$1(key_1, ctx) {
	let div;
	let pre;
	let t1;
	let span;
	let property;
	let current;

	property = new Property({
			props: {
				depth: /*nextDepth*/ ctx[3],
				key: /*property*/ ctx[11],
				context: /*value*/ ctx[0],
				descriptor: getPropertyDescriptor(/*value*/ ctx[0], /*property*/ ctx[11]),
				separator: ": "
			}
		});

	return {
		key: key_1,
		first: null,
		c() {
			div = element("div");
			pre = element("pre");
			pre.textContent = "";
			t1 = space();
			span = element("span");
			create_component(property.$$.fragment);
			attr(pre, "class", "indentation svelte-11omaqa");
			attr(span, "class", "item svelte-11omaqa");
			attr(div, "class", "row svelte-11omaqa");
			this.first = div;
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, pre);
			append(div, t1);
			append(div, span);
			mount_component(property, span, null);
			current = true;
		},
		p(ctx, dirty) {
			const property_changes = {};
			if (dirty & /*nextDepth*/ 8) property_changes.depth = /*nextDepth*/ ctx[3];
			if (dirty & /*properties, maxCount*/ 6) property_changes.key = /*property*/ ctx[11];
			if (dirty & /*value*/ 1) property_changes.context = /*value*/ ctx[0];
			if (dirty & /*value, properties, maxCount*/ 7) property_changes.descriptor = getPropertyDescriptor(/*value*/ ctx[0], /*property*/ ctx[11]);
			property.$set(property_changes);
		},
		i(local) {
			if (current) return;
			transition_in(property.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(property.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(property);
		}
	};
}

// (38:2) {#if maxCount < properties.length}
function create_if_block$6(ctx) {
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_1_anchor;
	let current;
	let each_value = { length: 1 };
	const get_key = ctx => /*maxCount*/ ctx[1];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$3(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$3(key, child_ctx));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*maxCount, paging, focusPrev, onTick, focusNext, properties, Math*/ 6) {
				const each_value = { length: 1 };
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$3, each_1_anchor, get_each_context$3);
				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d(detaching);
			}

			if (detaching) detach(each_1_anchor);
		}
	};
}

// (42:8) <Toggle           on:open={() => {             maxCount += paging;             focusPrev();             onTick(focusNext);           }}         >
function create_default_slot$2(ctx) {
	let t0;
	let t1;
	let t2;
	let t3_value = Math.min(/*properties*/ ctx[2].length, /*maxCount*/ ctx[1] + paging - 1) + "";
	let t3;
	let t4;
	let t5_value = /*properties*/ ctx[2].length + "";
	let t5;
	let t6;

	return {
		c() {
			t0 = text$1("Show ");
			t1 = text$1(/*maxCount*/ ctx[1]);
			t2 = text$1("  ");
			t3 = text$1(t3_value);
			t4 = text$1(" of ");
			t5 = text$1(t5_value);
			t6 = text$1(" properties");
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
			insert(target, t2, anchor);
			insert(target, t3, anchor);
			insert(target, t4, anchor);
			insert(target, t5, anchor);
			insert(target, t6, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*maxCount*/ 2) set_data(t1, /*maxCount*/ ctx[1]);
			if (dirty & /*properties, maxCount*/ 6 && t3_value !== (t3_value = Math.min(/*properties*/ ctx[2].length, /*maxCount*/ ctx[1] + paging - 1) + "")) set_data(t3, t3_value);
			if (dirty & /*properties*/ 4 && t5_value !== (t5_value = /*properties*/ ctx[2].length + "")) set_data(t5, t5_value);
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
			if (detaching) detach(t2);
			if (detaching) detach(t3);
			if (detaching) detach(t4);
			if (detaching) detach(t5);
			if (detaching) detach(t6);
		}
	};
}

// (39:4) {#each {length: 1} as _ (maxCount)}
function create_each_block$3(key_1, ctx) {
	let div;
	let pre;
	let t1;
	let toggle;
	let t2;
	let current;

	toggle = new Toggle({
			props: {
				$$slots: { default: [create_default_slot$2] },
				$$scope: { ctx }
			}
		});

	toggle.$on("open", /*open_handler*/ ctx[6]);

	return {
		key: key_1,
		first: null,
		c() {
			div = element("div");
			pre = element("pre");
			pre.textContent = "";
			t1 = space();
			create_component(toggle.$$.fragment);
			t2 = space();
			attr(pre, "class", "indentation svelte-11omaqa");
			attr(div, "class", "row svelte-11omaqa");
			this.first = div;
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, pre);
			append(div, t1);
			mount_component(toggle, div, null);
			append(div, t2);
			current = true;
		},
		p(ctx, dirty) {
			const toggle_changes = {};

			if (dirty & /*$$scope, properties, maxCount*/ 134) {
				toggle_changes.$$scope = { dirty, ctx };
			}

			toggle.$set(toggle_changes);
		},
		i(local) {
			if (current) return;
			transition_in(toggle.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(toggle.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(toggle);
		}
	};
}

function create_fragment$h(ctx) {
	let span;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t;
	let scope_action;
	let current;
	let mounted;
	let dispose;
	let each_value_1 = /*properties*/ ctx[2].slice(0, /*maxCount*/ ctx[1]);
	const get_key = ctx => /*property*/ ctx[11];

	for (let i = 0; i < each_value_1.length; i += 1) {
		let child_ctx = get_each_context_1$1(ctx, each_value_1, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block_1$1(key, child_ctx));
	}

	let each_1_else = null;

	if (!each_value_1.length) {
		each_1_else = create_else_block$1(ctx);
	}

	let if_block = /*maxCount*/ ctx[1] < /*properties*/ ctx[2].length && create_if_block$6(ctx);

	return {
		c() {
			span = element("span");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			if (each_1_else) {
				each_1_else.c();
			}

			t = space();
			if (if_block) if_block.c();
		},
		m(target, anchor) {
			insert(target, span, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(span, null);
			}

			if (each_1_else) {
				each_1_else.m(span, null);
			}

			append(span, t);
			if (if_block) if_block.m(span, null);
			current = true;

			if (!mounted) {
				dispose = action_destroyer(scope_action = scope.call(null, span));
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*nextDepth, properties, maxCount, value, getPropertyDescriptor, $$scope*/ 143) {
				const each_value_1 = /*properties*/ ctx[2].slice(0, /*maxCount*/ ctx[1]);
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, span, outro_and_destroy_block, create_each_block_1$1, t, get_each_context_1$1);
				check_outros();

				if (!each_value_1.length && each_1_else) {
					each_1_else.p(ctx, dirty);
				} else if (!each_value_1.length) {
					each_1_else = create_else_block$1(ctx);
					each_1_else.c();
					transition_in(each_1_else, 1);
					each_1_else.m(span, t);
				} else if (each_1_else) {
					group_outros();

					transition_out(each_1_else, 1, 1, () => {
						each_1_else = null;
					});

					check_outros();
				}
			}

			if (/*maxCount*/ ctx[1] < /*properties*/ ctx[2].length) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*maxCount, properties*/ 6) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$6(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(span, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(if_block);
			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			if (each_1_else) each_1_else.d();
			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};
}

const paging = 100;

function instance$g($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { depth = 0 } = $$props;
	let { value } = $$props;
	let maxCount = paging;

	const open_handler = () => {
		$$invalidate(1, maxCount += paging);
		focusPrev();
		onTick(focusNext);
	};

	$$self.$$set = $$props => {
		if ("depth" in $$props) $$invalidate(4, depth = $$props.depth);
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("$$scope" in $$props) $$invalidate(7, $$scope = $$props.$$scope);
	};

	let properties;
	let nextDepth;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 1) {
			 $$invalidate(2, properties = isNil(value) ? [] : getAllProperties(value));
		}

		if ($$self.$$.dirty & /*depth*/ 16) {
			 $$invalidate(3, nextDepth = Math.max(0, depth - 1));
		}
	};

	return [value, maxCount, properties, nextDepth, depth, slots, open_handler, $$scope];
}

class PropertyList extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-11omaqa-style")) add_css$8();
		init(this, options, instance$g, create_fragment$h, safe_not_equal, { depth: 4, value: 0 });
	}
}

/* node_modules/svelte-inspect/inspect/Toggle.svelte generated by Svelte v3.31.0 */

function add_css$9() {
	var style = element("style");
	style.id = "svelte-xjtn8w-style";
	style.textContent = ".toggle.svelte-xjtn8w{cursor:pointer}.toggle.svelte-xjtn8w:focus{outline-color:var(--color-selection);box-shadow:inset 0 0 0 1em var(--color-selection),\n      0 0 0 2px var(--color-selection);border-radius:1px}";
	append(document.head, style);
}

function create_fragment$i(ctx) {
	let span;
	let span_class_value;
	let target_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	return {
		c() {
			span = element("span");
			if (default_slot) default_slot.c();
			attr(span, "role", "button");
			attr(span, "class", span_class_value = "" + (null_to_empty(/*className*/ ctx[1]) + " svelte-xjtn8w"));
			toggle_class(span, "toggle", true);
		},
		m(target$1, anchor) {
			insert(target$1, span, anchor);

			if (default_slot) {
				default_slot.m(span, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(target_action = target.call(null, span)),
					listen(span, "click", /*click_handler*/ ctx[6]),
					listen(span, "keydown", /*onKeyDown*/ ctx[3])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}

			if (!current || dirty & /*className*/ 2 && span_class_value !== (span_class_value = "" + (null_to_empty(/*className*/ ctx[1]) + " svelte-xjtn8w"))) {
				attr(span, "class", span_class_value);
			}

			if (dirty & /*className*/ 2) {
				toggle_class(span, "toggle", true);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

let typingBuffer = "";
let hasSearchBufferTimeout = false;
let clearBufferTimeout;

function type(char) {
	typingBuffer += char;

	if (!hasSearchBufferTimeout) {
		hasSearchBufferTimeout = true;

		setTimeout(
			() => {
				hasSearchBufferTimeout = false;
				focusBySearch(typingBuffer);
			},
			100
		);
	}

	clearTimeout(clearBufferTimeout);

	clearBufferTimeout = setTimeout(
		() => {
			typingBuffer = "";
		},
		600
	);
}

function instance$h($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	const dispatch = createEventDispatcher();
	let { className = "" } = $$props;
	let { isOpen = false } = $$props;

	const toggle = (bool = !isOpen) => {
		$$invalidate(0, isOpen = bool);
		dispatch("open", bool);
	};

	const onKeyDown = keydownEvent => {
		let shouldPreventDefault = true;

		switch (keydownEvent.code) {
			case "Space":
				{
					toggle();
					break;
				}
			case "ArrowUp":
				{
					focusPrev();
					break;
				}
			case "ArrowDown":
				{
					focusNext();
					break;
				}
			case "Escape":
				{
					exitFocusScope();
					break;
				}
			case "ArrowLeft":
				{
					if (isOpen) {
						toggle(false);
					} else {
						exitFocusScope();
					}

					break;
				}
			case "Enter":
				{
					if (!isOpen) {
						toggle(true);
						focusPrev();
						onTick(focusNext).then(enterFocusScope);
					} else {
						const didFocus = enterFocusScope();

						if (!didFocus) {
							toggle(false);
						}
					}

					break;
				}
			case "ArrowRight":
				{
					if (!isOpen) {
						toggle(true);
					} else {
						enterFocusScope();
					}

					break;
				}
			default:
				{
					if (keydownEvent.key.length === 1) {
						type(keydownEvent.key);
					}

					shouldPreventDefault = false;
				}
		}

		if (shouldPreventDefault) {
			keydownEvent.preventDefault();
		}
	};

	const click_handler = event => {
		if (event.detail === 1) {
			toggle();
		} else if (isOpen && event.detail === 2) {
			enterFocusScope();
		}
	};

	$$self.$$set = $$props => {
		if ("className" in $$props) $$invalidate(1, className = $$props.className);
		if ("isOpen" in $$props) $$invalidate(0, isOpen = $$props.isOpen);
		if ("$$scope" in $$props) $$invalidate(4, $$scope = $$props.$$scope);
	};

	return [isOpen, className, toggle, onKeyDown, $$scope, slots, click_handler];
}

class Toggle extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-xjtn8w-style")) add_css$9();
		init(this, options, instance$h, create_fragment$i, safe_not_equal, { className: 1, isOpen: 0 });
	}
}

/* node_modules/svelte-inspect/inspect/PrimitiveBase.svelte generated by Svelte v3.31.0 */

function add_css$a() {
	var style = element("style");
	style.id = "svelte-15230ek-style";
	style.textContent = ".on-intent.svelte-15230ek{display:none}.toggle:hover>.on-intent.svelte-15230ek,.toggle:focus>.on-intent.svelte-15230ek{display:inline}";
	append(document.head, style);
}

const get_default_slot_changes = dirty => ({ isOpen: dirty & /*isOpen*/ 2 });
const get_default_slot_context = ctx => ({ isOpen: /*isOpen*/ ctx[1] });

// (16:2) {:else}
function create_else_block$2(ctx) {
	let t;

	return {
		c() {
			t = text$1("{");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (14:2) {#if !isOpen}
function create_if_block_1$3(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			span.textContent = "";
			attr(span, "class", "on-intent svelte-15230ek");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (12:0) <Toggle className=toggle bind:isOpen>
function create_default_slot$3(ctx) {
	let t;
	let if_block_anchor;
	let current;
	const default_slot_template = /*#slots*/ ctx[2].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], get_default_slot_context);

	function select_block_type(ctx, dirty) {
		if (!/*isOpen*/ ctx[1]) return create_if_block_1$3;
		return create_else_block$2;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if (default_slot) default_slot.c();
			t = space();
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			insert(target, t, anchor);
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope, isOpen*/ 18) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, get_default_slot_changes, get_default_slot_context);
				}
			}

			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
			if (detaching) detach(t);
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (21:0) {#if isOpen}
function create_if_block$7(ctx) {
	let propertylist;
	let t;
	let current;
	propertylist = new PropertyList({ props: { value: /*value*/ ctx[0] } });

	return {
		c() {
			create_component(propertylist.$$.fragment);
			t = text$1("\n  }");
		},
		m(target, anchor) {
			mount_component(propertylist, target, anchor);
			insert(target, t, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const propertylist_changes = {};
			if (dirty & /*value*/ 1) propertylist_changes.value = /*value*/ ctx[0];
			propertylist.$set(propertylist_changes);
		},
		i(local) {
			if (current) return;
			transition_in(propertylist.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(propertylist.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(propertylist, detaching);
			if (detaching) detach(t);
		}
	};
}

function create_fragment$j(ctx) {
	let toggle;
	let updating_isOpen;
	let t;
	let if_block_anchor;
	let current;

	function toggle_isOpen_binding(value) {
		/*toggle_isOpen_binding*/ ctx[3].call(null, value);
	}

	let toggle_props = {
		className: "toggle",
		$$slots: { default: [create_default_slot$3] },
		$$scope: { ctx }
	};

	if (/*isOpen*/ ctx[1] !== void 0) {
		toggle_props.isOpen = /*isOpen*/ ctx[1];
	}

	toggle = new Toggle({ props: toggle_props });
	binding_callbacks.push(() => bind(toggle, "isOpen", toggle_isOpen_binding));
	let if_block = /*isOpen*/ ctx[1] && create_if_block$7(ctx);

	return {
		c() {
			create_component(toggle.$$.fragment);
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			mount_component(toggle, target, anchor);
			insert(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const toggle_changes = {};

			if (dirty & /*$$scope, isOpen*/ 18) {
				toggle_changes.$$scope = { dirty, ctx };
			}

			if (!updating_isOpen && dirty & /*isOpen*/ 2) {
				updating_isOpen = true;
				toggle_changes.isOpen = /*isOpen*/ ctx[1];
				add_flush_callback(() => updating_isOpen = false);
			}

			toggle.$set(toggle_changes);

			if (/*isOpen*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*isOpen*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$7(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(toggle.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(toggle.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			destroy_component(toggle, detaching);
			if (detaching) detach(t);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$i($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { value } = $$props;
	let isOpen = false;

	function toggle_isOpen_binding(value) {
		isOpen = value;
		$$invalidate(1, isOpen);
	}

	$$self.$$set = $$props => {
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("$$scope" in $$props) $$invalidate(4, $$scope = $$props.$$scope);
	};

	return [value, isOpen, slots, toggle_isOpen_binding, $$scope];
}

class PrimitiveBase extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-15230ek-style")) add_css$a();
		init(this, options, instance$i, create_fragment$j, safe_not_equal, { value: 0 });
	}
}

/* node_modules/svelte-inspect/inspect/formatters/NilFormatter.svelte generated by Svelte v3.31.0 */

function add_css$b() {
	var style = element("style");
	style.id = "svelte-xkydpr-style";
	style.textContent = ".nil.svelte-xkydpr{color:var(--color-gray)}";
	append(document.head, style);
}

// (11:0) <PrimitiveBase {value}>
function create_default_slot$4(ctx) {
	let t0;
	let span;
	let t1_value = String(/*value*/ ctx[0]) + "";
	let t1;
	let current;
	const default_slot_template = /*#slots*/ ctx[1].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	return {
		c() {
			if (default_slot) default_slot.c();
			t0 = space();
			span = element("span");
			t1 = text$1(t1_value);
			attr(span, "class", "nil svelte-xkydpr");
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			insert(target, t0, anchor);
			insert(target, span, anchor);
			append(span, t1);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
				}
			}

			if ((!current || dirty & /*value*/ 1) && t1_value !== (t1_value = String(/*value*/ ctx[0]) + "")) set_data(t1, t1_value);
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(span);
		}
	};
}

function create_fragment$k(ctx) {
	let primitivebase;
	let current;

	primitivebase = new PrimitiveBase({
			props: {
				value: /*value*/ ctx[0],
				$$slots: { default: [create_default_slot$4] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(primitivebase.$$.fragment);
		},
		m(target, anchor) {
			mount_component(primitivebase, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const primitivebase_changes = {};
			if (dirty & /*value*/ 1) primitivebase_changes.value = /*value*/ ctx[0];

			if (dirty & /*$$scope, value*/ 5) {
				primitivebase_changes.$$scope = { dirty, ctx };
			}

			primitivebase.$set(primitivebase_changes);
		},
		i(local) {
			if (current) return;
			transition_in(primitivebase.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(primitivebase.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(primitivebase, detaching);
		}
	};
}

const check = value => value === null || value === undefined;

function instance$j($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { value } = $$props;

	$$self.$$set = $$props => {
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	return [value, slots, $$scope];
}

class NilFormatter extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-xkydpr-style")) add_css$b();
		init(this, options, instance$j, create_fragment$k, safe_not_equal, { value: 0 });
	}
}

var NilFormatter$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': NilFormatter,
    check: check
});

/* node_modules/svelte-inspect/inspect/formatters/BooleanFormatter.svelte generated by Svelte v3.31.0 */

function add_css$c() {
	var style = element("style");
	style.id = "svelte-4iglbr-style";
	style.textContent = ".boolean.svelte-4iglbr{color:var(--color-blue)}";
	append(document.head, style);
}

// (11:0) <PrimitiveBase {value}>
function create_default_slot$5(ctx) {
	let t0;
	let span;
	let t1_value = String(/*value*/ ctx[0]) + "";
	let t1;
	let current;
	const default_slot_template = /*#slots*/ ctx[1].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	return {
		c() {
			if (default_slot) default_slot.c();
			t0 = space();
			span = element("span");
			t1 = text$1(t1_value);
			attr(span, "class", "boolean svelte-4iglbr");
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			insert(target, t0, anchor);
			insert(target, span, anchor);
			append(span, t1);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
				}
			}

			if ((!current || dirty & /*value*/ 1) && t1_value !== (t1_value = String(/*value*/ ctx[0]) + "")) set_data(t1, t1_value);
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(span);
		}
	};
}

function create_fragment$l(ctx) {
	let primitivebase;
	let current;

	primitivebase = new PrimitiveBase({
			props: {
				value: /*value*/ ctx[0],
				$$slots: { default: [create_default_slot$5] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(primitivebase.$$.fragment);
		},
		m(target, anchor) {
			mount_component(primitivebase, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const primitivebase_changes = {};
			if (dirty & /*value*/ 1) primitivebase_changes.value = /*value*/ ctx[0];

			if (dirty & /*$$scope, value*/ 5) {
				primitivebase_changes.$$scope = { dirty, ctx };
			}

			primitivebase.$set(primitivebase_changes);
		},
		i(local) {
			if (current) return;
			transition_in(primitivebase.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(primitivebase.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(primitivebase, detaching);
		}
	};
}

const typeOf = "boolean";

function instance$k($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { value } = $$props;

	$$self.$$set = $$props => {
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	return [value, slots, $$scope];
}

class BooleanFormatter extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-4iglbr-style")) add_css$c();
		init(this, options, instance$k, create_fragment$l, safe_not_equal, { value: 0 });
	}
}

var BooleanFormatter$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': BooleanFormatter,
    typeOf: typeOf
});

/* node_modules/svelte-inspect/inspect/Echo.svelte generated by Svelte v3.31.0 */

const get_slot_slot_changes = dirty => ({});
const get_slot_slot_context = ctx => ({});

function create_fragment$m(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[1].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);
	const slot_slot_template = /*#slots*/ ctx[1].slot;
	const slot_slot = create_slot(slot_slot_template, ctx, /*$$scope*/ ctx[0], get_slot_slot_context);

	return {
		c() {
			if (default_slot) default_slot.c();
			if (slot_slot) slot_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			if (slot_slot) {
				slot_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 1) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[0], dirty, null, null);
				}
			}

			if (slot_slot) {
				if (slot_slot.p && dirty & /*$$scope*/ 1) {
					update_slot(slot_slot, slot_slot_template, ctx, /*$$scope*/ ctx[0], dirty, get_slot_slot_changes, get_slot_slot_context);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(slot_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			transition_out(slot_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
			if (slot_slot) slot_slot.d(detaching);
		}
	};
}

function instance$l($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
	};

	return [$$scope, slots];
}

class Echo extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$l, create_fragment$m, safe_not_equal, {});
	}
}

/* node_modules/svelte-inspect/inspect/formatters/SymbolFormatter.svelte generated by Svelte v3.31.0 */

function add_css$d() {
	var style = element("style");
	style.id = "svelte-s7yhao-style";
	style.textContent = ".key.svelte-s7yhao{white-space:pre-wrap;color:var(--color-red)}.affix.svelte-s7yhao{color:var(--color-pink)}";
	append(document.head, style);
}

// (21:4) <span slot=slot class=affix>
function create_slot_slot(ctx) {
	let span0;
	let t0;
	let span1;
	let t1;
	let span2;

	return {
		c() {
			span0 = element("span");
			t0 = text$1(/*prefix*/ ctx[2]);
			span1 = element("span");
			t1 = text$1(/*key*/ ctx[1]);
			span2 = element("span");
			span2.textContent = ")";
			attr(span0, "slot", "slot");
			attr(span0, "class", "affix svelte-s7yhao");
			attr(span1, "slot", "slot");
			attr(span1, "class", "key svelte-s7yhao");
			attr(span2, "slot", "slot");
			attr(span2, "class", "affix svelte-s7yhao");
		},
		m(target, anchor) {
			insert(target, span0, anchor);
			append(span0, t0);
			insert(target, span1, anchor);
			append(span1, t1);
			insert(target, span2, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*prefix*/ 4) set_data(t0, /*prefix*/ ctx[2]);
			if (dirty & /*key*/ 2) set_data(t1, /*key*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) detach(span0);
			if (detaching) detach(span1);
			if (detaching) detach(span2);
		}
	};
}

// (18:2) <Echo>
function create_default_slot_1$1(ctx) {
	let t0;
	let t1;

	return {
		c() {
			t0 = space();
			t1 = space();
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
		}
	};
}

// (16:0) <PrimitiveBase {value}>
function create_default_slot$6(ctx) {
	let t;
	let echo;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

	echo = new Echo({
			props: {
				$$slots: {
					default: [create_default_slot_1$1],
					slot: [create_slot_slot]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			if (default_slot) default_slot.c();
			t = space();
			create_component(echo.$$.fragment);
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			insert(target, t, anchor);
			mount_component(echo, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
				}
			}

			const echo_changes = {};

			if (dirty & /*$$scope, key, prefix*/ 38) {
				echo_changes.$$scope = { dirty, ctx };
			}

			echo.$set(echo_changes);
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(echo.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			transition_out(echo.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
			if (detaching) detach(t);
			destroy_component(echo, detaching);
		}
	};
}

function create_fragment$n(ctx) {
	let primitivebase;
	let current;

	primitivebase = new PrimitiveBase({
			props: {
				value: /*value*/ ctx[0],
				$$slots: { default: [create_default_slot$6] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(primitivebase.$$.fragment);
		},
		m(target, anchor) {
			mount_component(primitivebase, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const primitivebase_changes = {};
			if (dirty & /*value*/ 1) primitivebase_changes.value = /*value*/ ctx[0];

			if (dirty & /*$$scope, key, prefix*/ 38) {
				primitivebase_changes.$$scope = { dirty, ctx };
			}

			primitivebase.$set(primitivebase_changes);
		},
		i(local) {
			if (current) return;
			transition_in(primitivebase.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(primitivebase.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(primitivebase, detaching);
		}
	};
}

const typeOf$1 = "symbol";

function instance$m($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { value } = $$props;

	$$self.$$set = $$props => {
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("$$scope" in $$props) $$invalidate(5, $$scope = $$props.$$scope);
	};

	let isWellKnown;
	let key;
	let prefix;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 1) {
			 $$invalidate(3, isWellKnown = Symbol.keyFor(value) !== undefined);
		}

		if ($$self.$$.dirty & /*isWellKnown, value*/ 9) {
			 $$invalidate(1, key = isWellKnown
			? Symbol.keyFor(value)
			: String(value).slice(7, -1));
		}

		if ($$self.$$.dirty & /*isWellKnown*/ 8) {
			 $$invalidate(2, prefix = isWellKnown ? "Symbol.for(" : "Symbol(");
		}
	};

	return [value, key, prefix, isWellKnown, slots, $$scope];
}

class SymbolFormatter extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-s7yhao-style")) add_css$d();
		init(this, options, instance$m, create_fragment$n, safe_not_equal, { value: 0 });
	}
}

var SymbolFormatter$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': SymbolFormatter,
    typeOf: typeOf$1
});

/* node_modules/svelte-inspect/inspect/formatters/NumberFormatter.svelte generated by Svelte v3.31.0 */

function add_css$e() {
	var style = element("style");
	style.id = "svelte-1wkpp4a-style";
	style.textContent = ".digits.svelte-1wkpp4a{color:var(--color-blue)}.punctuation.svelte-1wkpp4a{color:var(--color-black)}";
	append(document.head, style);
}

function get_each_context$4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i];
	child_ctx[6] = i;
	return child_ctx;
}

// (16:4) {#if group.length}
function create_if_block$8(ctx) {
	let span;
	let t_value = /*group*/ ctx[4] + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text$1(t_value);
			attr(span, "class", "svelte-1wkpp4a");
			toggle_class(span, "digits", /*index*/ ctx[6] % 2);
			toggle_class(span, "punctuation", !(/*index*/ ctx[6] % 2));
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*stringified*/ 2 && t_value !== (t_value = /*group*/ ctx[4] + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (15:2) {#each stringified.split(/(\d+)/) as group, index}
function create_each_block$4(ctx) {
	let if_block_anchor;
	let if_block = /*group*/ ctx[4].length && create_if_block$8(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (/*group*/ ctx[4].length) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$8(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (13:0) <PrimitiveBase {value}>
function create_default_slot$7(ctx) {
	let t;
	let each_1_anchor;
	let current;
	const default_slot_template = /*#slots*/ ctx[2].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let each_value = /*stringified*/ ctx[1].split(/(\d+)/);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
	}

	return {
		c() {
			if (default_slot) default_slot.c();
			t = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			insert(target, t, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			if (dirty & /*stringified*/ 2) {
				each_value = /*stringified*/ ctx[1].split(/(\d+)/);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$4(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$4(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
			if (detaching) detach(t);
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

function create_fragment$o(ctx) {
	let primitivebase;
	let current;

	primitivebase = new PrimitiveBase({
			props: {
				value: /*value*/ ctx[0],
				$$slots: { default: [create_default_slot$7] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(primitivebase.$$.fragment);
		},
		m(target, anchor) {
			mount_component(primitivebase, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const primitivebase_changes = {};
			if (dirty & /*value*/ 1) primitivebase_changes.value = /*value*/ ctx[0];

			if (dirty & /*$$scope, stringified*/ 10) {
				primitivebase_changes.$$scope = { dirty, ctx };
			}

			primitivebase.$set(primitivebase_changes);
		},
		i(local) {
			if (current) return;
			transition_in(primitivebase.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(primitivebase.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(primitivebase, detaching);
		}
	};
}

const typeOf$2 = "number";

function instance$n($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { value } = $$props;

	$$self.$$set = $$props => {
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("$$scope" in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	let stringified;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 1) {
			 $$invalidate(1, stringified = Object.is(value, -0)
			? "-0"
			: Number.prototype.toString.call(value, 10));
		}
	};

	return [value, stringified, slots, $$scope];
}

class NumberFormatter extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1wkpp4a-style")) add_css$e();
		init(this, options, instance$n, create_fragment$o, safe_not_equal, { value: 0 });
	}
}

var NumberFormatter$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': NumberFormatter,
    typeOf: typeOf$2
});

/* node_modules/svelte-inspect/inspect/formatters/BigIntFormatter.svelte generated by Svelte v3.31.0 */

function add_css$f() {
	var style = element("style");
	style.id = "svelte-1wkpp4a-style";
	style.textContent = ".digits.svelte-1wkpp4a{color:var(--color-blue)}.punctuation.svelte-1wkpp4a{color:var(--color-black)}";
	append(document.head, style);
}

function get_each_context$5(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i];
	child_ctx[6] = i;
	return child_ctx;
}

// (16:4) {#if group.length}
function create_if_block$9(ctx) {
	let span;
	let t_value = /*group*/ ctx[4] + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text$1(t_value);
			attr(span, "class", "svelte-1wkpp4a");
			toggle_class(span, "digits", /*index*/ ctx[6] % 2);
			toggle_class(span, "punctuation", !(/*index*/ ctx[6] % 2));
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*stringified*/ 2 && t_value !== (t_value = /*group*/ ctx[4] + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (15:2) {#each stringified.split(/(\d+)/) as group, index}
function create_each_block$5(ctx) {
	let if_block_anchor;
	let if_block = /*group*/ ctx[4].length && create_if_block$9(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (/*group*/ ctx[4].length) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$9(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (13:0) <PrimitiveBase {value}>
function create_default_slot$8(ctx) {
	let t;
	let each_1_anchor;
	let current;
	const default_slot_template = /*#slots*/ ctx[2].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let each_value = /*stringified*/ ctx[1].split(/(\d+)/);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
	}

	return {
		c() {
			if (default_slot) default_slot.c();
			t = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			insert(target, t, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			if (dirty & /*stringified*/ 2) {
				each_value = /*stringified*/ ctx[1].split(/(\d+)/);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$5(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$5(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
			if (detaching) detach(t);
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

function create_fragment$p(ctx) {
	let primitivebase;
	let current;

	primitivebase = new PrimitiveBase({
			props: {
				value: /*value*/ ctx[0],
				$$slots: { default: [create_default_slot$8] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(primitivebase.$$.fragment);
		},
		m(target, anchor) {
			mount_component(primitivebase, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const primitivebase_changes = {};
			if (dirty & /*value*/ 1) primitivebase_changes.value = /*value*/ ctx[0];

			if (dirty & /*$$scope, stringified*/ 10) {
				primitivebase_changes.$$scope = { dirty, ctx };
			}

			primitivebase.$set(primitivebase_changes);
		},
		i(local) {
			if (current) return;
			transition_in(primitivebase.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(primitivebase.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(primitivebase, detaching);
		}
	};
}

const typeOf$3 = "bigint";

function instance$o($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { value } = $$props;

	$$self.$$set = $$props => {
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("$$scope" in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	let stringified;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 1) {
			 $$invalidate(1, stringified = BigInt.prototype.toString.call(value) + "n");
		}
	};

	return [value, stringified, slots, $$scope];
}

class BigIntFormatter extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1wkpp4a-style")) add_css$f();
		init(this, options, instance$o, create_fragment$p, safe_not_equal, { value: 0 });
	}
}

var BigIntFormatter$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': BigIntFormatter,
    typeOf: typeOf$3
});

/* node_modules/svelte-inspect/inspect/formatters/StringFormatter.svelte generated by Svelte v3.31.0 */

function add_css$g() {
	var style = element("style");
	style.id = "svelte-1d160oy-style";
	style.textContent = ".string.svelte-1d160oy:after,.string.svelte-1d160oy:before{content:'\"';color:var(--color-black)}.chars.svelte-1d160oy{white-space:pre-wrap;color:var(--color-red)}.chars.escape.svelte-1d160oy{color:var(--color-pink)}";
	append(document.head, style);
}

function get_each_context$6(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i];
	return child_ctx;
}

// (18:4) {#each groups as group}
function create_each_block$6(ctx) {
	let span;
	let t_value = /*group*/ ctx[4] + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text$1(t_value);
			attr(span, "class", "chars svelte-1d160oy");
			toggle_class(span, "escape", isEscapeGroup(/*group*/ ctx[4]));
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*groups*/ 2 && t_value !== (t_value = /*group*/ ctx[4] + "")) set_data(t, t_value);

			if (dirty & /*isEscapeGroup, groups*/ 2) {
				toggle_class(span, "escape", isEscapeGroup(/*group*/ ctx[4]));
			}
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (15:0) <PrimitiveBase {value}>
function create_default_slot$9(ctx) {
	let t;
	let span;
	let current;
	const default_slot_template = /*#slots*/ ctx[2].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let each_value = /*groups*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
	}

	return {
		c() {
			if (default_slot) default_slot.c();
			t = space();
			span = element("span");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(span, "class", "string svelte-1d160oy");
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			insert(target, t, anchor);
			insert(target, span, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(span, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			if (dirty & /*isEscapeGroup, groups*/ 2) {
				each_value = /*groups*/ ctx[1];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$6(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$6(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(span, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
			if (detaching) detach(t);
			if (detaching) detach(span);
			destroy_each(each_blocks, detaching);
		}
	};
}

function create_fragment$q(ctx) {
	let primitivebase;
	let current;

	primitivebase = new PrimitiveBase({
			props: {
				value: /*value*/ ctx[0],
				$$slots: { default: [create_default_slot$9] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(primitivebase.$$.fragment);
		},
		m(target, anchor) {
			mount_component(primitivebase, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const primitivebase_changes = {};
			if (dirty & /*value*/ 1) primitivebase_changes.value = /*value*/ ctx[0];

			if (dirty & /*$$scope, groups*/ 10) {
				primitivebase_changes.$$scope = { dirty, ctx };
			}

			primitivebase.$set(primitivebase_changes);
		},
		i(local) {
			if (current) return;
			transition_in(primitivebase.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(primitivebase.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(primitivebase, detaching);
		}
	};
}

const typeOf$4 = "string";

function instance$p($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { value } = $$props;

	$$self.$$set = $$props => {
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("$$scope" in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	let groups;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 1) {
			 $$invalidate(1, groups = stringEscapeGroups(value));
		}
	};

	return [value, groups, slots, $$scope];
}

class StringFormatter extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1d160oy-style")) add_css$g();
		init(this, options, instance$p, create_fragment$q, safe_not_equal, { value: 0 });
	}
}

var StringFormatter$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': StringFormatter,
    typeOf: typeOf$4
});

/* node_modules/svelte-inspect/inspect/formatters/FunctionFormatter.svelte generated by Svelte v3.31.0 */

function add_css$h() {
	var style = element("style");
	style.id = "svelte-37n4yo-style";
	style.textContent = ".default.svelte-37n4yo{color:var(--color-gray)}.function-keyword.svelte-37n4yo{color:var(--color-black)}.async-keyword.svelte-37n4yo{color:var(--color-green)}.class-keyword.svelte-37n4yo{color:var(--color-purple)}.identifier.svelte-37n4yo{color:var(--color-blue)}";
	append(document.head, style);
}

function get_each_context$7(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i].key;
	child_ctx[6] = list[i].match;
	return child_ctx;
}

// (24:4) {#each grouper(functionString) as {key, match}}
function create_each_block$7(ctx) {
	let span;
	let t_value = /*match*/ ctx[6] + "";
	let t;
	let span_class_value;

	return {
		c() {
			span = element("span");
			t = text$1(t_value);
			attr(span, "class", span_class_value = "" + (null_to_empty(/*key*/ ctx[5] || "default") + " svelte-37n4yo"));
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*functionString*/ 2 && t_value !== (t_value = /*match*/ ctx[6] + "")) set_data(t, t_value);

			if (dirty & /*functionString*/ 2 && span_class_value !== (span_class_value = "" + (null_to_empty(/*key*/ ctx[5] || "default") + " svelte-37n4yo"))) {
				attr(span, "class", span_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (21:0) <PrimitiveBase {value}>
function create_default_slot$a(ctx) {
	let t;
	let span;
	let current;
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let each_value = /*grouper*/ ctx[2](/*functionString*/ ctx[1]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
	}

	return {
		c() {
			if (default_slot) default_slot.c();
			t = space();
			span = element("span");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			insert(target, t, anchor);
			insert(target, span, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(span, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}

			if (dirty & /*grouper, functionString*/ 6) {
				each_value = /*grouper*/ ctx[2](/*functionString*/ ctx[1]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$7(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$7(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(span, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
			if (detaching) detach(t);
			if (detaching) detach(span);
			destroy_each(each_blocks, detaching);
		}
	};
}

function create_fragment$r(ctx) {
	let primitivebase;
	let current;

	primitivebase = new PrimitiveBase({
			props: {
				value: /*value*/ ctx[0],
				$$slots: { default: [create_default_slot$a] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(primitivebase.$$.fragment);
		},
		m(target, anchor) {
			mount_component(primitivebase, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const primitivebase_changes = {};
			if (dirty & /*value*/ 1) primitivebase_changes.value = /*value*/ ctx[0];

			if (dirty & /*$$scope, functionString*/ 18) {
				primitivebase_changes.$$scope = { dirty, ctx };
			}

			primitivebase.$set(primitivebase_changes);
		},
		i(local) {
			if (current) return;
			transition_in(primitivebase.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(primitivebase.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(primitivebase, detaching);
		}
	};
}

const typeOf$5 = "function";

function instance$q($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;

	const grouper = groupByRegexes({
		"function-keyword": /(|function|\=\>)/,
		"async-keyword": /(async|await)/,
		"class-keyword": /(class|extends)/,
		identifier: /(\d|\w|_|\$)+/
	});

	let { value } = $$props;

	$$self.$$set = $$props => {
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("$$scope" in $$props) $$invalidate(4, $$scope = $$props.$$scope);
	};

	let functionString;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 1) {
			 $$invalidate(1, functionString = Function.prototype.toString.call(value).split("\n")[0].replace(/^function/, ""));
		}
	};

	return [value, functionString, grouper, slots, $$scope];
}

class FunctionFormatter extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-37n4yo-style")) add_css$h();
		init(this, options, instance$q, create_fragment$r, safe_not_equal, { value: 0 });
	}
}

var FunctionFormatter$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': FunctionFormatter,
    typeOf: typeOf$5
});

/* node_modules/svelte-inspect/inspect/formatters/RegExpFormatter.svelte generated by Svelte v3.31.0 */

function add_css$i() {
	var style = element("style");
	style.id = "svelte-1s91rjr-style";
	style.textContent = ".slash.svelte-1s91rjr{color:var(--color-black)}.source.svelte-1s91rjr{white-space:pre-wrap;color:var(--color-red)}.flags.svelte-1s91rjr{color:var(--color-pink)}";
	append(document.head, style);
}

// (22:6) <span slot=slot class=flags>
function create_slot_slot$1(ctx) {
	let span0;
	let span1;
	let t1;
	let span2;
	let span3;
	let t3;

	return {
		c() {
			span0 = element("span");
			span0.textContent = "/";
			span1 = element("span");
			t1 = text$1(/*source*/ ctx[1]);
			span2 = element("span");
			span2.textContent = "/";
			span3 = element("span");
			t3 = text$1(/*flags*/ ctx[2]);
			attr(span0, "slot", "slot");
			attr(span0, "class", "slash svelte-1s91rjr");
			attr(span1, "slot", "slot");
			attr(span1, "class", "source svelte-1s91rjr");
			attr(span2, "slot", "slot");
			attr(span2, "class", "slash svelte-1s91rjr");
			attr(span3, "slot", "slot");
			attr(span3, "class", "flags svelte-1s91rjr");
		},
		m(target, anchor) {
			insert(target, span0, anchor);
			insert(target, span1, anchor);
			append(span1, t1);
			insert(target, span2, anchor);
			insert(target, span3, anchor);
			append(span3, t3);
		},
		p(ctx, dirty) {
			if (dirty & /*source*/ 2) set_data(t1, /*source*/ ctx[1]);
			if (dirty & /*flags*/ 4) set_data(t3, /*flags*/ ctx[2]);
		},
		d(detaching) {
			if (detaching) detach(span0);
			if (detaching) detach(span1);
			if (detaching) detach(span2);
			if (detaching) detach(span3);
		}
	};
}

// (18:4) <Echo>
function create_default_slot_1$2(ctx) {
	let t0;
	let t1;
	let t2;

	return {
		c() {
			t0 = space();
			t1 = space();
			t2 = space();
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
			insert(target, t2, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
			if (detaching) detach(t2);
		}
	};
}

// (15:0) <PrimitiveBase {value}>
function create_default_slot$b(ctx) {
	let t;
	let span;
	let echo;
	let current;
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	echo = new Echo({
			props: {
				$$slots: {
					default: [create_default_slot_1$2],
					slot: [create_slot_slot$1]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			if (default_slot) default_slot.c();
			t = space();
			span = element("span");
			create_component(echo.$$.fragment);
			attr(span, "class", "regexp");
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			insert(target, t, anchor);
			insert(target, span, anchor);
			mount_component(echo, span, null);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}

			const echo_changes = {};

			if (dirty & /*$$scope, flags, source*/ 22) {
				echo_changes.$$scope = { dirty, ctx };
			}

			echo.$set(echo_changes);
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(echo.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			transition_out(echo.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
			if (detaching) detach(t);
			if (detaching) detach(span);
			destroy_component(echo);
		}
	};
}

function create_fragment$s(ctx) {
	let primitivebase;
	let current;

	primitivebase = new PrimitiveBase({
			props: {
				value: /*value*/ ctx[0],
				$$slots: { default: [create_default_slot$b] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(primitivebase.$$.fragment);
		},
		m(target, anchor) {
			mount_component(primitivebase, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const primitivebase_changes = {};
			if (dirty & /*value*/ 1) primitivebase_changes.value = /*value*/ ctx[0];

			if (dirty & /*$$scope, flags, source*/ 22) {
				primitivebase_changes.$$scope = { dirty, ctx };
			}

			primitivebase.$set(primitivebase_changes);
		},
		i(local) {
			if (current) return;
			transition_in(primitivebase.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(primitivebase.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(primitivebase, detaching);
		}
	};
}

const type$1 = RegExp;

function instance$r($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { value } = $$props;

	$$self.$$set = $$props => {
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("$$scope" in $$props) $$invalidate(4, $$scope = $$props.$$scope);
	};

	let source;
	let flags;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 1) {
			 $$invalidate(1, source = value.source);
		}

		if ($$self.$$.dirty & /*value*/ 1) {
			 $$invalidate(2, flags = value.flags);
		}
	};

	return [value, source, flags, slots, $$scope];
}

class RegExpFormatter extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1s91rjr-style")) add_css$i();
		init(this, options, instance$r, create_fragment$s, safe_not_equal, { value: 0 });
	}
}

var RegExpFormatter$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': RegExpFormatter,
    type: type$1
});

/* node_modules/svelte-inspect/inspect/formatters/DateFormatter.svelte generated by Svelte v3.31.0 */

function add_css$j() {
	var style = element("style");
	style.id = "svelte-q9phio-style";
	style.textContent = ".default.svelte-q9phio.svelte-q9phio{color:var(--color-gray)}.date.svelte-q9phio .number.svelte-q9phio{color:var(--color-blue)}.time.svelte-q9phio .number.svelte-q9phio{color:var(--color-purple)}";
	append(document.head, style);
}

function get_each_context$8(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i].key;
	child_ctx[8] = list[i].match;
	return child_ctx;
}

function get_each_context_1$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i].key;
	child_ctx[8] = list[i].match;
	return child_ctx;
}

// (26:6) {#each grouper(date) as {key, match}}
function create_each_block_1$2(ctx) {
	let span;
	let t_value = /*match*/ ctx[8] + "";
	let t;
	let span_class_value;

	return {
		c() {
			span = element("span");
			t = text$1(t_value);
			attr(span, "class", span_class_value = "" + (null_to_empty(/*key*/ ctx[7] || "default") + " svelte-q9phio"));
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*date*/ 2 && t_value !== (t_value = /*match*/ ctx[8] + "")) set_data(t, t_value);

			if (dirty & /*date*/ 2 && span_class_value !== (span_class_value = "" + (null_to_empty(/*key*/ ctx[7] || "default") + " svelte-q9phio"))) {
				attr(span, "class", span_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (31:6) {#each grouper(time) as {key, match}}
function create_each_block$8(ctx) {
	let span;
	let t_value = /*match*/ ctx[8] + "";
	let t;
	let span_class_value;

	return {
		c() {
			span = element("span");
			t = text$1(t_value);
			attr(span, "class", span_class_value = "" + (null_to_empty(/*key*/ ctx[7] || "default") + " svelte-q9phio"));
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*time*/ 4 && t_value !== (t_value = /*match*/ ctx[8] + "")) set_data(t, t_value);

			if (dirty & /*time*/ 4 && span_class_value !== (span_class_value = "" + (null_to_empty(/*key*/ ctx[7] || "default") + " svelte-q9phio"))) {
				attr(span, "class", span_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (35:4) <span slot=slot>
function create_slot_slot$2(ctx) {
	let span0;
	let span1;
	let span2;
	let span3;
	let each_value_1 = /*grouper*/ ctx[3](/*date*/ ctx[1]);
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks_1[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
	}

	let each_value = /*grouper*/ ctx[3](/*time*/ ctx[2]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
	}

	return {
		c() {
			span0 = element("span");
			span0.textContent = "Date(";
			span1 = element("span");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			span2 = element("span");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			span3 = element("span");
			span3.textContent = ")";
			attr(span0, "slot", "slot");
			attr(span1, "slot", "slot");
			attr(span1, "class", "date svelte-q9phio");
			attr(span2, "slot", "slot");
			attr(span2, "class", "time svelte-q9phio");
			attr(span3, "slot", "slot");
		},
		m(target, anchor) {
			insert(target, span0, anchor);
			insert(target, span1, anchor);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(span1, null);
			}

			insert(target, span2, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(span2, null);
			}

			insert(target, span3, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*grouper, date*/ 10) {
				each_value_1 = /*grouper*/ ctx[3](/*date*/ ctx[1]);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_1$2(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(span1, null);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_1.length;
			}

			if (dirty & /*grouper, time*/ 12) {
				each_value = /*grouper*/ ctx[3](/*time*/ ctx[2]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$8(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$8(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(span2, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d(detaching) {
			if (detaching) detach(span0);
			if (detaching) detach(span1);
			destroy_each(each_blocks_1, detaching);
			if (detaching) detach(span2);
			destroy_each(each_blocks, detaching);
			if (detaching) detach(span3);
		}
	};
}

// (23:2) <Echo>
function create_default_slot_1$3(ctx) {
	let t0;
	let t1;
	let t2;

	return {
		c() {
			t0 = space();
			t1 = space();
			t2 = space();
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
			insert(target, t2, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
			if (detaching) detach(t2);
		}
	};
}

// (21:0) <PrimitiveBase {value}>
function create_default_slot$c(ctx) {
	let t;
	let echo;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

	echo = new Echo({
			props: {
				$$slots: {
					default: [create_default_slot_1$3],
					slot: [create_slot_slot$2]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			if (default_slot) default_slot.c();
			t = space();
			create_component(echo.$$.fragment);
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			insert(target, t, anchor);
			mount_component(echo, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
				}
			}

			const echo_changes = {};

			if (dirty & /*$$scope, time, date*/ 70) {
				echo_changes.$$scope = { dirty, ctx };
			}

			echo.$set(echo_changes);
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(echo.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			transition_out(echo.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
			if (detaching) detach(t);
			destroy_component(echo, detaching);
		}
	};
}

function create_fragment$t(ctx) {
	let primitivebase;
	let current;

	primitivebase = new PrimitiveBase({
			props: {
				value: /*value*/ ctx[0],
				$$slots: { default: [create_default_slot$c] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(primitivebase.$$.fragment);
		},
		m(target, anchor) {
			mount_component(primitivebase, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const primitivebase_changes = {};
			if (dirty & /*value*/ 1) primitivebase_changes.value = /*value*/ ctx[0];

			if (dirty & /*$$scope, time, date*/ 70) {
				primitivebase_changes.$$scope = { dirty, ctx };
			}

			primitivebase.$set(primitivebase_changes);
		},
		i(local) {
			if (current) return;
			transition_in(primitivebase.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(primitivebase.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(primitivebase, detaching);
		}
	};
}

const type$2 = Date;

function instance$s($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	const grouper = groupByRegexes({ "number": /[0-9]+/ });
	let { value } = $$props;

	$$self.$$set = $$props => {
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("$$scope" in $$props) $$invalidate(6, $$scope = $$props.$$scope);
	};

	let ISOString;
	let date;
	let time;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 1) {
			 $$invalidate(4, ISOString = Date.prototype.toISOString.call(value));
		}

		if ($$self.$$.dirty & /*ISOString*/ 16) {
			 $$invalidate(1, date = ISOString.slice(0, 10));
		}

		if ($$self.$$.dirty & /*ISOString*/ 16) {
			 $$invalidate(2, time = ISOString.slice(10));
		}
	};

	return [value, date, time, grouper, ISOString, slots, $$scope];
}

class DateFormatter extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-q9phio-style")) add_css$j();
		init(this, options, instance$s, create_fragment$t, safe_not_equal, { value: 0 });
	}
}

var DateFormatter$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': DateFormatter,
    type: type$2
});

/* node_modules/svelte-inspect/inspect/formatters/ErrorFormatter.svelte generated by Svelte v3.31.0 */

function add_css$k() {
	var style = element("style");
	style.id = "svelte-3kqtoi-style";
	style.textContent = ".error.svelte-3kqtoi{color:var(--color-red)}";
	append(document.head, style);
}

// (11:0) <PrimitiveBase {value}>
function create_default_slot$d(ctx) {
	let t0;
	let span;
	let t1_value = String(/*value*/ ctx[0]) + "";
	let t1;
	let current;
	const default_slot_template = /*#slots*/ ctx[1].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	return {
		c() {
			if (default_slot) default_slot.c();
			t0 = space();
			span = element("span");
			t1 = text$1(t1_value);
			attr(span, "class", "error svelte-3kqtoi");
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			insert(target, t0, anchor);
			insert(target, span, anchor);
			append(span, t1);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
				}
			}

			if ((!current || dirty & /*value*/ 1) && t1_value !== (t1_value = String(/*value*/ ctx[0]) + "")) set_data(t1, t1_value);
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(span);
		}
	};
}

function create_fragment$u(ctx) {
	let primitivebase;
	let current;

	primitivebase = new PrimitiveBase({
			props: {
				value: /*value*/ ctx[0],
				$$slots: { default: [create_default_slot$d] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(primitivebase.$$.fragment);
		},
		m(target, anchor) {
			mount_component(primitivebase, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const primitivebase_changes = {};
			if (dirty & /*value*/ 1) primitivebase_changes.value = /*value*/ ctx[0];

			if (dirty & /*$$scope, value*/ 5) {
				primitivebase_changes.$$scope = { dirty, ctx };
			}

			primitivebase.$set(primitivebase_changes);
		},
		i(local) {
			if (current) return;
			transition_in(primitivebase.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(primitivebase.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(primitivebase, detaching);
		}
	};
}

const check$1 = value => value instanceof Error;

function instance$t($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { value } = $$props;

	$$self.$$set = $$props => {
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	return [value, slots, $$scope];
}

class ErrorFormatter extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-3kqtoi-style")) add_css$k();
		init(this, options, instance$t, create_fragment$u, safe_not_equal, { value: 0 });
	}
}

var ErrorFormatter$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': ErrorFormatter,
    check: check$1
});

/* node_modules/svelte-inspect/inspect/formatters/ArrayFormatter.svelte generated by Svelte v3.31.0 */

function add_css$l() {
	var style = element("style");
	style.id = "svelte-1jdc0qe-style";
	style.textContent = ".array.svelte-1jdc0qe{color:var(--color-black)}.length.svelte-1jdc0qe{color:var(--color-blue)}.on-intent.svelte-1jdc0qe{display:none}.array-toggle:hover>.on-intent.svelte-1jdc0qe,.array-toggle:focus>.on-intent.svelte-1jdc0qe{display:inline}";
	append(document.head, style);
}

// (22:4) <span slot=slot class=array>
function create_slot_slot$3(ctx) {
	let span0;
	let span1;
	let t1_value = /*value*/ ctx[1].length + "";
	let t1;
	let span2;

	return {
		c() {
			span0 = element("span");
			span0.textContent = "Array(";
			span1 = element("span");
			t1 = text$1(t1_value);
			span2 = element("span");
			span2.textContent = ")";
			attr(span0, "slot", "slot");
			attr(span0, "class", "array svelte-1jdc0qe");
			attr(span1, "slot", "slot");
			attr(span1, "class", "length svelte-1jdc0qe");
			attr(span2, "slot", "slot");
			attr(span2, "class", "array svelte-1jdc0qe");
		},
		m(target, anchor) {
			insert(target, span0, anchor);
			insert(target, span1, anchor);
			append(span1, t1);
			insert(target, span2, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*value*/ 2 && t1_value !== (t1_value = /*value*/ ctx[1].length + "")) set_data(t1, t1_value);
		},
		d(detaching) {
			if (detaching) detach(span0);
			if (detaching) detach(span1);
			if (detaching) detach(span2);
		}
	};
}

// (19:2) <Echo>
function create_default_slot_2(ctx) {
	let t0;
	let t1;

	return {
		c() {
			t0 = space();
			t1 = space();
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
		}
	};
}

// (24:3) {#if !isOpen}
function create_if_block_1$4(ctx) {
	let span;
	let t1;

	return {
		c() {
			span = element("span");
			span.textContent = "";
			t1 = text$1("]");
			attr(span, "class", "on-intent svelte-1jdc0qe");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			insert(target, t1, anchor);
		},
		d(detaching) {
			if (detaching) detach(span);
			if (detaching) detach(t1);
		}
	};
}

// (17:0) <Toggle className=array-toggle bind:isOpen>
function create_default_slot_1$4(ctx) {
	let t0;
	let echo;
	let t1;
	let if_block_anchor;
	let current;
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

	echo = new Echo({
			props: {
				$$slots: {
					default: [create_default_slot_2],
					slot: [create_slot_slot$3]
				},
				$$scope: { ctx }
			}
		});

	let if_block = !/*isOpen*/ ctx[2] && create_if_block_1$4();

	return {
		c() {
			if (default_slot) default_slot.c();
			t0 = space();
			create_component(echo.$$.fragment);
			t1 = text$1("\n  [");
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			insert(target, t0, anchor);
			mount_component(echo, target, anchor);
			insert(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
				}
			}

			const echo_changes = {};

			if (dirty & /*$$scope, value*/ 34) {
				echo_changes.$$scope = { dirty, ctx };
			}

			echo.$set(echo_changes);

			if (!/*isOpen*/ ctx[2]) {
				if (if_block) ; else {
					if_block = create_if_block_1$4();
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(echo.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			transition_out(echo.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
			if (detaching) detach(t0);
			destroy_component(echo, detaching);
			if (detaching) detach(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (29:0) {#if isOpen}
function create_if_block$a(ctx) {
	let propertylist;
	let t;
	let current;

	propertylist = new PropertyList({
			props: {
				depth: /*depth*/ ctx[0],
				value: /*value*/ ctx[1],
				$$slots: { default: [create_default_slot$e] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(propertylist.$$.fragment);
			t = text$1("\n  ]");
		},
		m(target, anchor) {
			mount_component(propertylist, target, anchor);
			insert(target, t, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const propertylist_changes = {};
			if (dirty & /*depth*/ 1) propertylist_changes.depth = /*depth*/ ctx[0];
			if (dirty & /*value*/ 2) propertylist_changes.value = /*value*/ ctx[1];

			if (dirty & /*$$scope*/ 32) {
				propertylist_changes.$$scope = { dirty, ctx };
			}

			propertylist.$set(propertylist_changes);
		},
		i(local) {
			if (current) return;
			transition_in(propertylist.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(propertylist.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(propertylist, detaching);
			if (detaching) detach(t);
		}
	};
}

// (30:2) <PropertyList     {depth}     {value}   >
function create_default_slot$e(ctx) {
	let t;

	return {
		c() {
			t = text$1("Empty array");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment$v(ctx) {
	let toggle;
	let updating_isOpen;
	let t;
	let if_block_anchor;
	let current;

	function toggle_isOpen_binding(value) {
		/*toggle_isOpen_binding*/ ctx[4].call(null, value);
	}

	let toggle_props = {
		className: "array-toggle",
		$$slots: { default: [create_default_slot_1$4] },
		$$scope: { ctx }
	};

	if (/*isOpen*/ ctx[2] !== void 0) {
		toggle_props.isOpen = /*isOpen*/ ctx[2];
	}

	toggle = new Toggle({ props: toggle_props });
	binding_callbacks.push(() => bind(toggle, "isOpen", toggle_isOpen_binding));
	let if_block = /*isOpen*/ ctx[2] && create_if_block$a(ctx);

	return {
		c() {
			create_component(toggle.$$.fragment);
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			mount_component(toggle, target, anchor);
			insert(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const toggle_changes = {};

			if (dirty & /*$$scope, isOpen, value*/ 38) {
				toggle_changes.$$scope = { dirty, ctx };
			}

			if (!updating_isOpen && dirty & /*isOpen*/ 4) {
				updating_isOpen = true;
				toggle_changes.isOpen = /*isOpen*/ ctx[2];
				add_flush_callback(() => updating_isOpen = false);
			}

			toggle.$set(toggle_changes);

			if (/*isOpen*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*isOpen*/ 4) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$a(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(toggle.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(toggle.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			destroy_component(toggle, detaching);
			if (detaching) detach(t);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

const type$3 = Array;
const hasDepthProp = true;

function instance$u($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { depth = 0 } = $$props;
	let { value } = $$props;
	let isOpen = depth > 0;

	function toggle_isOpen_binding(value) {
		isOpen = value;
		$$invalidate(2, isOpen);
	}

	$$self.$$set = $$props => {
		if ("depth" in $$props) $$invalidate(0, depth = $$props.depth);
		if ("value" in $$props) $$invalidate(1, value = $$props.value);
		if ("$$scope" in $$props) $$invalidate(5, $$scope = $$props.$$scope);
	};

	return [depth, value, isOpen, slots, toggle_isOpen_binding, $$scope];
}

class ArrayFormatter extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1jdc0qe-style")) add_css$l();
		init(this, options, instance$u, create_fragment$v, safe_not_equal, { depth: 0, value: 1 });
	}
}

var ArrayFormatter$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': ArrayFormatter,
    type: type$3,
    hasDepthProp: hasDepthProp
});

/* node_modules/svelte-inspect/inspect/formatters/TypedArrayFormatter.svelte generated by Svelte v3.31.0 */

function add_css$m() {
	var style = element("style");
	style.id = "svelte-1tg2qv5-style";
	style.textContent = ".typed-array.svelte-1tg2qv5{color:var(--color-black)}.length.svelte-1tg2qv5{color:var(--color-blue)}.on-intent.svelte-1tg2qv5{display:none}.array-toggle:hover>.on-intent.svelte-1tg2qv5,.array-toggle:focus>.on-intent.svelte-1tg2qv5{display:inline}";
	append(document.head, style);
}

// (43:4) <span slot=slot class=typed-array>
function create_slot_slot$4(ctx) {
	let span0;
	let t0;
	let t1;
	let span1;
	let t2_value = /*value*/ ctx[0].length + "";
	let t2;
	let span2;

	return {
		c() {
			span0 = element("span");
			t0 = text$1(/*typeDescription*/ ctx[2]);
			t1 = text$1("(");
			span1 = element("span");
			t2 = text$1(t2_value);
			span2 = element("span");
			span2.textContent = ")";
			attr(span0, "slot", "slot");
			attr(span0, "class", "typed-array svelte-1tg2qv5");
			attr(span1, "slot", "slot");
			attr(span1, "class", "length svelte-1tg2qv5");
			attr(span2, "slot", "slot");
			attr(span2, "class", "typed-array svelte-1tg2qv5");
		},
		m(target, anchor) {
			insert(target, span0, anchor);
			append(span0, t0);
			append(span0, t1);
			insert(target, span1, anchor);
			append(span1, t2);
			insert(target, span2, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*typeDescription*/ 4) set_data(t0, /*typeDescription*/ ctx[2]);
			if (dirty & /*value*/ 1 && t2_value !== (t2_value = /*value*/ ctx[0].length + "")) set_data(t2, t2_value);
		},
		d(detaching) {
			if (detaching) detach(span0);
			if (detaching) detach(span1);
			if (detaching) detach(span2);
		}
	};
}

// (40:2) <Echo>
function create_default_slot_2$1(ctx) {
	let t0;
	let t1;

	return {
		c() {
			t0 = space();
			t1 = space();
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
		}
	};
}

// (45:3) {#if !isOpen}
function create_if_block_1$5(ctx) {
	let span;
	let t1;

	return {
		c() {
			span = element("span");
			span.textContent = "";
			t1 = text$1("]");
			attr(span, "class", "on-intent svelte-1tg2qv5");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			insert(target, t1, anchor);
		},
		d(detaching) {
			if (detaching) detach(span);
			if (detaching) detach(t1);
		}
	};
}

// (38:0) <Toggle className=typed-array-toggle bind:isOpen>
function create_default_slot_1$5(ctx) {
	let t0;
	let echo;
	let t1;
	let if_block_anchor;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

	echo = new Echo({
			props: {
				$$slots: {
					default: [create_default_slot_2$1],
					slot: [create_slot_slot$4]
				},
				$$scope: { ctx }
			}
		});

	let if_block = !/*isOpen*/ ctx[1] && create_if_block_1$5();

	return {
		c() {
			if (default_slot) default_slot.c();
			t0 = space();
			create_component(echo.$$.fragment);
			t1 = text$1("\n  [");
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			insert(target, t0, anchor);
			mount_component(echo, target, anchor);
			insert(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
				}
			}

			const echo_changes = {};

			if (dirty & /*$$scope, value, typeDescription*/ 69) {
				echo_changes.$$scope = { dirty, ctx };
			}

			echo.$set(echo_changes);

			if (!/*isOpen*/ ctx[1]) {
				if (if_block) ; else {
					if_block = create_if_block_1$5();
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(echo.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			transition_out(echo.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
			if (detaching) detach(t0);
			destroy_component(echo, detaching);
			if (detaching) detach(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (50:0) {#if isOpen}
function create_if_block$b(ctx) {
	let propertylist;
	let t;
	let current;

	propertylist = new PropertyList({
			props: {
				value: /*value*/ ctx[0],
				$$slots: { default: [create_default_slot$f] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(propertylist.$$.fragment);
			t = text$1("\n  ]");
		},
		m(target, anchor) {
			mount_component(propertylist, target, anchor);
			insert(target, t, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const propertylist_changes = {};
			if (dirty & /*value*/ 1) propertylist_changes.value = /*value*/ ctx[0];

			if (dirty & /*$$scope*/ 64) {
				propertylist_changes.$$scope = { dirty, ctx };
			}

			propertylist.$set(propertylist_changes);
		},
		i(local) {
			if (current) return;
			transition_in(propertylist.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(propertylist.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(propertylist, detaching);
			if (detaching) detach(t);
		}
	};
}

// (51:2) <PropertyList     {value}   >
function create_default_slot$f(ctx) {
	let t;

	return {
		c() {
			t = text$1("Empty array");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment$w(ctx) {
	let toggle;
	let updating_isOpen;
	let t;
	let if_block_anchor;
	let current;

	function toggle_isOpen_binding(value) {
		/*toggle_isOpen_binding*/ ctx[5].call(null, value);
	}

	let toggle_props = {
		className: "typed-array-toggle",
		$$slots: { default: [create_default_slot_1$5] },
		$$scope: { ctx }
	};

	if (/*isOpen*/ ctx[1] !== void 0) {
		toggle_props.isOpen = /*isOpen*/ ctx[1];
	}

	toggle = new Toggle({ props: toggle_props });
	binding_callbacks.push(() => bind(toggle, "isOpen", toggle_isOpen_binding));
	let if_block = /*isOpen*/ ctx[1] && create_if_block$b(ctx);

	return {
		c() {
			create_component(toggle.$$.fragment);
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			mount_component(toggle, target, anchor);
			insert(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const toggle_changes = {};

			if (dirty & /*$$scope, isOpen, value, typeDescription*/ 71) {
				toggle_changes.$$scope = { dirty, ctx };
			}

			if (!updating_isOpen && dirty & /*isOpen*/ 2) {
				updating_isOpen = true;
				toggle_changes.isOpen = /*isOpen*/ ctx[1];
				add_flush_callback(() => updating_isOpen = false);
			}

			toggle.$set(toggle_changes);

			if (/*isOpen*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*isOpen*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$b(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(toggle.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(toggle.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			destroy_component(toggle, detaching);
			if (detaching) detach(t);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

const check$2 = value => {
	switch (Object.getPrototypeOf(value)) {
		case Int8Array.prototype:
		case Uint8Array.prototype:
		case Uint8ClampedArray.prototype:
		case Int16Array.prototype:
		case Uint16Array.prototype:
		case Int32Array.prototype:
		case Uint32Array.prototype:
		case Float32Array.prototype:
		case Float64Array.prototype:
		case typeof BigInt64Array !== "undefined" && BigInt64Array.prototype:
		case typeof BigUint64Array !== "undefined" && BigUint64Array.prototype:
			{
				return true;
			}
	}

	return false;
};

const hasDepthProp$1 = true;

function instance$v($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { depth = 0 } = $$props;
	let { value } = $$props;
	let isOpen = depth > 0;

	function toggle_isOpen_binding(value) {
		isOpen = value;
		$$invalidate(1, isOpen);
	}

	$$self.$$set = $$props => {
		if ("depth" in $$props) $$invalidate(3, depth = $$props.depth);
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("$$scope" in $$props) $$invalidate(6, $$scope = $$props.$$scope);
	};

	let typeDescription;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 1) {
			 $$invalidate(2, typeDescription = getObjectTypeString(value));
		}
	};

	return [value, isOpen, typeDescription, depth, slots, toggle_isOpen_binding, $$scope];
}

class TypedArrayFormatter extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1tg2qv5-style")) add_css$m();
		init(this, options, instance$v, create_fragment$w, safe_not_equal, { depth: 3, value: 0 });
	}
}

var TypedArrayFormatter$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': TypedArrayFormatter,
    check: check$2,
    hasDepthProp: hasDepthProp$1
});

/* node_modules/svelte-inspect/inspect/formatters/ElementFormatter.svelte generated by Svelte v3.31.0 */

function add_css$n() {
	var style = element("style");
	style.id = "svelte-1xw7gjz-style";
	style.textContent = ".tag-name.svelte-1xw7gjz{color:var(--color-green)}.punctuation.svelte-1xw7gjz{color:var(--color-black)}.attribute-name.svelte-1xw7gjz{color:var(--color-brown)}.attribute-value.svelte-1xw7gjz{white-space:pre-wrap;color:var(--color-red)}";
	append(document.head, style);
}

function get_each_context$9(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[3] = list[i];
	return child_ctx;
}

// (37:8) {:else}
function create_else_block$3(ctx) {
	let echo;
	let current;

	echo = new Echo({
			props: {
				$$slots: {
					default: [create_default_slot_3],
					slot: [create_slot_slot_2]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(echo.$$.fragment);
		},
		m(target, anchor) {
			mount_component(echo, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const echo_changes = {};

			if (dirty & /*$$scope, value*/ 5) {
				echo_changes.$$scope = { dirty, ctx };
			}

			echo.$set(echo_changes);
		},
		i(local) {
			if (current) return;
			transition_in(echo.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(echo.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(echo, detaching);
		}
	};
}

// (30:8) {#if attribute.value}
function create_if_block$c(ctx) {
	let echo;
	let current;

	echo = new Echo({
			props: {
				$$slots: {
					default: [create_default_slot_2$2],
					slot: [create_slot_slot_1]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(echo.$$.fragment);
		},
		m(target, anchor) {
			mount_component(echo, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const echo_changes = {};

			if (dirty & /*$$scope, value*/ 5) {
				echo_changes.$$scope = { dirty, ctx };
			}

			echo.$set(echo_changes);
		},
		i(local) {
			if (current) return;
			transition_in(echo.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(echo.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(echo, detaching);
		}
	};
}

// (39:12) <span slot=slot class=attribute-name>
function create_slot_slot_2(ctx) {
	let span;
	let t_value = /*attribute*/ ctx[3].name + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text$1(t_value);
			attr(span, "slot", "slot");
			attr(span, "class", "attribute-name svelte-1xw7gjz");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*value*/ 1 && t_value !== (t_value = /*attribute*/ ctx[3].name + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (38:10) <Echo>
function create_default_slot_3(ctx) {
	let t;

	return {
		c() {
			t = space();
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (35:12) <span slot=slot class=punctuation>
function create_slot_slot_1(ctx) {
	let span0;
	let t0_value = /*attribute*/ ctx[3].name + "";
	let t0;
	let span1;
	let span2;
	let t2_value = /*attribute*/ ctx[3].value + "";
	let t2;
	let span3;

	return {
		c() {
			span0 = element("span");
			t0 = text$1(t0_value);
			span1 = element("span");
			span1.textContent = "=\"";
			span2 = element("span");
			t2 = text$1(t2_value);
			span3 = element("span");
			span3.textContent = "\"";
			attr(span0, "slot", "slot");
			attr(span0, "class", "attribute-name svelte-1xw7gjz");
			attr(span1, "slot", "slot");
			attr(span1, "class", "punctuation svelte-1xw7gjz");
			attr(span2, "slot", "slot");
			attr(span2, "class", "attribute-value svelte-1xw7gjz");
			attr(span3, "slot", "slot");
			attr(span3, "class", "punctuation svelte-1xw7gjz");
		},
		m(target, anchor) {
			insert(target, span0, anchor);
			append(span0, t0);
			insert(target, span1, anchor);
			insert(target, span2, anchor);
			append(span2, t2);
			insert(target, span3, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*value*/ 1 && t0_value !== (t0_value = /*attribute*/ ctx[3].name + "")) set_data(t0, t0_value);
			if (dirty & /*value*/ 1 && t2_value !== (t2_value = /*attribute*/ ctx[3].value + "")) set_data(t2, t2_value);
		},
		d(detaching) {
			if (detaching) detach(span0);
			if (detaching) detach(span1);
			if (detaching) detach(span2);
			if (detaching) detach(span3);
		}
	};
}

// (31:10) <Echo>
function create_default_slot_2$2(ctx) {
	let t0;
	let t1;
	let t2;
	let t3;

	return {
		c() {
			t0 = space();
			t1 = space();
			t2 = space();
			t3 = space();
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
			insert(target, t2, anchor);
			insert(target, t3, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
			if (detaching) detach(t2);
			if (detaching) detach(t3);
		}
	};
}

// (28:6) {#each value.attributes as attribute}
function create_each_block$9(ctx) {
	let t0_value = " " + "";
	let t0;
	let t1;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$c, create_else_block$3];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*attribute*/ ctx[3].value) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			t0 = text$1(t0_value);
			t1 = space();
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (44:4) <span slot=slot class=punctuation>
function create_slot_slot$5(ctx) {
	let span0;
	let span1;
	let t1_value = /*value*/ ctx[0].tagName.toLowerCase() + "";
	let t1;
	let span2;
	let span3;
	let current;
	let each_value = /*value*/ ctx[0].attributes;
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			span0 = element("span");
			span0.textContent = "<";
			span1 = element("span");
			t1 = text$1(t1_value);
			span2 = element("span");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			span3 = element("span");
			span3.textContent = ">";
			attr(span0, "slot", "slot");
			attr(span0, "class", "punctuation svelte-1xw7gjz");
			attr(span1, "slot", "slot");
			attr(span1, "class", "tag-name svelte-1xw7gjz");
			attr(span2, "slot", "slot");
			attr(span3, "slot", "slot");
			attr(span3, "class", "punctuation svelte-1xw7gjz");
		},
		m(target, anchor) {
			insert(target, span0, anchor);
			insert(target, span1, anchor);
			append(span1, t1);
			insert(target, span2, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(span2, null);
			}

			insert(target, span3, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty & /*value*/ 1) && t1_value !== (t1_value = /*value*/ ctx[0].tagName.toLowerCase() + "")) set_data(t1, t1_value);

			if (dirty & /*value*/ 1) {
				each_value = /*value*/ ctx[0].attributes;
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$9(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$9(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(span2, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(span0);
			if (detaching) detach(span1);
			if (detaching) detach(span2);
			destroy_each(each_blocks, detaching);
			if (detaching) detach(span3);
		}
	};
}

// (24:2) <Echo>
function create_default_slot_1$6(ctx) {
	let t0;
	let t1;
	let t2;

	return {
		c() {
			t0 = space();
			t1 = space();
			t2 = space();
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
			insert(target, t2, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
			if (detaching) detach(t2);
		}
	};
}

// (22:0) <PrimitiveBase {value}>
function create_default_slot$g(ctx) {
	let t;
	let echo;
	let current;
	const default_slot_template = /*#slots*/ ctx[1].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	echo = new Echo({
			props: {
				$$slots: {
					default: [create_default_slot_1$6],
					slot: [create_slot_slot$5]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			if (default_slot) default_slot.c();
			t = space();
			create_component(echo.$$.fragment);
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			insert(target, t, anchor);
			mount_component(echo, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
				}
			}

			const echo_changes = {};

			if (dirty & /*$$scope, value*/ 5) {
				echo_changes.$$scope = { dirty, ctx };
			}

			echo.$set(echo_changes);
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(echo.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			transition_out(echo.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
			if (detaching) detach(t);
			destroy_component(echo, detaching);
		}
	};
}

function create_fragment$x(ctx) {
	let primitivebase;
	let current;

	primitivebase = new PrimitiveBase({
			props: {
				value: /*value*/ ctx[0],
				$$slots: { default: [create_default_slot$g] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(primitivebase.$$.fragment);
		},
		m(target, anchor) {
			mount_component(primitivebase, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const primitivebase_changes = {};
			if (dirty & /*value*/ 1) primitivebase_changes.value = /*value*/ ctx[0];

			if (dirty & /*$$scope, value*/ 5) {
				primitivebase_changes.$$scope = { dirty, ctx };
			}

			primitivebase.$set(primitivebase_changes);
		},
		i(local) {
			if (current) return;
			transition_in(primitivebase.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(primitivebase.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(primitivebase, detaching);
		}
	};
}

const check$3 = value => {
	if (!(value instanceof HTMLElement)) {
		return false;
	}

	try {
		return !!value.tagName;
	} catch(error) {
		
	}

	return false;
};

function instance$w($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { value } = $$props;

	$$self.$$set = $$props => {
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	return [value, slots, $$scope];
}

class ElementFormatter extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1xw7gjz-style")) add_css$n();
		init(this, options, instance$w, create_fragment$x, safe_not_equal, { value: 0 });
	}
}

var ElementFormatter$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': ElementFormatter,
    check: check$3
});

/* node_modules/svelte-inspect/inspect/formatters/MapEntry.svelte generated by Svelte v3.31.0 */

function add_css$o() {
	var style = element("style");
	style.id = "svelte-1ml47oo-style";
	style.textContent = ".on-intent.svelte-1ml47oo{display:none}.map-entry-toggle:hover>.on-intent.svelte-1ml47oo,.map-entry-toggle:focus>.on-intent.svelte-1ml47oo{display:inline}";
	append(document.head, style);
}

// (16:2) {#if !isOpen}
function create_if_block_1$6(ctx) {
	let t0_value = String(/*key*/ ctx[1]) + "";
	let t0;
	let t1;
	let t2_value = String(/*value*/ ctx[2]) + "";
	let t2;
	let t3;
	let span;

	return {
		c() {
			t0 = text$1(t0_value);
			t1 = text$1(" => ");
			t2 = text$1(t2_value);
			t3 = space();
			span = element("span");
			span.textContent = "";
			attr(span, "class", "on-intent svelte-1ml47oo");
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
			insert(target, t2, anchor);
			insert(target, t3, anchor);
			insert(target, span, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*key*/ 2 && t0_value !== (t0_value = String(/*key*/ ctx[1]) + "")) set_data(t0, t0_value);
			if (dirty & /*value*/ 4 && t2_value !== (t2_value = String(/*value*/ ctx[2]) + "")) set_data(t2, t2_value);
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
			if (detaching) detach(t2);
			if (detaching) detach(t3);
			if (detaching) detach(span);
		}
	};
}

// (14:0) <Toggle className=map-entry-toggle bind:isOpen>
function create_default_slot$h(ctx) {
	let t;
	let if_block_anchor;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);
	let if_block = !/*isOpen*/ ctx[3] && create_if_block_1$6(ctx);

	return {
		c() {
			if (default_slot) default_slot.c();
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			insert(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 128) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
				}
			}

			if (!/*isOpen*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$6(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
			if (detaching) detach(t);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (21:0) {#if isOpen}
function create_if_block$d(ctx) {
	let t0;
	let propertylist;
	let t1;
	let current;

	propertylist = new PropertyList({
			props: {
				depth: /*depth*/ ctx[0],
				value: /*propertyListValue*/ ctx[4]
			}
		});

	return {
		c() {
			t0 = text$1("{\n  ");
			create_component(propertylist.$$.fragment);
			t1 = text$1("\n  }");
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			mount_component(propertylist, target, anchor);
			insert(target, t1, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const propertylist_changes = {};
			if (dirty & /*depth*/ 1) propertylist_changes.depth = /*depth*/ ctx[0];
			if (dirty & /*propertyListValue*/ 16) propertylist_changes.value = /*propertyListValue*/ ctx[4];
			propertylist.$set(propertylist_changes);
		},
		i(local) {
			if (current) return;
			transition_in(propertylist.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(propertylist.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(t0);
			destroy_component(propertylist, detaching);
			if (detaching) detach(t1);
		}
	};
}

function create_fragment$y(ctx) {
	let toggle;
	let updating_isOpen;
	let t;
	let if_block_anchor;
	let current;

	function toggle_isOpen_binding(value) {
		/*toggle_isOpen_binding*/ ctx[6].call(null, value);
	}

	let toggle_props = {
		className: "map-entry-toggle",
		$$slots: { default: [create_default_slot$h] },
		$$scope: { ctx }
	};

	if (/*isOpen*/ ctx[3] !== void 0) {
		toggle_props.isOpen = /*isOpen*/ ctx[3];
	}

	toggle = new Toggle({ props: toggle_props });
	binding_callbacks.push(() => bind(toggle, "isOpen", toggle_isOpen_binding));
	let if_block = /*isOpen*/ ctx[3] && create_if_block$d(ctx);

	return {
		c() {
			create_component(toggle.$$.fragment);
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			mount_component(toggle, target, anchor);
			insert(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const toggle_changes = {};

			if (dirty & /*$$scope, value, key, isOpen*/ 142) {
				toggle_changes.$$scope = { dirty, ctx };
			}

			if (!updating_isOpen && dirty & /*isOpen*/ 8) {
				updating_isOpen = true;
				toggle_changes.isOpen = /*isOpen*/ ctx[3];
				add_flush_callback(() => updating_isOpen = false);
			}

			toggle.$set(toggle_changes);

			if (/*isOpen*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*isOpen*/ 8) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$d(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(toggle.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(toggle.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			destroy_component(toggle, detaching);
			if (detaching) detach(t);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$x($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { depth = 0 } = $$props;
	let { key } = $$props;
	let { value } = $$props;
	let isOpen = depth > 0;

	function toggle_isOpen_binding(value) {
		isOpen = value;
		$$invalidate(3, isOpen);
	}

	$$self.$$set = $$props => {
		if ("depth" in $$props) $$invalidate(0, depth = $$props.depth);
		if ("key" in $$props) $$invalidate(1, key = $$props.key);
		if ("value" in $$props) $$invalidate(2, value = $$props.value);
		if ("$$scope" in $$props) $$invalidate(7, $$scope = $$props.$$scope);
	};

	let propertyListValue;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*key, value*/ 6) {
			 $$invalidate(4, propertyListValue = Object.assign(Object.create(null), { key, value }));
		}
	};

	return [
		depth,
		key,
		value,
		isOpen,
		propertyListValue,
		slots,
		toggle_isOpen_binding,
		$$scope
	];
}

class MapEntry extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1ml47oo-style")) add_css$o();
		init(this, options, instance$x, create_fragment$y, safe_not_equal, { depth: 0, key: 1, value: 2 });
	}
}

/* node_modules/svelte-inspect/inspect/formatters/MapFormatter.svelte generated by Svelte v3.31.0 */

const { Map: Map_1 } = globals;

function add_css$p() {
	var style = element("style");
	style.id = "svelte-tozlb5-style";
	style.textContent = ".map.svelte-tozlb5.svelte-tozlb5{color:var(--color-black)}.size.svelte-tozlb5.svelte-tozlb5{color:var(--color-blue)}.on-intent.svelte-tozlb5.svelte-tozlb5{display:none}.map-toggle:hover>.on-intent.svelte-tozlb5.svelte-tozlb5,.map-toggle:focus>.on-intent.svelte-tozlb5.svelte-tozlb5{display:inline}.entry-index.svelte-tozlb5.svelte-tozlb5{color:var(--color-gray)}.row.svelte-tozlb5.svelte-tozlb5{display:flex}.row.svelte-tozlb5:not(:last-child)>.item.svelte-tozlb5:after{content:' , ';margin-left:-1ex;pointer-events:none;color:var(--color-black)}.indentation.svelte-tozlb5.svelte-tozlb5{margin:0;padding:0;display:inline-block}.empty.svelte-tozlb5.svelte-tozlb5{color:var(--color-gray);font-style:italic}";
	append(document.head, style);
}

function get_each_context$a(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i][0];
	child_ctx[8] = list[i][1];
	child_ctx[10] = i;
	return child_ctx;
}

// (25:4) <span slot=slot class=map>
function create_slot_slot$6(ctx) {
	let span0;
	let span1;
	let t1_value = /*value*/ ctx[1].size + "";
	let t1;
	let span2;

	return {
		c() {
			span0 = element("span");
			span0.textContent = "Map(";
			span1 = element("span");
			t1 = text$1(t1_value);
			span2 = element("span");
			span2.textContent = ")";
			attr(span0, "slot", "slot");
			attr(span0, "class", "map svelte-tozlb5");
			attr(span1, "slot", "slot");
			attr(span1, "class", "size svelte-tozlb5");
			attr(span2, "slot", "slot");
			attr(span2, "class", "map svelte-tozlb5");
		},
		m(target, anchor) {
			insert(target, span0, anchor);
			insert(target, span1, anchor);
			append(span1, t1);
			insert(target, span2, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*value*/ 2 && t1_value !== (t1_value = /*value*/ ctx[1].size + "")) set_data(t1, t1_value);
		},
		d(detaching) {
			if (detaching) detach(span0);
			if (detaching) detach(span1);
			if (detaching) detach(span2);
		}
	};
}

// (22:2) <Echo>
function create_default_slot_3$1(ctx) {
	let t0;
	let t1;

	return {
		c() {
			t0 = space();
			t1 = space();
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
		}
	};
}

// (27:8) {#if !isOpen}
function create_if_block_1$7(ctx) {
	let span;
	let t1;

	return {
		c() {
			span = element("span");
			span.textContent = "";
			t1 = text$1("}");
			attr(span, "class", "on-intent svelte-tozlb5");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			insert(target, t1, anchor);
		},
		d(detaching) {
			if (detaching) detach(span);
			if (detaching) detach(t1);
		}
	};
}

// (20:0) <Toggle className=map-toggle bind:isOpen>
function create_default_slot_2$3(ctx) {
	let t0;
	let echo;
	let t1;
	let if_block_anchor;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

	echo = new Echo({
			props: {
				$$slots: {
					default: [create_default_slot_3$1],
					slot: [create_slot_slot$6]
				},
				$$scope: { ctx }
			}
		});

	let if_block = !/*isOpen*/ ctx[2] && create_if_block_1$7();

	return {
		c() {
			if (default_slot) default_slot.c();
			t0 = space();
			create_component(echo.$$.fragment);
			t1 = text$1("\n  {");
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			insert(target, t0, anchor);
			mount_component(echo, target, anchor);
			insert(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
				}
			}

			const echo_changes = {};

			if (dirty & /*$$scope, value*/ 66) {
				echo_changes.$$scope = { dirty, ctx };
			}

			echo.$set(echo_changes);

			if (!/*isOpen*/ ctx[2]) {
				if (if_block) ; else {
					if_block = create_if_block_1$7();
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(echo.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			transition_out(echo.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
			if (detaching) detach(t0);
			destroy_component(echo, detaching);
			if (detaching) detach(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (32:0) {#if isOpen}
function create_if_block$e(ctx) {
	let each_blocks = [];
	let each_1_lookup = new Map_1();
	let t0;
	let propertylist;
	let t1;
	let current;
	let each_value = [.../*value*/ ctx[1]];
	const get_key = ctx => /*entryKey*/ ctx[7];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$a(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$a(key, child_ctx));
	}

	let each_1_else = null;

	if (!each_value.length) {
		each_1_else = create_else_block$4();
	}

	propertylist = new PropertyList({
			props: {
				depth: /*depth*/ ctx[0],
				value: /*value*/ ctx[1],
				$$slots: { default: [create_default_slot$i] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			if (each_1_else) {
				each_1_else.c();
			}

			t0 = space();
			create_component(propertylist.$$.fragment);
			t1 = text$1("\n  }");
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			if (each_1_else) {
				each_1_else.m(target, anchor);
			}

			insert(target, t0, anchor);
			mount_component(propertylist, target, anchor);
			insert(target, t1, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*nextDepth, value*/ 10) {
				const each_value = [.../*value*/ ctx[1]];
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, t0.parentNode, outro_and_destroy_block, create_each_block$a, t0, get_each_context$a);
				check_outros();

				if (each_value.length) {
					if (each_1_else) {
						each_1_else.d(1);
						each_1_else = null;
					}
				} else if (!each_1_else) {
					each_1_else = create_else_block$4();
					each_1_else.c();
					each_1_else.m(t0.parentNode, t0);
				}
			}

			const propertylist_changes = {};
			if (dirty & /*depth*/ 1) propertylist_changes.depth = /*depth*/ ctx[0];
			if (dirty & /*value*/ 2) propertylist_changes.value = /*value*/ ctx[1];

			if (dirty & /*$$scope*/ 64) {
				propertylist_changes.$$scope = { dirty, ctx };
			}

			propertylist.$set(propertylist_changes);
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(propertylist.$$.fragment, local);
			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(propertylist.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d(detaching);
			}

			if (each_1_else) each_1_else.d(detaching);
			if (detaching) detach(t0);
			destroy_component(propertylist, detaching);
			if (detaching) detach(t1);
		}
	};
}

// (40:2) {:else}
function create_else_block$4(ctx) {
	let div;

	return {
		c() {
			div = element("div");

			div.innerHTML = `<pre class="indentation svelte-tozlb5"></pre> 
      <span class="empty svelte-tozlb5">No entries</span>`;

			attr(div, "class", "row svelte-tozlb5");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (37:8) <MapEntry depth={nextDepth} key={entryKey} value={entryValue}>
function create_default_slot_1$7(ctx) {
	let span;
	let t0;
	let t1_value = /*index*/ ctx[10] + "";
	let t1;
	let t2;

	return {
		c() {
			span = element("span");
			t0 = text$1("entry ");
			t1 = text$1(t1_value);
			t2 = text$1(":");
			attr(span, "class", "entry-index svelte-tozlb5");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t0);
			append(span, t1);
			insert(target, t2, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*value*/ 2 && t1_value !== (t1_value = /*index*/ ctx[10] + "")) set_data(t1, t1_value);
		},
		d(detaching) {
			if (detaching) detach(span);
			if (detaching) detach(t2);
		}
	};
}

// (33:2) {#each [...value] as [entryKey, entryValue], index (entryKey)}
function create_each_block$a(key_1, ctx) {
	let div;
	let pre;
	let t1;
	let span;
	let mapentry;
	let current;

	mapentry = new MapEntry({
			props: {
				depth: /*nextDepth*/ ctx[3],
				key: /*entryKey*/ ctx[7],
				value: /*entryValue*/ ctx[8],
				$$slots: { default: [create_default_slot_1$7] },
				$$scope: { ctx }
			}
		});

	return {
		key: key_1,
		first: null,
		c() {
			div = element("div");
			pre = element("pre");
			pre.textContent = "";
			t1 = space();
			span = element("span");
			create_component(mapentry.$$.fragment);
			attr(pre, "class", "indentation svelte-tozlb5");
			attr(span, "class", "item svelte-tozlb5");
			attr(div, "class", "row svelte-tozlb5");
			this.first = div;
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, pre);
			append(div, t1);
			append(div, span);
			mount_component(mapentry, span, null);
			current = true;
		},
		p(ctx, dirty) {
			const mapentry_changes = {};
			if (dirty & /*nextDepth*/ 8) mapentry_changes.depth = /*nextDepth*/ ctx[3];
			if (dirty & /*value*/ 2) mapentry_changes.key = /*entryKey*/ ctx[7];
			if (dirty & /*value*/ 2) mapentry_changes.value = /*entryValue*/ ctx[8];

			if (dirty & /*$$scope, value*/ 66) {
				mapentry_changes.$$scope = { dirty, ctx };
			}

			mapentry.$set(mapentry_changes);
		},
		i(local) {
			if (current) return;
			transition_in(mapentry.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(mapentry.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(mapentry);
		}
	};
}

// (46:2) <PropertyList     {depth}     {value}   >
function create_default_slot$i(ctx) {
	let t;

	return {
		c() {
			t = text$1("No properties");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment$z(ctx) {
	let toggle;
	let updating_isOpen;
	let t;
	let if_block_anchor;
	let current;

	function toggle_isOpen_binding(value) {
		/*toggle_isOpen_binding*/ ctx[5].call(null, value);
	}

	let toggle_props = {
		className: "map-toggle",
		$$slots: { default: [create_default_slot_2$3] },
		$$scope: { ctx }
	};

	if (/*isOpen*/ ctx[2] !== void 0) {
		toggle_props.isOpen = /*isOpen*/ ctx[2];
	}

	toggle = new Toggle({ props: toggle_props });
	binding_callbacks.push(() => bind(toggle, "isOpen", toggle_isOpen_binding));
	let if_block = /*isOpen*/ ctx[2] && create_if_block$e(ctx);

	return {
		c() {
			create_component(toggle.$$.fragment);
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			mount_component(toggle, target, anchor);
			insert(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const toggle_changes = {};

			if (dirty & /*$$scope, isOpen, value*/ 70) {
				toggle_changes.$$scope = { dirty, ctx };
			}

			if (!updating_isOpen && dirty & /*isOpen*/ 4) {
				updating_isOpen = true;
				toggle_changes.isOpen = /*isOpen*/ ctx[2];
				add_flush_callback(() => updating_isOpen = false);
			}

			toggle.$set(toggle_changes);

			if (/*isOpen*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*isOpen*/ 4) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$e(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(toggle.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(toggle.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			destroy_component(toggle, detaching);
			if (detaching) detach(t);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

const type$4 = Map;
const hasDepthProp$2 = true;

function instance$y($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { depth = 0 } = $$props;
	let { value } = $$props;
	let isOpen = depth > 0;

	function toggle_isOpen_binding(value) {
		isOpen = value;
		$$invalidate(2, isOpen);
	}

	$$self.$$set = $$props => {
		if ("depth" in $$props) $$invalidate(0, depth = $$props.depth);
		if ("value" in $$props) $$invalidate(1, value = $$props.value);
		if ("$$scope" in $$props) $$invalidate(6, $$scope = $$props.$$scope);
	};

	let nextDepth;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*depth*/ 1) {
			 $$invalidate(3, nextDepth = Math.max(0, depth - 1));
		}
	};

	return [depth, value, isOpen, nextDepth, slots, toggle_isOpen_binding, $$scope];
}

class MapFormatter extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-tozlb5-style")) add_css$p();
		init(this, options, instance$y, create_fragment$z, safe_not_equal, { depth: 0, value: 1 });
	}
}

var MapFormatter$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': MapFormatter,
    type: type$4,
    hasDepthProp: hasDepthProp$2
});

/* node_modules/svelte-inspect/inspect/formatters/SetFormatter.svelte generated by Svelte v3.31.0 */

function add_css$q() {
	var style = element("style");
	style.id = "svelte-17ifixr-style";
	style.textContent = ".set.svelte-17ifixr.svelte-17ifixr{color:var(--color-black)}.size.svelte-17ifixr.svelte-17ifixr{color:var(--color-blue)}.on-intent.svelte-17ifixr.svelte-17ifixr{display:none}.set-toggle:hover>.on-intent.svelte-17ifixr.svelte-17ifixr,.set-toggle:focus>.on-intent.svelte-17ifixr.svelte-17ifixr{display:inline}.entry-index.svelte-17ifixr.svelte-17ifixr{color:var(--color-gray)}.row.svelte-17ifixr.svelte-17ifixr{display:flex}.row.svelte-17ifixr:not(:last-child)>.item.svelte-17ifixr:after{content:' , ';margin-left:-1ex;pointer-events:none;color:var(--color-black)}.indentation.svelte-17ifixr.svelte-17ifixr{margin:0;padding:0;display:inline-block}.empty.svelte-17ifixr.svelte-17ifixr{color:var(--color-gray);font-style:italic}";
	append(document.head, style);
}

function get_each_context$b(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i];
	child_ctx[9] = i;
	return child_ctx;
}

// (25:4) <span slot=slot class=set>
function create_slot_slot$7(ctx) {
	let span0;
	let span1;
	let t1_value = /*value*/ ctx[1].size + "";
	let t1;
	let span2;

	return {
		c() {
			span0 = element("span");
			span0.textContent = "Set(";
			span1 = element("span");
			t1 = text$1(t1_value);
			span2 = element("span");
			span2.textContent = ")";
			attr(span0, "slot", "slot");
			attr(span0, "class", "set svelte-17ifixr");
			attr(span1, "slot", "slot");
			attr(span1, "class", "size svelte-17ifixr");
			attr(span2, "slot", "slot");
			attr(span2, "class", "set svelte-17ifixr");
		},
		m(target, anchor) {
			insert(target, span0, anchor);
			insert(target, span1, anchor);
			append(span1, t1);
			insert(target, span2, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*value*/ 2 && t1_value !== (t1_value = /*value*/ ctx[1].size + "")) set_data(t1, t1_value);
		},
		d(detaching) {
			if (detaching) detach(span0);
			if (detaching) detach(span1);
			if (detaching) detach(span2);
		}
	};
}

// (22:2) <Echo>
function create_default_slot_3$2(ctx) {
	let t0;
	let t1;

	return {
		c() {
			t0 = space();
			t1 = space();
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
		}
	};
}

// (27:8) {#if !isOpen}
function create_if_block_1$8(ctx) {
	let span;
	let t1;

	return {
		c() {
			span = element("span");
			span.textContent = "";
			t1 = text$1("}");
			attr(span, "class", "on-intent svelte-17ifixr");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			insert(target, t1, anchor);
		},
		d(detaching) {
			if (detaching) detach(span);
			if (detaching) detach(t1);
		}
	};
}

// (20:0) <Toggle className=set-toggle bind:isOpen>
function create_default_slot_2$4(ctx) {
	let t0;
	let echo;
	let t1;
	let if_block_anchor;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

	echo = new Echo({
			props: {
				$$slots: {
					default: [create_default_slot_3$2],
					slot: [create_slot_slot$7]
				},
				$$scope: { ctx }
			}
		});

	let if_block = !/*isOpen*/ ctx[2] && create_if_block_1$8();

	return {
		c() {
			if (default_slot) default_slot.c();
			t0 = space();
			create_component(echo.$$.fragment);
			t1 = text$1("\n  {");
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			insert(target, t0, anchor);
			mount_component(echo, target, anchor);
			insert(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
				}
			}

			const echo_changes = {};

			if (dirty & /*$$scope, value*/ 66) {
				echo_changes.$$scope = { dirty, ctx };
			}

			echo.$set(echo_changes);

			if (!/*isOpen*/ ctx[2]) {
				if (if_block) ; else {
					if_block = create_if_block_1$8();
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(echo.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			transition_out(echo.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
			if (detaching) detach(t0);
			destroy_component(echo, detaching);
			if (detaching) detach(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (32:0) {#if isOpen}
function create_if_block$f(ctx) {
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t0;
	let propertylist;
	let t1;
	let current;
	let each_value = [.../*value*/ ctx[1]];
	const get_key = ctx => /*entryValue*/ ctx[7];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$b(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$b(key, child_ctx));
	}

	let each_1_else = null;

	if (!each_value.length) {
		each_1_else = create_else_block$5();
	}

	propertylist = new PropertyList({
			props: {
				depth: /*depth*/ ctx[0],
				value: /*value*/ ctx[1],
				$$slots: { default: [create_default_slot$j] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			if (each_1_else) {
				each_1_else.c();
			}

			t0 = space();
			create_component(propertylist.$$.fragment);
			t1 = text$1("\n  }");
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			if (each_1_else) {
				each_1_else.m(target, anchor);
			}

			insert(target, t0, anchor);
			mount_component(propertylist, target, anchor);
			insert(target, t1, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*nextDepth, value*/ 10) {
				const each_value = [.../*value*/ ctx[1]];
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, t0.parentNode, outro_and_destroy_block, create_each_block$b, t0, get_each_context$b);
				check_outros();

				if (each_value.length) {
					if (each_1_else) {
						each_1_else.d(1);
						each_1_else = null;
					}
				} else if (!each_1_else) {
					each_1_else = create_else_block$5();
					each_1_else.c();
					each_1_else.m(t0.parentNode, t0);
				}
			}

			const propertylist_changes = {};
			if (dirty & /*depth*/ 1) propertylist_changes.depth = /*depth*/ ctx[0];
			if (dirty & /*value*/ 2) propertylist_changes.value = /*value*/ ctx[1];

			if (dirty & /*$$scope*/ 64) {
				propertylist_changes.$$scope = { dirty, ctx };
			}

			propertylist.$set(propertylist_changes);
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(propertylist.$$.fragment, local);
			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(propertylist.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d(detaching);
			}

			if (each_1_else) each_1_else.d(detaching);
			if (detaching) detach(t0);
			destroy_component(propertylist, detaching);
			if (detaching) detach(t1);
		}
	};
}

// (40:2) {:else}
function create_else_block$5(ctx) {
	let div;

	return {
		c() {
			div = element("div");

			div.innerHTML = `<pre class="indentation svelte-17ifixr"></pre> 
      <span class="empty svelte-17ifixr">No entries</span>`;

			attr(div, "class", "row svelte-17ifixr");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (37:8) <Formatter depth={nextDepth} value={entryValue}>
function create_default_slot_1$8(ctx) {
	let span;
	let t0;
	let t1_value = /*index*/ ctx[9] + "";
	let t1;
	let t2;

	return {
		c() {
			span = element("span");
			t0 = text$1("entry ");
			t1 = text$1(t1_value);
			t2 = text$1(":");
			attr(span, "class", "entry-index svelte-17ifixr");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t0);
			append(span, t1);
			insert(target, t2, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*value*/ 2 && t1_value !== (t1_value = /*index*/ ctx[9] + "")) set_data(t1, t1_value);
		},
		d(detaching) {
			if (detaching) detach(span);
			if (detaching) detach(t2);
		}
	};
}

// (33:2) {#each [...value] as entryValue, index (entryValue)}
function create_each_block$b(key_1, ctx) {
	let div;
	let pre;
	let t1;
	let span;
	let formatter;
	let current;

	formatter = new Formatter({
			props: {
				depth: /*nextDepth*/ ctx[3],
				value: /*entryValue*/ ctx[7],
				$$slots: { default: [create_default_slot_1$8] },
				$$scope: { ctx }
			}
		});

	return {
		key: key_1,
		first: null,
		c() {
			div = element("div");
			pre = element("pre");
			pre.textContent = "";
			t1 = space();
			span = element("span");
			create_component(formatter.$$.fragment);
			attr(pre, "class", "indentation svelte-17ifixr");
			attr(span, "class", "item svelte-17ifixr");
			attr(div, "class", "row svelte-17ifixr");
			this.first = div;
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, pre);
			append(div, t1);
			append(div, span);
			mount_component(formatter, span, null);
			current = true;
		},
		p(ctx, dirty) {
			const formatter_changes = {};
			if (dirty & /*nextDepth*/ 8) formatter_changes.depth = /*nextDepth*/ ctx[3];
			if (dirty & /*value*/ 2) formatter_changes.value = /*entryValue*/ ctx[7];

			if (dirty & /*$$scope, value*/ 66) {
				formatter_changes.$$scope = { dirty, ctx };
			}

			formatter.$set(formatter_changes);
		},
		i(local) {
			if (current) return;
			transition_in(formatter.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(formatter.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(formatter);
		}
	};
}

// (46:2) <PropertyList     {depth}     {value}   >
function create_default_slot$j(ctx) {
	let t;

	return {
		c() {
			t = text$1("No properties");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment$A(ctx) {
	let toggle;
	let updating_isOpen;
	let t;
	let if_block_anchor;
	let current;

	function toggle_isOpen_binding(value) {
		/*toggle_isOpen_binding*/ ctx[5].call(null, value);
	}

	let toggle_props = {
		className: "set-toggle",
		$$slots: { default: [create_default_slot_2$4] },
		$$scope: { ctx }
	};

	if (/*isOpen*/ ctx[2] !== void 0) {
		toggle_props.isOpen = /*isOpen*/ ctx[2];
	}

	toggle = new Toggle({ props: toggle_props });
	binding_callbacks.push(() => bind(toggle, "isOpen", toggle_isOpen_binding));
	let if_block = /*isOpen*/ ctx[2] && create_if_block$f(ctx);

	return {
		c() {
			create_component(toggle.$$.fragment);
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			mount_component(toggle, target, anchor);
			insert(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const toggle_changes = {};

			if (dirty & /*$$scope, isOpen, value*/ 70) {
				toggle_changes.$$scope = { dirty, ctx };
			}

			if (!updating_isOpen && dirty & /*isOpen*/ 4) {
				updating_isOpen = true;
				toggle_changes.isOpen = /*isOpen*/ ctx[2];
				add_flush_callback(() => updating_isOpen = false);
			}

			toggle.$set(toggle_changes);

			if (/*isOpen*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*isOpen*/ 4) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$f(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(toggle.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(toggle.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			destroy_component(toggle, detaching);
			if (detaching) detach(t);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

const type$5 = Set;
const hasDepthProp$3 = true;

function instance$z($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { depth = 0 } = $$props;
	let { value } = $$props;
	let isOpen = depth > 0;

	function toggle_isOpen_binding(value) {
		isOpen = value;
		$$invalidate(2, isOpen);
	}

	$$self.$$set = $$props => {
		if ("depth" in $$props) $$invalidate(0, depth = $$props.depth);
		if ("value" in $$props) $$invalidate(1, value = $$props.value);
		if ("$$scope" in $$props) $$invalidate(6, $$scope = $$props.$$scope);
	};

	let nextDepth;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*depth*/ 1) {
			 $$invalidate(3, nextDepth = Math.max(0, depth - 1));
		}
	};

	return [depth, value, isOpen, nextDepth, slots, toggle_isOpen_binding, $$scope];
}

class SetFormatter extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-17ifixr-style")) add_css$q();
		init(this, options, instance$z, create_fragment$A, safe_not_equal, { depth: 0, value: 1 });
	}
}

var SetFormatter$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': SetFormatter,
    type: type$5,
    hasDepthProp: hasDepthProp$3
});

/* node_modules/svelte-inspect/inspect/formatters/ObjectFormatter.svelte generated by Svelte v3.31.0 */

function add_css$r() {
	var style = element("style");
	style.id = "svelte-e710e9-style";
	style.textContent = ".object.svelte-e710e9{color:var(--color-purple)}.on-intent.svelte-e710e9{display:none}.object-toggle:hover>.on-intent.svelte-e710e9,.object-toggle:focus>.on-intent.svelte-e710e9{display:inline}";
	append(document.head, style);
}

// (23:8) {#if !isOpen}
function create_if_block_1$9(ctx) {
	let span;
	let t1;

	return {
		c() {
			span = element("span");
			span.textContent = "";
			t1 = text$1("}");
			attr(span, "class", "on-intent svelte-e710e9");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			insert(target, t1, anchor);
		},
		d(detaching) {
			if (detaching) detach(span);
			if (detaching) detach(t1);
		}
	};
}

// (20:0) <Toggle className=object-toggle bind:isOpen>
function create_default_slot$k(ctx) {
	let t0;
	let span;
	let t1;
	let t2;
	let if_block_anchor;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
	let if_block = !/*isOpen*/ ctx[2] && create_if_block_1$9();

	return {
		c() {
			if (default_slot) default_slot.c();
			t0 = space();
			span = element("span");
			t1 = text$1(/*typeDescription*/ ctx[3]);
			t2 = text$1("\n  {");
			if (if_block) if_block.c();
			if_block_anchor = empty();
			attr(span, "class", "object svelte-e710e9");
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			insert(target, t0, anchor);
			insert(target, span, anchor);
			append(span, t1);
			insert(target, t2, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
				}
			}

			if (!current || dirty & /*typeDescription*/ 8) set_data(t1, /*typeDescription*/ ctx[3]);

			if (!/*isOpen*/ ctx[2]) {
				if (if_block) ; else {
					if_block = create_if_block_1$9();
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(span);
			if (detaching) detach(t2);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (28:0) {#if isOpen}
function create_if_block$g(ctx) {
	let propertylist;
	let t;
	let current;

	propertylist = new PropertyList({
			props: {
				depth: /*depth*/ ctx[0],
				value: /*value*/ ctx[1]
			}
		});

	return {
		c() {
			create_component(propertylist.$$.fragment);
			t = text$1("\n  }");
		},
		m(target, anchor) {
			mount_component(propertylist, target, anchor);
			insert(target, t, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const propertylist_changes = {};
			if (dirty & /*depth*/ 1) propertylist_changes.depth = /*depth*/ ctx[0];
			if (dirty & /*value*/ 2) propertylist_changes.value = /*value*/ ctx[1];
			propertylist.$set(propertylist_changes);
		},
		i(local) {
			if (current) return;
			transition_in(propertylist.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(propertylist.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(propertylist, detaching);
			if (detaching) detach(t);
		}
	};
}

function create_fragment$B(ctx) {
	let toggle;
	let updating_isOpen;
	let t;
	let if_block_anchor;
	let current;

	function toggle_isOpen_binding(value) {
		/*toggle_isOpen_binding*/ ctx[5].call(null, value);
	}

	let toggle_props = {
		className: "object-toggle",
		$$slots: { default: [create_default_slot$k] },
		$$scope: { ctx }
	};

	if (/*isOpen*/ ctx[2] !== void 0) {
		toggle_props.isOpen = /*isOpen*/ ctx[2];
	}

	toggle = new Toggle({ props: toggle_props });
	binding_callbacks.push(() => bind(toggle, "isOpen", toggle_isOpen_binding));
	let if_block = /*isOpen*/ ctx[2] && create_if_block$g(ctx);

	return {
		c() {
			create_component(toggle.$$.fragment);
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			mount_component(toggle, target, anchor);
			insert(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const toggle_changes = {};

			if (dirty & /*$$scope, isOpen, typeDescription*/ 76) {
				toggle_changes.$$scope = { dirty, ctx };
			}

			if (!updating_isOpen && dirty & /*isOpen*/ 4) {
				updating_isOpen = true;
				toggle_changes.isOpen = /*isOpen*/ ctx[2];
				add_flush_callback(() => updating_isOpen = false);
			}

			toggle.$set(toggle_changes);

			if (/*isOpen*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*isOpen*/ 4) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$g(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(toggle.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(toggle.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			destroy_component(toggle, detaching);
			if (detaching) detach(t);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

const check$4 = value => value !== null && typeof value === "object";
const hasDepthProp$4 = true;

function instance$A($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { depth = 0 } = $$props;
	let { value } = $$props;
	let isOpen = depth > 0;

	function toggle_isOpen_binding(value) {
		isOpen = value;
		$$invalidate(2, isOpen);
	}

	$$self.$$set = $$props => {
		if ("depth" in $$props) $$invalidate(0, depth = $$props.depth);
		if ("value" in $$props) $$invalidate(1, value = $$props.value);
		if ("$$scope" in $$props) $$invalidate(6, $$scope = $$props.$$scope);
	};

	let typeDescription;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 2) {
			 $$invalidate(3, typeDescription = getObjectTypeString(value));
		}
	};

	return [depth, value, isOpen, typeDescription, slots, toggle_isOpen_binding, $$scope];
}

class ObjectFormatter extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-e710e9-style")) add_css$r();
		init(this, options, instance$A, create_fragment$B, safe_not_equal, { depth: 0, value: 1 });
	}
}

var ObjectFormatter$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': ObjectFormatter,
    check: check$4,
    hasDepthProp: hasDepthProp$4
});

/* node_modules/svelte-inspect/inspect/formatters/FallbackFormatter.svelte generated by Svelte v3.31.0 */

function add_css$s() {
	var style = element("style");
	style.id = "svelte-cbfhie-style";
	style.textContent = ".fallback.svelte-cbfhie{color:var(--color-black)}";
	append(document.head, style);
}

// (11:0) <PrimitiveBase {value}>
function create_default_slot$l(ctx) {
	let t0;
	let span;
	let t1_value = String(/*value*/ ctx[0]) + "";
	let t1;
	let current;
	const default_slot_template = /*#slots*/ ctx[1].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	return {
		c() {
			if (default_slot) default_slot.c();
			t0 = space();
			span = element("span");
			t1 = text$1(t1_value);
			attr(span, "class", "fallback svelte-cbfhie");
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			insert(target, t0, anchor);
			insert(target, span, anchor);
			append(span, t1);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
				}
			}

			if ((!current || dirty & /*value*/ 1) && t1_value !== (t1_value = String(/*value*/ ctx[0]) + "")) set_data(t1, t1_value);
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(span);
		}
	};
}

function create_fragment$C(ctx) {
	let primitivebase;
	let current;

	primitivebase = new PrimitiveBase({
			props: {
				value: /*value*/ ctx[0],
				$$slots: { default: [create_default_slot$l] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(primitivebase.$$.fragment);
		},
		m(target, anchor) {
			mount_component(primitivebase, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const primitivebase_changes = {};
			if (dirty & /*value*/ 1) primitivebase_changes.value = /*value*/ ctx[0];

			if (dirty & /*$$scope, value*/ 5) {
				primitivebase_changes.$$scope = { dirty, ctx };
			}

			primitivebase.$set(primitivebase_changes);
		},
		i(local) {
			if (current) return;
			transition_in(primitivebase.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(primitivebase.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(primitivebase, detaching);
		}
	};
}

const check$5 = value => true;

function instance$B($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { value } = $$props;

	$$self.$$set = $$props => {
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	return [value, slots, $$scope];
}

class FallbackFormatter extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-cbfhie-style")) add_css$s();
		init(this, options, instance$B, create_fragment$C, safe_not_equal, { value: 0 });
	}
}

var FallbackFormatter$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': FallbackFormatter,
    check: check$5
});

/* node_modules/svelte-inspect/inspect/Formatter.svelte generated by Svelte v3.31.0 */

function create_default_slot$m(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 128) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$D(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [{ value: /*value*/ ctx[0] }, /*spread*/ ctx[2]];
	var switch_value = /*component*/ ctx[1];

	function switch_props(ctx) {
		let switch_instance_props = {
			$$slots: { default: [create_default_slot$m] },
			$$scope: { ctx }
		};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
	}

	return {
		c() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		m(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const switch_instance_changes = (dirty & /*value, spread*/ 5)
			? get_spread_update(switch_instance_spread_levels, [
					dirty & /*value*/ 1 && { value: /*value*/ ctx[0] },
					dirty & /*spread*/ 4 && get_spread_object(/*spread*/ ctx[2])
				])
			: {};

			if (dirty & /*$$scope*/ 128) {
				switch_instance_changes.$$scope = { dirty, ctx };
			}

			if (switch_value !== (switch_value = /*component*/ ctx[1])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

function instance$C($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { depth = 0 } = $$props;
	let { value } = $$props;

	const formatterModules = [
		NilFormatter$1,
		BooleanFormatter$1,
		SymbolFormatter$1,
		NumberFormatter$1,
		BigIntFormatter$1,
		StringFormatter$1,
		FunctionFormatter$1,
		RegExpFormatter$1,
		DateFormatter$1,
		ErrorFormatter$1,
		ArrayFormatter$1,
		TypedArrayFormatter$1,
		ElementFormatter$1,
		MapFormatter$1,
		SetFormatter$1,
		ObjectFormatter$1,
		FallbackFormatter$1
	];

	let component;
	let spread = {};

	$$self.$$set = $$props => {
		if ("depth" in $$props) $$invalidate(3, depth = $$props.depth);
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("$$scope" in $$props) $$invalidate(7, $$scope = $$props.$$scope);
	};

	let valueTypeOf;
	let valuePrototype;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 1) {
			 $$invalidate(4, valueTypeOf = typeof value);
		}

		if ($$self.$$.dirty & /*value*/ 1) {
			 $$invalidate(5, valuePrototype = value ? Object.getPrototypeOf(value) : undefined);
		}

		if ($$self.$$.dirty & /*value, valueTypeOf, valuePrototype, depth*/ 57) {
			 for (const formatterModule of formatterModules) {
				let match = false;

				if (formatterModule.check) {
					match = formatterModule.check(value);
				} else if (formatterModule.typeOf) {
					match = valueTypeOf === formatterModule.typeOf;
				} else if (formatterModule.type) {
					match = valuePrototype === formatterModule.type.prototype;
				}

				if (match) {
					$$invalidate(1, component = formatterModule.default);

					if (formatterModule.hasDepthProp) {
						$$invalidate(2, spread = { depth });
					}

					break;
				}
			}
		}
	};

	return [value, component, spread, depth, valueTypeOf, valuePrototype, slots, $$scope];
}

class Formatter extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$C, create_fragment$D, safe_not_equal, { depth: 3, value: 0 });
	}
}

/* node_modules/svelte-inspect/inspect/Getter.svelte generated by Svelte v3.31.0 */

function add_css$t() {
	var style = element("style");
	style.id = "svelte-fd03h8-style";
	style.textContent = ".prefix.svelte-fd03h8{color:var(--color-gray);font-style:italic}.error.svelte-fd03h8{color:var(--color-red);font-style:italic}.on-intent.svelte-fd03h8{display:none}.getter-toggle:hover>.on-intent.svelte-fd03h8,.getter-toggle:focus>.on-intent.svelte-fd03h8{display:inline}";
	append(document.head, style);
}

// (33:0) {:else}
function create_else_block$6(ctx) {
	let toggle;
	let current;

	toggle = new Toggle({
			props: {
				className: "getter-toggle",
				$$slots: { default: [create_default_slot_1$9] },
				$$scope: { ctx }
			}
		});

	toggle.$on("open", /*callGetter*/ ctx[4]);

	return {
		c() {
			create_component(toggle.$$.fragment);
		},
		m(target, anchor) {
			mount_component(toggle, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const toggle_changes = {};

			if (dirty & /*$$scope, getterError, hasError*/ 268) {
				toggle_changes.$$scope = { dirty, ctx };
			}

			toggle.$set(toggle_changes);
		},
		i(local) {
			if (current) return;
			transition_in(toggle.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(toggle.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(toggle, detaching);
		}
	};
}

// (28:0) {#if hasGottenResult}
function create_if_block$h(ctx) {
	let formatter;
	let current;

	formatter = new Formatter({
			props: {
				value: /*getterValue*/ ctx[0],
				$$slots: { default: [create_default_slot$n] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(formatter.$$.fragment);
		},
		m(target, anchor) {
			mount_component(formatter, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const formatter_changes = {};
			if (dirty & /*getterValue*/ 1) formatter_changes.value = /*getterValue*/ ctx[0];

			if (dirty & /*$$scope*/ 256) {
				formatter_changes.$$scope = { dirty, ctx };
			}

			formatter.$set(formatter_changes);
		},
		i(local) {
			if (current) return;
			transition_in(formatter.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(formatter.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(formatter, detaching);
		}
	};
}

// (42:4) {:else}
function create_else_block_1(ctx) {
	let t0;
	let span;
	let t2;

	return {
		c() {
			t0 = text$1("(");
			span = element("span");
			span.textContent = "";
			t2 = text$1(")");
			attr(span, "class", "on-intent svelte-fd03h8");
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, span, anchor);
			insert(target, t2, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(span);
			if (detaching) detach(t2);
		}
	};
}

// (40:4) {#if hasError}
function create_if_block_1$a(ctx) {
	let span;
	let t;

	return {
		c() {
			span = element("span");
			t = text$1(/*getterError*/ ctx[2]);
			attr(span, "class", "error svelte-fd03h8");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*getterError*/ 4) set_data(t, /*getterError*/ ctx[2]);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (34:2) <Toggle     className=getter-toggle     on:open={callGetter}   >
function create_default_slot_1$9(ctx) {
	let span;
	let t1;
	let t2;
	let if_block_anchor;
	let current;
	const default_slot_template = /*#slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

	function select_block_type_1(ctx, dirty) {
		if (/*hasError*/ ctx[3]) return create_if_block_1$a;
		return create_else_block_1;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			span = element("span");
			span.textContent = "get";
			t1 = space();
			if (default_slot) default_slot.c();
			t2 = space();
			if_block.c();
			if_block_anchor = empty();
			attr(span, "class", "prefix svelte-fd03h8");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			insert(target, t1, anchor);

			if (default_slot) {
				default_slot.m(target, anchor);
			}

			insert(target, t2, anchor);
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
				}
			}

			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);
			if (detaching) detach(t1);
			if (default_slot) default_slot.d(detaching);
			if (detaching) detach(t2);
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (29:2) <Formatter value={getterValue}>
function create_default_slot$n(ctx) {
	let span;
	let t1;
	let current;
	const default_slot_template = /*#slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

	return {
		c() {
			span = element("span");
			span.textContent = "get";
			t1 = space();
			if (default_slot) default_slot.c();
			attr(span, "class", "prefix svelte-fd03h8");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			insert(target, t1, anchor);

			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);
			if (detaching) detach(t1);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$E(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$h, create_else_block$6];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*hasGottenResult*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$D($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { descriptor = {} } = $$props;
	let { context = {} } = $$props;
	let getterValue;
	let hasGottenResult = false;
	let getterError;
	let hasError = false;

	const callGetter = () => {
		try {
			$$invalidate(0, getterValue = descriptor.get.call(context));
			$$invalidate(1, hasGottenResult = true);
			focusPrev();
			onTick(focusNext);
		} catch(error) {
			$$invalidate(2, getterError = error);
			$$invalidate(3, hasError = true);
		}
	};

	$$self.$$set = $$props => {
		if ("descriptor" in $$props) $$invalidate(5, descriptor = $$props.descriptor);
		if ("context" in $$props) $$invalidate(6, context = $$props.context);
		if ("$$scope" in $$props) $$invalidate(8, $$scope = $$props.$$scope);
	};

	return [
		getterValue,
		hasGottenResult,
		getterError,
		hasError,
		callGetter,
		descriptor,
		context,
		slots,
		$$scope
	];
}

class Getter extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-fd03h8-style")) add_css$t();
		init(this, options, instance$D, create_fragment$E, safe_not_equal, { descriptor: 5, context: 6 });
	}
}

/* node_modules/svelte-inspect/inspect/Property.svelte generated by Svelte v3.31.0 */

function add_css$u() {
	var style = element("style");
	style.id = "svelte-1aib386-style";
	style.textContent = ".pre.svelte-1aib386{white-space:pre-wrap}.key.svelte-1aib386{color:var(--color-purple)}.key.index.svelte-1aib386{color:var(--color-gray)}.key.svelte-1aib386:not(.enumerable){opacity:0.5}.separator.svelte-1aib386{color:var(--color-black)}";
	append(document.head, style);
}

// (18:0) <svelte:component   this={getter ? Getter : Formatter}   {...(getter ? {descriptor, context} : {value, depth: enumerable ? depth : 0})} >
function create_default_slot$o(ctx) {
	let span2;
	let span0;
	let t0_value = String(/*key*/ ctx[1]) + "";
	let t0;
	let span1;
	let t1;

	return {
		c() {
			span2 = element("span");
			span0 = element("span");
			t0 = text$1(t0_value);
			span1 = element("span");
			t1 = text$1(/*separator*/ ctx[4]);
			attr(span0, "class", "pre svelte-1aib386");
			attr(span1, "class", "separator svelte-1aib386");
			attr(span2, "class", "key svelte-1aib386");
			toggle_class(span2, "enumerable", /*enumerable*/ ctx[5]);
			toggle_class(span2, "index", keyIsIndex(/*key*/ ctx[1]));
		},
		m(target, anchor) {
			insert(target, span2, anchor);
			append(span2, span0);
			append(span0, t0);
			append(span2, span1);
			append(span1, t1);
		},
		p(ctx, dirty) {
			if (dirty & /*key*/ 2 && t0_value !== (t0_value = String(/*key*/ ctx[1]) + "")) set_data(t0, t0_value);
			if (dirty & /*separator*/ 16) set_data(t1, /*separator*/ ctx[4]);

			if (dirty & /*enumerable*/ 32) {
				toggle_class(span2, "enumerable", /*enumerable*/ ctx[5]);
			}

			if (dirty & /*keyIsIndex, key*/ 2) {
				toggle_class(span2, "index", keyIsIndex(/*key*/ ctx[1]));
			}
		},
		d(detaching) {
			if (detaching) detach(span2);
		}
	};
}

function create_fragment$F(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;

	const switch_instance_spread_levels = [
		/*getter*/ ctx[6]
		? {
				descriptor: /*descriptor*/ ctx[3],
				context: /*context*/ ctx[2]
			}
		: {
				value: /*value*/ ctx[7],
				depth: /*enumerable*/ ctx[5] ? /*depth*/ ctx[0] : 0
			}
	];

	var switch_value = /*getter*/ ctx[6] ? Getter : Formatter;

	function switch_props(ctx) {
		let switch_instance_props = {
			$$slots: { default: [create_default_slot$o] },
			$$scope: { ctx }
		};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
	}

	return {
		c() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		m(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const switch_instance_changes = (dirty & /*getter, descriptor, context, value, enumerable, depth*/ 237)
			? get_spread_update(switch_instance_spread_levels, [
					get_spread_object(/*getter*/ ctx[6]
					? {
							descriptor: /*descriptor*/ ctx[3],
							context: /*context*/ ctx[2]
						}
					: {
							value: /*value*/ ctx[7],
							depth: /*enumerable*/ ctx[5] ? /*depth*/ ctx[0] : 0
						})
				])
			: {};

			if (dirty & /*$$scope, enumerable, key, separator*/ 306) {
				switch_instance_changes.$$scope = { dirty, ctx };
			}

			if (switch_value !== (switch_value = /*getter*/ ctx[6] ? Getter : Formatter)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

function instance$E($$self, $$props, $$invalidate) {
	let { depth = 0 } = $$props;
	let { key } = $$props;
	let { context } = $$props;
	let { descriptor = {} } = $$props;
	let { separator } = $$props;

	$$self.$$set = $$props => {
		if ("depth" in $$props) $$invalidate(0, depth = $$props.depth);
		if ("key" in $$props) $$invalidate(1, key = $$props.key);
		if ("context" in $$props) $$invalidate(2, context = $$props.context);
		if ("descriptor" in $$props) $$invalidate(3, descriptor = $$props.descriptor);
		if ("separator" in $$props) $$invalidate(4, separator = $$props.separator);
	};

	let enumerable;
	let getter;
	let value;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*descriptor*/ 8) {
			 $$invalidate(5, enumerable = descriptor.enumerable);
		}

		if ($$self.$$.dirty & /*descriptor*/ 8) {
			 $$invalidate(6, getter = descriptor.get);
		}

		if ($$self.$$.dirty & /*descriptor*/ 8) {
			 $$invalidate(7, value = descriptor.value);
		}
	};

	return [depth, key, context, descriptor, separator, enumerable, getter, value];
}

class Property extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1aib386-style")) add_css$u();

		init(this, options, instance$E, create_fragment$F, safe_not_equal, {
			depth: 0,
			key: 1,
			context: 2,
			descriptor: 3,
			separator: 4
		});
	}
}

/* node_modules/svelte-inspect/inspect/Inspect.svelte generated by Svelte v3.31.0 */

function add_css$v() {
	var style = element("style");
	style.id = "svelte-sp5u0u-style";
	style.textContent = ".inspect.svelte-sp5u0u{font-family:Menlo,\n      Consolas,\n      Lucida Console,\n      Courier New,\n      Dejavu Sans Mono,\n      monospace;font-size:11px;line-height:1.35;color:var(--color-black);--color-red:darkred;--color-blue:darkblue;--color-green:darkgreen;--color-purple:purple;--color-orange:darkorange;--color-yellow:gold;--color-brown:darkgoldenrod;--color-pink:hotpink;--color-gray:#a0a0a0;--color-black:#202020;--color-white:#f0f0f0;--color-selection:lightskyblue}.semicolon.svelte-sp5u0u:after{content:' ; ';margin-left:-1ex;pointer-events:none;color:var(--color-black)}.block.svelte-sp5u0u{display:block}.inline.svelte-sp5u0u{display:inline}";
	append(document.head, style);
}

function get_each_context$c(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	return child_ctx;
}

// (32:0) {:else}
function create_else_block$7(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*propKeys*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*style, block, inline, semicolon, depth, propKeys, Object, $$props*/ 191) {
				each_value = /*propKeys*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$c(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$c(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (25:0) {#if valueOnly}
function create_if_block$i(ctx) {
	let span;
	let formatter;
	let current;

	formatter = new Formatter({
			props: {
				depth: /*$$props*/ ctx[7].depth || /*depth*/ ctx[5],
				value: /*$$props*/ ctx[7].value
			}
		});

	return {
		c() {
			span = element("span");
			create_component(formatter.$$.fragment);
			attr(span, "class", "inspect svelte-sp5u0u");
			attr(span, "style", /*style*/ ctx[2]);
			toggle_class(span, "inline", /*inline*/ ctx[3]);
		},
		m(target, anchor) {
			insert(target, span, anchor);
			mount_component(formatter, span, null);
			current = true;
		},
		p(ctx, dirty) {
			const formatter_changes = {};
			if (dirty & /*$$props*/ 128) formatter_changes.depth = /*$$props*/ ctx[7].depth || /*depth*/ ctx[5];
			if (dirty & /*$$props*/ 128) formatter_changes.value = /*$$props*/ ctx[7].value;
			formatter.$set(formatter_changes);

			if (!current || dirty & /*style*/ 4) {
				attr(span, "style", /*style*/ ctx[2]);
			}

			if (dirty & /*inline*/ 8) {
				toggle_class(span, "inline", /*inline*/ ctx[3]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(formatter.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(formatter.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);
			destroy_component(formatter);
		}
	};
}

// (33:2) {#each propKeys as key}
function create_each_block$c(ctx) {
	let span;
	let property;
	let t;
	let current;

	property = new Property({
			props: {
				depth: /*depth*/ ctx[5],
				key: /*key*/ ctx[11],
				context: null,
				descriptor: Object.getOwnPropertyDescriptor(/*$$props*/ ctx[7], /*key*/ ctx[11]),
				separator: " = "
			}
		});

	return {
		c() {
			span = element("span");
			create_component(property.$$.fragment);
			t = space();
			attr(span, "class", "inspect svelte-sp5u0u");
			attr(span, "style", /*style*/ ctx[2]);
			toggle_class(span, "block", /*block*/ ctx[1]);
			toggle_class(span, "inline", /*inline*/ ctx[3]);
			toggle_class(span, "semicolon", /*semicolon*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, span, anchor);
			mount_component(property, span, null);
			append(span, t);
			current = true;
		},
		p(ctx, dirty) {
			const property_changes = {};
			if (dirty & /*propKeys*/ 1) property_changes.key = /*key*/ ctx[11];
			if (dirty & /*$$props, propKeys*/ 129) property_changes.descriptor = Object.getOwnPropertyDescriptor(/*$$props*/ ctx[7], /*key*/ ctx[11]);
			property.$set(property_changes);

			if (!current || dirty & /*style*/ 4) {
				attr(span, "style", /*style*/ ctx[2]);
			}

			if (dirty & /*block*/ 2) {
				toggle_class(span, "block", /*block*/ ctx[1]);
			}

			if (dirty & /*inline*/ 8) {
				toggle_class(span, "inline", /*inline*/ ctx[3]);
			}

			if (dirty & /*semicolon*/ 16) {
				toggle_class(span, "semicolon", /*semicolon*/ ctx[4]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(property.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(property.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);
			destroy_component(property);
		}
	};
}

function create_fragment$G(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$i, create_else_block$7];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*valueOnly*/ ctx[6]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if_block.p(ctx, dirty);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$F($$self, $$props, $$invalidate) {
	const getConfiguration = props => {
		const userConfiguration = props[Symbol.for("configuration")] || {};

		return {
			depth: 1,
			palette: {},
			...userConfiguration
		};
	};

	let { depth, palette, valueOnly } = getConfiguration($$props);

	$$self.$$set = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	let colors;
	let style;
	let propKeys;
	let block;
	let inline;
	let semicolon;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*colors*/ 256) {
			 $$invalidate(2, style = colors.map(color => `--color-${color}: ${palette[color]};`).join(""));
		}

		 $$invalidate(0, propKeys = Object.keys($$props));

		if ($$self.$$.dirty & /*propKeys*/ 1) {
			 $$invalidate(1, block = propKeys.length > 1);
		}

		if ($$self.$$.dirty & /*block*/ 2) {
			 $$invalidate(3, inline = valueOnly || !block);
		}
	};

	 $$invalidate(8, colors = Object.keys(palette));
	 $$invalidate(4, semicolon = !valueOnly);
	$$props = exclude_internal_props($$props);
	return [propKeys, block, style, inline, semicolon, depth, valueOnly, $$props, colors];
}

class Inspect extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-sp5u0u-style")) add_css$v();
		init(this, options, instance$F, create_fragment$G, safe_not_equal, {});
	}
}

function configure(configuration) {
  if (Inspect.render) {
    // It's an SSR'd component. We need to wrap .render
    return {
      ...Inspect,
      render(props) {
        return Inspect.render({
          ...props,
          [Symbol.for('configuration')]: configuration
        })
      }
    };
  } else {
    // It's a client side component. We need to extend the class.
    return class ConfiguredInspect extends Inspect {
      constructor(options) {
        const props = options.props || {};
        super({
          ...options,
          props: {
            ...props,
            [Symbol.for('configuration')]: configuration
          }
        });
      }
    };
  }
}
const invertedPalette = {
  red: 'red',
  blue: 'dodgerblue',
  green: 'yellowgreen',
  purple: 'violet',
  gray: '#808080',
  black: '#d0d0d0',
  white: '#202020',
  selection: 'darkblue'
};

const Inverted = configure({
  palette: invertedPalette
});

const Value = configure({
  valueOnly: true
});

Inspect.configure = configure;
Inspect.Inverted = Inverted;
Inspect.Value = Value;

for (let i = 0; i <= 10; i++) {
  Inspect[i] = configure({depth: i});
  Inspect.Inverted[i] = configure({depth: i, palette: invertedPalette});
}

/* src/components/widgets/LiveCodeParseOutput.svelte generated by Svelte v3.31.0 */

function add_css$w() {
	var style = element("style");
	style.id = "svelte-nnxuzr-style";
	style.textContent = ".liveCodeParse-container.svelte-nnxuzr{position:relative;width:100%;height:100%;border:none;line-height:1.4;overflow:hidden;margin-top:20px}.scrollable.svelte-nnxuzr{flex:1 1 auto;margin:0 0 0.5em 0;overflow-y:auto}.error-state.svelte-nnxuzr{color:rgb(220, 0, 0);margin-top:3px;margin-left:5px;margin-bottom:10px}.correct-state.svelte-nnxuzr{color:var(--color-gray);margin:25px 0px 15px 0px;color:rgb(0, 220, 0)}.headline.svelte-nnxuzr{overflow-y:scroll;height:auto;margin-left:5px;margin-bottom:10px}.prewrap.svelte-nnxuzr{display:inline-flexbox;width:100%;overflow-x:auto;white-space:pre-wrap;white-space:-moz-pre-wrap;white-space:-pre-wrap;white-space:-o-pre-wrap;word-wrap:break-word;font-family:monospace;font-size:1em;font-weight:800;-moz-user-select:text;-khtml-user-select:text;-webkit-user-select:text;-ms-user-select:text;user-select:text}";
	append(document.head, style);
}

// (186:2) {:else}
function create_else_block_1$1(ctx) {
	let div;
	let span0;
	let t1;
	let span1;
	let t3;
	let mounted;
	let dispose;

	function select_block_type_2(ctx, dirty) {
		if (/*$siteMode*/ ctx[3] === "dark") return create_if_block_4;
		return create_else_block_2;
	}

	let current_block_type = select_block_type_2(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			div = element("div");
			span0 = element("span");
			span0.textContent = "Live Code correct ";
			t1 = text$1("(\n\t\t\t  ");
			span1 = element("span");
			span1.textContent = "show Abstract Syntax Tree";
			t3 = text$1(")\n\t\t\t\t\n\t\t\t\t");
			if_block.c();
			attr(span0, "class", "correct-state svelte-nnxuzr");
			set_style(span1, "cursor", "pointer");
			set_style(span1, "text-decoration", "underline");
			attr(div, "class", "headline svelte-nnxuzr");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, span0);
			append(div, t1);
			append(div, span1);
			append(div, t3);
			if_block.m(div, null);

			if (!mounted) {
				dispose = listen(span1, "click", /*click_handler_1*/ ctx[15]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (current_block_type !== (current_block_type = select_block_type_2(ctx))) {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div, null);
				}
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			if_block.d();
			mounted = false;
			dispose();
		}
	};
}

// (161:2) {#if showAST }
function create_if_block_2$2(ctx) {
	let div;
	let span0;
	let t1;
	let span1;
	let t3;
	let br;
	let t4;
	let current_block_type_index;
	let if_block;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block_3, create_else_block$8];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*$siteMode*/ ctx[3] === "dark") return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			div = element("div");
			span0 = element("span");
			span0.textContent = "Abstract Syntax Tree ";
			t1 = text$1("(\n\t\t\t\t");
			span1 = element("span");
			span1.textContent = "show less detail ";
			t3 = text$1(")\n\t\t\t\t");
			br = element("br");
			t4 = space();
			if_block.c();
			attr(span0, "class", "correct-state svelte-nnxuzr");
			set_style(span1, "cursor", "pointer");
			set_style(span1, "text-decoration", "underline");
			attr(div, "class", "headline svelte-nnxuzr");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, span0);
			append(div, t1);
			append(div, span1);
			append(div, t3);
			append(div, br);
			append(div, t4);
			if_blocks[current_block_type_index].m(div, null);
			current = true;

			if (!mounted) {
				dispose = listen(span1, "click", /*click_handler*/ ctx[14]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div, null);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if_blocks[current_block_type_index].d();
			mounted = false;
			dispose();
		}
	};
}

// (151:40) 
function create_if_block_1$b(ctx) {
	let div1;
	let div0;
	let span;
	let t;

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			span = element("span");
			t = text$1(/*$liveCodeParseErrors*/ ctx[1]);
			attr(span, "class", "prewrap  error-state svelte-nnxuzr");
			set_style(div0, "margin-left", "5px");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			append(div0, span);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*$liveCodeParseErrors*/ 2) set_data(t, /*$liveCodeParseErrors*/ ctx[1]);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div1);
		}
	};
}

// (147:2) {#if $grammarCompilationErrors != ""}
function create_if_block$j(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			div.innerHTML = `<span class="error-state svelte-nnxuzr">Go work on your grammar!</span>`;
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (199:4) {:else}
function create_else_block_2(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			set_style(div, "overflow-y", "scroll");
			set_style(div, "height", "auto");
			attr(div, "class", "inspect");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (191:4) {#if $siteMode === 'dark' }
function create_if_block_4(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			set_style(div, "overflow-y", "scroll");
			set_style(div, "height", "auto");
			attr(div, "class", "inspect");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (175:4) {:else}
function create_else_block$8(ctx) {
	let div;
	let inspect;
	let current;

	inspect = new Inspect({
			props: {
				value: /*$liveCodeAbstractSyntaxTree*/ ctx[4],
				depth: 7
			}
		});

	return {
		c() {
			div = element("div");
			create_component(inspect.$$.fragment);
			set_style(div, "overflow-y", "scroll");
			set_style(div, "height", "auto");
			attr(div, "class", "inspect");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(inspect, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const inspect_changes = {};
			if (dirty & /*$liveCodeAbstractSyntaxTree*/ 16) inspect_changes.value = /*$liveCodeAbstractSyntaxTree*/ ctx[4];
			inspect.$set(inspect_changes);
		},
		i(local) {
			if (current) return;
			transition_in(inspect.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(inspect.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(inspect);
		}
	};
}

// (167:4) {#if $siteMode === 'dark' }
function create_if_block_3(ctx) {
	let div;
	let inspect_inverted;
	let current;

	inspect_inverted = new Inspect.Inverted({
			props: {
				value: /*$liveCodeAbstractSyntaxTree*/ ctx[4],
				depth: 7
			}
		});

	return {
		c() {
			div = element("div");
			create_component(inspect_inverted.$$.fragment);
			set_style(div, "overflow-y", "scroll");
			set_style(div, "height", "auto");
			attr(div, "class", "inspect");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(inspect_inverted, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const inspect_inverted_changes = {};
			if (dirty & /*$liveCodeAbstractSyntaxTree*/ 16) inspect_inverted_changes.value = /*$liveCodeAbstractSyntaxTree*/ ctx[4];
			inspect_inverted.$set(inspect_inverted_changes);
		},
		i(local) {
			if (current) return;
			transition_in(inspect_inverted.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(inspect_inverted.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(inspect_inverted);
		}
	};
}

function create_fragment$H(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let div_style_value;
	let current;
	const if_block_creators = [create_if_block$j, create_if_block_1$b, create_if_block_2$2, create_else_block_1$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*$grammarCompilationErrors*/ ctx[2] != "") return 0;
		if (/*$liveCodeParseErrors*/ ctx[1] !== "") return 1;
		if (/*showAST*/ ctx[0]) return 2;
		return 3;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			div = element("div");
			if_block.c();
			attr(div, "id", "liveCodeCompilerOutput");
			attr(div, "class", "liveCodeParse-container flex scrollable svelte-nnxuzr");

			attr(div, "style", div_style_value = /*$liveCodeParseErrors*/ ctx[1] === ""
			? "background-color:rgb(0, 20, 0)"
			: "background-color:rgb(20, 0, 0)");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div, null);
			}

			if (!current || dirty & /*$liveCodeParseErrors*/ 2 && div_style_value !== (div_style_value = /*$liveCodeParseErrors*/ ctx[1] === ""
			? "background-color:rgb(0, 20, 0)"
			: "background-color:rgb(20, 0, 0)")) {
				attr(div, "style", div_style_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if_blocks[current_block_type_index].d();
		}
	};
}

function instance$G($$self, $$props, $$invalidate) {
	let $liveCodeParseErrors;
	let $grammarCompilationErrors;
	let $siteMode;
	let $liveCodeAbstractSyntaxTree;
	component_subscribe($$self, liveCodeParseErrors, $$value => $$invalidate(1, $liveCodeParseErrors = $$value));
	component_subscribe($$self, grammarCompilationErrors, $$value => $$invalidate(2, $grammarCompilationErrors = $$value));
	component_subscribe($$self, siteMode, $$value => $$invalidate(3, $siteMode = $$value));
	component_subscribe($$self, liveCodeAbstractSyntaxTree, $$value => $$invalidate(4, $liveCodeAbstractSyntaxTree = $$value));

	const CustomInspect = Inspect.configure({
		palette: {
			selection: "hotpink",
			blue: "dodgerblue",
			black: "white",
			gray: "white",
			pink: "white",
			brown: "white",
			yellow: "white",
			orange: "white",
			purple: "white",
			blue: "white",
			red: "white",
			white: "white"
		}
	});

	let { id } = $$props;
	let { name } = $$props;
	let { type } = $$props;
	let { hasFocus } = $$props;
	let { background } = $$props;
	let { lineNumbers } = $$props;
	let { theme } = $$props;
	let { component } = $$props;
	let { class: className } = $$props;

	let showAST = false;

	onMount(async () => {
	});

	onDestroy(async () => {
		
	});

	const click_handler = () => {
		$$invalidate(0, showAST = false);
	};

	const click_handler_1 = () => {
		$$invalidate(0, showAST = true);
	};

	$$self.$$set = $$props => {
		if ("id" in $$props) $$invalidate(5, id = $$props.id);
		if ("name" in $$props) $$invalidate(6, name = $$props.name);
		if ("type" in $$props) $$invalidate(7, type = $$props.type);
		if ("hasFocus" in $$props) $$invalidate(8, hasFocus = $$props.hasFocus);
		if ("background" in $$props) $$invalidate(9, background = $$props.background);
		if ("lineNumbers" in $$props) $$invalidate(10, lineNumbers = $$props.lineNumbers);
		if ("theme" in $$props) $$invalidate(11, theme = $$props.theme);
		if ("component" in $$props) $$invalidate(12, component = $$props.component);
		if ("class" in $$props) $$invalidate(13, className = $$props.class);
	};

	return [
		showAST,
		$liveCodeParseErrors,
		$grammarCompilationErrors,
		$siteMode,
		$liveCodeAbstractSyntaxTree,
		id,
		name,
		type,
		hasFocus,
		background,
		lineNumbers,
		theme,
		component,
		className,
		click_handler,
		click_handler_1
	];
}

class LiveCodeParseOutput extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-nnxuzr-style")) add_css$w();

		init(this, options, instance$G, create_fragment$H, safe_not_equal, {
			id: 5,
			name: 6,
			type: 7,
			hasFocus: 8,
			background: 9,
			lineNumbers: 10,
			theme: 11,
			component: 12,
			class: 13
		});
	}
}

/* src/components/widgets/GrammarCompileOutput.svelte generated by Svelte v3.31.0 */

function add_css$x() {
	var style = element("style");
	style.id = "svelte-1bxuhdk-style";
	style.textContent = ".grammarCompiler-container.svelte-1bxuhdk{position:relative;width:100%;height:100%;border:none;line-height:1.4;overflow:hidden}.scrollable.svelte-1bxuhdk{flex:1 1 auto;margin:0 0 0.5em 0;overflow-y:auto}.error-state.svelte-1bxuhdk{color:rgb(2200, 0, 0)}.correct-state.svelte-1bxuhdk{color:rgb(0, 160, 0);margin:25px 0px 15px 0px}.prewrap.svelte-1bxuhdk{display:inline-flexbox;width:100%;overflow-x:auto;white-space:pre-wrap;white-space:-moz-pre-wrap;white-space:-pre-wrap;white-space:-o-pre-wrap;word-wrap:break-word;font-family:monospace;font-size:1em;font-weight:800;-moz-user-select:text;-khtml-user-select:text;-webkit-user-select:text;-ms-user-select:text;user-select:text}.headline.svelte-1bxuhdk{overflow-y:scroll;height:auto;margin-left:5px;margin-bottom:10px}";
	append(document.head, style);
}

// (102:2) {:else}
function create_else_block$9(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			div.innerHTML = `<span class="correct-state svelte-1bxuhdk">Grammar validated and parser generated!</span>`;
			attr(div, "class", "headline svelte-1bxuhdk");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (95:2) {#if $grammarCompilationErrors !== ""}
function create_if_block$k(ctx) {
	let div1;
	let div0;
	let span;
	let t;

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			span = element("span");
			t = text$1(/*$grammarCompilationErrors*/ ctx[0]);
			attr(span, "class", "prewrap error-state svelte-1bxuhdk");
			set_style(div0, "margin-left", "5px");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			append(div0, span);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*$grammarCompilationErrors*/ 1) set_data(t, /*$grammarCompilationErrors*/ ctx[0]);
		},
		d(detaching) {
			if (detaching) detach(div1);
		}
	};
}

function create_fragment$I(ctx) {
	let div;

	function select_block_type(ctx, dirty) {
		if (/*$grammarCompilationErrors*/ ctx[0] !== "") return create_if_block$k;
		return create_else_block$9;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			div = element("div");
			if_block.c();
			attr(div, "id", "grammarOutput");
			attr(div, "class", "grammarCompiler-container flex scrollable svelte-1bxuhdk");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_block.m(div, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div, null);
				}
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			if_block.d();
		}
	};
}

function instance$H($$self, $$props, $$invalidate) {
	let $grammarCompilationErrors;
	component_subscribe($$self, grammarCompilationErrors, $$value => $$invalidate(0, $grammarCompilationErrors = $$value));

	let { id } = $$props;
	let { name } = $$props;
	let { type } = $$props;
	let { hasFocus } = $$props;
	let { background } = $$props;
	let { lineNumbers } = $$props;
	let { theme } = $$props;
	let { component } = $$props;
	let { class: className } = $$props;

	onMount(async () => {
	});

	onDestroy(async () => {
		
	});

	$$self.$$set = $$props => {
		if ("id" in $$props) $$invalidate(1, id = $$props.id);
		if ("name" in $$props) $$invalidate(2, name = $$props.name);
		if ("type" in $$props) $$invalidate(3, type = $$props.type);
		if ("hasFocus" in $$props) $$invalidate(4, hasFocus = $$props.hasFocus);
		if ("background" in $$props) $$invalidate(5, background = $$props.background);
		if ("lineNumbers" in $$props) $$invalidate(6, lineNumbers = $$props.lineNumbers);
		if ("theme" in $$props) $$invalidate(7, theme = $$props.theme);
		if ("component" in $$props) $$invalidate(8, component = $$props.component);
		if ("class" in $$props) $$invalidate(9, className = $$props.class);
	};

	return [
		$grammarCompilationErrors,
		id,
		name,
		type,
		hasFocus,
		background,
		lineNumbers,
		theme,
		component,
		className
	];
}

class GrammarCompileOutput extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1bxuhdk-style")) add_css$x();

		init(this, options, instance$H, create_fragment$I, safe_not_equal, {
			id: 1,
			name: 2,
			type: 3,
			hasFocus: 4,
			background: 5,
			lineNumbers: 6,
			theme: 7,
			component: 8,
			class: 9
		});
	}
}

/* src/components/widgets/Analyser.svelte generated by Svelte v3.31.0 */

function add_css$y() {
	var style = element("style");
	style.id = "svelte-10y0e9v-style";
	style.textContent = "canvas.svelte-10y0e9v{background-color:rgb(16, 16, 16);height:100%;width:100%;visibility:visible;border-radius:1px;vertical-align:baseline}";
	append(document.head, style);
}

function create_fragment$J(ctx) {
	let canvas_1;

	return {
		c() {
			canvas_1 = element("canvas");
			attr(canvas_1, "class", "canvas svelte-10y0e9v");
		},
		m(target, anchor) {
			insert(target, canvas_1, anchor);
			/*canvas_1_binding*/ ctx[12](canvas_1);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(canvas_1);
			/*canvas_1_binding*/ ctx[12](null);
		}
	};
}

function instance$I($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let engine;
	let messaging = new PubSub();
	let { id } = $$props;
	let { name } = $$props;
	let { type } = $$props;
	let { mode } = $$props;
	let { hasFocus } = $$props;
	let { background } = $$props;
	let { lineNumbers } = $$props;
	let { theme } = $$props;
	let { component } = $$props;
	let { channelID = 1 } = $$props;
	let { class: className } = $$props;

	let fftSize = 256,
		frequencyBinCount = 128,
		smoothingTimeConstant = 0.8,
		frequencyDataArray = [],
		timeDataArray = [];

	let canvas;
	let frame;
	let isRendering = true;

	let updateAnalyserByteData = e => {
		if (e !== undefined) {
			smoothingTimeConstant = e.smoothingTimeConstant;
			fftSize = e.fftSize;
			frequencyDataArray = e.frequencyDataArray;
			timeDataArray = e.timeDataArray;
		}
	};

	const drawFrequencyData = drawContext => {
		for (let i = 0; i < frequencyBinCount; i++) {
			let value = frequencyDataArray[i];
			let percent = value / 255;
			let height = canvas.offsetHeight * percent;
			let offset = canvas.offsetHeight - height - 1;
			let barWidth = canvas.offsetWidth / frequencyBinCount;
			let hue = i / frequencyBinCount * 255;
			drawContext.fillStyle = "hsl(" + hue + ", 100%, 75%)";
			drawContext.fillRect(i * barWidth, offset, barWidth, canvas.offsetHeight);
		}
	};

	const drawTimeData = drawContext => {
		for (let i = 0; i < frequencyBinCount; i++) {
			let value = timeDataArray[i];
			let percent = value;
			let height = canvas.offsetHeight * percent;
			let offset = canvas.offsetHeight - height - 1;
			let barWidth = canvas.offsetWidth / frequencyBinCount;
			drawContext.fillStyle = "white";
			drawContext.fillRect(i * barWidth, offset, barWidth, 2);
		}
	};

	const renderLoop = () => {
		if (isRendering) {
			frame = requestAnimationFrame(renderLoop);
			let drawContext = canvas.getContext("2d");
			drawContext.canvas.width = canvas.offsetWidth; // needed for 'automatic' resizing the canvas to current size
			drawContext.canvas.height = canvas.offsetHeight; // TODO: Optimise by doing this only on canvas resize call
			drawContext.clearRect(0, 0, canvas.offsetWidth, canvas.offsetHeight);
			sabRender();

			if (mode === "oscilloscope") {
				drawTimeData(drawContext);
			} else if (mode === "spectrogram") drawFrequencyData(drawContext); else {
				drawFrequencyData(drawContext);
				drawTimeData(drawContext);
			}
		} else return;
	};

	function sabRender() {
		try {
			// for (let v in engine.sharedArrayBuffers) {
			if (engine && engine.sharedArrayBuffers && engine.sharedArrayBuffers[channelID] && engine.sharedArrayBuffers[channelID].ttype === "scope") {
				let avail = engine.sharedArrayBuffers[channelID].rb.available_read();

				if (avail > 0 && avail != engine.sharedArrayBuffers[channelID].rb.capacity) {
					for (let i = 0; i < avail; i += engine.sharedArrayBuffers[channelID].blocksize) {
						let val = new Float64Array(engine.sharedArrayBuffers[channelID].blocksize);

						// ( !shift && 0 === frequencyBinCounter-- ) ? ( shift = true ) : undefined;
						// shift ? timeDataArray.shift() : undefined;
						// timeDataArray.push(val);
						engine.sharedArrayBuffers[channelID].rb.pop(val);
					}
				}
			}
		} catch(error) {
			console.error(error);
		}
	}

	const toggleRendering = () => {
		console.log("toggleRender");

		if (isRendering) {
			cancelAnimationFrame(frame);
		} else {
			frame = requestAnimationFrame(renderLoop);
		}

		isRendering = !isRendering;
		$$invalidate(1, hasFocus = true);
		console.log("click");
		dispatch("change", { prop: "hasFocus", value: true });
	};

	onMount(async () => {
		if (!engine) {
			engine = new Engine$1();
		}

		// console.log('analyser')
		// sabRender()
		// Request the creation of an WAAPI analyser to the Audio Engine
		// messaging.publish("add-engine-analyser", { id } );
		engine.createAnalyser(id, e => updateAnalyserByteData(e));

		canvas.addEventListener("click", () => toggleRendering(), false);

		renderLoop();
	});

	onDestroy(async () => {
		isRendering = false;
		engine.removeAnalyser({ id });
		return () => cancelAnimationFrame(frame);
	});

	function canvas_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			canvas = $$value;
			$$invalidate(0, canvas);
		});
	}

	$$self.$$set = $$props => {
		if ("id" in $$props) $$invalidate(2, id = $$props.id);
		if ("name" in $$props) $$invalidate(3, name = $$props.name);
		if ("type" in $$props) $$invalidate(4, type = $$props.type);
		if ("mode" in $$props) $$invalidate(5, mode = $$props.mode);
		if ("hasFocus" in $$props) $$invalidate(1, hasFocus = $$props.hasFocus);
		if ("background" in $$props) $$invalidate(6, background = $$props.background);
		if ("lineNumbers" in $$props) $$invalidate(7, lineNumbers = $$props.lineNumbers);
		if ("theme" in $$props) $$invalidate(8, theme = $$props.theme);
		if ("component" in $$props) $$invalidate(9, component = $$props.component);
		if ("channelID" in $$props) $$invalidate(10, channelID = $$props.channelID);
		if ("class" in $$props) $$invalidate(11, className = $$props.class);
	};

	return [
		canvas,
		hasFocus,
		id,
		name,
		type,
		mode,
		background,
		lineNumbers,
		theme,
		component,
		channelID,
		className,
		canvas_1_binding
	];
}

class Analyser extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-10y0e9v-style")) add_css$y();

		init(
			this,
			options,
			instance$I,
			create_fragment$J,
			safe_not_equal,
			{
				id: 2,
				name: 3,
				type: 4,
				mode: 5,
				hasFocus: 1,
				background: 6,
				lineNumbers: 7,
				theme: 8,
				component: 9,
				channelID: 10,
				class: 11
			},
			[-1, -1]
		);
	}
}

/* src/components/widgets/StoreInspector.svelte generated by Svelte v3.31.0 */

function add_css$z() {
	var style = element("style");
	style.id = "svelte-mhru0r-style";
	style.textContent = ".container.svelte-mhru0r{position:relative;width:100%;height:100%;border:none}.scrollable.svelte-mhru0r{flex:1 1 auto;margin:0 0 0.5em 0;overflow-y:auto}";
	append(document.head, style);
}

function create_fragment$K(ctx) {
	let div;
	let pre;
	let t_value = JSON.stringify(/*$items*/ ctx[0], null, 2) + "";
	let t;

	return {
		c() {
			div = element("div");
			pre = element("pre");
			t = text$1(t_value);
			attr(div, "class", "container scrollable svelte-mhru0r");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, pre);
			append(pre, t);
		},
		p(ctx, [dirty]) {
			if (dirty & /*$items*/ 1 && t_value !== (t_value = JSON.stringify(/*$items*/ ctx[0], null, 2) + "")) set_data(t, t_value);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function instance$J($$self, $$props, $$invalidate) {
	let $items;
	component_subscribe($$self, items, $$value => $$invalidate(0, $items = $$value));
	return [$items];
}

class StoreInspector extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-mhru0r-style")) add_css$z();
		init(this, options, instance$J, create_fragment$K, safe_not_equal, {});
	}
}

/* src/components/widgets/Console.svelte generated by Svelte v3.31.0 */

function add_css$A() {
	var style = element("style");
	style.id = "svelte-pp7mlb-style";
	style.textContent = ".console-container.svelte-pp7mlb{width:100%;height:100%;border:none}.console-textarea.svelte-pp7mlb{width:100%;height:100%;resize:none;overflow-y:scroll}";
	append(document.head, style);
}

function create_fragment$L(ctx) {
	let div;
	let pre;
	let t;

	return {
		c() {
			div = element("div");
			pre = element("pre");
			t = text$1(/*value*/ ctx[1]);
			attr(pre, "readonly", "");
			attr(pre, "class", "console-textarea svelte-pp7mlb");
			attr(div, "class", "console-container scrollable-textarea svelte-pp7mlb");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, pre);
			append(pre, t);
			/*pre_binding*/ ctx[12](pre);
		},
		p(ctx, [dirty]) {
			if (dirty & /*value*/ 2) set_data(t, /*value*/ ctx[1]);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			/*pre_binding*/ ctx[12](null);
		}
	};
}

function instance$K($$self, $$props, $$invalidate) {
	let textArea;
	let { id } = $$props;
	let { name } = $$props;
	let { type } = $$props;
	let { hasFocus } = $$props;
	let { background } = $$props;
	let { lineNumbers } = $$props;
	let { theme } = $$props;
	let { component } = $$props;
	let { class: className } = $$props;
	let { append = "" } = $$props;

	let value = `  running Maximilian v2.3.0 (Wasm)
  running Maximilian v2.3.0 (PureJS)
  running Open303 (Wasm)
  Sample rate: 44100
  buffer received
  DAC: 2 channels
  loading sample '909.wav'
  loading sample 'patterndrone3.wav'
  loading sample 'phoo-old1.wav'
  loading sample 'pork.wav'
  loading sample 'revbell.wav'
  loading sample 'rocks.wav'
  loading sample 'skake2Ed.wav'
  loading sample 'snork.wav'
  loading sample 'spade.wav'
  loading sample 'spark.wav'
  loading sample 'stretch.wav'
  loading sample '909b.wav'
  loading sample '909closed.wav'
  loading sample '909open.wav'
  loading sample 'sweetmachine-old1.wav'
  loading sample 'swipe-old1.wav'
  loading sample 'auboom.wav'
  loading sample 'triplet.wav'
  loading sample 'auclick.wav'
  loading sample 'audoubelclick2.wav'
  loading sample 'audoubleclick.wav'
  loading sample 'auhiclick.wav'
  loading sample 'vindvabd.wav'
  loading sample 'ausiclick.wav'
  loading sample 'backswing-old1.wav'
  loading sample 'bee.wav'
  loading sample 'bellrip.wav'
  loading sample 'bellrip2.wav'
  loading sample 'bellrip3.wav'
  loading sample 'blade-old1.wav'
  loading sample 'boom.wav'
  loading sample 'vindvahat.wav'
  loading sample 'camclick-old1.wav'
  loading sample 'camina1.wav'
  loading sample 'camina2.wav'
  loading sample 'camina3.wav'
  loading sample 'chain.wav'
  loading sample 'click-old1.wav'
  loading sample 'woodsamp.wav'
  loading sample 'wooo-old1.wav'
  loading sample 'dalispark.wav'
  loading sample 'digaa.wav'
  loading sample 'dorje.wav'
  loading sample 'drr.wav'
  loading sample 'firecrack.wav'
  loading sample 'firespark.wav'
  loading sample 'firespark2.wav'
  loading sample 'glitch-old1.wav'
  loading sample 'harshi-old1.wav'
  loading sample 'harshlow-old1.wav'
  loading sample 'heart.wav'
  loading sample 'ice.wav'
  loading sample 'insec.wav'
  loading sample 'insec2.wav'
  loading sample 'iron.wav'
  loading sample 'ironrip.wav'
  loading sample 'jump.wav'
  loading sample 'kernel.wav'
  loading sample 'kernel2.wav'
  loading sample 'kerneldrone.wav'
  loading sample 'kicic2.wav'
  loading sample 'kicicboom.wav'
  loading sample 'knock.wav'
  loading sample 'laekur.wav'
  loading sample 'machine.wav'
  loading sample 'magnetclock-old1.wav'
  loading sample 'noinoi.wav'
  loading sample 'noise-old1.wav'
  loading sample 'patterndrone2.wav'
  loading sample 'rotatingIron.wav'
  loading sample 'sbq.wav'
  loading sample 'snow.wav'
  loading sample 'auboom2.wav'
  loading sample 'vindva.wav'
  loading sample 'vindvaclick.wav'
  loading sample 'bello.wav'
  loading sample 'vindvadbase.wav'
  loading sample 'boom2.wav'
  loading sample 'boomwag.wav'
  loading sample 'viromachine-old1.wav'
  loading sample 'camina4.wav'
  loading sample 'click.wav'
  loading sample 'clicko-old1.wav'
  loading sample 'clicko.wav'
  loading sample 'clicks1.wav'
  loading sample 'convol2.wav'
  loading sample 'convol3.wav'
  loading sample 'crackle3.wav'
  loading sample 'dentist-old1.wav'
  loading sample 'zhish.wav'
  loading sample 'zzzz.wav'
  loading sample 'electro.wav'
  loading sample 'elstatic-old1.wav'
  loading sample 'flash-old1.wav'
  loading sample 'hapsi.wav'
  loading sample 'insec3.wav'
  loading sample 'kernelmix.wav'
  loading sample 'kicic.wav'
  loading sample 'noise2.wav'
  loading sample 'paper.wav'
  loading sample 'pattern10.wav'
  loading sample 'pattern11.wav'
  loading sample 'pattern8.wav'
  loading sample 'pattern9.wav'
  loading sample 'patterndrone.wav'
  loading sample 'birta.wav'
  loading sample 'chainSpade.wav'
  loading sample 'convol1.wav'
  loading sample 'xylophone.wav'
  loading sample 'convol4.wav'
  loading sample 'convol5.wav'
  loading sample 'noise1.wav'
  loading sample 'InsectBee2.wav'
  loading sample 'Macrosemia.wav'
  loading sample 'MacrosemiaTonk.wav'
  loading sample 'MeimunaNau.wav'
  loading sample 'drone2.wav'
  loading sample 'Cryptotympana.wav'
  loading sample 'Dundunia.wav'
  loading sample 'InsectFly.wav'
  loading sample 'CARinsect.wav'
  loading sample 'InsecticideZG.wav'
  loading sample 'rain_ravi.wav'
  loading sample 'InsectBee.wav'
  loading sample 'crickBee.wav'
  loading sample 'holeMONO.wav'
  loading sample 'ravi.wav'
  loading sample 'drone1.wav'
  loading sample 'lookout.wav'
  loading sample 'insectzapZG.wav'
  >toModel: -0.9954648526077098,0
  >toModel: -0.9954648526077098,0
  >toModel: -0.9954648526077098,0
  >toModel: -0.9954648526077098,0
  >toModel: -0.9954648526077098,0
  >toModel: -0.9954648526077098,0
  >toModel: -0.9954648526077098,0
  >toModel: -0.3424036281178866,0
  >toModel: 0.34240362811777336,0
  >toModel: -0.3424036281176468,0
  >toModel: 0.34240362811753355,0
  >toModel: -0.342403628117407,0
  >toModel: 0.34240362811729375,0
  >toModel: -0.3424036281171672,0
  >toModel: 0.34240362811705394,0
  >toModel: -0.34240362811692737,0
  >toModel: 0.34240362811681413,0
  >toModel: -0.34240362811668756,0
  >toModel: 0.3424036281165743,0
  >toModel: -0.34240362811644776,0
  >toModel: 0.3378684807240442,0
  >toModel: 0.3378684807240442,0
  >toModel: 0.3378684807240442,0
  >toModel: 0.3378684807240442,0
  >toModel: 0.3378684807240442,0
  >toModel: 0.3378684807240442,0
  >toModel: 0.3378684807240442,0
  >toModel: -0.32426303855038374,0
  >toModel: 0.32426303855048566,0
  >toModel: -0.32426303855062355,0
  >toModel: 0.32426303855072547,0
  >toModel: -0.32426303855086336,0
  >toModel: 0.3242630385509653,0
  >toModel: -0.32426303855110317,0
  >toModel: -0.9909297052178178,0
  >toModel: -0.9909297052178178,0
  >toModel: -0.9909297052178178,0
  >toModel: -0.9909297052178178,0
  >toModel: -0.9909297052178178,0
  >toModel: -0.9909297052178178,0
  >toModel: -0.9909297052178178,0
  >toModel: 0.9909297052178987,0
  >toModel: -0.9909297052180576,0
  >toModel: 0.9909297052181385,0
  >toModel: -0.9909297052182974,0
  >toModel: 0.9909297052183783,0
  >toModel: -0.9909297052185372,0
  >toModel: 0.9909297052186181,0
  >toModel: -0.990929x705218777,0
  >toModel: 0.9909297052188579,0
  >toModel: -0.9909297052190168,0
  >toModel: 0.9909297052190977,0
  >toModel: -0.9909297052192566,0
  >toModel: 0.9909297052193375,0
  >toModel: 0.3378684807216461,0
  >toModel: 0.3378684807216461,0
  >toModel: 0.3378684807216461,0
  >toModel: 0.3378684807216461,0
  >toModel: 0.3378684807216461,0
  >toModel: 0.3378684807216461,0
  >toModel: 0.3378684807216461,0
  `;

	// append
	onMount(async () => {
		// if(!logger){
		// logger = new Logger();
		// }
		console.log("Console");

		log(id, name, type, className, lineNumbers, hasFocus, theme, background, component);
	});

	onDestroy(async () => {
		
	});

	function pre_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			textArea = $$value;
			$$invalidate(0, textArea);
		});
	}

	$$self.$$set = $$props => {
		if ("id" in $$props) $$invalidate(2, id = $$props.id);
		if ("name" in $$props) $$invalidate(3, name = $$props.name);
		if ("type" in $$props) $$invalidate(4, type = $$props.type);
		if ("hasFocus" in $$props) $$invalidate(5, hasFocus = $$props.hasFocus);
		if ("background" in $$props) $$invalidate(6, background = $$props.background);
		if ("lineNumbers" in $$props) $$invalidate(7, lineNumbers = $$props.lineNumbers);
		if ("theme" in $$props) $$invalidate(8, theme = $$props.theme);
		if ("component" in $$props) $$invalidate(9, component = $$props.component);
		if ("class" in $$props) $$invalidate(10, className = $$props.class);
		if ("append" in $$props) $$invalidate(11, append = $$props.append);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value, append*/ 2050) {
			 $$invalidate(1, value += append);
		}
	};

	return [
		textArea,
		value,
		id,
		name,
		type,
		hasFocus,
		background,
		lineNumbers,
		theme,
		component,
		className,
		append,
		pre_binding
	];
}

class Console extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-pp7mlb-style")) add_css$A();

		init(this, options, instance$K, create_fragment$L, safe_not_equal, {
			id: 2,
			name: 3,
			type: 4,
			hasFocus: 5,
			background: 6,
			lineNumbers: 7,
			theme: 8,
			component: 9,
			class: 10,
			append: 11
		});
	}
}

/*jshint node:true */

function OutputLine(parent) {
  this.__parent = parent;
  this.__character_count = 0;
  // use indent_count as a marker for this.__lines that have preserved indentation
  this.__indent_count = -1;
  this.__alignment_count = 0;
  this.__wrap_point_index = 0;
  this.__wrap_point_character_count = 0;
  this.__wrap_point_indent_count = -1;
  this.__wrap_point_alignment_count = 0;

  this.__items = [];
}

OutputLine.prototype.clone_empty = function() {
  var line = new OutputLine(this.__parent);
  line.set_indent(this.__indent_count, this.__alignment_count);
  return line;
};

OutputLine.prototype.item = function(index) {
  if (index < 0) {
    return this.__items[this.__items.length + index];
  } else {
    return this.__items[index];
  }
};

OutputLine.prototype.has_match = function(pattern) {
  for (var lastCheckedOutput = this.__items.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--) {
    if (this.__items[lastCheckedOutput].match(pattern)) {
      return true;
    }
  }
  return false;
};

OutputLine.prototype.set_indent = function(indent, alignment) {
  if (this.is_empty()) {
    this.__indent_count = indent || 0;
    this.__alignment_count = alignment || 0;
    this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);
  }
};

OutputLine.prototype._set_wrap_point = function() {
  if (this.__parent.wrap_line_length) {
    this.__wrap_point_index = this.__items.length;
    this.__wrap_point_character_count = this.__character_count;
    this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;
    this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;
  }
};

OutputLine.prototype._should_wrap = function() {
  return this.__wrap_point_index &&
    this.__character_count > this.__parent.wrap_line_length &&
    this.__wrap_point_character_count > this.__parent.next_line.__character_count;
};

OutputLine.prototype._allow_wrap = function() {
  if (this._should_wrap()) {
    this.__parent.add_new_line();
    var next = this.__parent.current_line;
    next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);
    next.__items = this.__items.slice(this.__wrap_point_index);
    this.__items = this.__items.slice(0, this.__wrap_point_index);

    next.__character_count += this.__character_count - this.__wrap_point_character_count;
    this.__character_count = this.__wrap_point_character_count;

    if (next.__items[0] === " ") {
      next.__items.splice(0, 1);
      next.__character_count -= 1;
    }
    return true;
  }
  return false;
};

OutputLine.prototype.is_empty = function() {
  return this.__items.length === 0;
};

OutputLine.prototype.last = function() {
  if (!this.is_empty()) {
    return this.__items[this.__items.length - 1];
  } else {
    return null;
  }
};

OutputLine.prototype.push = function(item) {
  this.__items.push(item);
  var last_newline_index = item.lastIndexOf('\n');
  if (last_newline_index !== -1) {
    this.__character_count = item.length - last_newline_index;
  } else {
    this.__character_count += item.length;
  }
};

OutputLine.prototype.pop = function() {
  var item = null;
  if (!this.is_empty()) {
    item = this.__items.pop();
    this.__character_count -= item.length;
  }
  return item;
};


OutputLine.prototype._remove_indent = function() {
  if (this.__indent_count > 0) {
    this.__indent_count -= 1;
    this.__character_count -= this.__parent.indent_size;
  }
};

OutputLine.prototype._remove_wrap_indent = function() {
  if (this.__wrap_point_indent_count > 0) {
    this.__wrap_point_indent_count -= 1;
  }
};
OutputLine.prototype.trim = function() {
  while (this.last() === ' ') {
    this.__items.pop();
    this.__character_count -= 1;
  }
};

OutputLine.prototype.toString = function() {
  var result = '';
  if (this.is_empty()) {
    if (this.__parent.indent_empty_lines) {
      result = this.__parent.get_indent_string(this.__indent_count);
    }
  } else {
    result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);
    result += this.__items.join('');
  }
  return result;
};

function IndentStringCache(options, baseIndentString) {
  this.__cache = [''];
  this.__indent_size = options.indent_size;
  this.__indent_string = options.indent_char;
  if (!options.indent_with_tabs) {
    this.__indent_string = new Array(options.indent_size + 1).join(options.indent_char);
  }

  // Set to null to continue support for auto detection of base indent
  baseIndentString = baseIndentString || '';
  if (options.indent_level > 0) {
    baseIndentString = new Array(options.indent_level + 1).join(this.__indent_string);
  }

  this.__base_string = baseIndentString;
  this.__base_string_length = baseIndentString.length;
}

IndentStringCache.prototype.get_indent_size = function(indent, column) {
  var result = this.__base_string_length;
  column = column || 0;
  if (indent < 0) {
    result = 0;
  }
  result += indent * this.__indent_size;
  result += column;
  return result;
};

IndentStringCache.prototype.get_indent_string = function(indent_level, column) {
  var result = this.__base_string;
  column = column || 0;
  if (indent_level < 0) {
    indent_level = 0;
    result = '';
  }
  column += indent_level * this.__indent_size;
  this.__ensure_cache(column);
  result += this.__cache[column];
  return result;
};

IndentStringCache.prototype.__ensure_cache = function(column) {
  while (column >= this.__cache.length) {
    this.__add_column();
  }
};

IndentStringCache.prototype.__add_column = function() {
  var column = this.__cache.length;
  var indent = 0;
  var result = '';
  if (this.__indent_size && column >= this.__indent_size) {
    indent = Math.floor(column / this.__indent_size);
    column -= indent * this.__indent_size;
    result = new Array(indent + 1).join(this.__indent_string);
  }
  if (column) {
    result += new Array(column + 1).join(' ');
  }

  this.__cache.push(result);
};

function Output(options, baseIndentString) {
  this.__indent_cache = new IndentStringCache(options, baseIndentString);
  this.raw = false;
  this._end_with_newline = options.end_with_newline;
  this.indent_size = options.indent_size;
  this.wrap_line_length = options.wrap_line_length;
  this.indent_empty_lines = options.indent_empty_lines;
  this.__lines = [];
  this.previous_line = null;
  this.current_line = null;
  this.next_line = new OutputLine(this);
  this.space_before_token = false;
  this.non_breaking_space = false;
  this.previous_token_wrapped = false;
  // initialize
  this.__add_outputline();
}

Output.prototype.__add_outputline = function() {
  this.previous_line = this.current_line;
  this.current_line = this.next_line.clone_empty();
  this.__lines.push(this.current_line);
};

Output.prototype.get_line_number = function() {
  return this.__lines.length;
};

Output.prototype.get_indent_string = function(indent, column) {
  return this.__indent_cache.get_indent_string(indent, column);
};

Output.prototype.get_indent_size = function(indent, column) {
  return this.__indent_cache.get_indent_size(indent, column);
};

Output.prototype.is_empty = function() {
  return !this.previous_line && this.current_line.is_empty();
};

Output.prototype.add_new_line = function(force_newline) {
  // never newline at the start of file
  // otherwise, newline only if we didn't just add one or we're forced
  if (this.is_empty() ||
    (!force_newline && this.just_added_newline())) {
    return false;
  }

  // if raw output is enabled, don't print additional newlines,
  // but still return True as though you had
  if (!this.raw) {
    this.__add_outputline();
  }
  return true;
};

Output.prototype.get_code = function(eol) {
  this.trim(true);

  // handle some edge cases where the last tokens
  // has text that ends with newline(s)
  var last_item = this.current_line.pop();
  if (last_item) {
    if (last_item[last_item.length - 1] === '\n') {
      last_item = last_item.replace(/\n+$/g, '');
    }
    this.current_line.push(last_item);
  }

  if (this._end_with_newline) {
    this.__add_outputline();
  }

  var sweet_code = this.__lines.join('\n');

  if (eol !== '\n') {
    sweet_code = sweet_code.replace(/[\n]/g, eol);
  }
  return sweet_code;
};

Output.prototype.set_wrap_point = function() {
  this.current_line._set_wrap_point();
};

Output.prototype.set_indent = function(indent, alignment) {
  indent = indent || 0;
  alignment = alignment || 0;

  // Next line stores alignment values
  this.next_line.set_indent(indent, alignment);

  // Never indent your first output indent at the start of the file
  if (this.__lines.length > 1) {
    this.current_line.set_indent(indent, alignment);
    return true;
  }

  this.current_line.set_indent();
  return false;
};

Output.prototype.add_raw_token = function(token) {
  for (var x = 0; x < token.newlines; x++) {
    this.__add_outputline();
  }
  this.current_line.set_indent(-1);
  this.current_line.push(token.whitespace_before);
  this.current_line.push(token.text);
  this.space_before_token = false;
  this.non_breaking_space = false;
  this.previous_token_wrapped = false;
};

Output.prototype.add_token = function(printable_token) {
  this.__add_space_before_token();
  this.current_line.push(printable_token);
  this.space_before_token = false;
  this.non_breaking_space = false;
  this.previous_token_wrapped = this.current_line._allow_wrap();
};

Output.prototype.__add_space_before_token = function() {
  if (this.space_before_token && !this.just_added_newline()) {
    if (!this.non_breaking_space) {
      this.set_wrap_point();
    }
    this.current_line.push(' ');
  }
};

Output.prototype.remove_indent = function(index) {
  var output_length = this.__lines.length;
  while (index < output_length) {
    this.__lines[index]._remove_indent();
    index++;
  }
  this.current_line._remove_wrap_indent();
};

Output.prototype.trim = function(eat_newlines) {
  eat_newlines = (eat_newlines === undefined) ? false : eat_newlines;

  this.current_line.trim();

  while (eat_newlines && this.__lines.length > 1 &&
    this.current_line.is_empty()) {
    this.__lines.pop();
    this.current_line = this.__lines[this.__lines.length - 1];
    this.current_line.trim();
  }

  this.previous_line = this.__lines.length > 1 ?
    this.__lines[this.__lines.length - 2] : null;
};

Output.prototype.just_added_newline = function() {
  return this.current_line.is_empty();
};

Output.prototype.just_added_blankline = function() {
  return this.is_empty() ||
    (this.current_line.is_empty() && this.previous_line.is_empty());
};

Output.prototype.ensure_empty_line_above = function(starts_with, ends_with) {
  var index = this.__lines.length - 2;
  while (index >= 0) {
    var potentialEmptyLine = this.__lines[index];
    if (potentialEmptyLine.is_empty()) {
      break;
    } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 &&
      potentialEmptyLine.item(-1) !== ends_with) {
      this.__lines.splice(index + 1, 0, new OutputLine(this));
      this.previous_line = this.__lines[this.__lines.length - 2];
      break;
    }
    index--;
  }
};

var Output_1 = Output;

var output = {
	Output: Output_1
};

/*jshint node:true */

function Token(type, text, newlines, whitespace_before) {
  this.type = type;
  this.text = text;

  // comments_before are
  // comments that have a new line before them
  // and may or may not have a newline after
  // this is a set of comments before
  this.comments_before = null; /* inline comment*/


  // this.comments_after =  new TokenStream(); // no new line before and newline after
  this.newlines = newlines || 0;
  this.whitespace_before = whitespace_before || '';
  this.parent = null;
  this.next = null;
  this.previous = null;
  this.opened = null;
  this.closed = null;
  this.directives = null;
}


var Token_1 = Token;

var token = {
	Token: Token_1
};

var acorn = createCommonjsModule(function (module, exports) {

// acorn used char codes to squeeze the last bit of performance out
// Beautifier is okay without that, so we're using regex
// permit # (23), $ (36), and @ (64). @ is used in ES7 decorators.
// 65 through 91 are uppercase letters.
// permit _ (95).
// 97 through 123 are lowercase letters.
var baseASCIIidentifierStartChars = "\\x23\\x24\\x40\\x41-\\x5a\\x5f\\x61-\\x7a";

// inside an identifier @ is not allowed but 0-9 are.
var baseASCIIidentifierChars = "\\x24\\x30-\\x39\\x41-\\x5a\\x5f\\x61-\\x7a";

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.
var nonASCIIidentifierStartChars = "\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc";
var nonASCIIidentifierChars = "\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f";
//var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
//var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

var identifierStart = "(?:\\\\u[0-9a-fA-F]{4}|[" + baseASCIIidentifierStartChars + nonASCIIidentifierStartChars + "])";
var identifierChars = "(?:\\\\u[0-9a-fA-F]{4}|[" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "])*";

exports.identifier = new RegExp(identifierStart + identifierChars, 'g');
exports.identifierStart = new RegExp(identifierStart);
exports.identifierMatch = new RegExp("(?:\\\\u[0-9a-fA-F]{4}|[" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "])+");

// Whether a single character denotes a newline.

exports.newline = /[\n\r\u2028\u2029]/;

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

// in javascript, these two differ
// in python they are the same, different methods are called on them
exports.lineBreak = new RegExp('\r\n|' + exports.newline.source);
exports.allLineBreaks = new RegExp(exports.lineBreak.source, 'g');
});

/*jshint node:true */

function Options(options, merge_child_field) {
  this.raw_options = _mergeOpts(options, merge_child_field);

  // Support passing the source text back with no change
  this.disabled = this._get_boolean('disabled');

  this.eol = this._get_characters('eol', 'auto');
  this.end_with_newline = this._get_boolean('end_with_newline');
  this.indent_size = this._get_number('indent_size', 4);
  this.indent_char = this._get_characters('indent_char', ' ');
  this.indent_level = this._get_number('indent_level');

  this.preserve_newlines = this._get_boolean('preserve_newlines', true);
  this.max_preserve_newlines = this._get_number('max_preserve_newlines', 32786);
  if (!this.preserve_newlines) {
    this.max_preserve_newlines = 0;
  }

  this.indent_with_tabs = this._get_boolean('indent_with_tabs', this.indent_char === '\t');
  if (this.indent_with_tabs) {
    this.indent_char = '\t';

    // indent_size behavior changed after 1.8.6
    // It used to be that indent_size would be
    // set to 1 for indent_with_tabs. That is no longer needed and
    // actually doesn't make sense - why not use spaces? Further,
    // that might produce unexpected behavior - tabs being used
    // for single-column alignment. So, when indent_with_tabs is true
    // and indent_size is 1, reset indent_size to 4.
    if (this.indent_size === 1) {
      this.indent_size = 4;
    }
  }

  // Backwards compat with 1.3.x
  this.wrap_line_length = this._get_number('wrap_line_length', this._get_number('max_char'));

  this.indent_empty_lines = this._get_boolean('indent_empty_lines');

  // valid templating languages ['django', 'erb', 'handlebars', 'php', 'smarty']
  // For now, 'auto' = all off for javascript, all on for html (and inline javascript).
  // other values ignored
  this.templating = this._get_selection_list('templating', ['auto', 'none', 'django', 'erb', 'handlebars', 'php', 'smarty'], ['auto']);
}

Options.prototype._get_array = function(name, default_value) {
  var option_value = this.raw_options[name];
  var result = default_value || [];
  if (typeof option_value === 'object') {
    if (option_value !== null && typeof option_value.concat === 'function') {
      result = option_value.concat();
    }
  } else if (typeof option_value === 'string') {
    result = option_value.split(/[^a-zA-Z0-9_\/\-]+/);
  }
  return result;
};

Options.prototype._get_boolean = function(name, default_value) {
  var option_value = this.raw_options[name];
  var result = option_value === undefined ? !!default_value : !!option_value;
  return result;
};

Options.prototype._get_characters = function(name, default_value) {
  var option_value = this.raw_options[name];
  var result = default_value || '';
  if (typeof option_value === 'string') {
    result = option_value.replace(/\\r/, '\r').replace(/\\n/, '\n').replace(/\\t/, '\t');
  }
  return result;
};

Options.prototype._get_number = function(name, default_value) {
  var option_value = this.raw_options[name];
  default_value = parseInt(default_value, 10);
  if (isNaN(default_value)) {
    default_value = 0;
  }
  var result = parseInt(option_value, 10);
  if (isNaN(result)) {
    result = default_value;
  }
  return result;
};

Options.prototype._get_selection = function(name, selection_list, default_value) {
  var result = this._get_selection_list(name, selection_list, default_value);
  if (result.length !== 1) {
    throw new Error(
      "Invalid Option Value: The option '" + name + "' can only be one of the following values:\n" +
      selection_list + "\nYou passed in: '" + this.raw_options[name] + "'");
  }

  return result[0];
};


Options.prototype._get_selection_list = function(name, selection_list, default_value) {
  if (!selection_list || selection_list.length === 0) {
    throw new Error("Selection list cannot be empty.");
  }

  default_value = default_value || [selection_list[0]];
  if (!this._is_valid_selection(default_value, selection_list)) {
    throw new Error("Invalid Default Value!");
  }

  var result = this._get_array(name, default_value);
  if (!this._is_valid_selection(result, selection_list)) {
    throw new Error(
      "Invalid Option Value: The option '" + name + "' can contain only the following values:\n" +
      selection_list + "\nYou passed in: '" + this.raw_options[name] + "'");
  }

  return result;
};

Options.prototype._is_valid_selection = function(result, selection_list) {
  return result.length && selection_list.length &&
    !result.some(function(item) { return selection_list.indexOf(item) === -1; });
};


// merges child options up with the parent options object
// Example: obj = {a: 1, b: {a: 2}}
//          mergeOpts(obj, 'b')
//
//          Returns: {a: 2}
function _mergeOpts(allOptions, childFieldName) {
  var finalOpts = {};
  allOptions = _normalizeOpts(allOptions);
  var name;

  for (name in allOptions) {
    if (name !== childFieldName) {
      finalOpts[name] = allOptions[name];
    }
  }

  //merge in the per type settings for the childFieldName
  if (childFieldName && allOptions[childFieldName]) {
    for (name in allOptions[childFieldName]) {
      finalOpts[name] = allOptions[childFieldName][name];
    }
  }
  return finalOpts;
}

function _normalizeOpts(options) {
  var convertedOpts = {};
  var key;

  for (key in options) {
    var newKey = key.replace(/-/g, "_");
    convertedOpts[newKey] = options[key];
  }
  return convertedOpts;
}

var Options_1 = Options;
var normalizeOpts = _normalizeOpts;
var mergeOpts = _mergeOpts;

var options = {
	Options: Options_1,
	normalizeOpts: normalizeOpts,
	mergeOpts: mergeOpts
};

var BaseOptions = options.Options;

var validPositionValues = ['before-newline', 'after-newline', 'preserve-newline'];

function Options$1(options) {
  BaseOptions.call(this, options, 'js');

  // compatibility, re
  var raw_brace_style = this.raw_options.brace_style || null;
  if (raw_brace_style === "expand-strict") { //graceful handling of deprecated option
    this.raw_options.brace_style = "expand";
  } else if (raw_brace_style === "collapse-preserve-inline") { //graceful handling of deprecated option
    this.raw_options.brace_style = "collapse,preserve-inline";
  } else if (this.raw_options.braces_on_own_line !== undefined) { //graceful handling of deprecated option
    this.raw_options.brace_style = this.raw_options.braces_on_own_line ? "expand" : "collapse";
    // } else if (!raw_brace_style) { //Nothing exists to set it
    //   raw_brace_style = "collapse";
  }

  //preserve-inline in delimited string will trigger brace_preserve_inline, everything
  //else is considered a brace_style and the last one only will have an effect

  var brace_style_split = this._get_selection_list('brace_style', ['collapse', 'expand', 'end-expand', 'none', 'preserve-inline']);

  this.brace_preserve_inline = false; //Defaults in case one or other was not specified in meta-option
  this.brace_style = "collapse";

  for (var bs = 0; bs < brace_style_split.length; bs++) {
    if (brace_style_split[bs] === "preserve-inline") {
      this.brace_preserve_inline = true;
    } else {
      this.brace_style = brace_style_split[bs];
    }
  }

  this.unindent_chained_methods = this._get_boolean('unindent_chained_methods');
  this.break_chained_methods = this._get_boolean('break_chained_methods');
  this.space_in_paren = this._get_boolean('space_in_paren');
  this.space_in_empty_paren = this._get_boolean('space_in_empty_paren');
  this.jslint_happy = this._get_boolean('jslint_happy');
  this.space_after_anon_function = this._get_boolean('space_after_anon_function');
  this.space_after_named_function = this._get_boolean('space_after_named_function');
  this.keep_array_indentation = this._get_boolean('keep_array_indentation');
  this.space_before_conditional = this._get_boolean('space_before_conditional', true);
  this.unescape_strings = this._get_boolean('unescape_strings');
  this.e4x = this._get_boolean('e4x');
  this.comma_first = this._get_boolean('comma_first');
  this.operator_position = this._get_selection('operator_position', validPositionValues);

  // For testing of beautify preserve:start directive
  this.test_output_raw = this._get_boolean('test_output_raw');

  // force this._options.space_after_anon_function to true if this._options.jslint_happy
  if (this.jslint_happy) {
    this.space_after_anon_function = true;
  }

}
Options$1.prototype = new BaseOptions();



var Options_1$1 = Options$1;

var options$1 = {
	Options: Options_1$1
};

/*jshint node:true */

var regexp_has_sticky = RegExp.prototype.hasOwnProperty('sticky');

function InputScanner(input_string) {
  this.__input = input_string || '';
  this.__input_length = this.__input.length;
  this.__position = 0;
}

InputScanner.prototype.restart = function() {
  this.__position = 0;
};

InputScanner.prototype.back = function() {
  if (this.__position > 0) {
    this.__position -= 1;
  }
};

InputScanner.prototype.hasNext = function() {
  return this.__position < this.__input_length;
};

InputScanner.prototype.next = function() {
  var val = null;
  if (this.hasNext()) {
    val = this.__input.charAt(this.__position);
    this.__position += 1;
  }
  return val;
};

InputScanner.prototype.peek = function(index) {
  var val = null;
  index = index || 0;
  index += this.__position;
  if (index >= 0 && index < this.__input_length) {
    val = this.__input.charAt(index);
  }
  return val;
};

// This is a JavaScript only helper function (not in python)
// Javascript doesn't have a match method
// and not all implementation support "sticky" flag.
// If they do not support sticky then both this.match() and this.test() method
// must get the match and check the index of the match.
// If sticky is supported and set, this method will use it.
// Otherwise it will check that global is set, and fall back to the slower method.
InputScanner.prototype.__match = function(pattern, index) {
  pattern.lastIndex = index;
  var pattern_match = pattern.exec(this.__input);

  if (pattern_match && !(regexp_has_sticky && pattern.sticky)) {
    if (pattern_match.index !== index) {
      pattern_match = null;
    }
  }

  return pattern_match;
};

InputScanner.prototype.test = function(pattern, index) {
  index = index || 0;
  index += this.__position;

  if (index >= 0 && index < this.__input_length) {
    return !!this.__match(pattern, index);
  } else {
    return false;
  }
};

InputScanner.prototype.testChar = function(pattern, index) {
  // test one character regex match
  var val = this.peek(index);
  pattern.lastIndex = 0;
  return val !== null && pattern.test(val);
};

InputScanner.prototype.match = function(pattern) {
  var pattern_match = this.__match(pattern, this.__position);
  if (pattern_match) {
    this.__position += pattern_match[0].length;
  } else {
    pattern_match = null;
  }
  return pattern_match;
};

InputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {
  var val = '';
  var match;
  if (starting_pattern) {
    match = this.match(starting_pattern);
    if (match) {
      val += match[0];
    }
  }
  if (until_pattern && (match || !starting_pattern)) {
    val += this.readUntil(until_pattern, until_after);
  }
  return val;
};

InputScanner.prototype.readUntil = function(pattern, until_after) {
  var val = '';
  var match_index = this.__position;
  pattern.lastIndex = this.__position;
  var pattern_match = pattern.exec(this.__input);
  if (pattern_match) {
    match_index = pattern_match.index;
    if (until_after) {
      match_index += pattern_match[0].length;
    }
  } else {
    match_index = this.__input_length;
  }

  val = this.__input.substring(this.__position, match_index);
  this.__position = match_index;
  return val;
};

InputScanner.prototype.readUntilAfter = function(pattern) {
  return this.readUntil(pattern, true);
};

InputScanner.prototype.get_regexp = function(pattern, match_from) {
  var result = null;
  var flags = 'g';
  if (match_from && regexp_has_sticky) {
    flags = 'y';
  }
  // strings are converted to regexp
  if (typeof pattern === "string" && pattern !== '') {
    // result = new RegExp(pattern.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), flags);
    result = new RegExp(pattern, flags);
  } else if (pattern) {
    result = new RegExp(pattern.source, flags);
  }
  return result;
};

InputScanner.prototype.get_literal_regexp = function(literal_string) {
  return RegExp(literal_string.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'));
};

/* css beautifier legacy helpers */
InputScanner.prototype.peekUntilAfter = function(pattern) {
  var start = this.__position;
  var val = this.readUntilAfter(pattern);
  this.__position = start;
  return val;
};

InputScanner.prototype.lookBack = function(testVal) {
  var start = this.__position - 1;
  return start >= testVal.length && this.__input.substring(start - testVal.length, start)
    .toLowerCase() === testVal;
};

var InputScanner_1 = InputScanner;

var inputscanner = {
	InputScanner: InputScanner_1
};

/*jshint node:true */

function TokenStream(parent_token) {
  // private
  this.__tokens = [];
  this.__tokens_length = this.__tokens.length;
  this.__position = 0;
  this.__parent_token = parent_token;
}

TokenStream.prototype.restart = function() {
  this.__position = 0;
};

TokenStream.prototype.isEmpty = function() {
  return this.__tokens_length === 0;
};

TokenStream.prototype.hasNext = function() {
  return this.__position < this.__tokens_length;
};

TokenStream.prototype.next = function() {
  var val = null;
  if (this.hasNext()) {
    val = this.__tokens[this.__position];
    this.__position += 1;
  }
  return val;
};

TokenStream.prototype.peek = function(index) {
  var val = null;
  index = index || 0;
  index += this.__position;
  if (index >= 0 && index < this.__tokens_length) {
    val = this.__tokens[index];
  }
  return val;
};

TokenStream.prototype.add = function(token) {
  if (this.__parent_token) {
    token.parent = this.__parent_token;
  }
  this.__tokens.push(token);
  this.__tokens_length += 1;
};

var TokenStream_1 = TokenStream;

var tokenstream = {
	TokenStream: TokenStream_1
};

/*jshint node:true */

function Pattern(input_scanner, parent) {
  this._input = input_scanner;
  this._starting_pattern = null;
  this._match_pattern = null;
  this._until_pattern = null;
  this._until_after = false;

  if (parent) {
    this._starting_pattern = this._input.get_regexp(parent._starting_pattern, true);
    this._match_pattern = this._input.get_regexp(parent._match_pattern, true);
    this._until_pattern = this._input.get_regexp(parent._until_pattern);
    this._until_after = parent._until_after;
  }
}

Pattern.prototype.read = function() {
  var result = this._input.read(this._starting_pattern);
  if (!this._starting_pattern || result) {
    result += this._input.read(this._match_pattern, this._until_pattern, this._until_after);
  }
  return result;
};

Pattern.prototype.read_match = function() {
  return this._input.match(this._match_pattern);
};

Pattern.prototype.until_after = function(pattern) {
  var result = this._create();
  result._until_after = true;
  result._until_pattern = this._input.get_regexp(pattern);
  result._update();
  return result;
};

Pattern.prototype.until = function(pattern) {
  var result = this._create();
  result._until_after = false;
  result._until_pattern = this._input.get_regexp(pattern);
  result._update();
  return result;
};

Pattern.prototype.starting_with = function(pattern) {
  var result = this._create();
  result._starting_pattern = this._input.get_regexp(pattern, true);
  result._update();
  return result;
};

Pattern.prototype.matching = function(pattern) {
  var result = this._create();
  result._match_pattern = this._input.get_regexp(pattern, true);
  result._update();
  return result;
};

Pattern.prototype._create = function() {
  return new Pattern(this._input, this);
};

Pattern.prototype._update = function() {};

var Pattern_1 = Pattern;

var pattern = {
	Pattern: Pattern_1
};

var Pattern$1 = pattern.Pattern;

function WhitespacePattern(input_scanner, parent) {
  Pattern$1.call(this, input_scanner, parent);
  if (parent) {
    this._line_regexp = this._input.get_regexp(parent._line_regexp);
  } else {
    this.__set_whitespace_patterns('', '');
  }

  this.newline_count = 0;
  this.whitespace_before_token = '';
}
WhitespacePattern.prototype = new Pattern$1();

WhitespacePattern.prototype.__set_whitespace_patterns = function(whitespace_chars, newline_chars) {
  whitespace_chars += '\\t ';
  newline_chars += '\\n\\r';

  this._match_pattern = this._input.get_regexp(
    '[' + whitespace_chars + newline_chars + ']+', true);
  this._newline_regexp = this._input.get_regexp(
    '\\r\\n|[' + newline_chars + ']');
};

WhitespacePattern.prototype.read = function() {
  this.newline_count = 0;
  this.whitespace_before_token = '';

  var resulting_string = this._input.read(this._match_pattern);
  if (resulting_string === ' ') {
    this.whitespace_before_token = ' ';
  } else if (resulting_string) {
    var matches = this.__split(this._newline_regexp, resulting_string);
    this.newline_count = matches.length - 1;
    this.whitespace_before_token = matches[this.newline_count];
  }

  return resulting_string;
};

WhitespacePattern.prototype.matching = function(whitespace_chars, newline_chars) {
  var result = this._create();
  result.__set_whitespace_patterns(whitespace_chars, newline_chars);
  result._update();
  return result;
};

WhitespacePattern.prototype._create = function() {
  return new WhitespacePattern(this._input, this);
};

WhitespacePattern.prototype.__split = function(regexp, input_string) {
  regexp.lastIndex = 0;
  var start_index = 0;
  var result = [];
  var next_match = regexp.exec(input_string);
  while (next_match) {
    result.push(input_string.substring(start_index, next_match.index));
    start_index = next_match.index + next_match[0].length;
    next_match = regexp.exec(input_string);
  }

  if (start_index < input_string.length) {
    result.push(input_string.substring(start_index, input_string.length));
  } else {
    result.push('');
  }

  return result;
};



var WhitespacePattern_1 = WhitespacePattern;

var whitespacepattern = {
	WhitespacePattern: WhitespacePattern_1
};

var InputScanner$1 = inputscanner.InputScanner;
var Token$1 = token.Token;
var TokenStream$1 = tokenstream.TokenStream;
var WhitespacePattern$1 = whitespacepattern.WhitespacePattern;

var TOKEN = {
  START: 'TK_START',
  RAW: 'TK_RAW',
  EOF: 'TK_EOF'
};

var Tokenizer = function(input_string, options) {
  this._input = new InputScanner$1(input_string);
  this._options = options || {};
  this.__tokens = null;

  this._patterns = {};
  this._patterns.whitespace = new WhitespacePattern$1(this._input);
};

Tokenizer.prototype.tokenize = function() {
  this._input.restart();
  this.__tokens = new TokenStream$1();

  this._reset();

  var current;
  var previous = new Token$1(TOKEN.START, '');
  var open_token = null;
  var open_stack = [];
  var comments = new TokenStream$1();

  while (previous.type !== TOKEN.EOF) {
    current = this._get_next_token(previous, open_token);
    while (this._is_comment(current)) {
      comments.add(current);
      current = this._get_next_token(previous, open_token);
    }

    if (!comments.isEmpty()) {
      current.comments_before = comments;
      comments = new TokenStream$1();
    }

    current.parent = open_token;

    if (this._is_opening(current)) {
      open_stack.push(open_token);
      open_token = current;
    } else if (open_token && this._is_closing(current, open_token)) {
      current.opened = open_token;
      open_token.closed = current;
      open_token = open_stack.pop();
      current.parent = open_token;
    }

    current.previous = previous;
    previous.next = current;

    this.__tokens.add(current);
    previous = current;
  }

  return this.__tokens;
};


Tokenizer.prototype._is_first_token = function() {
  return this.__tokens.isEmpty();
};

Tokenizer.prototype._reset = function() {};

Tokenizer.prototype._get_next_token = function(previous_token, open_token) { // jshint unused:false
  this._readWhitespace();
  var resulting_string = this._input.read(/.+/g);
  if (resulting_string) {
    return this._create_token(TOKEN.RAW, resulting_string);
  } else {
    return this._create_token(TOKEN.EOF, '');
  }
};

Tokenizer.prototype._is_comment = function(current_token) { // jshint unused:false
  return false;
};

Tokenizer.prototype._is_opening = function(current_token) { // jshint unused:false
  return false;
};

Tokenizer.prototype._is_closing = function(current_token, open_token) { // jshint unused:false
  return false;
};

Tokenizer.prototype._create_token = function(type, text) {
  var token = new Token$1(type, text,
    this._patterns.whitespace.newline_count,
    this._patterns.whitespace.whitespace_before_token);
  return token;
};

Tokenizer.prototype._readWhitespace = function() {
  return this._patterns.whitespace.read();
};



var Tokenizer_1 = Tokenizer;
var TOKEN_1 = TOKEN;

var tokenizer = {
	Tokenizer: Tokenizer_1,
	TOKEN: TOKEN_1
};

/*jshint node:true */

function Directives(start_block_pattern, end_block_pattern) {
  start_block_pattern = typeof start_block_pattern === 'string' ? start_block_pattern : start_block_pattern.source;
  end_block_pattern = typeof end_block_pattern === 'string' ? end_block_pattern : end_block_pattern.source;
  this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \w+[:]\w+)+ /.source + end_block_pattern, 'g');
  this.__directive_pattern = / (\w+)[:](\w+)/g;

  this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\sbeautify\signore:end\s/.source + end_block_pattern, 'g');
}

Directives.prototype.get_directives = function(text) {
  if (!text.match(this.__directives_block_pattern)) {
    return null;
  }

  var directives = {};
  this.__directive_pattern.lastIndex = 0;
  var directive_match = this.__directive_pattern.exec(text);

  while (directive_match) {
    directives[directive_match[1]] = directive_match[2];
    directive_match = this.__directive_pattern.exec(text);
  }

  return directives;
};

Directives.prototype.readIgnored = function(input) {
  return input.readUntilAfter(this.__directives_end_ignore_pattern);
};


var Directives_1 = Directives;

var directives = {
	Directives: Directives_1
};

var Pattern$2 = pattern.Pattern;


var template_names = {
  django: false,
  erb: false,
  handlebars: false,
  php: false,
  smarty: false
};

// This lets templates appear anywhere we would do a readUntil
// The cost is higher but it is pay to play.
function TemplatablePattern(input_scanner, parent) {
  Pattern$2.call(this, input_scanner, parent);
  this.__template_pattern = null;
  this._disabled = Object.assign({}, template_names);
  this._excluded = Object.assign({}, template_names);

  if (parent) {
    this.__template_pattern = this._input.get_regexp(parent.__template_pattern);
    this._excluded = Object.assign(this._excluded, parent._excluded);
    this._disabled = Object.assign(this._disabled, parent._disabled);
  }
  var pattern = new Pattern$2(input_scanner);
  this.__patterns = {
    handlebars_comment: pattern.starting_with(/{{!--/).until_after(/--}}/),
    handlebars_unescaped: pattern.starting_with(/{{{/).until_after(/}}}/),
    handlebars: pattern.starting_with(/{{/).until_after(/}}/),
    php: pattern.starting_with(/<\?(?:[=]|php)/).until_after(/\?>/),
    erb: pattern.starting_with(/<%[^%]/).until_after(/[^%]%>/),
    // django coflicts with handlebars a bit.
    django: pattern.starting_with(/{%/).until_after(/%}/),
    django_value: pattern.starting_with(/{{/).until_after(/}}/),
    django_comment: pattern.starting_with(/{#/).until_after(/#}/),
    smarty: pattern.starting_with(/{(?=[^}{\s\n])/).until_after(/[^\s\n]}/),
    smarty_comment: pattern.starting_with(/{\*/).until_after(/\*}/),
    smarty_literal: pattern.starting_with(/{literal}/).until_after(/{\/literal}/)
  };
}
TemplatablePattern.prototype = new Pattern$2();

TemplatablePattern.prototype._create = function() {
  return new TemplatablePattern(this._input, this);
};

TemplatablePattern.prototype._update = function() {
  this.__set_templated_pattern();
};

TemplatablePattern.prototype.disable = function(language) {
  var result = this._create();
  result._disabled[language] = true;
  result._update();
  return result;
};

TemplatablePattern.prototype.read_options = function(options) {
  var result = this._create();
  for (var language in template_names) {
    result._disabled[language] = options.templating.indexOf(language) === -1;
  }
  result._update();
  return result;
};

TemplatablePattern.prototype.exclude = function(language) {
  var result = this._create();
  result._excluded[language] = true;
  result._update();
  return result;
};

TemplatablePattern.prototype.read = function() {
  var result = '';
  if (this._match_pattern) {
    result = this._input.read(this._starting_pattern);
  } else {
    result = this._input.read(this._starting_pattern, this.__template_pattern);
  }
  var next = this._read_template();
  while (next) {
    if (this._match_pattern) {
      next += this._input.read(this._match_pattern);
    } else {
      next += this._input.readUntil(this.__template_pattern);
    }
    result += next;
    next = this._read_template();
  }

  if (this._until_after) {
    result += this._input.readUntilAfter(this._until_pattern);
  }
  return result;
};

TemplatablePattern.prototype.__set_templated_pattern = function() {
  var items = [];

  if (!this._disabled.php) {
    items.push(this.__patterns.php._starting_pattern.source);
  }
  if (!this._disabled.handlebars) {
    items.push(this.__patterns.handlebars._starting_pattern.source);
  }
  if (!this._disabled.erb) {
    items.push(this.__patterns.erb._starting_pattern.source);
  }
  if (!this._disabled.django) {
    items.push(this.__patterns.django._starting_pattern.source);
    // The starting pattern for django is more complex because it has different
    // patterns for value, comment, and other sections
    items.push(this.__patterns.django_value._starting_pattern.source);
    items.push(this.__patterns.django_comment._starting_pattern.source);
  }
  if (!this._disabled.smarty) {
    items.push(this.__patterns.smarty._starting_pattern.source);
  }

  if (this._until_pattern) {
    items.push(this._until_pattern.source);
  }
  this.__template_pattern = this._input.get_regexp('(?:' + items.join('|') + ')');
};

TemplatablePattern.prototype._read_template = function() {
  var resulting_string = '';
  var c = this._input.peek();
  if (c === '<') {
    var peek1 = this._input.peek(1);
    //if we're in a comment, do something special
    // We treat all comments as literals, even more than preformatted tags
    // we just look for the appropriate close tag
    if (!this._disabled.php && !this._excluded.php && peek1 === '?') {
      resulting_string = resulting_string ||
        this.__patterns.php.read();
    }
    if (!this._disabled.erb && !this._excluded.erb && peek1 === '%') {
      resulting_string = resulting_string ||
        this.__patterns.erb.read();
    }
  } else if (c === '{') {
    if (!this._disabled.handlebars && !this._excluded.handlebars) {
      resulting_string = resulting_string ||
        this.__patterns.handlebars_comment.read();
      resulting_string = resulting_string ||
        this.__patterns.handlebars_unescaped.read();
      resulting_string = resulting_string ||
        this.__patterns.handlebars.read();
    }
    if (!this._disabled.django) {
      // django coflicts with handlebars a bit.
      if (!this._excluded.django && !this._excluded.handlebars) {
        resulting_string = resulting_string ||
          this.__patterns.django_value.read();
      }
      if (!this._excluded.django) {
        resulting_string = resulting_string ||
          this.__patterns.django_comment.read();
        resulting_string = resulting_string ||
          this.__patterns.django.read();
      }
    }
    if (!this._disabled.smarty) {
      // smarty cannot be enabled with django or handlebars enabled
      if (this._disabled.django && this._disabled.handlebars) {
        resulting_string = resulting_string ||
          this.__patterns.smarty_comment.read();
        resulting_string = resulting_string ||
          this.__patterns.smarty_literal.read();
        resulting_string = resulting_string ||
          this.__patterns.smarty.read();
      }
    }
  }
  return resulting_string;
};


var TemplatablePattern_1 = TemplatablePattern;

var templatablepattern = {
	TemplatablePattern: TemplatablePattern_1
};

var InputScanner$2 = inputscanner.InputScanner;
var BaseTokenizer = tokenizer.Tokenizer;
var BASETOKEN = tokenizer.TOKEN;
var Directives$1 = directives.Directives;

var Pattern$3 = pattern.Pattern;
var TemplatablePattern$1 = templatablepattern.TemplatablePattern;


function in_array(what, arr) {
  return arr.indexOf(what) !== -1;
}


var TOKEN$1 = {
  START_EXPR: 'TK_START_EXPR',
  END_EXPR: 'TK_END_EXPR',
  START_BLOCK: 'TK_START_BLOCK',
  END_BLOCK: 'TK_END_BLOCK',
  WORD: 'TK_WORD',
  RESERVED: 'TK_RESERVED',
  SEMICOLON: 'TK_SEMICOLON',
  STRING: 'TK_STRING',
  EQUALS: 'TK_EQUALS',
  OPERATOR: 'TK_OPERATOR',
  COMMA: 'TK_COMMA',
  BLOCK_COMMENT: 'TK_BLOCK_COMMENT',
  COMMENT: 'TK_COMMENT',
  DOT: 'TK_DOT',
  UNKNOWN: 'TK_UNKNOWN',
  START: BASETOKEN.START,
  RAW: BASETOKEN.RAW,
  EOF: BASETOKEN.EOF
};


var directives_core = new Directives$1(/\/\*/, /\*\//);

var number_pattern = /0[xX][0123456789abcdefABCDEF]*|0[oO][01234567]*|0[bB][01]*|\d+n|(?:\.\d+|\d+\.?\d*)(?:[eE][+-]?\d+)?/;

var digit = /[0-9]/;

// Dot "." must be distinguished from "..." and decimal
var dot_pattern = /[^\d\.]/;

var positionable_operators = (
  ">>> === !== " +
  "<< && >= ** != == <= >> || ?? |> " +
  "< / - + > : & % ? ^ | *").split(' ');

// IMPORTANT: this must be sorted longest to shortest or tokenizing many not work.
// Also, you must update possitionable operators separately from punct
var punct =
  ">>>= " +
  "... >>= <<= === >>> !== **= " +
  "=> ^= :: /= << <= == && -= >= >> != -- += ** || ?? ++ %= &= *= |= |> " +
  "= ! ? > < : / ^ - + * & % ~ |";

punct = punct.replace(/[-[\]{}()*+?.,\\^$|#]/g, "\\$&");
// ?. but not if followed by a number 
punct = '\\?\\.(?!\\d) ' + punct;
punct = punct.replace(/ /g, '|');

var punct_pattern = new RegExp(punct);

// words which should always start on new line.
var line_starters = 'continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,import,export'.split(',');
var reserved_words = line_starters.concat(['do', 'in', 'of', 'else', 'get', 'set', 'new', 'catch', 'finally', 'typeof', 'yield', 'async', 'await', 'from', 'as']);
var reserved_word_pattern = new RegExp('^(?:' + reserved_words.join('|') + ')$');

// var template_pattern = /(?:(?:<\?php|<\?=)[\s\S]*?\?>)|(?:<%[\s\S]*?%>)/g;

var in_html_comment;

var Tokenizer$1 = function(input_string, options) {
  BaseTokenizer.call(this, input_string, options);

  this._patterns.whitespace = this._patterns.whitespace.matching(
    /\u00A0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff/.source,
    /\u2028\u2029/.source);

  var pattern_reader = new Pattern$3(this._input);
  var templatable = new TemplatablePattern$1(this._input)
    .read_options(this._options);

  this.__patterns = {
    template: templatable,
    identifier: templatable.starting_with(acorn.identifier).matching(acorn.identifierMatch),
    number: pattern_reader.matching(number_pattern),
    punct: pattern_reader.matching(punct_pattern),
    // comment ends just before nearest linefeed or end of file
    comment: pattern_reader.starting_with(/\/\//).until(/[\n\r\u2028\u2029]/),
    //  /* ... */ comment ends with nearest */ or end of file
    block_comment: pattern_reader.starting_with(/\/\*/).until_after(/\*\//),
    html_comment_start: pattern_reader.matching(/<!--/),
    html_comment_end: pattern_reader.matching(/-->/),
    include: pattern_reader.starting_with(/#include/).until_after(acorn.lineBreak),
    shebang: pattern_reader.starting_with(/#!/).until_after(acorn.lineBreak),
    xml: pattern_reader.matching(/[\s\S]*?<(\/?)([-a-zA-Z:0-9_.]+|{[\s\S]+?}|!\[CDATA\[[\s\S]*?\]\]|)(\s+{[\s\S]+?}|\s+[-a-zA-Z:0-9_.]+|\s+[-a-zA-Z:0-9_.]+\s*=\s*('[^']*'|"[^"]*"|{[\s\S]+?}))*\s*(\/?)\s*>/),
    single_quote: templatable.until(/['\\\n\r\u2028\u2029]/),
    double_quote: templatable.until(/["\\\n\r\u2028\u2029]/),
    template_text: templatable.until(/[`\\$]/),
    template_expression: templatable.until(/[`}\\]/)
  };

};
Tokenizer$1.prototype = new BaseTokenizer();

Tokenizer$1.prototype._is_comment = function(current_token) {
  return current_token.type === TOKEN$1.COMMENT || current_token.type === TOKEN$1.BLOCK_COMMENT || current_token.type === TOKEN$1.UNKNOWN;
};

Tokenizer$1.prototype._is_opening = function(current_token) {
  return current_token.type === TOKEN$1.START_BLOCK || current_token.type === TOKEN$1.START_EXPR;
};

Tokenizer$1.prototype._is_closing = function(current_token, open_token) {
  return (current_token.type === TOKEN$1.END_BLOCK || current_token.type === TOKEN$1.END_EXPR) &&
    (open_token && (
      (current_token.text === ']' && open_token.text === '[') ||
      (current_token.text === ')' && open_token.text === '(') ||
      (current_token.text === '}' && open_token.text === '{')));
};

Tokenizer$1.prototype._reset = function() {
  in_html_comment = false;
};

Tokenizer$1.prototype._get_next_token = function(previous_token, open_token) { // jshint unused:false
  var token = null;
  this._readWhitespace();
  var c = this._input.peek();

  if (c === null) {
    return this._create_token(TOKEN$1.EOF, '');
  }

  token = token || this._read_non_javascript(c);
  token = token || this._read_string(c);
  token = token || this._read_word(previous_token);
  token = token || this._read_singles(c);
  token = token || this._read_comment(c);
  token = token || this._read_regexp(c, previous_token);
  token = token || this._read_xml(c, previous_token);
  token = token || this._read_punctuation();
  token = token || this._create_token(TOKEN$1.UNKNOWN, this._input.next());

  return token;
};

Tokenizer$1.prototype._read_word = function(previous_token) {
  var resulting_string;
  resulting_string = this.__patterns.identifier.read();
  if (resulting_string !== '') {
    resulting_string = resulting_string.replace(acorn.allLineBreaks, '\n');
    if (!(previous_token.type === TOKEN$1.DOT ||
        (previous_token.type === TOKEN$1.RESERVED && (previous_token.text === 'set' || previous_token.text === 'get'))) &&
      reserved_word_pattern.test(resulting_string)) {
      if (resulting_string === 'in' || resulting_string === 'of') { // hack for 'in' and 'of' operators
        return this._create_token(TOKEN$1.OPERATOR, resulting_string);
      }
      return this._create_token(TOKEN$1.RESERVED, resulting_string);
    }
    return this._create_token(TOKEN$1.WORD, resulting_string);
  }

  resulting_string = this.__patterns.number.read();
  if (resulting_string !== '') {
    return this._create_token(TOKEN$1.WORD, resulting_string);
  }
};

Tokenizer$1.prototype._read_singles = function(c) {
  var token = null;
  if (c === '(' || c === '[') {
    token = this._create_token(TOKEN$1.START_EXPR, c);
  } else if (c === ')' || c === ']') {
    token = this._create_token(TOKEN$1.END_EXPR, c);
  } else if (c === '{') {
    token = this._create_token(TOKEN$1.START_BLOCK, c);
  } else if (c === '}') {
    token = this._create_token(TOKEN$1.END_BLOCK, c);
  } else if (c === ';') {
    token = this._create_token(TOKEN$1.SEMICOLON, c);
  } else if (c === '.' && dot_pattern.test(this._input.peek(1))) {
    token = this._create_token(TOKEN$1.DOT, c);
  } else if (c === ',') {
    token = this._create_token(TOKEN$1.COMMA, c);
  }

  if (token) {
    this._input.next();
  }
  return token;
};

Tokenizer$1.prototype._read_punctuation = function() {
  var resulting_string = this.__patterns.punct.read();

  if (resulting_string !== '') {
    if (resulting_string === '=') {
      return this._create_token(TOKEN$1.EQUALS, resulting_string);
    } else if (resulting_string === '?.') {
      return this._create_token(TOKEN$1.DOT, resulting_string);
    } else {
      return this._create_token(TOKEN$1.OPERATOR, resulting_string);
    }
  }
};

Tokenizer$1.prototype._read_non_javascript = function(c) {
  var resulting_string = '';

  if (c === '#') {
    if (this._is_first_token()) {
      resulting_string = this.__patterns.shebang.read();

      if (resulting_string) {
        return this._create_token(TOKEN$1.UNKNOWN, resulting_string.trim() + '\n');
      }
    }

    // handles extendscript #includes
    resulting_string = this.__patterns.include.read();

    if (resulting_string) {
      return this._create_token(TOKEN$1.UNKNOWN, resulting_string.trim() + '\n');
    }

    c = this._input.next();

    // Spidermonkey-specific sharp variables for circular references. Considered obsolete.
    var sharp = '#';
    if (this._input.hasNext() && this._input.testChar(digit)) {
      do {
        c = this._input.next();
        sharp += c;
      } while (this._input.hasNext() && c !== '#' && c !== '=');
      if (c === '#') ; else if (this._input.peek() === '[' && this._input.peek(1) === ']') {
        sharp += '[]';
        this._input.next();
        this._input.next();
      } else if (this._input.peek() === '{' && this._input.peek(1) === '}') {
        sharp += '{}';
        this._input.next();
        this._input.next();
      }
      return this._create_token(TOKEN$1.WORD, sharp);
    }

    this._input.back();

  } else if (c === '<' && this._is_first_token()) {
    resulting_string = this.__patterns.html_comment_start.read();
    if (resulting_string) {
      while (this._input.hasNext() && !this._input.testChar(acorn.newline)) {
        resulting_string += this._input.next();
      }
      in_html_comment = true;
      return this._create_token(TOKEN$1.COMMENT, resulting_string);
    }
  } else if (in_html_comment && c === '-') {
    resulting_string = this.__patterns.html_comment_end.read();
    if (resulting_string) {
      in_html_comment = false;
      return this._create_token(TOKEN$1.COMMENT, resulting_string);
    }
  }

  return null;
};

Tokenizer$1.prototype._read_comment = function(c) {
  var token = null;
  if (c === '/') {
    var comment = '';
    if (this._input.peek(1) === '*') {
      // peek for comment /* ... */
      comment = this.__patterns.block_comment.read();
      var directives = directives_core.get_directives(comment);
      if (directives && directives.ignore === 'start') {
        comment += directives_core.readIgnored(this._input);
      }
      comment = comment.replace(acorn.allLineBreaks, '\n');
      token = this._create_token(TOKEN$1.BLOCK_COMMENT, comment);
      token.directives = directives;
    } else if (this._input.peek(1) === '/') {
      // peek for comment // ...
      comment = this.__patterns.comment.read();
      token = this._create_token(TOKEN$1.COMMENT, comment);
    }
  }
  return token;
};

Tokenizer$1.prototype._read_string = function(c) {
  if (c === '`' || c === "'" || c === '"') {
    var resulting_string = this._input.next();
    this.has_char_escapes = false;

    if (c === '`') {
      resulting_string += this._read_string_recursive('`', true, '${');
    } else {
      resulting_string += this._read_string_recursive(c);
    }

    if (this.has_char_escapes && this._options.unescape_strings) {
      resulting_string = unescape_string(resulting_string);
    }

    if (this._input.peek() === c) {
      resulting_string += this._input.next();
    }

    resulting_string = resulting_string.replace(acorn.allLineBreaks, '\n');

    return this._create_token(TOKEN$1.STRING, resulting_string);
  }

  return null;
};

Tokenizer$1.prototype._allow_regexp_or_xml = function(previous_token) {
  // regex and xml can only appear in specific locations during parsing
  return (previous_token.type === TOKEN$1.RESERVED && in_array(previous_token.text, ['return', 'case', 'throw', 'else', 'do', 'typeof', 'yield'])) ||
    (previous_token.type === TOKEN$1.END_EXPR && previous_token.text === ')' &&
      previous_token.opened.previous.type === TOKEN$1.RESERVED && in_array(previous_token.opened.previous.text, ['if', 'while', 'for'])) ||
    (in_array(previous_token.type, [TOKEN$1.COMMENT, TOKEN$1.START_EXPR, TOKEN$1.START_BLOCK, TOKEN$1.START,
      TOKEN$1.END_BLOCK, TOKEN$1.OPERATOR, TOKEN$1.EQUALS, TOKEN$1.EOF, TOKEN$1.SEMICOLON, TOKEN$1.COMMA
    ]));
};

Tokenizer$1.prototype._read_regexp = function(c, previous_token) {

  if (c === '/' && this._allow_regexp_or_xml(previous_token)) {
    // handle regexp
    //
    var resulting_string = this._input.next();
    var esc = false;

    var in_char_class = false;
    while (this._input.hasNext() &&
      ((esc || in_char_class || this._input.peek() !== c) &&
        !this._input.testChar(acorn.newline))) {
      resulting_string += this._input.peek();
      if (!esc) {
        esc = this._input.peek() === '\\';
        if (this._input.peek() === '[') {
          in_char_class = true;
        } else if (this._input.peek() === ']') {
          in_char_class = false;
        }
      } else {
        esc = false;
      }
      this._input.next();
    }

    if (this._input.peek() === c) {
      resulting_string += this._input.next();

      // regexps may have modifiers /regexp/MOD , so fetch those, too
      // Only [gim] are valid, but if the user puts in garbage, do what we can to take it.
      resulting_string += this._input.read(acorn.identifier);
    }
    return this._create_token(TOKEN$1.STRING, resulting_string);
  }
  return null;
};

Tokenizer$1.prototype._read_xml = function(c, previous_token) {

  if (this._options.e4x && c === "<" && this._allow_regexp_or_xml(previous_token)) {
    var xmlStr = '';
    var match = this.__patterns.xml.read_match();
    // handle e4x xml literals
    //
    if (match) {
      // Trim root tag to attempt to
      var rootTag = match[2].replace(/^{\s+/, '{').replace(/\s+}$/, '}');
      var isCurlyRoot = rootTag.indexOf('{') === 0;
      var depth = 0;
      while (match) {
        var isEndTag = !!match[1];
        var tagName = match[2];
        var isSingletonTag = (!!match[match.length - 1]) || (tagName.slice(0, 8) === "![CDATA[");
        if (!isSingletonTag &&
          (tagName === rootTag || (isCurlyRoot && tagName.replace(/^{\s+/, '{').replace(/\s+}$/, '}')))) {
          if (isEndTag) {
            --depth;
          } else {
            ++depth;
          }
        }
        xmlStr += match[0];
        if (depth <= 0) {
          break;
        }
        match = this.__patterns.xml.read_match();
      }
      // if we didn't close correctly, keep unformatted.
      if (!match) {
        xmlStr += this._input.match(/[\s\S]*/g)[0];
      }
      xmlStr = xmlStr.replace(acorn.allLineBreaks, '\n');
      return this._create_token(TOKEN$1.STRING, xmlStr);
    }
  }

  return null;
};

function unescape_string(s) {
  // You think that a regex would work for this
  // return s.replace(/\\x([0-9a-f]{2})/gi, function(match, val) {
  //         return String.fromCharCode(parseInt(val, 16));
  //     })
  // However, dealing with '\xff', '\\xff', '\\\xff' makes this more fun.
  var out = '',
    escaped = 0;

  var input_scan = new InputScanner$2(s);
  var matched = null;

  while (input_scan.hasNext()) {
    // Keep any whitespace, non-slash characters
    // also keep slash pairs.
    matched = input_scan.match(/([\s]|[^\\]|\\\\)+/g);

    if (matched) {
      out += matched[0];
    }

    if (input_scan.peek() === '\\') {
      input_scan.next();
      if (input_scan.peek() === 'x') {
        matched = input_scan.match(/x([0-9A-Fa-f]{2})/g);
      } else if (input_scan.peek() === 'u') {
        matched = input_scan.match(/u([0-9A-Fa-f]{4})/g);
      } else {
        out += '\\';
        if (input_scan.hasNext()) {
          out += input_scan.next();
        }
        continue;
      }

      // If there's some error decoding, return the original string
      if (!matched) {
        return s;
      }

      escaped = parseInt(matched[1], 16);

      if (escaped > 0x7e && escaped <= 0xff && matched[0].indexOf('x') === 0) {
        // we bail out on \x7f..\xff,
        // leaving whole string escaped,
        // as it's probably completely binary
        return s;
      } else if (escaped >= 0x00 && escaped < 0x20) {
        // leave 0x00...0x1f escaped
        out += '\\' + matched[0];
        continue;
      } else if (escaped === 0x22 || escaped === 0x27 || escaped === 0x5c) {
        // single-quote, apostrophe, backslash - escape these
        out += '\\' + String.fromCharCode(escaped);
      } else {
        out += String.fromCharCode(escaped);
      }
    }
  }

  return out;
}

// handle string
//
Tokenizer$1.prototype._read_string_recursive = function(delimiter, allow_unescaped_newlines, start_sub) {
  var current_char;
  var pattern;
  if (delimiter === '\'') {
    pattern = this.__patterns.single_quote;
  } else if (delimiter === '"') {
    pattern = this.__patterns.double_quote;
  } else if (delimiter === '`') {
    pattern = this.__patterns.template_text;
  } else if (delimiter === '}') {
    pattern = this.__patterns.template_expression;
  }

  var resulting_string = pattern.read();
  var next = '';
  while (this._input.hasNext()) {
    next = this._input.next();
    if (next === delimiter ||
      (!allow_unescaped_newlines && acorn.newline.test(next))) {
      this._input.back();
      break;
    } else if (next === '\\' && this._input.hasNext()) {
      current_char = this._input.peek();

      if (current_char === 'x' || current_char === 'u') {
        this.has_char_escapes = true;
      } else if (current_char === '\r' && this._input.peek(1) === '\n') {
        this._input.next();
      }
      next += this._input.next();
    } else if (start_sub) {
      if (start_sub === '${' && next === '$' && this._input.peek() === '{') {
        next += this._input.next();
      }

      if (start_sub === next) {
        if (delimiter === '`') {
          next += this._read_string_recursive('}', allow_unescaped_newlines, '`');
        } else {
          next += this._read_string_recursive('`', allow_unescaped_newlines, '${');
        }
        if (this._input.hasNext()) {
          next += this._input.next();
        }
      }
    }
    next += pattern.read();
    resulting_string += next;
  }

  return resulting_string;
};

var Tokenizer_1$1 = Tokenizer$1;
var TOKEN_1$1 = TOKEN$1;
var positionable_operators_1 = positionable_operators.slice();
var line_starters_1 = line_starters.slice();

var tokenizer$1 = {
	Tokenizer: Tokenizer_1$1,
	TOKEN: TOKEN_1$1,
	positionable_operators: positionable_operators_1,
	line_starters: line_starters_1
};

var Output$1 = output.Output;
var Token$2 = token.Token;

var Options$2 = options$1.Options;
var Tokenizer$2 = tokenizer$1.Tokenizer;
var line_starters$1 = tokenizer$1.line_starters;
var positionable_operators$1 = tokenizer$1.positionable_operators;
var TOKEN$2 = tokenizer$1.TOKEN;


function in_array$1(what, arr) {
  return arr.indexOf(what) !== -1;
}

function ltrim(s) {
  return s.replace(/^\s+/g, '');
}

function generateMapFromStrings(list) {
  var result = {};
  for (var x = 0; x < list.length; x++) {
    // make the mapped names underscored instead of dash
    result[list[x].replace(/-/g, '_')] = list[x];
  }
  return result;
}

function reserved_word(token, word) {
  return token && token.type === TOKEN$2.RESERVED && token.text === word;
}

function reserved_array(token, words) {
  return token && token.type === TOKEN$2.RESERVED && in_array$1(token.text, words);
}
// Unsure of what they mean, but they work. Worth cleaning up in future.
var special_words = ['case', 'return', 'do', 'if', 'throw', 'else', 'await', 'break', 'continue', 'async'];

var validPositionValues$1 = ['before-newline', 'after-newline', 'preserve-newline'];

// Generate map from array
var OPERATOR_POSITION = generateMapFromStrings(validPositionValues$1);

var OPERATOR_POSITION_BEFORE_OR_PRESERVE = [OPERATOR_POSITION.before_newline, OPERATOR_POSITION.preserve_newline];

var MODE = {
  BlockStatement: 'BlockStatement', // 'BLOCK'
  Statement: 'Statement', // 'STATEMENT'
  ObjectLiteral: 'ObjectLiteral', // 'OBJECT',
  ArrayLiteral: 'ArrayLiteral', //'[EXPRESSION]',
  ForInitializer: 'ForInitializer', //'(FOR-EXPRESSION)',
  Conditional: 'Conditional', //'(COND-EXPRESSION)',
  Expression: 'Expression' //'(EXPRESSION)'
};

function remove_redundant_indentation(output, frame) {
  // This implementation is effective but has some issues:
  //     - can cause line wrap to happen too soon due to indent removal
  //           after wrap points are calculated
  // These issues are minor compared to ugly indentation.

  if (frame.multiline_frame ||
    frame.mode === MODE.ForInitializer ||
    frame.mode === MODE.Conditional) {
    return;
  }

  // remove one indent from each line inside this section
  output.remove_indent(frame.start_line_index);
}

// we could use just string.split, but
// IE doesn't like returning empty strings
function split_linebreaks(s) {
  //return s.split(/\x0d\x0a|\x0a/);

  s = s.replace(acorn.allLineBreaks, '\n');
  var out = [],
    idx = s.indexOf("\n");
  while (idx !== -1) {
    out.push(s.substring(0, idx));
    s = s.substring(idx + 1);
    idx = s.indexOf("\n");
  }
  if (s.length) {
    out.push(s);
  }
  return out;
}

function is_array(mode) {
  return mode === MODE.ArrayLiteral;
}

function is_expression(mode) {
  return in_array$1(mode, [MODE.Expression, MODE.ForInitializer, MODE.Conditional]);
}

function all_lines_start_with(lines, c) {
  for (var i = 0; i < lines.length; i++) {
    var line = lines[i].trim();
    if (line.charAt(0) !== c) {
      return false;
    }
  }
  return true;
}

function each_line_matches_indent(lines, indent) {
  var i = 0,
    len = lines.length,
    line;
  for (; i < len; i++) {
    line = lines[i];
    // allow empty lines to pass through
    if (line && line.indexOf(indent) !== 0) {
      return false;
    }
  }
  return true;
}


function Beautifier(source_text, options) {
  options = options || {};
  this._source_text = source_text || '';

  this._output = null;
  this._tokens = null;
  this._last_last_text = null;
  this._flags = null;
  this._previous_flags = null;

  this._flag_store = null;
  this._options = new Options$2(options);
}

Beautifier.prototype.create_flags = function(flags_base, mode) {
  var next_indent_level = 0;
  if (flags_base) {
    next_indent_level = flags_base.indentation_level;
    if (!this._output.just_added_newline() &&
      flags_base.line_indent_level > next_indent_level) {
      next_indent_level = flags_base.line_indent_level;
    }
  }

  var next_flags = {
    mode: mode,
    parent: flags_base,
    last_token: flags_base ? flags_base.last_token : new Token$2(TOKEN$2.START_BLOCK, ''), // last token text
    last_word: flags_base ? flags_base.last_word : '', // last TOKEN.WORD passed
    declaration_statement: false,
    declaration_assignment: false,
    multiline_frame: false,
    inline_frame: false,
    if_block: false,
    else_block: false,
    do_block: false,
    do_while: false,
    import_block: false,
    in_case_statement: false, // switch(..){ INSIDE HERE }
    in_case: false, // we're on the exact line with "case 0:"
    case_body: false, // the indented case-action block
    indentation_level: next_indent_level,
    alignment: 0,
    line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,
    start_line_index: this._output.get_line_number(),
    ternary_depth: 0
  };
  return next_flags;
};

Beautifier.prototype._reset = function(source_text) {
  var baseIndentString = source_text.match(/^[\t ]*/)[0];

  this._last_last_text = ''; // pre-last token text
  this._output = new Output$1(this._options, baseIndentString);

  // If testing the ignore directive, start with output disable set to true
  this._output.raw = this._options.test_output_raw;


  // Stack of parsing/formatting states, including MODE.
  // We tokenize, parse, and output in an almost purely a forward-only stream of token input
  // and formatted output.  This makes the beautifier less accurate than full parsers
  // but also far more tolerant of syntax errors.
  //
  // For example, the default mode is MODE.BlockStatement. If we see a '{' we push a new frame of type
  // MODE.BlockStatement on the the stack, even though it could be object literal.  If we later
  // encounter a ":", we'll switch to to MODE.ObjectLiteral.  If we then see a ";",
  // most full parsers would die, but the beautifier gracefully falls back to
  // MODE.BlockStatement and continues on.
  this._flag_store = [];
  this.set_mode(MODE.BlockStatement);
  var tokenizer = new Tokenizer$2(source_text, this._options);
  this._tokens = tokenizer.tokenize();
  return source_text;
};

Beautifier.prototype.beautify = function() {
  // if disabled, return the input unchanged.
  if (this._options.disabled) {
    return this._source_text;
  }

  var sweet_code;
  var source_text = this._reset(this._source_text);

  var eol = this._options.eol;
  if (this._options.eol === 'auto') {
    eol = '\n';
    if (source_text && acorn.lineBreak.test(source_text || '')) {
      eol = source_text.match(acorn.lineBreak)[0];
    }
  }

  var current_token = this._tokens.next();
  while (current_token) {
    this.handle_token(current_token);

    this._last_last_text = this._flags.last_token.text;
    this._flags.last_token = current_token;

    current_token = this._tokens.next();
  }

  sweet_code = this._output.get_code(eol);

  return sweet_code;
};

Beautifier.prototype.handle_token = function(current_token, preserve_statement_flags) {
  if (current_token.type === TOKEN$2.START_EXPR) {
    this.handle_start_expr(current_token);
  } else if (current_token.type === TOKEN$2.END_EXPR) {
    this.handle_end_expr(current_token);
  } else if (current_token.type === TOKEN$2.START_BLOCK) {
    this.handle_start_block(current_token);
  } else if (current_token.type === TOKEN$2.END_BLOCK) {
    this.handle_end_block(current_token);
  } else if (current_token.type === TOKEN$2.WORD) {
    this.handle_word(current_token);
  } else if (current_token.type === TOKEN$2.RESERVED) {
    this.handle_word(current_token);
  } else if (current_token.type === TOKEN$2.SEMICOLON) {
    this.handle_semicolon(current_token);
  } else if (current_token.type === TOKEN$2.STRING) {
    this.handle_string(current_token);
  } else if (current_token.type === TOKEN$2.EQUALS) {
    this.handle_equals(current_token);
  } else if (current_token.type === TOKEN$2.OPERATOR) {
    this.handle_operator(current_token);
  } else if (current_token.type === TOKEN$2.COMMA) {
    this.handle_comma(current_token);
  } else if (current_token.type === TOKEN$2.BLOCK_COMMENT) {
    this.handle_block_comment(current_token, preserve_statement_flags);
  } else if (current_token.type === TOKEN$2.COMMENT) {
    this.handle_comment(current_token, preserve_statement_flags);
  } else if (current_token.type === TOKEN$2.DOT) {
    this.handle_dot(current_token);
  } else if (current_token.type === TOKEN$2.EOF) {
    this.handle_eof(current_token);
  } else if (current_token.type === TOKEN$2.UNKNOWN) {
    this.handle_unknown(current_token, preserve_statement_flags);
  } else {
    this.handle_unknown(current_token, preserve_statement_flags);
  }
};

Beautifier.prototype.handle_whitespace_and_comments = function(current_token, preserve_statement_flags) {
  var newlines = current_token.newlines;
  var keep_whitespace = this._options.keep_array_indentation && is_array(this._flags.mode);

  if (current_token.comments_before) {
    var comment_token = current_token.comments_before.next();
    while (comment_token) {
      // The cleanest handling of inline comments is to treat them as though they aren't there.
      // Just continue formatting and the behavior should be logical.
      // Also ignore unknown tokens.  Again, this should result in better behavior.
      this.handle_whitespace_and_comments(comment_token, preserve_statement_flags);
      this.handle_token(comment_token, preserve_statement_flags);
      comment_token = current_token.comments_before.next();
    }
  }

  if (keep_whitespace) {
    for (var i = 0; i < newlines; i += 1) {
      this.print_newline(i > 0, preserve_statement_flags);
    }
  } else {
    if (this._options.max_preserve_newlines && newlines > this._options.max_preserve_newlines) {
      newlines = this._options.max_preserve_newlines;
    }

    if (this._options.preserve_newlines) {
      if (newlines > 1) {
        this.print_newline(false, preserve_statement_flags);
        for (var j = 1; j < newlines; j += 1) {
          this.print_newline(true, preserve_statement_flags);
        }
      }
    }
  }

};

var newline_restricted_tokens = ['async', 'break', 'continue', 'return', 'throw', 'yield'];

Beautifier.prototype.allow_wrap_or_preserved_newline = function(current_token, force_linewrap) {
  force_linewrap = (force_linewrap === undefined) ? false : force_linewrap;

  // Never wrap the first token on a line
  if (this._output.just_added_newline()) {
    return;
  }

  var shouldPreserveOrForce = (this._options.preserve_newlines && current_token.newlines) || force_linewrap;
  var operatorLogicApplies = in_array$1(this._flags.last_token.text, positionable_operators$1) ||
    in_array$1(current_token.text, positionable_operators$1);

  if (operatorLogicApplies) {
    var shouldPrintOperatorNewline = (
        in_array$1(this._flags.last_token.text, positionable_operators$1) &&
        in_array$1(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)
      ) ||
      in_array$1(current_token.text, positionable_operators$1);
    shouldPreserveOrForce = shouldPreserveOrForce && shouldPrintOperatorNewline;
  }

  if (shouldPreserveOrForce) {
    this.print_newline(false, true);
  } else if (this._options.wrap_line_length) {
    if (reserved_array(this._flags.last_token, newline_restricted_tokens)) {
      // These tokens should never have a newline inserted
      // between them and the following expression.
      return;
    }
    this._output.set_wrap_point();
  }
};

Beautifier.prototype.print_newline = function(force_newline, preserve_statement_flags) {
  if (!preserve_statement_flags) {
    if (this._flags.last_token.text !== ';' && this._flags.last_token.text !== ',' && this._flags.last_token.text !== '=' && (this._flags.last_token.type !== TOKEN$2.OPERATOR || this._flags.last_token.text === '--' || this._flags.last_token.text === '++')) {
      var next_token = this._tokens.peek();
      while (this._flags.mode === MODE.Statement &&
        !(this._flags.if_block && reserved_word(next_token, 'else')) &&
        !this._flags.do_block) {
        this.restore_mode();
      }
    }
  }

  if (this._output.add_new_line(force_newline)) {
    this._flags.multiline_frame = true;
  }
};

Beautifier.prototype.print_token_line_indentation = function(current_token) {
  if (this._output.just_added_newline()) {
    if (this._options.keep_array_indentation &&
      current_token.newlines &&
      (current_token.text === '[' || is_array(this._flags.mode))) {
      this._output.current_line.set_indent(-1);
      this._output.current_line.push(current_token.whitespace_before);
      this._output.space_before_token = false;
    } else if (this._output.set_indent(this._flags.indentation_level, this._flags.alignment)) {
      this._flags.line_indent_level = this._flags.indentation_level;
    }
  }
};

Beautifier.prototype.print_token = function(current_token) {
  if (this._output.raw) {
    this._output.add_raw_token(current_token);
    return;
  }

  if (this._options.comma_first && current_token.previous && current_token.previous.type === TOKEN$2.COMMA &&
    this._output.just_added_newline()) {
    if (this._output.previous_line.last() === ',') {
      var popped = this._output.previous_line.pop();
      // if the comma was already at the start of the line,
      // pull back onto that line and reprint the indentation
      if (this._output.previous_line.is_empty()) {
        this._output.previous_line.push(popped);
        this._output.trim(true);
        this._output.current_line.pop();
        this._output.trim();
      }

      // add the comma in front of the next token
      this.print_token_line_indentation(current_token);
      this._output.add_token(',');
      this._output.space_before_token = true;
    }
  }

  this.print_token_line_indentation(current_token);
  this._output.non_breaking_space = true;
  this._output.add_token(current_token.text);
  if (this._output.previous_token_wrapped) {
    this._flags.multiline_frame = true;
  }
};

Beautifier.prototype.indent = function() {
  this._flags.indentation_level += 1;
  this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
};

Beautifier.prototype.deindent = function() {
  if (this._flags.indentation_level > 0 &&
    ((!this._flags.parent) || this._flags.indentation_level > this._flags.parent.indentation_level)) {
    this._flags.indentation_level -= 1;
    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
  }
};

Beautifier.prototype.set_mode = function(mode) {
  if (this._flags) {
    this._flag_store.push(this._flags);
    this._previous_flags = this._flags;
  } else {
    this._previous_flags = this.create_flags(null, mode);
  }

  this._flags = this.create_flags(this._previous_flags, mode);
  this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
};


Beautifier.prototype.restore_mode = function() {
  if (this._flag_store.length > 0) {
    this._previous_flags = this._flags;
    this._flags = this._flag_store.pop();
    if (this._previous_flags.mode === MODE.Statement) {
      remove_redundant_indentation(this._output, this._previous_flags);
    }
    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
  }
};

Beautifier.prototype.start_of_object_property = function() {
  return this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement && (
    (this._flags.last_token.text === ':' && this._flags.ternary_depth === 0) || (reserved_array(this._flags.last_token, ['get', 'set'])));
};

Beautifier.prototype.start_of_statement = function(current_token) {
  var start = false;
  start = start || reserved_array(this._flags.last_token, ['var', 'let', 'const']) && current_token.type === TOKEN$2.WORD;
  start = start || reserved_word(this._flags.last_token, 'do');
  start = start || (!(this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement)) && reserved_array(this._flags.last_token, newline_restricted_tokens) && !current_token.newlines;
  start = start || reserved_word(this._flags.last_token, 'else') &&
    !(reserved_word(current_token, 'if') && !current_token.comments_before);
  start = start || (this._flags.last_token.type === TOKEN$2.END_EXPR && (this._previous_flags.mode === MODE.ForInitializer || this._previous_flags.mode === MODE.Conditional));
  start = start || (this._flags.last_token.type === TOKEN$2.WORD && this._flags.mode === MODE.BlockStatement &&
    !this._flags.in_case &&
    !(current_token.text === '--' || current_token.text === '++') &&
    this._last_last_text !== 'function' &&
    current_token.type !== TOKEN$2.WORD && current_token.type !== TOKEN$2.RESERVED);
  start = start || (this._flags.mode === MODE.ObjectLiteral && (
    (this._flags.last_token.text === ':' && this._flags.ternary_depth === 0) || reserved_array(this._flags.last_token, ['get', 'set'])));

  if (start) {
    this.set_mode(MODE.Statement);
    this.indent();

    this.handle_whitespace_and_comments(current_token, true);

    // Issue #276:
    // If starting a new statement with [if, for, while, do], push to a new line.
    // if (a) if (b) if(c) d(); else e(); else f();
    if (!this.start_of_object_property()) {
      this.allow_wrap_or_preserved_newline(current_token,
        reserved_array(current_token, ['do', 'for', 'if', 'while']));
    }
    return true;
  }
  return false;
};

Beautifier.prototype.handle_start_expr = function(current_token) {
  // The conditional starts the statement if appropriate.
  if (!this.start_of_statement(current_token)) {
    this.handle_whitespace_and_comments(current_token);
  }

  var next_mode = MODE.Expression;
  if (current_token.text === '[') {

    if (this._flags.last_token.type === TOKEN$2.WORD || this._flags.last_token.text === ')') {
      // this is array index specifier, break immediately
      // a[x], fn()[x]
      if (reserved_array(this._flags.last_token, line_starters$1)) {
        this._output.space_before_token = true;
      }
      this.print_token(current_token);
      this.set_mode(next_mode);
      this.indent();
      if (this._options.space_in_paren) {
        this._output.space_before_token = true;
      }
      return;
    }

    next_mode = MODE.ArrayLiteral;
    if (is_array(this._flags.mode)) {
      if (this._flags.last_token.text === '[' ||
        (this._flags.last_token.text === ',' && (this._last_last_text === ']' || this._last_last_text === '}'))) {
        // ], [ goes to new line
        // }, [ goes to new line
        if (!this._options.keep_array_indentation) {
          this.print_newline();
        }
      }
    }

    if (!in_array$1(this._flags.last_token.type, [TOKEN$2.START_EXPR, TOKEN$2.END_EXPR, TOKEN$2.WORD, TOKEN$2.OPERATOR])) {
      this._output.space_before_token = true;
    }
  } else {
    if (this._flags.last_token.type === TOKEN$2.RESERVED) {
      if (this._flags.last_token.text === 'for') {
        this._output.space_before_token = this._options.space_before_conditional;
        next_mode = MODE.ForInitializer;
      } else if (in_array$1(this._flags.last_token.text, ['if', 'while'])) {
        this._output.space_before_token = this._options.space_before_conditional;
        next_mode = MODE.Conditional;
      } else if (in_array$1(this._flags.last_word, ['await', 'async'])) {
        // Should be a space between await and an IIFE, or async and an arrow function
        this._output.space_before_token = true;
      } else if (this._flags.last_token.text === 'import' && current_token.whitespace_before === '') {
        this._output.space_before_token = false;
      } else if (in_array$1(this._flags.last_token.text, line_starters$1) || this._flags.last_token.text === 'catch') {
        this._output.space_before_token = true;
      }
    } else if (this._flags.last_token.type === TOKEN$2.EQUALS || this._flags.last_token.type === TOKEN$2.OPERATOR) {
      // Support of this kind of newline preservation.
      // a = (b &&
      //     (c || d));
      if (!this.start_of_object_property()) {
        this.allow_wrap_or_preserved_newline(current_token);
      }
    } else if (this._flags.last_token.type === TOKEN$2.WORD) {
      this._output.space_before_token = false;

      // function name() vs function name ()
      // function* name() vs function* name ()
      // async name() vs async name ()
      // In ES6, you can also define the method properties of an object
      // var obj = {a: function() {}}
      // It can be abbreviated
      // var obj = {a() {}}
      // var obj = { a() {}} vs var obj = { a () {}}
      // var obj = { * a() {}} vs var obj = { * a () {}}
      var peek_back_two = this._tokens.peek(-3);
      if (this._options.space_after_named_function && peek_back_two) {
        // peek starts at next character so -1 is current token
        var peek_back_three = this._tokens.peek(-4);
        if (reserved_array(peek_back_two, ['async', 'function']) ||
          (peek_back_two.text === '*' && reserved_array(peek_back_three, ['async', 'function']))) {
          this._output.space_before_token = true;
        } else if (this._flags.mode === MODE.ObjectLiteral) {
          if ((peek_back_two.text === '{' || peek_back_two.text === ',') ||
            (peek_back_two.text === '*' && (peek_back_three.text === '{' || peek_back_three.text === ','))) {
            this._output.space_before_token = true;
          }
        }
      }
    } else {
      // Support preserving wrapped arrow function expressions
      // a.b('c',
      //     () => d.e
      // )
      this.allow_wrap_or_preserved_newline(current_token);
    }

    // function() vs function ()
    // yield*() vs yield* ()
    // function*() vs function* ()
    if ((this._flags.last_token.type === TOKEN$2.RESERVED && (this._flags.last_word === 'function' || this._flags.last_word === 'typeof')) ||
      (this._flags.last_token.text === '*' &&
        (in_array$1(this._last_last_text, ['function', 'yield']) ||
          (this._flags.mode === MODE.ObjectLiteral && in_array$1(this._last_last_text, ['{', ',']))))) {
      this._output.space_before_token = this._options.space_after_anon_function;
    }
  }

  if (this._flags.last_token.text === ';' || this._flags.last_token.type === TOKEN$2.START_BLOCK) {
    this.print_newline();
  } else if (this._flags.last_token.type === TOKEN$2.END_EXPR || this._flags.last_token.type === TOKEN$2.START_EXPR || this._flags.last_token.type === TOKEN$2.END_BLOCK || this._flags.last_token.text === '.' || this._flags.last_token.type === TOKEN$2.COMMA) {
    // do nothing on (( and )( and ][ and ]( and .(
    // TODO: Consider whether forcing this is required.  Review failing tests when removed.
    this.allow_wrap_or_preserved_newline(current_token, current_token.newlines);
  }

  this.print_token(current_token);
  this.set_mode(next_mode);
  if (this._options.space_in_paren) {
    this._output.space_before_token = true;
  }

  // In all cases, if we newline while inside an expression it should be indented.
  this.indent();
};

Beautifier.prototype.handle_end_expr = function(current_token) {
  // statements inside expressions are not valid syntax, but...
  // statements must all be closed when their container closes
  while (this._flags.mode === MODE.Statement) {
    this.restore_mode();
  }

  this.handle_whitespace_and_comments(current_token);

  if (this._flags.multiline_frame) {
    this.allow_wrap_or_preserved_newline(current_token,
      current_token.text === ']' && is_array(this._flags.mode) && !this._options.keep_array_indentation);
  }

  if (this._options.space_in_paren) {
    if (this._flags.last_token.type === TOKEN$2.START_EXPR && !this._options.space_in_empty_paren) {
      // () [] no inner space in empty parens like these, ever, ref #320
      this._output.trim();
      this._output.space_before_token = false;
    } else {
      this._output.space_before_token = true;
    }
  }
  this.deindent();
  this.print_token(current_token);
  this.restore_mode();

  remove_redundant_indentation(this._output, this._previous_flags);

  // do {} while () // no statement required after
  if (this._flags.do_while && this._previous_flags.mode === MODE.Conditional) {
    this._previous_flags.mode = MODE.Expression;
    this._flags.do_block = false;
    this._flags.do_while = false;

  }
};

Beautifier.prototype.handle_start_block = function(current_token) {
  this.handle_whitespace_and_comments(current_token);

  // Check if this is should be treated as a ObjectLiteral
  var next_token = this._tokens.peek();
  var second_token = this._tokens.peek(1);
  if (this._flags.last_word === 'switch' && this._flags.last_token.type === TOKEN$2.END_EXPR) {
    this.set_mode(MODE.BlockStatement);
    this._flags.in_case_statement = true;
  } else if (this._flags.case_body) {
    this.set_mode(MODE.BlockStatement);
  } else if (second_token && (
      (in_array$1(second_token.text, [':', ',']) && in_array$1(next_token.type, [TOKEN$2.STRING, TOKEN$2.WORD, TOKEN$2.RESERVED])) ||
      (in_array$1(next_token.text, ['get', 'set', '...']) && in_array$1(second_token.type, [TOKEN$2.WORD, TOKEN$2.RESERVED]))
    )) {
    // We don't support TypeScript,but we didn't break it for a very long time.
    // We'll try to keep not breaking it.
    if (!in_array$1(this._last_last_text, ['class', 'interface'])) {
      this.set_mode(MODE.ObjectLiteral);
    } else {
      this.set_mode(MODE.BlockStatement);
    }
  } else if (this._flags.last_token.type === TOKEN$2.OPERATOR && this._flags.last_token.text === '=>') {
    // arrow function: (param1, paramN) => { statements }
    this.set_mode(MODE.BlockStatement);
  } else if (in_array$1(this._flags.last_token.type, [TOKEN$2.EQUALS, TOKEN$2.START_EXPR, TOKEN$2.COMMA, TOKEN$2.OPERATOR]) ||
    reserved_array(this._flags.last_token, ['return', 'throw', 'import', 'default'])
  ) {
    // Detecting shorthand function syntax is difficult by scanning forward,
    //     so check the surrounding context.
    // If the block is being returned, imported, export default, passed as arg,
    //     assigned with = or assigned in a nested object, treat as an ObjectLiteral.
    this.set_mode(MODE.ObjectLiteral);
  } else {
    this.set_mode(MODE.BlockStatement);
  }

  var empty_braces = !next_token.comments_before && next_token.text === '}';
  var empty_anonymous_function = empty_braces && this._flags.last_word === 'function' &&
    this._flags.last_token.type === TOKEN$2.END_EXPR;

  if (this._options.brace_preserve_inline) // check for inline, set inline_frame if so
  {
    // search forward for a newline wanted inside this block
    var index = 0;
    var check_token = null;
    this._flags.inline_frame = true;
    do {
      index += 1;
      check_token = this._tokens.peek(index - 1);
      if (check_token.newlines) {
        this._flags.inline_frame = false;
        break;
      }
    } while (check_token.type !== TOKEN$2.EOF &&
      !(check_token.type === TOKEN$2.END_BLOCK && check_token.opened === current_token));
  }

  if ((this._options.brace_style === "expand" ||
      (this._options.brace_style === "none" && current_token.newlines)) &&
    !this._flags.inline_frame) {
    if (this._flags.last_token.type !== TOKEN$2.OPERATOR &&
      (empty_anonymous_function ||
        this._flags.last_token.type === TOKEN$2.EQUALS ||
        (reserved_array(this._flags.last_token, special_words) && this._flags.last_token.text !== 'else'))) {
      this._output.space_before_token = true;
    } else {
      this.print_newline(false, true);
    }
  } else { // collapse || inline_frame
    if (is_array(this._previous_flags.mode) && (this._flags.last_token.type === TOKEN$2.START_EXPR || this._flags.last_token.type === TOKEN$2.COMMA)) {
      if (this._flags.last_token.type === TOKEN$2.COMMA || this._options.space_in_paren) {
        this._output.space_before_token = true;
      }

      if (this._flags.last_token.type === TOKEN$2.COMMA || (this._flags.last_token.type === TOKEN$2.START_EXPR && this._flags.inline_frame)) {
        this.allow_wrap_or_preserved_newline(current_token);
        this._previous_flags.multiline_frame = this._previous_flags.multiline_frame || this._flags.multiline_frame;
        this._flags.multiline_frame = false;
      }
    }
    if (this._flags.last_token.type !== TOKEN$2.OPERATOR && this._flags.last_token.type !== TOKEN$2.START_EXPR) {
      if (this._flags.last_token.type === TOKEN$2.START_BLOCK && !this._flags.inline_frame) {
        this.print_newline();
      } else {
        this._output.space_before_token = true;
      }
    }
  }
  this.print_token(current_token);
  this.indent();

  // Except for specific cases, open braces are followed by a new line.
  if (!empty_braces && !(this._options.brace_preserve_inline && this._flags.inline_frame)) {
    this.print_newline();
  }
};

Beautifier.prototype.handle_end_block = function(current_token) {
  // statements must all be closed when their container closes
  this.handle_whitespace_and_comments(current_token);

  while (this._flags.mode === MODE.Statement) {
    this.restore_mode();
  }

  var empty_braces = this._flags.last_token.type === TOKEN$2.START_BLOCK;

  if (this._flags.inline_frame && !empty_braces) { // try inline_frame (only set if this._options.braces-preserve-inline) first
    this._output.space_before_token = true;
  } else if (this._options.brace_style === "expand") {
    if (!empty_braces) {
      this.print_newline();
    }
  } else {
    // skip {}
    if (!empty_braces) {
      if (is_array(this._flags.mode) && this._options.keep_array_indentation) {
        // we REALLY need a newline here, but newliner would skip that
        this._options.keep_array_indentation = false;
        this.print_newline();
        this._options.keep_array_indentation = true;

      } else {
        this.print_newline();
      }
    }
  }
  this.restore_mode();
  this.print_token(current_token);
};

Beautifier.prototype.handle_word = function(current_token) {
  if (current_token.type === TOKEN$2.RESERVED) {
    if (in_array$1(current_token.text, ['set', 'get']) && this._flags.mode !== MODE.ObjectLiteral) {
      current_token.type = TOKEN$2.WORD;
    } else if (current_token.text === 'import' && this._tokens.peek().text === '(') {
      current_token.type = TOKEN$2.WORD;
    } else if (in_array$1(current_token.text, ['as', 'from']) && !this._flags.import_block) {
      current_token.type = TOKEN$2.WORD;
    } else if (this._flags.mode === MODE.ObjectLiteral) {
      var next_token = this._tokens.peek();
      if (next_token.text === ':') {
        current_token.type = TOKEN$2.WORD;
      }
    }
  }

  if (this.start_of_statement(current_token)) {
    // The conditional starts the statement if appropriate.
    if (reserved_array(this._flags.last_token, ['var', 'let', 'const']) && current_token.type === TOKEN$2.WORD) {
      this._flags.declaration_statement = true;
    }
  } else if (current_token.newlines && !is_expression(this._flags.mode) &&
    (this._flags.last_token.type !== TOKEN$2.OPERATOR || (this._flags.last_token.text === '--' || this._flags.last_token.text === '++')) &&
    this._flags.last_token.type !== TOKEN$2.EQUALS &&
    (this._options.preserve_newlines || !reserved_array(this._flags.last_token, ['var', 'let', 'const', 'set', 'get']))) {
    this.handle_whitespace_and_comments(current_token);
    this.print_newline();
  } else {
    this.handle_whitespace_and_comments(current_token);
  }

  if (this._flags.do_block && !this._flags.do_while) {
    if (reserved_word(current_token, 'while')) {
      // do {} ## while ()
      this._output.space_before_token = true;
      this.print_token(current_token);
      this._output.space_before_token = true;
      this._flags.do_while = true;
      return;
    } else {
      // do {} should always have while as the next word.
      // if we don't see the expected while, recover
      this.print_newline();
      this._flags.do_block = false;
    }
  }

  // if may be followed by else, or not
  // Bare/inline ifs are tricky
  // Need to unwind the modes correctly: if (a) if (b) c(); else d(); else e();
  if (this._flags.if_block) {
    if (!this._flags.else_block && reserved_word(current_token, 'else')) {
      this._flags.else_block = true;
    } else {
      while (this._flags.mode === MODE.Statement) {
        this.restore_mode();
      }
      this._flags.if_block = false;
      this._flags.else_block = false;
    }
  }

  if (this._flags.in_case_statement && reserved_array(current_token, ['case', 'default'])) {
    this.print_newline();
    if (this._flags.last_token.type !== TOKEN$2.END_BLOCK && (this._flags.case_body || this._options.jslint_happy)) {
      // switch cases following one another
      this.deindent();
    }
    this._flags.case_body = false;

    this.print_token(current_token);
    this._flags.in_case = true;
    return;
  }

  if (this._flags.last_token.type === TOKEN$2.COMMA || this._flags.last_token.type === TOKEN$2.START_EXPR || this._flags.last_token.type === TOKEN$2.EQUALS || this._flags.last_token.type === TOKEN$2.OPERATOR) {
    if (!this.start_of_object_property()) {
      this.allow_wrap_or_preserved_newline(current_token);
    }
  }

  if (reserved_word(current_token, 'function')) {
    if (in_array$1(this._flags.last_token.text, ['}', ';']) ||
      (this._output.just_added_newline() && !(in_array$1(this._flags.last_token.text, ['(', '[', '{', ':', '=', ',']) || this._flags.last_token.type === TOKEN$2.OPERATOR))) {
      // make sure there is a nice clean space of at least one blank line
      // before a new function definition
      if (!this._output.just_added_blankline() && !current_token.comments_before) {
        this.print_newline();
        this.print_newline(true);
      }
    }
    if (this._flags.last_token.type === TOKEN$2.RESERVED || this._flags.last_token.type === TOKEN$2.WORD) {
      if (reserved_array(this._flags.last_token, ['get', 'set', 'new', 'export']) ||
        reserved_array(this._flags.last_token, newline_restricted_tokens)) {
        this._output.space_before_token = true;
      } else if (reserved_word(this._flags.last_token, 'default') && this._last_last_text === 'export') {
        this._output.space_before_token = true;
      } else if (this._flags.last_token.text === 'declare') {
        // accomodates Typescript declare function formatting
        this._output.space_before_token = true;
      } else {
        this.print_newline();
      }
    } else if (this._flags.last_token.type === TOKEN$2.OPERATOR || this._flags.last_token.text === '=') {
      // foo = function
      this._output.space_before_token = true;
    } else if (!this._flags.multiline_frame && (is_expression(this._flags.mode) || is_array(this._flags.mode))) ; else {
      this.print_newline();
    }

    this.print_token(current_token);
    this._flags.last_word = current_token.text;
    return;
  }

  var prefix = 'NONE';

  if (this._flags.last_token.type === TOKEN$2.END_BLOCK) {

    if (this._previous_flags.inline_frame) {
      prefix = 'SPACE';
    } else if (!reserved_array(current_token, ['else', 'catch', 'finally', 'from'])) {
      prefix = 'NEWLINE';
    } else {
      if (this._options.brace_style === "expand" ||
        this._options.brace_style === "end-expand" ||
        (this._options.brace_style === "none" && current_token.newlines)) {
        prefix = 'NEWLINE';
      } else {
        prefix = 'SPACE';
        this._output.space_before_token = true;
      }
    }
  } else if (this._flags.last_token.type === TOKEN$2.SEMICOLON && this._flags.mode === MODE.BlockStatement) {
    // TODO: Should this be for STATEMENT as well?
    prefix = 'NEWLINE';
  } else if (this._flags.last_token.type === TOKEN$2.SEMICOLON && is_expression(this._flags.mode)) {
    prefix = 'SPACE';
  } else if (this._flags.last_token.type === TOKEN$2.STRING) {
    prefix = 'NEWLINE';
  } else if (this._flags.last_token.type === TOKEN$2.RESERVED || this._flags.last_token.type === TOKEN$2.WORD ||
    (this._flags.last_token.text === '*' &&
      (in_array$1(this._last_last_text, ['function', 'yield']) ||
        (this._flags.mode === MODE.ObjectLiteral && in_array$1(this._last_last_text, ['{', ',']))))) {
    prefix = 'SPACE';
  } else if (this._flags.last_token.type === TOKEN$2.START_BLOCK) {
    if (this._flags.inline_frame) {
      prefix = 'SPACE';
    } else {
      prefix = 'NEWLINE';
    }
  } else if (this._flags.last_token.type === TOKEN$2.END_EXPR) {
    this._output.space_before_token = true;
    prefix = 'NEWLINE';
  }

  if (reserved_array(current_token, line_starters$1) && this._flags.last_token.text !== ')') {
    if (this._flags.inline_frame || this._flags.last_token.text === 'else' || this._flags.last_token.text === 'export') {
      prefix = 'SPACE';
    } else {
      prefix = 'NEWLINE';
    }

  }

  if (reserved_array(current_token, ['else', 'catch', 'finally'])) {
    if ((!(this._flags.last_token.type === TOKEN$2.END_BLOCK && this._previous_flags.mode === MODE.BlockStatement) ||
        this._options.brace_style === "expand" ||
        this._options.brace_style === "end-expand" ||
        (this._options.brace_style === "none" && current_token.newlines)) &&
      !this._flags.inline_frame) {
      this.print_newline();
    } else {
      this._output.trim(true);
      var line = this._output.current_line;
      // If we trimmed and there's something other than a close block before us
      // put a newline back in.  Handles '} // comment' scenario.
      if (line.last() !== '}') {
        this.print_newline();
      }
      this._output.space_before_token = true;
    }
  } else if (prefix === 'NEWLINE') {
    if (reserved_array(this._flags.last_token, special_words)) {
      // no newline between 'return nnn'
      this._output.space_before_token = true;
    } else if (this._flags.last_token.text === 'declare' && reserved_array(current_token, ['var', 'let', 'const'])) {
      // accomodates Typescript declare formatting
      this._output.space_before_token = true;
    } else if (this._flags.last_token.type !== TOKEN$2.END_EXPR) {
      if ((this._flags.last_token.type !== TOKEN$2.START_EXPR || !reserved_array(current_token, ['var', 'let', 'const'])) && this._flags.last_token.text !== ':') {
        // no need to force newline on 'var': for (var x = 0...)
        if (reserved_word(current_token, 'if') && reserved_word(current_token.previous, 'else')) {
          // no newline for } else if {
          this._output.space_before_token = true;
        } else {
          this.print_newline();
        }
      }
    } else if (reserved_array(current_token, line_starters$1) && this._flags.last_token.text !== ')') {
      this.print_newline();
    }
  } else if (this._flags.multiline_frame && is_array(this._flags.mode) && this._flags.last_token.text === ',' && this._last_last_text === '}') {
    this.print_newline(); // }, in lists get a newline treatment
  } else if (prefix === 'SPACE') {
    this._output.space_before_token = true;
  }
  if (current_token.previous && (current_token.previous.type === TOKEN$2.WORD || current_token.previous.type === TOKEN$2.RESERVED)) {
    this._output.space_before_token = true;
  }
  this.print_token(current_token);
  this._flags.last_word = current_token.text;

  if (current_token.type === TOKEN$2.RESERVED) {
    if (current_token.text === 'do') {
      this._flags.do_block = true;
    } else if (current_token.text === 'if') {
      this._flags.if_block = true;
    } else if (current_token.text === 'import') {
      this._flags.import_block = true;
    } else if (this._flags.import_block && reserved_word(current_token, 'from')) {
      this._flags.import_block = false;
    }
  }
};

Beautifier.prototype.handle_semicolon = function(current_token) {
  if (this.start_of_statement(current_token)) {
    // The conditional starts the statement if appropriate.
    // Semicolon can be the start (and end) of a statement
    this._output.space_before_token = false;
  } else {
    this.handle_whitespace_and_comments(current_token);
  }

  var next_token = this._tokens.peek();
  while (this._flags.mode === MODE.Statement &&
    !(this._flags.if_block && reserved_word(next_token, 'else')) &&
    !this._flags.do_block) {
    this.restore_mode();
  }

  // hacky but effective for the moment
  if (this._flags.import_block) {
    this._flags.import_block = false;
  }
  this.print_token(current_token);
};

Beautifier.prototype.handle_string = function(current_token) {
  if (current_token.text.startsWith("`") && current_token.newlines === 0 && current_token.whitespace_before === '' && (current_token.previous.text === ')' || this._flags.last_token.type === TOKEN$2.WORD)) ; else if (this.start_of_statement(current_token)) {
    // The conditional starts the statement if appropriate.
    // One difference - strings want at least a space before
    this._output.space_before_token = true;
  } else {
    this.handle_whitespace_and_comments(current_token);
    if (this._flags.last_token.type === TOKEN$2.RESERVED || this._flags.last_token.type === TOKEN$2.WORD || this._flags.inline_frame) {
      this._output.space_before_token = true;
    } else if (this._flags.last_token.type === TOKEN$2.COMMA || this._flags.last_token.type === TOKEN$2.START_EXPR || this._flags.last_token.type === TOKEN$2.EQUALS || this._flags.last_token.type === TOKEN$2.OPERATOR) {
      if (!this.start_of_object_property()) {
        this.allow_wrap_or_preserved_newline(current_token);
      }
    } else if ((current_token.text.startsWith("`") && this._flags.last_token.type === TOKEN$2.END_EXPR && (current_token.previous.text === ']' || current_token.previous.text === ')') && current_token.newlines === 0)) {
      this._output.space_before_token = true;
    } else {
      this.print_newline();
    }
  }
  this.print_token(current_token);
};

Beautifier.prototype.handle_equals = function(current_token) {
  if (this.start_of_statement(current_token)) ; else {
    this.handle_whitespace_and_comments(current_token);
  }

  if (this._flags.declaration_statement) {
    // just got an '=' in a var-line, different formatting/line-breaking, etc will now be done
    this._flags.declaration_assignment = true;
  }
  this._output.space_before_token = true;
  this.print_token(current_token);
  this._output.space_before_token = true;
};

Beautifier.prototype.handle_comma = function(current_token) {
  this.handle_whitespace_and_comments(current_token, true);

  this.print_token(current_token);
  this._output.space_before_token = true;
  if (this._flags.declaration_statement) {
    if (is_expression(this._flags.parent.mode)) {
      // do not break on comma, for(var a = 1, b = 2)
      this._flags.declaration_assignment = false;
    }

    if (this._flags.declaration_assignment) {
      this._flags.declaration_assignment = false;
      this.print_newline(false, true);
    } else if (this._options.comma_first) {
      // for comma-first, we want to allow a newline before the comma
      // to turn into a newline after the comma, which we will fixup later
      this.allow_wrap_or_preserved_newline(current_token);
    }
  } else if (this._flags.mode === MODE.ObjectLiteral ||
    (this._flags.mode === MODE.Statement && this._flags.parent.mode === MODE.ObjectLiteral)) {
    if (this._flags.mode === MODE.Statement) {
      this.restore_mode();
    }

    if (!this._flags.inline_frame) {
      this.print_newline();
    }
  } else if (this._options.comma_first) {
    // EXPR or DO_BLOCK
    // for comma-first, we want to allow a newline before the comma
    // to turn into a newline after the comma, which we will fixup later
    this.allow_wrap_or_preserved_newline(current_token);
  }
};

Beautifier.prototype.handle_operator = function(current_token) {
  var isGeneratorAsterisk = current_token.text === '*' &&
    (reserved_array(this._flags.last_token, ['function', 'yield']) ||
      (in_array$1(this._flags.last_token.type, [TOKEN$2.START_BLOCK, TOKEN$2.COMMA, TOKEN$2.END_BLOCK, TOKEN$2.SEMICOLON]))
    );
  var isUnary = in_array$1(current_token.text, ['-', '+']) && (
    in_array$1(this._flags.last_token.type, [TOKEN$2.START_BLOCK, TOKEN$2.START_EXPR, TOKEN$2.EQUALS, TOKEN$2.OPERATOR]) ||
    in_array$1(this._flags.last_token.text, line_starters$1) ||
    this._flags.last_token.text === ','
  );

  if (this.start_of_statement(current_token)) ; else {
    var preserve_statement_flags = !isGeneratorAsterisk;
    this.handle_whitespace_and_comments(current_token, preserve_statement_flags);
  }

  if (reserved_array(this._flags.last_token, special_words)) {
    // "return" had a special handling in TK_WORD. Now we need to return the favor
    this._output.space_before_token = true;
    this.print_token(current_token);
    return;
  }

  // hack for actionscript's import .*;
  if (current_token.text === '*' && this._flags.last_token.type === TOKEN$2.DOT) {
    this.print_token(current_token);
    return;
  }

  if (current_token.text === '::') {
    // no spaces around exotic namespacing syntax operator
    this.print_token(current_token);
    return;
  }

  // Allow line wrapping between operators when operator_position is
  //   set to before or preserve
  if (this._flags.last_token.type === TOKEN$2.OPERATOR && in_array$1(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)) {
    this.allow_wrap_or_preserved_newline(current_token);
  }

  if (current_token.text === ':' && this._flags.in_case) {
    this.print_token(current_token);

    this._flags.in_case = false;
    this._flags.case_body = true;
    if (this._tokens.peek().type !== TOKEN$2.START_BLOCK) {
      this.indent();
      this.print_newline();
    } else {
      this._output.space_before_token = true;
    }
    return;
  }

  var space_before = true;
  var space_after = true;
  var in_ternary = false;
  if (current_token.text === ':') {
    if (this._flags.ternary_depth === 0) {
      // Colon is invalid javascript outside of ternary and object, but do our best to guess what was meant.
      space_before = false;
    } else {
      this._flags.ternary_depth -= 1;
      in_ternary = true;
    }
  } else if (current_token.text === '?') {
    this._flags.ternary_depth += 1;
  }

  // let's handle the operator_position option prior to any conflicting logic
  if (!isUnary && !isGeneratorAsterisk && this._options.preserve_newlines && in_array$1(current_token.text, positionable_operators$1)) {
    var isColon = current_token.text === ':';
    var isTernaryColon = (isColon && in_ternary);
    var isOtherColon = (isColon && !in_ternary);

    switch (this._options.operator_position) {
      case OPERATOR_POSITION.before_newline:
        // if the current token is : and it's not a ternary statement then we set space_before to false
        this._output.space_before_token = !isOtherColon;

        this.print_token(current_token);

        if (!isColon || isTernaryColon) {
          this.allow_wrap_or_preserved_newline(current_token);
        }

        this._output.space_before_token = true;
        return;

      case OPERATOR_POSITION.after_newline:
        // if the current token is anything but colon, or (via deduction) it's a colon and in a ternary statement,
        //   then print a newline.

        this._output.space_before_token = true;

        if (!isColon || isTernaryColon) {
          if (this._tokens.peek().newlines) {
            this.print_newline(false, true);
          } else {
            this.allow_wrap_or_preserved_newline(current_token);
          }
        } else {
          this._output.space_before_token = false;
        }

        this.print_token(current_token);

        this._output.space_before_token = true;
        return;

      case OPERATOR_POSITION.preserve_newline:
        if (!isOtherColon) {
          this.allow_wrap_or_preserved_newline(current_token);
        }

        // if we just added a newline, or the current token is : and it's not a ternary statement,
        //   then we set space_before to false
        space_before = !(this._output.just_added_newline() || isOtherColon);

        this._output.space_before_token = space_before;
        this.print_token(current_token);
        this._output.space_before_token = true;
        return;
    }
  }

  if (isGeneratorAsterisk) {
    this.allow_wrap_or_preserved_newline(current_token);
    space_before = false;
    var next_token = this._tokens.peek();
    space_after = next_token && in_array$1(next_token.type, [TOKEN$2.WORD, TOKEN$2.RESERVED]);
  } else if (current_token.text === '...') {
    this.allow_wrap_or_preserved_newline(current_token);
    space_before = this._flags.last_token.type === TOKEN$2.START_BLOCK;
    space_after = false;
  } else if (in_array$1(current_token.text, ['--', '++', '!', '~']) || isUnary) {
    // unary operators (and binary +/- pretending to be unary) special cases
    if (this._flags.last_token.type === TOKEN$2.COMMA || this._flags.last_token.type === TOKEN$2.START_EXPR) {
      this.allow_wrap_or_preserved_newline(current_token);
    }

    space_before = false;
    space_after = false;

    // http://www.ecma-international.org/ecma-262/5.1/#sec-7.9.1
    // if there is a newline between -- or ++ and anything else we should preserve it.
    if (current_token.newlines && (current_token.text === '--' || current_token.text === '++')) {
      this.print_newline(false, true);
    }

    if (this._flags.last_token.text === ';' && is_expression(this._flags.mode)) {
      // for (;; ++i)
      //        ^^^
      space_before = true;
    }

    if (this._flags.last_token.type === TOKEN$2.RESERVED) {
      space_before = true;
    } else if (this._flags.last_token.type === TOKEN$2.END_EXPR) {
      space_before = !(this._flags.last_token.text === ']' && (current_token.text === '--' || current_token.text === '++'));
    } else if (this._flags.last_token.type === TOKEN$2.OPERATOR) {
      // a++ + ++b;
      // a - -b
      space_before = in_array$1(current_token.text, ['--', '-', '++', '+']) && in_array$1(this._flags.last_token.text, ['--', '-', '++', '+']);
      // + and - are not unary when preceeded by -- or ++ operator
      // a-- + b
      // a * +b
      // a - -b
      if (in_array$1(current_token.text, ['+', '-']) && in_array$1(this._flags.last_token.text, ['--', '++'])) {
        space_after = true;
      }
    }


    if (((this._flags.mode === MODE.BlockStatement && !this._flags.inline_frame) || this._flags.mode === MODE.Statement) &&
      (this._flags.last_token.text === '{' || this._flags.last_token.text === ';')) {
      // { foo; --i }
      // foo(); --bar;
      this.print_newline();
    }
  }

  this._output.space_before_token = this._output.space_before_token || space_before;
  this.print_token(current_token);
  this._output.space_before_token = space_after;
};

Beautifier.prototype.handle_block_comment = function(current_token, preserve_statement_flags) {
  if (this._output.raw) {
    this._output.add_raw_token(current_token);
    if (current_token.directives && current_token.directives.preserve === 'end') {
      // If we're testing the raw output behavior, do not allow a directive to turn it off.
      this._output.raw = this._options.test_output_raw;
    }
    return;
  }

  if (current_token.directives) {
    this.print_newline(false, preserve_statement_flags);
    this.print_token(current_token);
    if (current_token.directives.preserve === 'start') {
      this._output.raw = true;
    }
    this.print_newline(false, true);
    return;
  }

  // inline block
  if (!acorn.newline.test(current_token.text) && !current_token.newlines) {
    this._output.space_before_token = true;
    this.print_token(current_token);
    this._output.space_before_token = true;
    return;
  } else {
    this.print_block_commment(current_token, preserve_statement_flags);
  }
};

Beautifier.prototype.print_block_commment = function(current_token, preserve_statement_flags) {
  var lines = split_linebreaks(current_token.text);
  var j; // iterator for this case
  var javadoc = false;
  var starless = false;
  var lastIndent = current_token.whitespace_before;
  var lastIndentLength = lastIndent.length;

  // block comment starts with a new line
  this.print_newline(false, preserve_statement_flags);

  // first line always indented
  this.print_token_line_indentation(current_token);
  this._output.add_token(lines[0]);
  this.print_newline(false, preserve_statement_flags);


  if (lines.length > 1) {
    lines = lines.slice(1);
    javadoc = all_lines_start_with(lines, '*');
    starless = each_line_matches_indent(lines, lastIndent);

    if (javadoc) {
      this._flags.alignment = 1;
    }

    for (j = 0; j < lines.length; j++) {
      if (javadoc) {
        // javadoc: reformat and re-indent
        this.print_token_line_indentation(current_token);
        this._output.add_token(ltrim(lines[j]));
      } else if (starless && lines[j]) {
        // starless: re-indent non-empty content, avoiding trim
        this.print_token_line_indentation(current_token);
        this._output.add_token(lines[j].substring(lastIndentLength));
      } else {
        // normal comments output raw
        this._output.current_line.set_indent(-1);
        this._output.add_token(lines[j]);
      }

      // for comments on their own line or  more than one line, make sure there's a new line after
      this.print_newline(false, preserve_statement_flags);
    }

    this._flags.alignment = 0;
  }
};


Beautifier.prototype.handle_comment = function(current_token, preserve_statement_flags) {
  if (current_token.newlines) {
    this.print_newline(false, preserve_statement_flags);
  } else {
    this._output.trim(true);
  }

  this._output.space_before_token = true;
  this.print_token(current_token);
  this.print_newline(false, preserve_statement_flags);
};

Beautifier.prototype.handle_dot = function(current_token) {
  if (this.start_of_statement(current_token)) ; else {
    this.handle_whitespace_and_comments(current_token, true);
  }

  if (reserved_array(this._flags.last_token, special_words)) {
    this._output.space_before_token = false;
  } else {
    // allow preserved newlines before dots in general
    // force newlines on dots after close paren when break_chained - for bar().baz()
    this.allow_wrap_or_preserved_newline(current_token,
      this._flags.last_token.text === ')' && this._options.break_chained_methods);
  }

  // Only unindent chained method dot if this dot starts a new line.
  // Otherwise the automatic extra indentation removal will handle the over indent
  if (this._options.unindent_chained_methods && this._output.just_added_newline()) {
    this.deindent();
  }

  this.print_token(current_token);
};

Beautifier.prototype.handle_unknown = function(current_token, preserve_statement_flags) {
  this.print_token(current_token);

  if (current_token.text[current_token.text.length - 1] === '\n') {
    this.print_newline(false, preserve_statement_flags);
  }
};

Beautifier.prototype.handle_eof = function(current_token) {
  // Unwind any open statements
  while (this._flags.mode === MODE.Statement) {
    this.restore_mode();
  }
  this.handle_whitespace_and_comments(current_token);
};

var Beautifier_1 = Beautifier;

var beautifier = {
	Beautifier: Beautifier_1
};

var Beautifier$1 = beautifier.Beautifier,
  Options$3 = options$1.Options;

function js_beautify(js_source_text, options) {
  var beautifier = new Beautifier$1(js_source_text, options);
  return beautifier.beautify();
}

var javascript = js_beautify;
var defaultOptions = function() {
  return new Options$3();
};
javascript.defaultOptions = defaultOptions;

var BaseOptions$1 = options.Options;

function Options$4(options) {
  BaseOptions$1.call(this, options, 'css');

  this.selector_separator_newline = this._get_boolean('selector_separator_newline', true);
  this.newline_between_rules = this._get_boolean('newline_between_rules', true);
  var space_around_selector_separator = this._get_boolean('space_around_selector_separator');
  this.space_around_combinator = this._get_boolean('space_around_combinator') || space_around_selector_separator;

  var brace_style_split = this._get_selection_list('brace_style', ['collapse', 'expand', 'end-expand', 'none', 'preserve-inline']);
  this.brace_style = 'collapse';
  for (var bs = 0; bs < brace_style_split.length; bs++) {
    if (brace_style_split[bs] !== 'expand') {
      // default to collapse, as only collapse|expand is implemented for now
      this.brace_style = 'collapse';
    } else {
      this.brace_style = brace_style_split[bs];
    }
  }
}
Options$4.prototype = new BaseOptions$1();



var Options_1$2 = Options$4;

var options$2 = {
	Options: Options_1$2
};

var Options$5 = options$2.Options;
var Output$2 = output.Output;
var InputScanner$3 = inputscanner.InputScanner;
var Directives$2 = directives.Directives;

var directives_core$1 = new Directives$2(/\/\*/, /\*\//);

var lineBreak = /\r\n|[\r\n]/;
var allLineBreaks = /\r\n|[\r\n]/g;

// tokenizer
var whitespaceChar = /\s/;
var whitespacePattern = /(?:\s|\n)+/g;
var block_comment_pattern = /\/\*(?:[\s\S]*?)((?:\*\/)|$)/g;
var comment_pattern = /\/\/(?:[^\n\r\u2028\u2029]*)/g;

function Beautifier$2(source_text, options) {
  this._source_text = source_text || '';
  // Allow the setting of language/file-type specific options
  // with inheritance of overall settings
  this._options = new Options$5(options);
  this._ch = null;
  this._input = null;

  // https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule
  this.NESTED_AT_RULE = {
    "@page": true,
    "@font-face": true,
    "@keyframes": true,
    // also in CONDITIONAL_GROUP_RULE below
    "@media": true,
    "@supports": true,
    "@document": true
  };
  this.CONDITIONAL_GROUP_RULE = {
    "@media": true,
    "@supports": true,
    "@document": true
  };

}

Beautifier$2.prototype.eatString = function(endChars) {
  var result = '';
  this._ch = this._input.next();
  while (this._ch) {
    result += this._ch;
    if (this._ch === "\\") {
      result += this._input.next();
    } else if (endChars.indexOf(this._ch) !== -1 || this._ch === "\n") {
      break;
    }
    this._ch = this._input.next();
  }
  return result;
};

// Skips any white space in the source text from the current position.
// When allowAtLeastOneNewLine is true, will output new lines for each
// newline character found; if the user has preserve_newlines off, only
// the first newline will be output
Beautifier$2.prototype.eatWhitespace = function(allowAtLeastOneNewLine) {
  var result = whitespaceChar.test(this._input.peek());
  var newline_count = 0;
  while (whitespaceChar.test(this._input.peek())) {
    this._ch = this._input.next();
    if (allowAtLeastOneNewLine && this._ch === '\n') {
      if (newline_count === 0 || newline_count < this._options.max_preserve_newlines) {
        newline_count++;
        this._output.add_new_line(true);
      }
    }
  }
  return result;
};

// Nested pseudo-class if we are insideRule
// and the next special character found opens
// a new block
Beautifier$2.prototype.foundNestedPseudoClass = function() {
  var openParen = 0;
  var i = 1;
  var ch = this._input.peek(i);
  while (ch) {
    if (ch === "{") {
      return true;
    } else if (ch === '(') {
      // pseudoclasses can contain ()
      openParen += 1;
    } else if (ch === ')') {
      if (openParen === 0) {
        return false;
      }
      openParen -= 1;
    } else if (ch === ";" || ch === "}") {
      return false;
    }
    i++;
    ch = this._input.peek(i);
  }
  return false;
};

Beautifier$2.prototype.print_string = function(output_string) {
  this._output.set_indent(this._indentLevel);
  this._output.non_breaking_space = true;
  this._output.add_token(output_string);
};

Beautifier$2.prototype.preserveSingleSpace = function(isAfterSpace) {
  if (isAfterSpace) {
    this._output.space_before_token = true;
  }
};

Beautifier$2.prototype.indent = function() {
  this._indentLevel++;
};

Beautifier$2.prototype.outdent = function() {
  if (this._indentLevel > 0) {
    this._indentLevel--;
  }
};

/*_____________________--------------------_____________________*/

Beautifier$2.prototype.beautify = function() {
  if (this._options.disabled) {
    return this._source_text;
  }

  var source_text = this._source_text;
  var eol = this._options.eol;
  if (eol === 'auto') {
    eol = '\n';
    if (source_text && lineBreak.test(source_text || '')) {
      eol = source_text.match(lineBreak)[0];
    }
  }


  // HACK: newline parsing inconsistent. This brute force normalizes the this._input.
  source_text = source_text.replace(allLineBreaks, '\n');

  // reset
  var baseIndentString = source_text.match(/^[\t ]*/)[0];

  this._output = new Output$2(this._options, baseIndentString);
  this._input = new InputScanner$3(source_text);
  this._indentLevel = 0;
  this._nestedLevel = 0;

  this._ch = null;
  var parenLevel = 0;

  var insideRule = false;
  // This is the value side of a property value pair (blue in the following ex)
  // label { content: blue }
  var insidePropertyValue = false;
  var enteringConditionalGroup = false;
  var insideAtExtend = false;
  var insideAtImport = false;
  var topCharacter = this._ch;
  var whitespace;
  var isAfterSpace;
  var previous_ch;

  while (true) {
    whitespace = this._input.read(whitespacePattern);
    isAfterSpace = whitespace !== '';
    previous_ch = topCharacter;
    this._ch = this._input.next();
    if (this._ch === '\\' && this._input.hasNext()) {
      this._ch += this._input.next();
    }
    topCharacter = this._ch;

    if (!this._ch) {
      break;
    } else if (this._ch === '/' && this._input.peek() === '*') {
      // /* css comment */
      // Always start block comments on a new line.
      // This handles scenarios where a block comment immediately
      // follows a property definition on the same line or where
      // minified code is being beautified.
      this._output.add_new_line();
      this._input.back();

      var comment = this._input.read(block_comment_pattern);

      // Handle ignore directive
      var directives = directives_core$1.get_directives(comment);
      if (directives && directives.ignore === 'start') {
        comment += directives_core$1.readIgnored(this._input);
      }

      this.print_string(comment);

      // Ensures any new lines following the comment are preserved
      this.eatWhitespace(true);

      // Block comments are followed by a new line so they don't
      // share a line with other properties
      this._output.add_new_line();
    } else if (this._ch === '/' && this._input.peek() === '/') {
      // // single line comment
      // Preserves the space before a comment
      // on the same line as a rule
      this._output.space_before_token = true;
      this._input.back();
      this.print_string(this._input.read(comment_pattern));

      // Ensures any new lines following the comment are preserved
      this.eatWhitespace(true);
    } else if (this._ch === '@') {
      this.preserveSingleSpace(isAfterSpace);

      // deal with less propery mixins @{...}
      if (this._input.peek() === '{') {
        this.print_string(this._ch + this.eatString('}'));
      } else {
        this.print_string(this._ch);

        // strip trailing space, if present, for hash property checks
        var variableOrRule = this._input.peekUntilAfter(/[: ,;{}()[\]\/='"]/g);

        if (variableOrRule.match(/[ :]$/)) {
          // we have a variable or pseudo-class, add it and insert one space before continuing
          variableOrRule = this.eatString(": ").replace(/\s$/, '');
          this.print_string(variableOrRule);
          this._output.space_before_token = true;
        }

        variableOrRule = variableOrRule.replace(/\s$/, '');

        if (variableOrRule === 'extend') {
          insideAtExtend = true;
        } else if (variableOrRule === 'import') {
          insideAtImport = true;
        }

        // might be a nesting at-rule
        if (variableOrRule in this.NESTED_AT_RULE) {
          this._nestedLevel += 1;
          if (variableOrRule in this.CONDITIONAL_GROUP_RULE) {
            enteringConditionalGroup = true;
          }
          // might be less variable
        } else if (!insideRule && parenLevel === 0 && variableOrRule.indexOf(':') !== -1) {
          insidePropertyValue = true;
          this.indent();
        }
      }
    } else if (this._ch === '#' && this._input.peek() === '{') {
      this.preserveSingleSpace(isAfterSpace);
      this.print_string(this._ch + this.eatString('}'));
    } else if (this._ch === '{') {
      if (insidePropertyValue) {
        insidePropertyValue = false;
        this.outdent();
      }

      // when entering conditional groups, only rulesets are allowed
      if (enteringConditionalGroup) {
        enteringConditionalGroup = false;
        insideRule = (this._indentLevel >= this._nestedLevel);
      } else {
        // otherwise, declarations are also allowed
        insideRule = (this._indentLevel >= this._nestedLevel - 1);
      }
      if (this._options.newline_between_rules && insideRule) {
        if (this._output.previous_line && this._output.previous_line.item(-1) !== '{') {
          this._output.ensure_empty_line_above('/', ',');
        }
      }

      this._output.space_before_token = true;

      // The difference in print_string and indent order is necessary to indent the '{' correctly
      if (this._options.brace_style === 'expand') {
        this._output.add_new_line();
        this.print_string(this._ch);
        this.indent();
        this._output.set_indent(this._indentLevel);
      } else {
        this.indent();
        this.print_string(this._ch);
      }

      this.eatWhitespace(true);
      this._output.add_new_line();
    } else if (this._ch === '}') {
      this.outdent();
      this._output.add_new_line();
      if (previous_ch === '{') {
        this._output.trim(true);
      }
      insideAtImport = false;
      insideAtExtend = false;
      if (insidePropertyValue) {
        this.outdent();
        insidePropertyValue = false;
      }
      this.print_string(this._ch);
      insideRule = false;
      if (this._nestedLevel) {
        this._nestedLevel--;
      }

      this.eatWhitespace(true);
      this._output.add_new_line();

      if (this._options.newline_between_rules && !this._output.just_added_blankline()) {
        if (this._input.peek() !== '}') {
          this._output.add_new_line(true);
        }
      }
    } else if (this._ch === ":") {
      if ((insideRule || enteringConditionalGroup) && !(this._input.lookBack("&") || this.foundNestedPseudoClass()) && !this._input.lookBack("(") && !insideAtExtend && parenLevel === 0) {
        // 'property: value' delimiter
        // which could be in a conditional group query
        this.print_string(':');
        if (!insidePropertyValue) {
          insidePropertyValue = true;
          this._output.space_before_token = true;
          this.eatWhitespace(true);
          this.indent();
        }
      } else {
        // sass/less parent reference don't use a space
        // sass nested pseudo-class don't use a space

        // preserve space before pseudoclasses/pseudoelements, as it means "in any child"
        if (this._input.lookBack(" ")) {
          this._output.space_before_token = true;
        }
        if (this._input.peek() === ":") {
          // pseudo-element
          this._ch = this._input.next();
          this.print_string("::");
        } else {
          // pseudo-class
          this.print_string(':');
        }
      }
    } else if (this._ch === '"' || this._ch === '\'') {
      this.preserveSingleSpace(isAfterSpace);
      this.print_string(this._ch + this.eatString(this._ch));
      this.eatWhitespace(true);
    } else if (this._ch === ';') {
      if (parenLevel === 0) {
        if (insidePropertyValue) {
          this.outdent();
          insidePropertyValue = false;
        }
        insideAtExtend = false;
        insideAtImport = false;
        this.print_string(this._ch);
        this.eatWhitespace(true);

        // This maintains single line comments on the same
        // line. Block comments are also affected, but
        // a new line is always output before one inside
        // that section
        if (this._input.peek() !== '/') {
          this._output.add_new_line();
        }
      } else {
        this.print_string(this._ch);
        this.eatWhitespace(true);
        this._output.space_before_token = true;
      }
    } else if (this._ch === '(') { // may be a url
      if (this._input.lookBack("url")) {
        this.print_string(this._ch);
        this.eatWhitespace();
        parenLevel++;
        this.indent();
        this._ch = this._input.next();
        if (this._ch === ')' || this._ch === '"' || this._ch === '\'') {
          this._input.back();
        } else if (this._ch) {
          this.print_string(this._ch + this.eatString(')'));
          if (parenLevel) {
            parenLevel--;
            this.outdent();
          }
        }
      } else {
        this.preserveSingleSpace(isAfterSpace);
        this.print_string(this._ch);
        this.eatWhitespace();
        parenLevel++;
        this.indent();
      }
    } else if (this._ch === ')') {
      if (parenLevel) {
        parenLevel--;
        this.outdent();
      }
      this.print_string(this._ch);
    } else if (this._ch === ',') {
      this.print_string(this._ch);
      this.eatWhitespace(true);
      if (this._options.selector_separator_newline && !insidePropertyValue && parenLevel === 0 && !insideAtImport) {
        this._output.add_new_line();
      } else {
        this._output.space_before_token = true;
      }
    } else if ((this._ch === '>' || this._ch === '+' || this._ch === '~') && !insidePropertyValue && parenLevel === 0) {
      //handle combinator spacing
      if (this._options.space_around_combinator) {
        this._output.space_before_token = true;
        this.print_string(this._ch);
        this._output.space_before_token = true;
      } else {
        this.print_string(this._ch);
        this.eatWhitespace();
        // squash extra whitespace
        if (this._ch && whitespaceChar.test(this._ch)) {
          this._ch = '';
        }
      }
    } else if (this._ch === ']') {
      this.print_string(this._ch);
    } else if (this._ch === '[') {
      this.preserveSingleSpace(isAfterSpace);
      this.print_string(this._ch);
    } else if (this._ch === '=') { // no whitespace before or after
      this.eatWhitespace();
      this.print_string('=');
      if (whitespaceChar.test(this._ch)) {
        this._ch = '';
      }
    } else if (this._ch === '!' && !this._input.lookBack("\\")) { // !important
      this.print_string(' ');
      this.print_string(this._ch);
    } else {
      this.preserveSingleSpace(isAfterSpace);
      this.print_string(this._ch);
    }
  }

  var sweetCode = this._output.get_code(eol);

  return sweetCode;
};

var Beautifier_1$1 = Beautifier$2;

var beautifier$1 = {
	Beautifier: Beautifier_1$1
};

var Beautifier$3 = beautifier$1.Beautifier,
  Options$6 = options$2.Options;

function css_beautify(source_text, options) {
  var beautifier = new Beautifier$3(source_text, options);
  return beautifier.beautify();
}

var css = css_beautify;
var defaultOptions$1 = function() {
  return new Options$6();
};
css.defaultOptions = defaultOptions$1;

var BaseOptions$2 = options.Options;

function Options$7(options) {
  BaseOptions$2.call(this, options, 'html');
  if (this.templating.length === 1 && this.templating[0] === 'auto') {
    this.templating = ['django', 'erb', 'handlebars', 'php'];
  }

  this.indent_inner_html = this._get_boolean('indent_inner_html');
  this.indent_body_inner_html = this._get_boolean('indent_body_inner_html', true);
  this.indent_head_inner_html = this._get_boolean('indent_head_inner_html', true);

  this.indent_handlebars = this._get_boolean('indent_handlebars', true);
  this.wrap_attributes = this._get_selection('wrap_attributes',
    ['auto', 'force', 'force-aligned', 'force-expand-multiline', 'aligned-multiple', 'preserve', 'preserve-aligned']);
  this.wrap_attributes_indent_size = this._get_number('wrap_attributes_indent_size', this.indent_size);
  this.extra_liners = this._get_array('extra_liners', ['head', 'body', '/html']);

  // Block vs inline elements
  // https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements
  // https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements
  // https://www.w3.org/TR/html5/dom.html#phrasing-content
  this.inline = this._get_array('inline', [
    'a', 'abbr', 'area', 'audio', 'b', 'bdi', 'bdo', 'br', 'button', 'canvas', 'cite',
    'code', 'data', 'datalist', 'del', 'dfn', 'em', 'embed', 'i', 'iframe', 'img',
    'input', 'ins', 'kbd', 'keygen', 'label', 'map', 'mark', 'math', 'meter', 'noscript',
    'object', 'output', 'progress', 'q', 'ruby', 's', 'samp', /* 'script', */ 'select', 'small',
    'span', 'strong', 'sub', 'sup', 'svg', 'template', 'textarea', 'time', 'u', 'var',
    'video', 'wbr', 'text',
    // obsolete inline tags
    'acronym', 'big', 'strike', 'tt'
  ]);
  this.void_elements = this._get_array('void_elements', [
    // HTLM void elements - aka self-closing tags - aka singletons
    // https://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements
    'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen',
    'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr',
    // NOTE: Optional tags are too complex for a simple list
    // they are hard coded in _do_optional_end_element

    // Doctype and xml elements
    '!doctype', '?xml',

    // obsolete tags
    // basefont: https://www.computerhope.com/jargon/h/html-basefont-tag.htm
    // isndex: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/isindex
    'basefont', 'isindex'
  ]);
  this.unformatted = this._get_array('unformatted', []);
  this.content_unformatted = this._get_array('content_unformatted', [
    'pre', 'textarea'
  ]);
  this.unformatted_content_delimiter = this._get_characters('unformatted_content_delimiter');
  this.indent_scripts = this._get_selection('indent_scripts', ['normal', 'keep', 'separate']);

}
Options$7.prototype = new BaseOptions$2();



var Options_1$3 = Options$7;

var options$3 = {
	Options: Options_1$3
};

var BaseTokenizer$1 = tokenizer.Tokenizer;
var BASETOKEN$1 = tokenizer.TOKEN;
var Directives$3 = directives.Directives;
var TemplatablePattern$2 = templatablepattern.TemplatablePattern;
var Pattern$4 = pattern.Pattern;

var TOKEN$3 = {
  TAG_OPEN: 'TK_TAG_OPEN',
  TAG_CLOSE: 'TK_TAG_CLOSE',
  ATTRIBUTE: 'TK_ATTRIBUTE',
  EQUALS: 'TK_EQUALS',
  VALUE: 'TK_VALUE',
  COMMENT: 'TK_COMMENT',
  TEXT: 'TK_TEXT',
  UNKNOWN: 'TK_UNKNOWN',
  START: BASETOKEN$1.START,
  RAW: BASETOKEN$1.RAW,
  EOF: BASETOKEN$1.EOF
};

var directives_core$2 = new Directives$3(/<\!--/, /-->/);

var Tokenizer$3 = function(input_string, options) {
  BaseTokenizer$1.call(this, input_string, options);
  this._current_tag_name = '';

  // Words end at whitespace or when a tag starts
  // if we are indenting handlebars, they are considered tags
  var templatable_reader = new TemplatablePattern$2(this._input).read_options(this._options);
  var pattern_reader = new Pattern$4(this._input);

  this.__patterns = {
    word: templatable_reader.until(/[\n\r\t <]/),
    single_quote: templatable_reader.until_after(/'/),
    double_quote: templatable_reader.until_after(/"/),
    attribute: templatable_reader.until(/[\n\r\t =>]|\/>/),
    element_name: templatable_reader.until(/[\n\r\t >\/]/),

    handlebars_comment: pattern_reader.starting_with(/{{!--/).until_after(/--}}/),
    handlebars: pattern_reader.starting_with(/{{/).until_after(/}}/),
    handlebars_open: pattern_reader.until(/[\n\r\t }]/),
    handlebars_raw_close: pattern_reader.until(/}}/),
    comment: pattern_reader.starting_with(/<!--/).until_after(/-->/),
    cdata: pattern_reader.starting_with(/<!\[CDATA\[/).until_after(/]]>/),
    // https://en.wikipedia.org/wiki/Conditional_comment
    conditional_comment: pattern_reader.starting_with(/<!\[/).until_after(/]>/),
    processing: pattern_reader.starting_with(/<\?/).until_after(/\?>/)
  };

  if (this._options.indent_handlebars) {
    this.__patterns.word = this.__patterns.word.exclude('handlebars');
  }

  this._unformatted_content_delimiter = null;

  if (this._options.unformatted_content_delimiter) {
    var literal_regexp = this._input.get_literal_regexp(this._options.unformatted_content_delimiter);
    this.__patterns.unformatted_content_delimiter =
      pattern_reader.matching(literal_regexp)
      .until_after(literal_regexp);
  }
};
Tokenizer$3.prototype = new BaseTokenizer$1();

Tokenizer$3.prototype._is_comment = function(current_token) { // jshint unused:false
  return false; //current_token.type === TOKEN.COMMENT || current_token.type === TOKEN.UNKNOWN;
};

Tokenizer$3.prototype._is_opening = function(current_token) {
  return current_token.type === TOKEN$3.TAG_OPEN;
};

Tokenizer$3.prototype._is_closing = function(current_token, open_token) {
  return current_token.type === TOKEN$3.TAG_CLOSE &&
    (open_token && (
      ((current_token.text === '>' || current_token.text === '/>') && open_token.text[0] === '<') ||
      (current_token.text === '}}' && open_token.text[0] === '{' && open_token.text[1] === '{')));
};

Tokenizer$3.prototype._reset = function() {
  this._current_tag_name = '';
};

Tokenizer$3.prototype._get_next_token = function(previous_token, open_token) { // jshint unused:false
  var token = null;
  this._readWhitespace();
  var c = this._input.peek();

  if (c === null) {
    return this._create_token(TOKEN$3.EOF, '');
  }

  token = token || this._read_open_handlebars(c, open_token);
  token = token || this._read_attribute(c, previous_token, open_token);
  token = token || this._read_close(c, open_token);
  token = token || this._read_raw_content(c, previous_token, open_token);
  token = token || this._read_content_word(c);
  token = token || this._read_comment_or_cdata(c);
  token = token || this._read_processing(c);
  token = token || this._read_open(c, open_token);
  token = token || this._create_token(TOKEN$3.UNKNOWN, this._input.next());

  return token;
};

Tokenizer$3.prototype._read_comment_or_cdata = function(c) { // jshint unused:false
  var token = null;
  var resulting_string = null;
  var directives = null;

  if (c === '<') {
    var peek1 = this._input.peek(1);
    // We treat all comments as literals, even more than preformatted tags
    // we only look for the appropriate closing marker
    if (peek1 === '!') {
      resulting_string = this.__patterns.comment.read();

      // only process directive on html comments
      if (resulting_string) {
        directives = directives_core$2.get_directives(resulting_string);
        if (directives && directives.ignore === 'start') {
          resulting_string += directives_core$2.readIgnored(this._input);
        }
      } else {
        resulting_string = this.__patterns.cdata.read();
      }
    }

    if (resulting_string) {
      token = this._create_token(TOKEN$3.COMMENT, resulting_string);
      token.directives = directives;
    }
  }

  return token;
};

Tokenizer$3.prototype._read_processing = function(c) { // jshint unused:false
  var token = null;
  var resulting_string = null;
  var directives = null;

  if (c === '<') {
    var peek1 = this._input.peek(1);
    if (peek1 === '!' || peek1 === '?') {
      resulting_string = this.__patterns.conditional_comment.read();
      resulting_string = resulting_string || this.__patterns.processing.read();
    }

    if (resulting_string) {
      token = this._create_token(TOKEN$3.COMMENT, resulting_string);
      token.directives = directives;
    }
  }

  return token;
};

Tokenizer$3.prototype._read_open = function(c, open_token) {
  var resulting_string = null;
  var token = null;
  if (!open_token) {
    if (c === '<') {

      resulting_string = this._input.next();
      if (this._input.peek() === '/') {
        resulting_string += this._input.next();
      }
      resulting_string += this.__patterns.element_name.read();
      token = this._create_token(TOKEN$3.TAG_OPEN, resulting_string);
    }
  }
  return token;
};

Tokenizer$3.prototype._read_open_handlebars = function(c, open_token) {
  var resulting_string = null;
  var token = null;
  if (!open_token) {
    if (this._options.indent_handlebars && c === '{' && this._input.peek(1) === '{') {
      if (this._input.peek(2) === '!') {
        resulting_string = this.__patterns.handlebars_comment.read();
        resulting_string = resulting_string || this.__patterns.handlebars.read();
        token = this._create_token(TOKEN$3.COMMENT, resulting_string);
      } else {
        resulting_string = this.__patterns.handlebars_open.read();
        token = this._create_token(TOKEN$3.TAG_OPEN, resulting_string);
      }
    }
  }
  return token;
};


Tokenizer$3.prototype._read_close = function(c, open_token) {
  var resulting_string = null;
  var token = null;
  if (open_token) {
    if (open_token.text[0] === '<' && (c === '>' || (c === '/' && this._input.peek(1) === '>'))) {
      resulting_string = this._input.next();
      if (c === '/') { //  for close tag "/>"
        resulting_string += this._input.next();
      }
      token = this._create_token(TOKEN$3.TAG_CLOSE, resulting_string);
    } else if (open_token.text[0] === '{' && c === '}' && this._input.peek(1) === '}') {
      this._input.next();
      this._input.next();
      token = this._create_token(TOKEN$3.TAG_CLOSE, '}}');
    }
  }

  return token;
};

Tokenizer$3.prototype._read_attribute = function(c, previous_token, open_token) {
  var token = null;
  var resulting_string = '';
  if (open_token && open_token.text[0] === '<') {

    if (c === '=') {
      token = this._create_token(TOKEN$3.EQUALS, this._input.next());
    } else if (c === '"' || c === "'") {
      var content = this._input.next();
      if (c === '"') {
        content += this.__patterns.double_quote.read();
      } else {
        content += this.__patterns.single_quote.read();
      }
      token = this._create_token(TOKEN$3.VALUE, content);
    } else {
      resulting_string = this.__patterns.attribute.read();

      if (resulting_string) {
        if (previous_token.type === TOKEN$3.EQUALS) {
          token = this._create_token(TOKEN$3.VALUE, resulting_string);
        } else {
          token = this._create_token(TOKEN$3.ATTRIBUTE, resulting_string);
        }
      }
    }
  }
  return token;
};

Tokenizer$3.prototype._is_content_unformatted = function(tag_name) {
  // void_elements have no content and so cannot have unformatted content
  // script and style tags should always be read as unformatted content
  // finally content_unformatted and unformatted element contents are unformatted
  return this._options.void_elements.indexOf(tag_name) === -1 &&
    (this._options.content_unformatted.indexOf(tag_name) !== -1 ||
      this._options.unformatted.indexOf(tag_name) !== -1);
};


Tokenizer$3.prototype._read_raw_content = function(c, previous_token, open_token) { // jshint unused:false
  var resulting_string = '';
  if (open_token && open_token.text[0] === '{') {
    resulting_string = this.__patterns.handlebars_raw_close.read();
  } else if (previous_token.type === TOKEN$3.TAG_CLOSE &&
    previous_token.opened.text[0] === '<' && previous_token.text[0] !== '/') {
    // ^^ empty tag has no content 
    var tag_name = previous_token.opened.text.substr(1).toLowerCase();
    if (tag_name === 'script' || tag_name === 'style') {
      // Script and style tags are allowed to have comments wrapping their content
      // or just have regular content.
      var token = this._read_comment_or_cdata(c);
      if (token) {
        token.type = TOKEN$3.TEXT;
        return token;
      }
      resulting_string = this._input.readUntil(new RegExp('</' + tag_name + '[\\n\\r\\t ]*?>', 'ig'));
    } else if (this._is_content_unformatted(tag_name)) {

      resulting_string = this._input.readUntil(new RegExp('</' + tag_name + '[\\n\\r\\t ]*?>', 'ig'));
    }
  }

  if (resulting_string) {
    return this._create_token(TOKEN$3.TEXT, resulting_string);
  }

  return null;
};

Tokenizer$3.prototype._read_content_word = function(c) {
  var resulting_string = '';
  if (this._options.unformatted_content_delimiter) {
    if (c === this._options.unformatted_content_delimiter[0]) {
      resulting_string = this.__patterns.unformatted_content_delimiter.read();
    }
  }

  if (!resulting_string) {
    resulting_string = this.__patterns.word.read();
  }
  if (resulting_string) {
    return this._create_token(TOKEN$3.TEXT, resulting_string);
  }
};

var Tokenizer_1$2 = Tokenizer$3;
var TOKEN_1$2 = TOKEN$3;

var tokenizer$2 = {
	Tokenizer: Tokenizer_1$2,
	TOKEN: TOKEN_1$2
};

var Options$8 = options$3.Options;
var Output$3 = output.Output;
var Tokenizer$4 = tokenizer$2.Tokenizer;
var TOKEN$4 = tokenizer$2.TOKEN;

var lineBreak$1 = /\r\n|[\r\n]/;
var allLineBreaks$1 = /\r\n|[\r\n]/g;

var Printer = function(options, base_indent_string) { //handles input/output and some other printing functions

  this.indent_level = 0;
  this.alignment_size = 0;
  this.max_preserve_newlines = options.max_preserve_newlines;
  this.preserve_newlines = options.preserve_newlines;

  this._output = new Output$3(options, base_indent_string);

};

Printer.prototype.current_line_has_match = function(pattern) {
  return this._output.current_line.has_match(pattern);
};

Printer.prototype.set_space_before_token = function(value, non_breaking) {
  this._output.space_before_token = value;
  this._output.non_breaking_space = non_breaking;
};

Printer.prototype.set_wrap_point = function() {
  this._output.set_indent(this.indent_level, this.alignment_size);
  this._output.set_wrap_point();
};


Printer.prototype.add_raw_token = function(token) {
  this._output.add_raw_token(token);
};

Printer.prototype.print_preserved_newlines = function(raw_token) {
  var newlines = 0;
  if (raw_token.type !== TOKEN$4.TEXT && raw_token.previous.type !== TOKEN$4.TEXT) {
    newlines = raw_token.newlines ? 1 : 0;
  }

  if (this.preserve_newlines) {
    newlines = raw_token.newlines < this.max_preserve_newlines + 1 ? raw_token.newlines : this.max_preserve_newlines + 1;
  }
  for (var n = 0; n < newlines; n++) {
    this.print_newline(n > 0);
  }

  return newlines !== 0;
};

Printer.prototype.traverse_whitespace = function(raw_token) {
  if (raw_token.whitespace_before || raw_token.newlines) {
    if (!this.print_preserved_newlines(raw_token)) {
      this._output.space_before_token = true;
    }
    return true;
  }
  return false;
};

Printer.prototype.previous_token_wrapped = function() {
  return this._output.previous_token_wrapped;
};

Printer.prototype.print_newline = function(force) {
  this._output.add_new_line(force);
};

Printer.prototype.print_token = function(token) {
  if (token.text) {
    this._output.set_indent(this.indent_level, this.alignment_size);
    this._output.add_token(token.text);
  }
};

Printer.prototype.indent = function() {
  this.indent_level++;
};

Printer.prototype.get_full_indent = function(level) {
  level = this.indent_level + (level || 0);
  if (level < 1) {
    return '';
  }

  return this._output.get_indent_string(level);
};

var get_type_attribute = function(start_token) {
  var result = null;
  var raw_token = start_token.next;

  // Search attributes for a type attribute
  while (raw_token.type !== TOKEN$4.EOF && start_token.closed !== raw_token) {
    if (raw_token.type === TOKEN$4.ATTRIBUTE && raw_token.text === 'type') {
      if (raw_token.next && raw_token.next.type === TOKEN$4.EQUALS &&
        raw_token.next.next && raw_token.next.next.type === TOKEN$4.VALUE) {
        result = raw_token.next.next.text;
      }
      break;
    }
    raw_token = raw_token.next;
  }

  return result;
};

var get_custom_beautifier_name = function(tag_check, raw_token) {
  var typeAttribute = null;
  var result = null;

  if (!raw_token.closed) {
    return null;
  }

  if (tag_check === 'script') {
    typeAttribute = 'text/javascript';
  } else if (tag_check === 'style') {
    typeAttribute = 'text/css';
  }

  typeAttribute = get_type_attribute(raw_token) || typeAttribute;

  // For script and style tags that have a type attribute, only enable custom beautifiers for matching values
  // For those without a type attribute use default;
  if (typeAttribute.search('text/css') > -1) {
    result = 'css';
  } else if (typeAttribute.search(/module|((text|application|dojo)\/(x-)?(javascript|ecmascript|jscript|livescript|(ld\+)?json|method|aspect))/) > -1) {
    result = 'javascript';
  } else if (typeAttribute.search(/(text|application|dojo)\/(x-)?(html)/) > -1) {
    result = 'html';
  } else if (typeAttribute.search(/test\/null/) > -1) {
    // Test only mime-type for testing the beautifier when null is passed as beautifing function
    result = 'null';
  }

  return result;
};

function in_array$2(what, arr) {
  return arr.indexOf(what) !== -1;
}

function TagFrame(parent, parser_token, indent_level) {
  this.parent = parent || null;
  this.tag = parser_token ? parser_token.tag_name : '';
  this.indent_level = indent_level || 0;
  this.parser_token = parser_token || null;
}

function TagStack(printer) {
  this._printer = printer;
  this._current_frame = null;
}

TagStack.prototype.get_parser_token = function() {
  return this._current_frame ? this._current_frame.parser_token : null;
};

TagStack.prototype.record_tag = function(parser_token) { //function to record a tag and its parent in this.tags Object
  var new_frame = new TagFrame(this._current_frame, parser_token, this._printer.indent_level);
  this._current_frame = new_frame;
};

TagStack.prototype._try_pop_frame = function(frame) { //function to retrieve the opening tag to the corresponding closer
  var parser_token = null;

  if (frame) {
    parser_token = frame.parser_token;
    this._printer.indent_level = frame.indent_level;
    this._current_frame = frame.parent;
  }

  return parser_token;
};

TagStack.prototype._get_frame = function(tag_list, stop_list) { //function to retrieve the opening tag to the corresponding closer
  var frame = this._current_frame;

  while (frame) { //till we reach '' (the initial value);
    if (tag_list.indexOf(frame.tag) !== -1) { //if this is it use it
      break;
    } else if (stop_list && stop_list.indexOf(frame.tag) !== -1) {
      frame = null;
      break;
    }
    frame = frame.parent;
  }

  return frame;
};

TagStack.prototype.try_pop = function(tag, stop_list) { //function to retrieve the opening tag to the corresponding closer
  var frame = this._get_frame([tag], stop_list);
  return this._try_pop_frame(frame);
};

TagStack.prototype.indent_to_tag = function(tag_list) {
  var frame = this._get_frame(tag_list);
  if (frame) {
    this._printer.indent_level = frame.indent_level;
  }
};

function Beautifier$4(source_text, options, js_beautify, css_beautify) {
  //Wrapper function to invoke all the necessary constructors and deal with the output.
  this._source_text = source_text || '';
  options = options || {};
  this._js_beautify = js_beautify;
  this._css_beautify = css_beautify;
  this._tag_stack = null;

  // Allow the setting of language/file-type specific options
  // with inheritance of overall settings
  var optionHtml = new Options$8(options, 'html');

  this._options = optionHtml;

  this._is_wrap_attributes_force = this._options.wrap_attributes.substr(0, 'force'.length) === 'force';
  this._is_wrap_attributes_force_expand_multiline = (this._options.wrap_attributes === 'force-expand-multiline');
  this._is_wrap_attributes_force_aligned = (this._options.wrap_attributes === 'force-aligned');
  this._is_wrap_attributes_aligned_multiple = (this._options.wrap_attributes === 'aligned-multiple');
  this._is_wrap_attributes_preserve = this._options.wrap_attributes.substr(0, 'preserve'.length) === 'preserve';
  this._is_wrap_attributes_preserve_aligned = (this._options.wrap_attributes === 'preserve-aligned');
}

Beautifier$4.prototype.beautify = function() {

  // if disabled, return the input unchanged.
  if (this._options.disabled) {
    return this._source_text;
  }

  var source_text = this._source_text;
  var eol = this._options.eol;
  if (this._options.eol === 'auto') {
    eol = '\n';
    if (source_text && lineBreak$1.test(source_text)) {
      eol = source_text.match(lineBreak$1)[0];
    }
  }

  // HACK: newline parsing inconsistent. This brute force normalizes the input.
  source_text = source_text.replace(allLineBreaks$1, '\n');

  var baseIndentString = source_text.match(/^[\t ]*/)[0];

  var last_token = {
    text: '',
    type: ''
  };

  var last_tag_token = new TagOpenParserToken();

  var printer = new Printer(this._options, baseIndentString);
  var tokens = new Tokenizer$4(source_text, this._options).tokenize();

  this._tag_stack = new TagStack(printer);

  var parser_token = null;
  var raw_token = tokens.next();
  while (raw_token.type !== TOKEN$4.EOF) {

    if (raw_token.type === TOKEN$4.TAG_OPEN || raw_token.type === TOKEN$4.COMMENT) {
      parser_token = this._handle_tag_open(printer, raw_token, last_tag_token, last_token);
      last_tag_token = parser_token;
    } else if ((raw_token.type === TOKEN$4.ATTRIBUTE || raw_token.type === TOKEN$4.EQUALS || raw_token.type === TOKEN$4.VALUE) ||
      (raw_token.type === TOKEN$4.TEXT && !last_tag_token.tag_complete)) {
      parser_token = this._handle_inside_tag(printer, raw_token, last_tag_token, tokens);
    } else if (raw_token.type === TOKEN$4.TAG_CLOSE) {
      parser_token = this._handle_tag_close(printer, raw_token, last_tag_token);
    } else if (raw_token.type === TOKEN$4.TEXT) {
      parser_token = this._handle_text(printer, raw_token, last_tag_token);
    } else {
      // This should never happen, but if it does. Print the raw token
      printer.add_raw_token(raw_token);
    }

    last_token = parser_token;

    raw_token = tokens.next();
  }
  var sweet_code = printer._output.get_code(eol);

  return sweet_code;
};

Beautifier$4.prototype._handle_tag_close = function(printer, raw_token, last_tag_token) {
  var parser_token = {
    text: raw_token.text,
    type: raw_token.type
  };
  printer.alignment_size = 0;
  last_tag_token.tag_complete = true;

  printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== '', true);
  if (last_tag_token.is_unformatted) {
    printer.add_raw_token(raw_token);
  } else {
    if (last_tag_token.tag_start_char === '<') {
      printer.set_space_before_token(raw_token.text[0] === '/', true); // space before />, no space before >
      if (this._is_wrap_attributes_force_expand_multiline && last_tag_token.has_wrapped_attrs) {
        printer.print_newline(false);
      }
    }
    printer.print_token(raw_token);

  }

  if (last_tag_token.indent_content &&
    !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {
    printer.indent();

    // only indent once per opened tag
    last_tag_token.indent_content = false;
  }

  if (!last_tag_token.is_inline_element &&
    !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {
    printer.set_wrap_point();
  }

  return parser_token;
};

Beautifier$4.prototype._handle_inside_tag = function(printer, raw_token, last_tag_token, tokens) {
  var wrapped = last_tag_token.has_wrapped_attrs;
  var parser_token = {
    text: raw_token.text,
    type: raw_token.type
  };

  printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== '', true);
  if (last_tag_token.is_unformatted) {
    printer.add_raw_token(raw_token);
  } else if (last_tag_token.tag_start_char === '{' && raw_token.type === TOKEN$4.TEXT) {
    // For the insides of handlebars allow newlines or a single space between open and contents
    if (printer.print_preserved_newlines(raw_token)) {
      raw_token.newlines = 0;
      printer.add_raw_token(raw_token);
    } else {
      printer.print_token(raw_token);
    }
  } else {
    if (raw_token.type === TOKEN$4.ATTRIBUTE) {
      printer.set_space_before_token(true);
      last_tag_token.attr_count += 1;
    } else if (raw_token.type === TOKEN$4.EQUALS) { //no space before =
      printer.set_space_before_token(false);
    } else if (raw_token.type === TOKEN$4.VALUE && raw_token.previous.type === TOKEN$4.EQUALS) { //no space before value
      printer.set_space_before_token(false);
    }

    if (raw_token.type === TOKEN$4.ATTRIBUTE && last_tag_token.tag_start_char === '<') {
      if (this._is_wrap_attributes_preserve || this._is_wrap_attributes_preserve_aligned) {
        printer.traverse_whitespace(raw_token);
        wrapped = wrapped || raw_token.newlines !== 0;
      }


      if (this._is_wrap_attributes_force) {
        var force_attr_wrap = last_tag_token.attr_count > 1;
        if (this._is_wrap_attributes_force_expand_multiline && last_tag_token.attr_count === 1) {
          var is_only_attribute = true;
          var peek_index = 0;
          var peek_token;
          do {
            peek_token = tokens.peek(peek_index);
            if (peek_token.type === TOKEN$4.ATTRIBUTE) {
              is_only_attribute = false;
              break;
            }
            peek_index += 1;
          } while (peek_index < 4 && peek_token.type !== TOKEN$4.EOF && peek_token.type !== TOKEN$4.TAG_CLOSE);

          force_attr_wrap = !is_only_attribute;
        }

        if (force_attr_wrap) {
          printer.print_newline(false);
          wrapped = true;
        }
      }
    }
    printer.print_token(raw_token);
    wrapped = wrapped || printer.previous_token_wrapped();
    last_tag_token.has_wrapped_attrs = wrapped;
  }
  return parser_token;
};

Beautifier$4.prototype._handle_text = function(printer, raw_token, last_tag_token) {
  var parser_token = {
    text: raw_token.text,
    type: 'TK_CONTENT'
  };
  if (last_tag_token.custom_beautifier_name) { //check if we need to format javascript
    this._print_custom_beatifier_text(printer, raw_token, last_tag_token);
  } else if (last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) {
    printer.add_raw_token(raw_token);
  } else {
    printer.traverse_whitespace(raw_token);
    printer.print_token(raw_token);
  }
  return parser_token;
};

Beautifier$4.prototype._print_custom_beatifier_text = function(printer, raw_token, last_tag_token) {
  var local = this;
  if (raw_token.text !== '') {

    var text = raw_token.text,
      _beautifier,
      script_indent_level = 1,
      pre = '',
      post = '';
    if (last_tag_token.custom_beautifier_name === 'javascript' && typeof this._js_beautify === 'function') {
      _beautifier = this._js_beautify;
    } else if (last_tag_token.custom_beautifier_name === 'css' && typeof this._css_beautify === 'function') {
      _beautifier = this._css_beautify;
    } else if (last_tag_token.custom_beautifier_name === 'html') {
      _beautifier = function(html_source, options) {
        var beautifier = new Beautifier$4(html_source, options, local._js_beautify, local._css_beautify);
        return beautifier.beautify();
      };
    }

    if (this._options.indent_scripts === "keep") {
      script_indent_level = 0;
    } else if (this._options.indent_scripts === "separate") {
      script_indent_level = -printer.indent_level;
    }

    var indentation = printer.get_full_indent(script_indent_level);

    // if there is at least one empty line at the end of this text, strip it
    // we'll be adding one back after the text but before the containing tag.
    text = text.replace(/\n[ \t]*$/, '');

    // Handle the case where content is wrapped in a comment or cdata.
    if (last_tag_token.custom_beautifier_name !== 'html' &&
      text[0] === '<' && text.match(/^(<!--|<!\[CDATA\[)/)) {
      var matched = /^(<!--[^\n]*|<!\[CDATA\[)(\n?)([ \t\n]*)([\s\S]*)(-->|]]>)$/.exec(text);

      // if we start to wrap but don't finish, print raw
      if (!matched) {
        printer.add_raw_token(raw_token);
        return;
      }

      pre = indentation + matched[1] + '\n';
      text = matched[4];
      if (matched[5]) {
        post = indentation + matched[5];
      }

      // if there is at least one empty line at the end of this text, strip it
      // we'll be adding one back after the text but before the containing tag.
      text = text.replace(/\n[ \t]*$/, '');

      if (matched[2] || matched[3].indexOf('\n') !== -1) {
        // if the first line of the non-comment text has spaces
        // use that as the basis for indenting in null case.
        matched = matched[3].match(/[ \t]+$/);
        if (matched) {
          raw_token.whitespace_before = matched[0];
        }
      }
    }

    if (text) {
      if (_beautifier) {

        // call the Beautifier if avaliable
        var Child_options = function() {
          this.eol = '\n';
        };
        Child_options.prototype = this._options.raw_options;
        var child_options = new Child_options();
        text = _beautifier(indentation + text, child_options);
      } else {
        // simply indent the string otherwise
        var white = raw_token.whitespace_before;
        if (white) {
          text = text.replace(new RegExp('\n(' + white + ')?', 'g'), '\n');
        }

        text = indentation + text.replace(/\n/g, '\n' + indentation);
      }
    }

    if (pre) {
      if (!text) {
        text = pre + post;
      } else {
        text = pre + text + '\n' + post;
      }
    }

    printer.print_newline(false);
    if (text) {
      raw_token.text = text;
      raw_token.whitespace_before = '';
      raw_token.newlines = 0;
      printer.add_raw_token(raw_token);
      printer.print_newline(true);
    }
  }
};

Beautifier$4.prototype._handle_tag_open = function(printer, raw_token, last_tag_token, last_token) {
  var parser_token = this._get_tag_open_token(raw_token);

  if ((last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) &&
    !last_tag_token.is_empty_element &&
    raw_token.type === TOKEN$4.TAG_OPEN && raw_token.text.indexOf('</') === 0) {
    // End element tags for unformatted or content_unformatted elements
    // are printed raw to keep any newlines inside them exactly the same.
    printer.add_raw_token(raw_token);
    parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name);
  } else {
    printer.traverse_whitespace(raw_token);
    this._set_tag_position(printer, raw_token, parser_token, last_tag_token, last_token);
    if (!parser_token.is_inline_element) {
      printer.set_wrap_point();
    }
    printer.print_token(raw_token);
  }

  //indent attributes an auto, forced, aligned or forced-align line-wrap
  if (this._is_wrap_attributes_force_aligned || this._is_wrap_attributes_aligned_multiple || this._is_wrap_attributes_preserve_aligned) {
    parser_token.alignment_size = raw_token.text.length + 1;
  }

  if (!parser_token.tag_complete && !parser_token.is_unformatted) {
    printer.alignment_size = parser_token.alignment_size;
  }

  return parser_token;
};

var TagOpenParserToken = function(parent, raw_token) {
  this.parent = parent || null;
  this.text = '';
  this.type = 'TK_TAG_OPEN';
  this.tag_name = '';
  this.is_inline_element = false;
  this.is_unformatted = false;
  this.is_content_unformatted = false;
  this.is_empty_element = false;
  this.is_start_tag = false;
  this.is_end_tag = false;
  this.indent_content = false;
  this.multiline_content = false;
  this.custom_beautifier_name = null;
  this.start_tag_token = null;
  this.attr_count = 0;
  this.has_wrapped_attrs = false;
  this.alignment_size = 0;
  this.tag_complete = false;
  this.tag_start_char = '';
  this.tag_check = '';

  if (!raw_token) {
    this.tag_complete = true;
  } else {
    var tag_check_match;

    this.tag_start_char = raw_token.text[0];
    this.text = raw_token.text;

    if (this.tag_start_char === '<') {
      tag_check_match = raw_token.text.match(/^<([^\s>]*)/);
      this.tag_check = tag_check_match ? tag_check_match[1] : '';
    } else {
      tag_check_match = raw_token.text.match(/^{{(?:[\^]|#\*?)?([^\s}]+)/);
      this.tag_check = tag_check_match ? tag_check_match[1] : '';

      // handle "{{#> myPartial}}
      if (raw_token.text === '{{#>' && this.tag_check === '>' && raw_token.next !== null) {
        this.tag_check = raw_token.next.text;
      }
    }
    this.tag_check = this.tag_check.toLowerCase();

    if (raw_token.type === TOKEN$4.COMMENT) {
      this.tag_complete = true;
    }

    this.is_start_tag = this.tag_check.charAt(0) !== '/';
    this.tag_name = !this.is_start_tag ? this.tag_check.substr(1) : this.tag_check;
    this.is_end_tag = !this.is_start_tag ||
      (raw_token.closed && raw_token.closed.text === '/>');

    // handlebars tags that don't start with # or ^ are single_tags, and so also start and end.
    this.is_end_tag = this.is_end_tag ||
      (this.tag_start_char === '{' && (this.text.length < 3 || (/[^#\^]/.test(this.text.charAt(2)))));
  }
};

Beautifier$4.prototype._get_tag_open_token = function(raw_token) { //function to get a full tag and parse its type
  var parser_token = new TagOpenParserToken(this._tag_stack.get_parser_token(), raw_token);

  parser_token.alignment_size = this._options.wrap_attributes_indent_size;

  parser_token.is_end_tag = parser_token.is_end_tag ||
    in_array$2(parser_token.tag_check, this._options.void_elements);

  parser_token.is_empty_element = parser_token.tag_complete ||
    (parser_token.is_start_tag && parser_token.is_end_tag);

  parser_token.is_unformatted = !parser_token.tag_complete && in_array$2(parser_token.tag_check, this._options.unformatted);
  parser_token.is_content_unformatted = !parser_token.is_empty_element && in_array$2(parser_token.tag_check, this._options.content_unformatted);
  parser_token.is_inline_element = in_array$2(parser_token.tag_name, this._options.inline) || parser_token.tag_start_char === '{';

  return parser_token;
};

Beautifier$4.prototype._set_tag_position = function(printer, raw_token, parser_token, last_tag_token, last_token) {

  if (!parser_token.is_empty_element) {
    if (parser_token.is_end_tag) { //this tag is a double tag so check for tag-ending
      parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name); //remove it and all ancestors
    } else { // it's a start-tag
      // check if this tag is starting an element that has optional end element
      // and do an ending needed
      if (this._do_optional_end_element(parser_token)) {
        if (!parser_token.is_inline_element) {
          printer.print_newline(false);
        }
      }

      this._tag_stack.record_tag(parser_token); //push it on the tag stack

      if ((parser_token.tag_name === 'script' || parser_token.tag_name === 'style') &&
        !(parser_token.is_unformatted || parser_token.is_content_unformatted)) {
        parser_token.custom_beautifier_name = get_custom_beautifier_name(parser_token.tag_check, raw_token);
      }
    }
  }

  if (in_array$2(parser_token.tag_check, this._options.extra_liners)) { //check if this double needs an extra line
    printer.print_newline(false);
    if (!printer._output.just_added_blankline()) {
      printer.print_newline(true);
    }
  }

  if (parser_token.is_empty_element) { //if this tag name is a single tag type (either in the list or has a closing /)

    // if you hit an else case, reset the indent level if you are inside an:
    // 'if', 'unless', or 'each' block.
    if (parser_token.tag_start_char === '{' && parser_token.tag_check === 'else') {
      this._tag_stack.indent_to_tag(['if', 'unless', 'each']);
      parser_token.indent_content = true;
      // Don't add a newline if opening {{#if}} tag is on the current line
      var foundIfOnCurrentLine = printer.current_line_has_match(/{{#if/);
      if (!foundIfOnCurrentLine) {
        printer.print_newline(false);
      }
    }

    // Don't add a newline before elements that should remain where they are.
    if (parser_token.tag_name === '!--' && last_token.type === TOKEN$4.TAG_CLOSE &&
      last_tag_token.is_end_tag && parser_token.text.indexOf('\n') === -1) ; else {
      if (!(parser_token.is_inline_element || parser_token.is_unformatted)) {
        printer.print_newline(false);
      }
      this._calcluate_parent_multiline(printer, parser_token);
    }
  } else if (parser_token.is_end_tag) { //this tag is a double tag so check for tag-ending
    var do_end_expand = false;

    // deciding whether a block is multiline should not be this hard
    do_end_expand = parser_token.start_tag_token && parser_token.start_tag_token.multiline_content;
    do_end_expand = do_end_expand || (!parser_token.is_inline_element &&
      !(last_tag_token.is_inline_element || last_tag_token.is_unformatted) &&
      !(last_token.type === TOKEN$4.TAG_CLOSE && parser_token.start_tag_token === last_tag_token) &&
      last_token.type !== 'TK_CONTENT'
    );

    if (parser_token.is_content_unformatted || parser_token.is_unformatted) {
      do_end_expand = false;
    }

    if (do_end_expand) {
      printer.print_newline(false);
    }
  } else { // it's a start-tag
    parser_token.indent_content = !parser_token.custom_beautifier_name;

    if (parser_token.tag_start_char === '<') {
      if (parser_token.tag_name === 'html') {
        parser_token.indent_content = this._options.indent_inner_html;
      } else if (parser_token.tag_name === 'head') {
        parser_token.indent_content = this._options.indent_head_inner_html;
      } else if (parser_token.tag_name === 'body') {
        parser_token.indent_content = this._options.indent_body_inner_html;
      }
    }

    if (!(parser_token.is_inline_element || parser_token.is_unformatted) &&
      (last_token.type !== 'TK_CONTENT' || parser_token.is_content_unformatted)) {
      printer.print_newline(false);
    }

    this._calcluate_parent_multiline(printer, parser_token);
  }
};

Beautifier$4.prototype._calcluate_parent_multiline = function(printer, parser_token) {
  if (parser_token.parent && printer._output.just_added_newline() &&
    !((parser_token.is_inline_element || parser_token.is_unformatted) && parser_token.parent.is_inline_element)) {
    parser_token.parent.multiline_content = true;
  }
};

//To be used for <p> tag special case:
var p_closers = ['address', 'article', 'aside', 'blockquote', 'details', 'div', 'dl', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hr', 'main', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul'];
var p_parent_excludes = ['a', 'audio', 'del', 'ins', 'map', 'noscript', 'video'];

Beautifier$4.prototype._do_optional_end_element = function(parser_token) {
  var result = null;
  // NOTE: cases of "if there is no more content in the parent element"
  // are handled automatically by the beautifier.
  // It assumes parent or ancestor close tag closes all children.
  // https://www.w3.org/TR/html5/syntax.html#optional-tags
  if (parser_token.is_empty_element || !parser_token.is_start_tag || !parser_token.parent) {
    return;

  }

  if (parser_token.tag_name === 'body') {
    // A head elements end tag may be omitted if the head element is not immediately followed by a space character or a comment.
    result = result || this._tag_stack.try_pop('head');

    //} else if (parser_token.tag_name === 'body') {
    // DONE: A body elements end tag may be omitted if the body element is not immediately followed by a comment.

  } else if (parser_token.tag_name === 'li') {
    // An li elements end tag may be omitted if the li element is immediately followed by another li element or if there is no more content in the parent element.
    result = result || this._tag_stack.try_pop('li', ['ol', 'ul']);

  } else if (parser_token.tag_name === 'dd' || parser_token.tag_name === 'dt') {
    // A dd elements end tag may be omitted if the dd element is immediately followed by another dd element or a dt element, or if there is no more content in the parent element.
    // A dt elements end tag may be omitted if the dt element is immediately followed by another dt element or a dd element.
    result = result || this._tag_stack.try_pop('dt', ['dl']);
    result = result || this._tag_stack.try_pop('dd', ['dl']);


  } else if (parser_token.parent.tag_name === 'p' && p_closers.indexOf(parser_token.tag_name) !== -1) {
    // IMPORTANT: this else-if works because p_closers has no overlap with any other element we look for in this method
    // check for the parent element is an HTML element that is not an <a>, <audio>, <del>, <ins>, <map>, <noscript>, or <video> element,  or an autonomous custom element.
    // To do this right, this needs to be coded as an inclusion of the inverse of the exclusion above.
    // But to start with (if we ignore "autonomous custom elements") the exclusion would be fine.
    var p_parent = parser_token.parent.parent;
    if (!p_parent || p_parent_excludes.indexOf(p_parent.tag_name) === -1) {
      result = result || this._tag_stack.try_pop('p');
    }
  } else if (parser_token.tag_name === 'rp' || parser_token.tag_name === 'rt') {
    // An rt elements end tag may be omitted if the rt element is immediately followed by an rt or rp element, or if there is no more content in the parent element.
    // An rp elements end tag may be omitted if the rp element is immediately followed by an rt or rp element, or if there is no more content in the parent element.
    result = result || this._tag_stack.try_pop('rt', ['ruby', 'rtc']);
    result = result || this._tag_stack.try_pop('rp', ['ruby', 'rtc']);

  } else if (parser_token.tag_name === 'optgroup') {
    // An optgroup elements end tag may be omitted if the optgroup element is immediately followed by another optgroup element, or if there is no more content in the parent element.
    // An option elements end tag may be omitted if the option element is immediately followed by another option element, or if it is immediately followed by an optgroup element, or if there is no more content in the parent element.
    result = result || this._tag_stack.try_pop('optgroup', ['select']);
    //result = result || this._tag_stack.try_pop('option', ['select']);

  } else if (parser_token.tag_name === 'option') {
    // An option elements end tag may be omitted if the option element is immediately followed by another option element, or if it is immediately followed by an optgroup element, or if there is no more content in the parent element.
    result = result || this._tag_stack.try_pop('option', ['select', 'datalist', 'optgroup']);

  } else if (parser_token.tag_name === 'colgroup') {
    // DONE: A colgroup elements end tag may be omitted if the colgroup element is not immediately followed by a space character or a comment.
    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.
    result = result || this._tag_stack.try_pop('caption', ['table']);

  } else if (parser_token.tag_name === 'thead') {
    // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.
    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.
    result = result || this._tag_stack.try_pop('caption', ['table']);
    result = result || this._tag_stack.try_pop('colgroup', ['table']);

    //} else if (parser_token.tag_name === 'caption') {
    // DONE: A caption elements end tag may be omitted if the caption element is not immediately followed by a space character or a comment.

  } else if (parser_token.tag_name === 'tbody' || parser_token.tag_name === 'tfoot') {
    // A thead elements end tag may be omitted if the thead element is immediately followed by a tbody or tfoot element.
    // A tbody elements end tag may be omitted if the tbody element is immediately followed by a tbody or tfoot element, or if there is no more content in the parent element.
    // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.
    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.
    result = result || this._tag_stack.try_pop('caption', ['table']);
    result = result || this._tag_stack.try_pop('colgroup', ['table']);
    result = result || this._tag_stack.try_pop('thead', ['table']);
    result = result || this._tag_stack.try_pop('tbody', ['table']);

    //} else if (parser_token.tag_name === 'tfoot') {
    // DONE: A tfoot elements end tag may be omitted if there is no more content in the parent element.

  } else if (parser_token.tag_name === 'tr') {
    // A tr elements end tag may be omitted if the tr element is immediately followed by another tr element, or if there is no more content in the parent element.
    // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.
    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.
    result = result || this._tag_stack.try_pop('caption', ['table']);
    result = result || this._tag_stack.try_pop('colgroup', ['table']);
    result = result || this._tag_stack.try_pop('tr', ['table', 'thead', 'tbody', 'tfoot']);

  } else if (parser_token.tag_name === 'th' || parser_token.tag_name === 'td') {
    // A td elements end tag may be omitted if the td element is immediately followed by a td or th element, or if there is no more content in the parent element.
    // A th elements end tag may be omitted if the th element is immediately followed by a td or th element, or if there is no more content in the parent element.
    result = result || this._tag_stack.try_pop('td', ['table', 'thead', 'tbody', 'tfoot', 'tr']);
    result = result || this._tag_stack.try_pop('th', ['table', 'thead', 'tbody', 'tfoot', 'tr']);
  }

  // Start element omission not handled currently
  // A head elements start tag may be omitted if the element is empty, or if the first thing inside the head element is an element.
  // A tbody elements start tag may be omitted if the first thing inside the tbody element is a tr element, and if the element is not immediately preceded by a tbody, thead, or tfoot element whose end tag has been omitted. (It cant be omitted if the element is empty.)
  // A colgroup elements start tag may be omitted if the first thing inside the colgroup element is a col element, and if the element is not immediately preceded by another colgroup element whose end tag has been omitted. (It cant be omitted if the element is empty.)

  // Fix up the parent of the parser token
  parser_token.parent = this._tag_stack.get_parser_token();

  return result;
};

var Beautifier_1$2 = Beautifier$4;

var beautifier$2 = {
	Beautifier: Beautifier_1$2
};

var Beautifier$5 = beautifier$2.Beautifier,
  Options$9 = options$3.Options;

function style_html(html_source, options, js_beautify, css_beautify) {
  var beautifier = new Beautifier$5(html_source, options, js_beautify, css_beautify);
  return beautifier.beautify();
}

var html = style_html;
var defaultOptions$2 = function() {
  return new Options$9();
};
html.defaultOptions = defaultOptions$2;

function style_html$1(html_source, options, js, css$1) {
  js = js || javascript;
  css$1 = css$1 || css;
  return html(html_source, options, js, css$1);
}
style_html$1.defaultOptions = html.defaultOptions;

var js$1 = javascript;
var css$1 = css;
var html$1 = style_html$1;

var src = {
	js: js$1,
	css: css$1,
	html: html$1
};

var js$2 = createCommonjsModule(function (module) {

/**
The following batches are equivalent:

var beautify_js = require('js-beautify');
var beautify_js = require('js-beautify').js;
var beautify_js = require('js-beautify').js_beautify;

var beautify_css = require('js-beautify').css;
var beautify_css = require('js-beautify').css_beautify;

var beautify_html = require('js-beautify').html;
var beautify_html = require('js-beautify').html_beautify;

All methods returned accept two arguments, the source string and an options object.
**/

function get_beautify(js_beautify, css_beautify, html_beautify) {
  // the default is js
  var beautify = function(src, config) {
    return js_beautify.js_beautify(src, config);
  };

  // short aliases
  beautify.js = js_beautify.js_beautify;
  beautify.css = css_beautify.css_beautify;
  beautify.html = html_beautify.html_beautify;

  // legacy aliases
  beautify.js_beautify = js_beautify.js_beautify;
  beautify.css_beautify = css_beautify.css_beautify;
  beautify.html_beautify = html_beautify.html_beautify;

  return beautify;
}

{
  (function(mod) {
    var beautifier = src;
    beautifier.js_beautify = beautifier.js;
    beautifier.css_beautify = beautifier.css;
    beautifier.html_beautify = beautifier.html;

    mod.exports = get_beautify(beautifier, beautifier, beautifier);

  })(module);
}
});

function deepFreeze(obj) {
    if (obj instanceof Map) {
        obj.clear = obj.delete = obj.set = function () {
            throw new Error('map is read-only');
        };
    } else if (obj instanceof Set) {
        obj.add = obj.clear = obj.delete = function () {
            throw new Error('set is read-only');
        };
    }

    // Freeze self
    Object.freeze(obj);

    Object.getOwnPropertyNames(obj).forEach(function (name) {
        var prop = obj[name];

        // Freeze prop if it is an object
        if (typeof prop == 'object' && !Object.isFrozen(prop)) {
            deepFreeze(prop);
        }
    });

    return obj;
}

var deepFreezeEs6 = deepFreeze;
var _default = deepFreeze;
deepFreezeEs6.default = _default;

class Response {
  /**
   * @param {CompiledMode} mode
   */
  constructor(mode) {
    // eslint-disable-next-line no-undefined
    if (mode.data === undefined) mode.data = {};

    this.data = mode.data;
  }

  ignoreMatch() {
    this.ignore = true;
  }
}

/**
 * @param {string} value
 * @returns {string}
 */
function escapeHTML(value) {
  return value
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;');
}

/**
 * performs a shallow merge of multiple objects into one
 *
 * @template T
 * @param {T} original
 * @param {Record<string,any>[]} objects
 * @returns {T} a single new object
 */
function inherit(original, ...objects) {
  /** @type Record<string,any> */
  const result = Object.create(null);

  for (const key in original) {
    result[key] = original[key];
  }
  objects.forEach(function(obj) {
    for (const key in obj) {
      result[key] = obj[key];
    }
  });
  return /** @type {T} */ (result);
}

/**
 * @typedef {object} Renderer
 * @property {(text: string) => void} addText
 * @property {(node: Node) => void} openNode
 * @property {(node: Node) => void} closeNode
 * @property {() => string} value
 */

/** @typedef {{kind?: string, sublanguage?: boolean}} Node */
/** @typedef {{walk: (r: Renderer) => void}} Tree */
/** */

const SPAN_CLOSE = '</span>';

/**
 * Determines if a node needs to be wrapped in <span>
 *
 * @param {Node} node */
const emitsWrappingTags = (node) => {
  return !!node.kind;
};

/** @type {Renderer} */
class HTMLRenderer {
  /**
   * Creates a new HTMLRenderer
   *
   * @param {Tree} parseTree - the parse tree (must support `walk` API)
   * @param {{classPrefix: string}} options
   */
  constructor(parseTree, options) {
    this.buffer = "";
    this.classPrefix = options.classPrefix;
    parseTree.walk(this);
  }

  /**
   * Adds texts to the output stream
   *
   * @param {string} text */
  addText(text) {
    this.buffer += escapeHTML(text);
  }

  /**
   * Adds a node open to the output stream (if needed)
   *
   * @param {Node} node */
  openNode(node) {
    if (!emitsWrappingTags(node)) return;

    let className = node.kind;
    if (!node.sublanguage) {
      className = `${this.classPrefix}${className}`;
    }
    this.span(className);
  }

  /**
   * Adds a node close to the output stream (if needed)
   *
   * @param {Node} node */
  closeNode(node) {
    if (!emitsWrappingTags(node)) return;

    this.buffer += SPAN_CLOSE;
  }

  /**
   * returns the accumulated buffer
  */
  value() {
    return this.buffer;
  }

  // helpers

  /**
   * Builds a span element
   *
   * @param {string} className */
  span(className) {
    this.buffer += `<span class="${className}">`;
  }
}

/** @typedef {{kind?: string, sublanguage?: boolean, children: Node[]} | string} Node */
/** @typedef {{kind?: string, sublanguage?: boolean, children: Node[]} } DataNode */
/**  */

class TokenTree {
  constructor() {
    /** @type DataNode */
    this.rootNode = { children: [] };
    this.stack = [this.rootNode];
  }

  get top() {
    return this.stack[this.stack.length - 1];
  }

  get root() { return this.rootNode; }

  /** @param {Node} node */
  add(node) {
    this.top.children.push(node);
  }

  /** @param {string} kind */
  openNode(kind) {
    /** @type Node */
    const node = { kind, children: [] };
    this.add(node);
    this.stack.push(node);
  }

  closeNode() {
    if (this.stack.length > 1) {
      return this.stack.pop();
    }
    // eslint-disable-next-line no-undefined
    return undefined;
  }

  closeAllNodes() {
    while (this.closeNode());
  }

  toJSON() {
    return JSON.stringify(this.rootNode, null, 4);
  }

  /**
   * @typedef { import("./html_renderer").Renderer } Renderer
   * @param {Renderer} builder
   */
  walk(builder) {
    // this does not
    return this.constructor._walk(builder, this.rootNode);
    // this works
    // return TokenTree._walk(builder, this.rootNode);
  }

  /**
   * @param {Renderer} builder
   * @param {Node} node
   */
  static _walk(builder, node) {
    if (typeof node === "string") {
      builder.addText(node);
    } else if (node.children) {
      builder.openNode(node);
      node.children.forEach((child) => this._walk(builder, child));
      builder.closeNode(node);
    }
    return builder;
  }

  /**
   * @param {Node} node
   */
  static _collapse(node) {
    if (typeof node === "string") return;
    if (!node.children) return;

    if (node.children.every(el => typeof el === "string")) {
      // node.text = node.children.join("");
      // delete node.children;
      node.children = [node.children.join("")];
    } else {
      node.children.forEach((child) => {
        TokenTree._collapse(child);
      });
    }
  }
}

/**
  Currently this is all private API, but this is the minimal API necessary
  that an Emitter must implement to fully support the parser.

  Minimal interface:

  - addKeyword(text, kind)
  - addText(text)
  - addSublanguage(emitter, subLanguageName)
  - finalize()
  - openNode(kind)
  - closeNode()
  - closeAllNodes()
  - toHTML()

*/

/**
 * @implements {Emitter}
 */
class TokenTreeEmitter extends TokenTree {
  /**
   * @param {*} options
   */
  constructor(options) {
    super();
    this.options = options;
  }

  /**
   * @param {string} text
   * @param {string} kind
   */
  addKeyword(text, kind) {
    if (text === "") { return; }

    this.openNode(kind);
    this.addText(text);
    this.closeNode();
  }

  /**
   * @param {string} text
   */
  addText(text) {
    if (text === "") { return; }

    this.add(text);
  }

  /**
   * @param {Emitter & {root: DataNode}} emitter
   * @param {string} name
   */
  addSublanguage(emitter, name) {
    /** @type DataNode */
    const node = emitter.root;
    node.kind = name;
    node.sublanguage = true;
    this.add(node);
  }

  toHTML() {
    const renderer = new HTMLRenderer(this, this.options);
    return renderer.value();
  }

  finalize() {
    return true;
  }
}

/**
 * @param {string} value
 * @returns {RegExp}
 * */
function escape(value) {
  return new RegExp(value.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&'), 'm');
}

/**
 * @param {RegExp | string } re
 * @returns {string}
 */
function source(re) {
  if (!re) return null;
  if (typeof re === "string") return re;

  return re.source;
}

/**
 * @param {...(RegExp | string) } args
 * @returns {string}
 */
function concat(...args) {
  const joined = args.map((x) => source(x)).join("");
  return joined;
}

/**
 * Any of the passed expresssions may match
 *
 * Creates a huge this | this | that | that match
 * @param {(RegExp | string)[] } args
 * @returns {string}
 */
function either(...args) {
  const joined = '(' + args.map((x) => source(x)).join("|") + ")";
  return joined;
}

/**
 * @param {RegExp} re
 * @returns {number}
 */
function countMatchGroups(re) {
  return (new RegExp(re.toString() + '|')).exec('').length - 1;
}

/**
 * Does lexeme start with a regular expression match at the beginning
 * @param {RegExp} re
 * @param {string} lexeme
 */
function startsWith(re, lexeme) {
  const match = re && re.exec(lexeme);
  return match && match.index === 0;
}

// join logically computes regexps.join(separator), but fixes the
// backreferences so they continue to match.
// it also places each individual regular expression into it's own
// match group, keeping track of the sequencing of those match groups
// is currently an exercise for the caller. :-)
/**
 * @param {(string | RegExp)[]} regexps
 * @param {string} separator
 * @returns {string}
 */
function join(regexps, separator = "|") {
  // backreferenceRe matches an open parenthesis or backreference. To avoid
  // an incorrect parse, it additionally matches the following:
  // - [...] elements, where the meaning of parentheses and escapes change
  // - other escape sequences, so we do not misparse escape sequences as
  //   interesting elements
  // - non-matching or lookahead parentheses, which do not capture. These
  //   follow the '(' with a '?'.
  const backreferenceRe = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
  let numCaptures = 0;
  let ret = '';
  for (let i = 0; i < regexps.length; i++) {
    numCaptures += 1;
    const offset = numCaptures;
    let re = source(regexps[i]);
    if (i > 0) {
      ret += separator;
    }
    ret += "(";
    while (re.length > 0) {
      const match = backreferenceRe.exec(re);
      if (match == null) {
        ret += re;
        break;
      }
      ret += re.substring(0, match.index);
      re = re.substring(match.index + match[0].length);
      if (match[0][0] === '\\' && match[1]) {
        // Adjust the backreference.
        ret += '\\' + String(Number(match[1]) + offset);
      } else {
        ret += match[0];
        if (match[0] === '(') {
          numCaptures++;
        }
      }
    }
    ret += ")";
  }
  return ret;
}

// Common regexps
const MATCH_NOTHING_RE = /\b\B/;
const IDENT_RE = '[a-zA-Z]\\w*';
const UNDERSCORE_IDENT_RE = '[a-zA-Z_]\\w*';
const NUMBER_RE = '\\b\\d+(\\.\\d+)?';
const C_NUMBER_RE = '(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)'; // 0x..., 0..., decimal, float
const BINARY_NUMBER_RE = '\\b(0b[01]+)'; // 0b...
const RE_STARTERS_RE = '!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~';

/**
* @param { Partial<Mode> & {binary?: string | RegExp} } opts
*/
const SHEBANG = (opts = {}) => {
  const beginShebang = /^#![ ]*\//;
  if (opts.binary) {
    opts.begin = concat(
      beginShebang,
      /.*\b/,
      opts.binary,
      /\b.*/);
  }
  return inherit({
    className: 'meta',
    begin: beginShebang,
    end: /$/,
    relevance: 0,
    /** @type {ModeCallback} */
    "on:begin": (m, resp) => {
      if (m.index !== 0) resp.ignoreMatch();
    }
  }, opts);
};

// Common modes
const BACKSLASH_ESCAPE = {
  begin: '\\\\[\\s\\S]', relevance: 0
};
const APOS_STRING_MODE = {
  className: 'string',
  begin: '\'',
  end: '\'',
  illegal: '\\n',
  contains: [BACKSLASH_ESCAPE]
};
const QUOTE_STRING_MODE = {
  className: 'string',
  begin: '"',
  end: '"',
  illegal: '\\n',
  contains: [BACKSLASH_ESCAPE]
};
const PHRASAL_WORDS_MODE = {
  begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
};
/**
 * Creates a comment mode
 *
 * @param {string | RegExp} begin
 * @param {string | RegExp} end
 * @param {Mode | {}} [modeOptions]
 * @returns {Partial<Mode>}
 */
const COMMENT = function(begin, end, modeOptions = {}) {
  const mode = inherit(
    {
      className: 'comment',
      begin,
      end,
      contains: []
    },
    modeOptions
  );
  mode.contains.push(PHRASAL_WORDS_MODE);
  mode.contains.push({
    className: 'doctag',
    begin: '(?:TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):',
    relevance: 0
  });
  return mode;
};
const C_LINE_COMMENT_MODE = COMMENT('//', '$');
const C_BLOCK_COMMENT_MODE = COMMENT('/\\*', '\\*/');
const HASH_COMMENT_MODE = COMMENT('#', '$');
const NUMBER_MODE = {
  className: 'number',
  begin: NUMBER_RE,
  relevance: 0
};
const C_NUMBER_MODE = {
  className: 'number',
  begin: C_NUMBER_RE,
  relevance: 0
};
const BINARY_NUMBER_MODE = {
  className: 'number',
  begin: BINARY_NUMBER_RE,
  relevance: 0
};
const CSS_NUMBER_MODE = {
  className: 'number',
  begin: NUMBER_RE + '(' +
    '%|em|ex|ch|rem' +
    '|vw|vh|vmin|vmax' +
    '|cm|mm|in|pt|pc|px' +
    '|deg|grad|rad|turn' +
    '|s|ms' +
    '|Hz|kHz' +
    '|dpi|dpcm|dppx' +
    ')?',
  relevance: 0
};
const REGEXP_MODE = {
  // this outer rule makes sure we actually have a WHOLE regex and not simply
  // an expression such as:
  //
  //     3 / something
  //
  // (which will then blow up when regex's `illegal` sees the newline)
  begin: /(?=\/[^/\n]*\/)/,
  contains: [{
    className: 'regexp',
    begin: /\//,
    end: /\/[gimuy]*/,
    illegal: /\n/,
    contains: [
      BACKSLASH_ESCAPE,
      {
        begin: /\[/,
        end: /\]/,
        relevance: 0,
        contains: [BACKSLASH_ESCAPE]
      }
    ]
  }]
};
const TITLE_MODE = {
  className: 'title',
  begin: IDENT_RE,
  relevance: 0
};
const UNDERSCORE_TITLE_MODE = {
  className: 'title',
  begin: UNDERSCORE_IDENT_RE,
  relevance: 0
};
const METHOD_GUARD = {
  // excludes method names from keyword processing
  begin: '\\.\\s*' + UNDERSCORE_IDENT_RE,
  relevance: 0
};

/**
 * Adds end same as begin mechanics to a mode
 *
 * Your mode must include at least a single () match group as that first match
 * group is what is used for comparison
 * @param {Partial<Mode>} mode
 */
const END_SAME_AS_BEGIN = function(mode) {
  return Object.assign(mode,
    {
      /** @type {ModeCallback} */
      'on:begin': (m, resp) => { resp.data._beginMatch = m[1]; },
      /** @type {ModeCallback} */
      'on:end': (m, resp) => { if (resp.data._beginMatch !== m[1]) resp.ignoreMatch(); }
    });
};

var MODES = /*#__PURE__*/Object.freeze({
    __proto__: null,
    MATCH_NOTHING_RE: MATCH_NOTHING_RE,
    IDENT_RE: IDENT_RE,
    UNDERSCORE_IDENT_RE: UNDERSCORE_IDENT_RE,
    NUMBER_RE: NUMBER_RE,
    C_NUMBER_RE: C_NUMBER_RE,
    BINARY_NUMBER_RE: BINARY_NUMBER_RE,
    RE_STARTERS_RE: RE_STARTERS_RE,
    SHEBANG: SHEBANG,
    BACKSLASH_ESCAPE: BACKSLASH_ESCAPE,
    APOS_STRING_MODE: APOS_STRING_MODE,
    QUOTE_STRING_MODE: QUOTE_STRING_MODE,
    PHRASAL_WORDS_MODE: PHRASAL_WORDS_MODE,
    COMMENT: COMMENT,
    C_LINE_COMMENT_MODE: C_LINE_COMMENT_MODE,
    C_BLOCK_COMMENT_MODE: C_BLOCK_COMMENT_MODE,
    HASH_COMMENT_MODE: HASH_COMMENT_MODE,
    NUMBER_MODE: NUMBER_MODE,
    C_NUMBER_MODE: C_NUMBER_MODE,
    BINARY_NUMBER_MODE: BINARY_NUMBER_MODE,
    CSS_NUMBER_MODE: CSS_NUMBER_MODE,
    REGEXP_MODE: REGEXP_MODE,
    TITLE_MODE: TITLE_MODE,
    UNDERSCORE_TITLE_MODE: UNDERSCORE_TITLE_MODE,
    METHOD_GUARD: METHOD_GUARD,
    END_SAME_AS_BEGIN: END_SAME_AS_BEGIN
});

// Grammar extensions / plugins
// See: https://github.com/highlightjs/highlight.js/issues/2833

// Grammar extensions allow "syntactic sugar" to be added to the grammar modes
// without requiring any underlying changes to the compiler internals.

// `compileMatch` being the perfect small example of now allowing a grammar
// author to write `match` when they desire to match a single expression rather
// than being forced to use `begin`.  The extension then just moves `match` into
// `begin` when it runs.  Ie, no features have been added, but we've just made
// the experience of writing (and reading grammars) a little bit nicer.

// ------

// TODO: We need negative look-behind support to do this properly
/**
 * Skip a match if it has a preceding dot
 *
 * This is used for `beginKeywords` to prevent matching expressions such as
 * `bob.keyword.do()`. The mode compiler automatically wires this up as a
 * special _internal_ 'on:begin' callback for modes with `beginKeywords`
 * @param {RegExpMatchArray} match
 * @param {CallbackResponse} response
 */
function skipIfhasPrecedingDot(match, response) {
  const before = match.input[match.index - 1];
  if (before === ".") {
    response.ignoreMatch();
  }
}


/**
 * `beginKeywords` syntactic sugar
 * @type {CompilerExt}
 */
function beginKeywords(mode, parent) {
  if (!parent) return;
  if (!mode.beginKeywords) return;

  // for languages with keywords that include non-word characters checking for
  // a word boundary is not sufficient, so instead we check for a word boundary
  // or whitespace - this does no harm in any case since our keyword engine
  // doesn't allow spaces in keywords anyways and we still check for the boundary
  // first
  mode.begin = '\\b(' + mode.beginKeywords.split(' ').join('|') + ')(?!\\.)(?=\\b|\\s)';
  mode.__beforeBegin = skipIfhasPrecedingDot;
  mode.keywords = mode.keywords || mode.beginKeywords;
  delete mode.beginKeywords;

  // prevents double relevance, the keywords themselves provide
  // relevance, the mode doesn't need to double it
  // eslint-disable-next-line no-undefined
  if (mode.relevance === undefined) mode.relevance = 0;
}

/**
 * Allow `illegal` to contain an array of illegal values
 * @type {CompilerExt}
 */
function compileIllegal(mode, _parent) {
  if (!Array.isArray(mode.illegal)) return;

  mode.illegal = either(...mode.illegal);
}

/**
 * `match` to match a single expression for readability
 * @type {CompilerExt}
 */
function compileMatch(mode, _parent) {
  if (!mode.match) return;
  if (mode.begin || mode.end) throw new Error("begin & end are not supported with match");

  mode.begin = mode.match;
  delete mode.match;
}

/**
 * provides the default 1 relevance to all modes
 * @type {CompilerExt}
 */
function compileRelevance(mode, _parent) {
  // eslint-disable-next-line no-undefined
  if (mode.relevance === undefined) mode.relevance = 1;
}

// keywords that should have no default relevance value
const COMMON_KEYWORDS = [
  'of',
  'and',
  'for',
  'in',
  'not',
  'or',
  'if',
  'then',
  'parent', // common variable name
  'list', // common variable name
  'value' // common variable name
];

const DEFAULT_KEYWORD_CLASSNAME = "keyword";

/**
 * Given raw keywords from a language definition, compile them.
 *
 * @param {string | Record<string,string|string[]> | Array<string>} rawKeywords
 * @param {boolean} caseInsensitive
 */
function compileKeywords(rawKeywords, caseInsensitive, className = DEFAULT_KEYWORD_CLASSNAME) {
  /** @type KeywordDict */
  const compiledKeywords = {};

  // input can be a string of keywords, an array of keywords, or a object with
  // named keys representing className (which can then point to a string or array)
  if (typeof rawKeywords === 'string') {
    compileList(className, rawKeywords.split(" "));
  } else if (Array.isArray(rawKeywords)) {
    compileList(className, rawKeywords);
  } else {
    Object.keys(rawKeywords).forEach(function(className) {
      // collapse all our objects back into the parent object
      Object.assign(
        compiledKeywords,
        compileKeywords(rawKeywords[className], caseInsensitive, className)
      );
    });
  }
  return compiledKeywords;

  // ---

  /**
   * Compiles an individual list of keywords
   *
   * Ex: "for if when while|5"
   *
   * @param {string} className
   * @param {Array<string>} keywordList
   */
  function compileList(className, keywordList) {
    if (caseInsensitive) {
      keywordList = keywordList.map(x => x.toLowerCase());
    }
    keywordList.forEach(function(keyword) {
      const pair = keyword.split('|');
      compiledKeywords[pair[0]] = [className, scoreForKeyword(pair[0], pair[1])];
    });
  }
}

/**
 * Returns the proper score for a given keyword
 *
 * Also takes into account comment keywords, which will be scored 0 UNLESS
 * another score has been manually assigned.
 * @param {string} keyword
 * @param {string} [providedScore]
 */
function scoreForKeyword(keyword, providedScore) {
  // manual scores always win over common keywords
  // so you can force a score of 1 if you really insist
  if (providedScore) {
    return Number(providedScore);
  }

  return commonKeyword(keyword) ? 0 : 1;
}

/**
 * Determines if a given keyword is common or not
 *
 * @param {string} keyword */
function commonKeyword(keyword) {
  return COMMON_KEYWORDS.includes(keyword.toLowerCase());
}

// compilation

/**
 * Compiles a language definition result
 *
 * Given the raw result of a language definition (Language), compiles this so
 * that it is ready for highlighting code.
 * @param {Language} language
 * @param {{plugins: HLJSPlugin[]}} opts
 * @returns {CompiledLanguage}
 */
function compileLanguage(language, { plugins }) {
  /**
   * Builds a regex with the case sensativility of the current language
   *
   * @param {RegExp | string} value
   * @param {boolean} [global]
   */
  function langRe(value, global) {
    return new RegExp(
      source(value),
      'm' + (language.case_insensitive ? 'i' : '') + (global ? 'g' : '')
    );
  }

  /**
    Stores multiple regular expressions and allows you to quickly search for
    them all in a string simultaneously - returning the first match.  It does
    this by creating a huge (a|b|c) regex - each individual item wrapped with ()
    and joined by `|` - using match groups to track position.  When a match is
    found checking which position in the array has content allows us to figure
    out which of the original regexes / match groups triggered the match.

    The match object itself (the result of `Regex.exec`) is returned but also
    enhanced by merging in any meta-data that was registered with the regex.
    This is how we keep track of which mode matched, and what type of rule
    (`illegal`, `begin`, end, etc).
  */
  class MultiRegex {
    constructor() {
      this.matchIndexes = {};
      // @ts-ignore
      this.regexes = [];
      this.matchAt = 1;
      this.position = 0;
    }

    // @ts-ignore
    addRule(re, opts) {
      opts.position = this.position++;
      // @ts-ignore
      this.matchIndexes[this.matchAt] = opts;
      this.regexes.push([opts, re]);
      this.matchAt += countMatchGroups(re) + 1;
    }

    compile() {
      if (this.regexes.length === 0) {
        // avoids the need to check length every time exec is called
        // @ts-ignore
        this.exec = () => null;
      }
      const terminators = this.regexes.map(el => el[1]);
      this.matcherRe = langRe(join(terminators), true);
      this.lastIndex = 0;
    }

    /** @param {string} s */
    exec(s) {
      this.matcherRe.lastIndex = this.lastIndex;
      const match = this.matcherRe.exec(s);
      if (!match) { return null; }

      // eslint-disable-next-line no-undefined
      const i = match.findIndex((el, i) => i > 0 && el !== undefined);
      // @ts-ignore
      const matchData = this.matchIndexes[i];
      // trim off any earlier non-relevant match groups (ie, the other regex
      // match groups that make up the multi-matcher)
      match.splice(0, i);

      return Object.assign(match, matchData);
    }
  }

  /*
    Created to solve the key deficiently with MultiRegex - there is no way to
    test for multiple matches at a single location.  Why would we need to do
    that?  In the future a more dynamic engine will allow certain matches to be
    ignored.  An example: if we matched say the 3rd regex in a large group but
    decided to ignore it - we'd need to started testing again at the 4th
    regex... but MultiRegex itself gives us no real way to do that.

    So what this class creates MultiRegexs on the fly for whatever search
    position they are needed.

    NOTE: These additional MultiRegex objects are created dynamically.  For most
    grammars most of the time we will never actually need anything more than the
    first MultiRegex - so this shouldn't have too much overhead.

    Say this is our search group, and we match regex3, but wish to ignore it.

      regex1 | regex2 | regex3 | regex4 | regex5    ' ie, startAt = 0

    What we need is a new MultiRegex that only includes the remaining
    possibilities:

      regex4 | regex5                               ' ie, startAt = 3

    This class wraps all that complexity up in a simple API... `startAt` decides
    where in the array of expressions to start doing the matching. It
    auto-increments, so if a match is found at position 2, then startAt will be
    set to 3.  If the end is reached startAt will return to 0.

    MOST of the time the parser will be setting startAt manually to 0.
  */
  class ResumableMultiRegex {
    constructor() {
      // @ts-ignore
      this.rules = [];
      // @ts-ignore
      this.multiRegexes = [];
      this.count = 0;

      this.lastIndex = 0;
      this.regexIndex = 0;
    }

    // @ts-ignore
    getMatcher(index) {
      if (this.multiRegexes[index]) return this.multiRegexes[index];

      const matcher = new MultiRegex();
      this.rules.slice(index).forEach(([re, opts]) => matcher.addRule(re, opts));
      matcher.compile();
      this.multiRegexes[index] = matcher;
      return matcher;
    }

    resumingScanAtSamePosition() {
      return this.regexIndex !== 0;
    }

    considerAll() {
      this.regexIndex = 0;
    }

    // @ts-ignore
    addRule(re, opts) {
      this.rules.push([re, opts]);
      if (opts.type === "begin") this.count++;
    }

    /** @param {string} s */
    exec(s) {
      const m = this.getMatcher(this.regexIndex);
      m.lastIndex = this.lastIndex;
      let result = m.exec(s);

      // The following is because we have no easy way to say "resume scanning at the
      // existing position but also skip the current rule ONLY". What happens is
      // all prior rules are also skipped which can result in matching the wrong
      // thing. Example of matching "booger":

      // our matcher is [string, "booger", number]
      //
      // ....booger....

      // if "booger" is ignored then we'd really need a regex to scan from the
      // SAME position for only: [string, number] but ignoring "booger" (if it
      // was the first match), a simple resume would scan ahead who knows how
      // far looking only for "number", ignoring potential string matches (or
      // future "booger" matches that might be valid.)

      // So what we do: We execute two matchers, one resuming at the same
      // position, but the second full matcher starting at the position after:

      //     /--- resume first regex match here (for [number])
      //     |/---- full match here for [string, "booger", number]
      //     vv
      // ....booger....

      // Which ever results in a match first is then used. So this 3-4 step
      // process essentially allows us to say "match at this position, excluding
      // a prior rule that was ignored".
      //
      // 1. Match "booger" first, ignore. Also proves that [string] does non match.
      // 2. Resume matching for [number]
      // 3. Match at index + 1 for [string, "booger", number]
      // 4. If #2 and #3 result in matches, which came first?
      if (this.resumingScanAtSamePosition()) {
        if (result && result.index === this.lastIndex) ; else { // use the second matcher result
          const m2 = this.getMatcher(0);
          m2.lastIndex = this.lastIndex + 1;
          result = m2.exec(s);
        }
      }

      if (result) {
        this.regexIndex += result.position + 1;
        if (this.regexIndex === this.count) {
          // wrap-around to considering all matches again
          this.considerAll();
        }
      }

      return result;
    }
  }

  /**
   * Given a mode, builds a huge ResumableMultiRegex that can be used to walk
   * the content and find matches.
   *
   * @param {CompiledMode} mode
   * @returns {ResumableMultiRegex}
   */
  function buildModeRegex(mode) {
    const mm = new ResumableMultiRegex();

    mode.contains.forEach(term => mm.addRule(term.begin, { rule: term, type: "begin" }));

    if (mode.terminatorEnd) {
      mm.addRule(mode.terminatorEnd, { type: "end" });
    }
    if (mode.illegal) {
      mm.addRule(mode.illegal, { type: "illegal" });
    }

    return mm;
  }

  /** skip vs abort vs ignore
   *
   * @skip   - The mode is still entered and exited normally (and contains rules apply),
   *           but all content is held and added to the parent buffer rather than being
   *           output when the mode ends.  Mostly used with `sublanguage` to build up
   *           a single large buffer than can be parsed by sublanguage.
   *
   *             - The mode begin ands ends normally.
   *             - Content matched is added to the parent mode buffer.
   *             - The parser cursor is moved forward normally.
   *
   * @abort  - A hack placeholder until we have ignore.  Aborts the mode (as if it
   *           never matched) but DOES NOT continue to match subsequent `contains`
   *           modes.  Abort is bad/suboptimal because it can result in modes
   *           farther down not getting applied because an earlier rule eats the
   *           content but then aborts.
   *
   *             - The mode does not begin.
   *             - Content matched by `begin` is added to the mode buffer.
   *             - The parser cursor is moved forward accordingly.
   *
   * @ignore - Ignores the mode (as if it never matched) and continues to match any
   *           subsequent `contains` modes.  Ignore isn't technically possible with
   *           the current parser implementation.
   *
   *             - The mode does not begin.
   *             - Content matched by `begin` is ignored.
   *             - The parser cursor is not moved forward.
   */

  /**
   * Compiles an individual mode
   *
   * This can raise an error if the mode contains certain detectable known logic
   * issues.
   * @param {Mode} mode
   * @param {CompiledMode | null} [parent]
   * @returns {CompiledMode | never}
   */
  function compileMode(mode, parent) {
    const cmode = /** @type CompiledMode */ (mode);
    if (mode.compiled) return cmode;

    [
      // do this early so compiler extensions generally don't have to worry about
      // the distinction between match/begin
      compileMatch
    ].forEach(ext => ext(mode, parent));

    language.compilerExtensions.forEach(ext => ext(mode, parent));

    // __beforeBegin is considered private API, internal use only
    mode.__beforeBegin = null;

    [
      beginKeywords,
      // do this later so compiler extensions that come earlier have access to the
      // raw array if they wanted to perhaps manipulate it, etc.
      compileIllegal,
      // default to 1 relevance if not specified
      compileRelevance
    ].forEach(ext => ext(mode, parent));

    mode.compiled = true;

    let keywordPattern = null;
    if (typeof mode.keywords === "object") {
      keywordPattern = mode.keywords.$pattern;
      delete mode.keywords.$pattern;
    }

    if (mode.keywords) {
      mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);
    }

    // both are not allowed
    if (mode.lexemes && keywordPattern) {
      throw new Error("ERR: Prefer `keywords.$pattern` to `mode.lexemes`, BOTH are not allowed. (see mode reference) ");
    }

    // `mode.lexemes` was the old standard before we added and now recommend
    // using `keywords.$pattern` to pass the keyword pattern
    keywordPattern = keywordPattern || mode.lexemes || /\w+/;
    cmode.keywordPatternRe = langRe(keywordPattern, true);

    if (parent) {
      if (!mode.begin) mode.begin = /\B|\b/;
      cmode.beginRe = langRe(mode.begin);
      if (mode.endSameAsBegin) mode.end = mode.begin;
      if (!mode.end && !mode.endsWithParent) mode.end = /\B|\b/;
      if (mode.end) cmode.endRe = langRe(mode.end);
      cmode.terminatorEnd = source(mode.end) || '';
      if (mode.endsWithParent && parent.terminatorEnd) {
        cmode.terminatorEnd += (mode.end ? '|' : '') + parent.terminatorEnd;
      }
    }
    if (mode.illegal) cmode.illegalRe = langRe(/** @type {RegExp | string} */ (mode.illegal));
    if (!mode.contains) mode.contains = [];

    mode.contains = [].concat(...mode.contains.map(function(c) {
      return expandOrCloneMode(c === 'self' ? mode : c);
    }));
    mode.contains.forEach(function(c) { compileMode(/** @type Mode */ (c), cmode); });

    if (mode.starts) {
      compileMode(mode.starts, parent);
    }

    cmode.matcher = buildModeRegex(cmode);
    return cmode;
  }

  if (!language.compilerExtensions) language.compilerExtensions = [];

  // self is not valid at the top-level
  if (language.contains && language.contains.includes('self')) {
    throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
  }

  // we need a null object, which inherit will guarantee
  language.classNameAliases = inherit(language.classNameAliases || {});

  return compileMode(/** @type Mode */ (language));
}

/**
 * Determines if a mode has a dependency on it's parent or not
 *
 * If a mode does have a parent dependency then often we need to clone it if
 * it's used in multiple places so that each copy points to the correct parent,
 * where-as modes without a parent can often safely be re-used at the bottom of
 * a mode chain.
 *
 * @param {Mode | null} mode
 * @returns {boolean} - is there a dependency on the parent?
 * */
function dependencyOnParent(mode) {
  if (!mode) return false;

  return mode.endsWithParent || dependencyOnParent(mode.starts);
}

/**
 * Expands a mode or clones it if necessary
 *
 * This is necessary for modes with parental dependenceis (see notes on
 * `dependencyOnParent`) and for nodes that have `variants` - which must then be
 * exploded into their own individual modes at compile time.
 *
 * @param {Mode} mode
 * @returns {Mode | Mode[]}
 * */
function expandOrCloneMode(mode) {
  if (mode.variants && !mode.cachedVariants) {
    mode.cachedVariants = mode.variants.map(function(variant) {
      return inherit(mode, { variants: null }, variant);
    });
  }

  // EXPAND
  // if we have variants then essentially "replace" the mode with the variants
  // this happens in compileMode, where this function is called from
  if (mode.cachedVariants) {
    return mode.cachedVariants;
  }

  // CLONE
  // if we have dependencies on parents then we need a unique
  // instance of ourselves, so we can be reused with many
  // different parents without issue
  if (dependencyOnParent(mode)) {
    return inherit(mode, { starts: mode.starts ? inherit(mode.starts) : null });
  }

  if (Object.isFrozen(mode)) {
    return inherit(mode);
  }

  // no special dependency issues, just return ourselves
  return mode;
}

var version$2 = "10.6.0";

// @ts-nocheck

function hasValueOrEmptyAttribute(value) {
  return Boolean(value || value === "");
}

function BuildVuePlugin(hljs) {
  const Component = {
    props: ["language", "code", "autodetect"],
    data: function() {
      return {
        detectedLanguage: "",
        unknownLanguage: false
      };
    },
    computed: {
      className() {
        if (this.unknownLanguage) return "";

        return "hljs " + this.detectedLanguage;
      },
      highlighted() {
        // no idea what language to use, return raw code
        if (!this.autoDetect && !hljs.getLanguage(this.language)) {
          console.warn(`The language "${this.language}" you specified could not be found.`);
          this.unknownLanguage = true;
          return escapeHTML(this.code);
        }

        let result = {};
        if (this.autoDetect) {
          result = hljs.highlightAuto(this.code);
          this.detectedLanguage = result.language;
        } else {
          result = hljs.highlight(this.language, this.code, this.ignoreIllegals);
          this.detectedLanguage = this.language;
        }
        return result.value;
      },
      autoDetect() {
        return !this.language || hasValueOrEmptyAttribute(this.autodetect);
      },
      ignoreIllegals() {
        return true;
      }
    },
    // this avoids needing to use a whole Vue compilation pipeline just
    // to build Highlight.js
    render(createElement) {
      return createElement("pre", {}, [
        createElement("code", {
          class: this.className,
          domProps: { innerHTML: this.highlighted }
        })
      ]);
    }
    // template: `<pre><code :class="className" v-html="highlighted"></code></pre>`
  };

  const VuePlugin = {
    install(Vue) {
      Vue.component('highlightjs', Component);
    }
  };

  return { Component, VuePlugin };
}

/* plugin itself */

/** @type {HLJSPlugin} */
const mergeHTMLPlugin = {
  "after:highlightBlock": ({ block, result, text }) => {
    const originalStream = nodeStream(block);
    if (!originalStream.length) return;

    const resultNode = document.createElement('div');
    resultNode.innerHTML = result.value;
    result.value = mergeStreams(originalStream, nodeStream(resultNode), text);
  }
};

/* Stream merging support functions */

/**
 * @typedef Event
 * @property {'start'|'stop'} event
 * @property {number} offset
 * @property {Node} node
 */

/**
 * @param {Node} node
 */
function tag(node) {
  return node.nodeName.toLowerCase();
}

/**
 * @param {Node} node
 */
function nodeStream(node) {
  /** @type Event[] */
  const result = [];
  (function _nodeStream(node, offset) {
    for (let child = node.firstChild; child; child = child.nextSibling) {
      if (child.nodeType === 3) {
        offset += child.nodeValue.length;
      } else if (child.nodeType === 1) {
        result.push({
          event: 'start',
          offset: offset,
          node: child
        });
        offset = _nodeStream(child, offset);
        // Prevent void elements from having an end tag that would actually
        // double them in the output. There are more void elements in HTML
        // but we list only those realistically expected in code display.
        if (!tag(child).match(/br|hr|img|input/)) {
          result.push({
            event: 'stop',
            offset: offset,
            node: child
          });
        }
      }
    }
    return offset;
  })(node, 0);
  return result;
}

/**
 * @param {any} original - the original stream
 * @param {any} highlighted - stream of the highlighted source
 * @param {string} value - the original source itself
 */
function mergeStreams(original, highlighted, value) {
  let processed = 0;
  let result = '';
  const nodeStack = [];

  function selectStream() {
    if (!original.length || !highlighted.length) {
      return original.length ? original : highlighted;
    }
    if (original[0].offset !== highlighted[0].offset) {
      return (original[0].offset < highlighted[0].offset) ? original : highlighted;
    }

    /*
    To avoid starting the stream just before it should stop the order is
    ensured that original always starts first and closes last:

    if (event1 == 'start' && event2 == 'start')
      return original;
    if (event1 == 'start' && event2 == 'stop')
      return highlighted;
    if (event1 == 'stop' && event2 == 'start')
      return original;
    if (event1 == 'stop' && event2 == 'stop')
      return highlighted;

    ... which is collapsed to:
    */
    return highlighted[0].event === 'start' ? original : highlighted;
  }

  /**
   * @param {Node} node
   */
  function open(node) {
    /** @param {Attr} attr */
    function attributeString(attr) {
      return ' ' + attr.nodeName + '="' + escapeHTML(attr.value) + '"';
    }
    // @ts-ignore
    result += '<' + tag(node) + [].map.call(node.attributes, attributeString).join('') + '>';
  }

  /**
   * @param {Node} node
   */
  function close(node) {
    result += '</' + tag(node) + '>';
  }

  /**
   * @param {Event} event
   */
  function render(event) {
    (event.event === 'start' ? open : close)(event.node);
  }

  while (original.length || highlighted.length) {
    let stream = selectStream();
    result += escapeHTML(value.substring(processed, stream[0].offset));
    processed = stream[0].offset;
    if (stream === original) {
      /*
      On any opening or closing tag of the original markup we first close
      the entire highlighted node stack, then render the original tag along
      with all the following original tags at the same offset and then
      reopen all the tags on the highlighted stack.
      */
      nodeStack.reverse().forEach(close);
      do {
        render(stream.splice(0, 1)[0]);
        stream = selectStream();
      } while (stream === original && stream.length && stream[0].offset === processed);
      nodeStack.reverse().forEach(open);
    } else {
      if (stream[0].event === 'start') {
        nodeStack.push(stream[0].node);
      } else {
        nodeStack.pop();
      }
      render(stream.splice(0, 1)[0]);
    }
  }
  return result + escapeHTML(value.substr(processed));
}

/*

For the reasoning behind this please see:
https://github.com/highlightjs/highlight.js/issues/2880#issuecomment-747275419

*/

/**
 * @param {string} message
 */
const error$1 = (message) => {
  console.error(message);
};

/**
 * @param {string} message
 * @param {any} args
 */
const warn$1 = (message, ...args) => {
  console.log(`WARN: ${message}`, ...args);
};

/**
 * @param {string} version
 * @param {string} message
 */
const deprecated$1 = (version, message) => {
  console.log(`Deprecated as of ${version}. ${message}`);
};

/*
Syntax highlighting with language autodetection.
https://highlightjs.org/
*/

const escape$1 = escapeHTML;
const inherit$1 = inherit;
const NO_MATCH = Symbol("nomatch");

/**
 * @param {any} hljs - object that is extended (legacy)
 * @returns {HLJSApi}
 */
const HLJS = function(hljs) {
  // Global internal variables used within the highlight.js library.
  /** @type {Record<string, Language>} */
  const languages = Object.create(null);
  /** @type {Record<string, string>} */
  const aliases = Object.create(null);
  /** @type {HLJSPlugin[]} */
  const plugins = [];

  // safe/production mode - swallows more errors, tries to keep running
  // even if a single syntax or parse hits a fatal error
  let SAFE_MODE = true;
  const fixMarkupRe = /(^(<[^>]+>|\t|)+|\n)/gm;
  const LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
  /** @type {Language} */
  const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: 'Plain text', contains: [] };

  // Global options used when within external APIs. This is modified when
  // calling the `hljs.configure` function.
  /** @type HLJSOptions */
  let options = {
    noHighlightRe: /^(no-?highlight)$/i,
    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
    classPrefix: 'hljs-',
    tabReplace: null,
    useBR: false,
    languages: null,
    // beta configuration options, subject to change, welcome to discuss
    // https://github.com/highlightjs/highlight.js/issues/1086
    __emitter: TokenTreeEmitter
  };

  /* Utility functions */

  /**
   * Tests a language name to see if highlighting should be skipped
   * @param {string} languageName
   */
  function shouldNotHighlight(languageName) {
    return options.noHighlightRe.test(languageName);
  }

  /**
   * @param {HighlightedHTMLElement} block - the HTML element to determine language for
   */
  function blockLanguage(block) {
    let classes = block.className + ' ';

    classes += block.parentNode ? block.parentNode.className : '';

    // language-* takes precedence over non-prefixed class names.
    const match = options.languageDetectRe.exec(classes);
    if (match) {
      const language = getLanguage(match[1]);
      if (!language) {
        warn$1(LANGUAGE_NOT_FOUND.replace("{}", match[1]));
        warn$1("Falling back to no-highlight mode for this block.", block);
      }
      return language ? match[1] : 'no-highlight';
    }

    return classes
      .split(/\s+/)
      .find((_class) => shouldNotHighlight(_class) || getLanguage(_class));
  }

  /**
   * Core highlighting function.
   *
   * @param {string} languageName - the language to use for highlighting
   * @param {string} code - the code to highlight
   * @param {boolean} [ignoreIllegals] - whether to ignore illegal matches, default is to bail
   * @param {CompiledMode} [continuation] - current continuation mode, if any
   *
   * @returns {HighlightResult} Result - an object that represents the result
   * @property {string} language - the language name
   * @property {number} relevance - the relevance score
   * @property {string} value - the highlighted HTML code
   * @property {string} code - the original raw code
   * @property {CompiledMode} top - top of the current mode stack
   * @property {boolean} illegal - indicates whether any illegal matches were found
  */
  function highlight(languageName, code, ignoreIllegals, continuation) {
    /** @type {BeforeHighlightContext} */
    const context = {
      code,
      language: languageName
    };
    // the plugin can change the desired language or the code to be highlighted
    // just be changing the object it was passed
    fire("before:highlight", context);

    // a before plugin can usurp the result completely by providing it's own
    // in which case we don't even need to call highlight
    const result = context.result
      ? context.result
      : _highlight(context.language, context.code, ignoreIllegals, continuation);

    result.code = context.code;
    // the plugin can change anything in result to suite it
    fire("after:highlight", result);

    return result;
  }

  /**
   * private highlight that's used internally and does not fire callbacks
   *
   * @param {string} languageName - the language to use for highlighting
   * @param {string} code - the code to highlight
   * @param {boolean} [ignoreIllegals] - whether to ignore illegal matches, default is to bail
   * @param {CompiledMode} [continuation] - current continuation mode, if any
   * @returns {HighlightResult} - result of the highlight operation
  */
  function _highlight(languageName, code, ignoreIllegals, continuation) {
    const codeToHighlight = code;

    /**
     * Return keyword data if a match is a keyword
     * @param {CompiledMode} mode - current mode
     * @param {RegExpMatchArray} match - regexp match data
     * @returns {KeywordData | false}
     */
    function keywordData(mode, match) {
      const matchText = language.case_insensitive ? match[0].toLowerCase() : match[0];
      return Object.prototype.hasOwnProperty.call(mode.keywords, matchText) && mode.keywords[matchText];
    }

    function processKeywords() {
      if (!top.keywords) {
        emitter.addText(modeBuffer);
        return;
      }

      let lastIndex = 0;
      top.keywordPatternRe.lastIndex = 0;
      let match = top.keywordPatternRe.exec(modeBuffer);
      let buf = "";

      while (match) {
        buf += modeBuffer.substring(lastIndex, match.index);
        const data = keywordData(top, match);
        if (data) {
          const [kind, keywordRelevance] = data;
          emitter.addText(buf);
          buf = "";

          relevance += keywordRelevance;
          const cssClass = language.classNameAliases[kind] || kind;
          emitter.addKeyword(match[0], cssClass);
        } else {
          buf += match[0];
        }
        lastIndex = top.keywordPatternRe.lastIndex;
        match = top.keywordPatternRe.exec(modeBuffer);
      }
      buf += modeBuffer.substr(lastIndex);
      emitter.addText(buf);
    }

    function processSubLanguage() {
      if (modeBuffer === "") return;
      /** @type HighlightResult */
      let result = null;

      if (typeof top.subLanguage === 'string') {
        if (!languages[top.subLanguage]) {
          emitter.addText(modeBuffer);
          return;
        }
        result = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);
        continuations[top.subLanguage] = /** @type {CompiledMode} */ (result.top);
      } else {
        result = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);
      }

      // Counting embedded language score towards the host language may be disabled
      // with zeroing the containing mode relevance. Use case in point is Markdown that
      // allows XML everywhere and makes every XML snippet to have a much larger Markdown
      // score.
      if (top.relevance > 0) {
        relevance += result.relevance;
      }
      emitter.addSublanguage(result.emitter, result.language);
    }

    function processBuffer() {
      if (top.subLanguage != null) {
        processSubLanguage();
      } else {
        processKeywords();
      }
      modeBuffer = '';
    }

    /**
     * @param {Mode} mode - new mode to start
     */
    function startNewMode(mode) {
      if (mode.className) {
        emitter.openNode(language.classNameAliases[mode.className] || mode.className);
      }
      top = Object.create(mode, { parent: { value: top } });
      return top;
    }

    /**
     * @param {CompiledMode } mode - the mode to potentially end
     * @param {RegExpMatchArray} match - the latest match
     * @param {string} matchPlusRemainder - match plus remainder of content
     * @returns {CompiledMode | void} - the next mode, or if void continue on in current mode
     */
    function endOfMode(mode, match, matchPlusRemainder) {
      let matched = startsWith(mode.endRe, matchPlusRemainder);

      if (matched) {
        if (mode["on:end"]) {
          const resp = new Response(mode);
          mode["on:end"](match, resp);
          if (resp.ignore) matched = false;
        }

        if (matched) {
          while (mode.endsParent && mode.parent) {
            mode = mode.parent;
          }
          return mode;
        }
      }
      // even if on:end fires an `ignore` it's still possible
      // that we might trigger the end node because of a parent mode
      if (mode.endsWithParent) {
        return endOfMode(mode.parent, match, matchPlusRemainder);
      }
    }

    /**
     * Handle matching but then ignoring a sequence of text
     *
     * @param {string} lexeme - string containing full match text
     */
    function doIgnore(lexeme) {
      if (top.matcher.regexIndex === 0) {
        // no more regexs to potentially match here, so we move the cursor forward one
        // space
        modeBuffer += lexeme[0];
        return 1;
      } else {
        // no need to move the cursor, we still have additional regexes to try and
        // match at this very spot
        resumeScanAtSamePosition = true;
        return 0;
      }
    }

    /**
     * Handle the start of a new potential mode match
     *
     * @param {EnhancedMatch} match - the current match
     * @returns {number} how far to advance the parse cursor
     */
    function doBeginMatch(match) {
      const lexeme = match[0];
      const newMode = match.rule;

      const resp = new Response(newMode);
      // first internal before callbacks, then the public ones
      const beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
      for (const cb of beforeCallbacks) {
        if (!cb) continue;
        cb(match, resp);
        if (resp.ignore) return doIgnore(lexeme);
      }

      if (newMode && newMode.endSameAsBegin) {
        newMode.endRe = escape(lexeme);
      }

      if (newMode.skip) {
        modeBuffer += lexeme;
      } else {
        if (newMode.excludeBegin) {
          modeBuffer += lexeme;
        }
        processBuffer();
        if (!newMode.returnBegin && !newMode.excludeBegin) {
          modeBuffer = lexeme;
        }
      }
      startNewMode(newMode);
      // if (mode["after:begin"]) {
      //   let resp = new Response(mode);
      //   mode["after:begin"](match, resp);
      // }
      return newMode.returnBegin ? 0 : lexeme.length;
    }

    /**
     * Handle the potential end of mode
     *
     * @param {RegExpMatchArray} match - the current match
     */
    function doEndMatch(match) {
      const lexeme = match[0];
      const matchPlusRemainder = codeToHighlight.substr(match.index);

      const endMode = endOfMode(top, match, matchPlusRemainder);
      if (!endMode) { return NO_MATCH; }

      const origin = top;
      if (origin.skip) {
        modeBuffer += lexeme;
      } else {
        if (!(origin.returnEnd || origin.excludeEnd)) {
          modeBuffer += lexeme;
        }
        processBuffer();
        if (origin.excludeEnd) {
          modeBuffer = lexeme;
        }
      }
      do {
        if (top.className) {
          emitter.closeNode();
        }
        if (!top.skip && !top.subLanguage) {
          relevance += top.relevance;
        }
        top = top.parent;
      } while (top !== endMode.parent);
      if (endMode.starts) {
        if (endMode.endSameAsBegin) {
          endMode.starts.endRe = endMode.endRe;
        }
        startNewMode(endMode.starts);
      }
      return origin.returnEnd ? 0 : lexeme.length;
    }

    function processContinuations() {
      const list = [];
      for (let current = top; current !== language; current = current.parent) {
        if (current.className) {
          list.unshift(current.className);
        }
      }
      list.forEach(item => emitter.openNode(item));
    }

    /** @type {{type?: MatchType, index?: number, rule?: Mode}}} */
    let lastMatch = {};

    /**
     *  Process an individual match
     *
     * @param {string} textBeforeMatch - text preceeding the match (since the last match)
     * @param {EnhancedMatch} [match] - the match itself
     */
    function processLexeme(textBeforeMatch, match) {
      const lexeme = match && match[0];

      // add non-matched text to the current mode buffer
      modeBuffer += textBeforeMatch;

      if (lexeme == null) {
        processBuffer();
        return 0;
      }

      // we've found a 0 width match and we're stuck, so we need to advance
      // this happens when we have badly behaved rules that have optional matchers to the degree that
      // sometimes they can end up matching nothing at all
      // Ref: https://github.com/highlightjs/highlight.js/issues/2140
      if (lastMatch.type === "begin" && match.type === "end" && lastMatch.index === match.index && lexeme === "") {
        // spit the "skipped" character that our regex choked on back into the output sequence
        modeBuffer += codeToHighlight.slice(match.index, match.index + 1);
        if (!SAFE_MODE) {
          /** @type {AnnotatedError} */
          const err = new Error('0 width match regex');
          err.languageName = languageName;
          err.badRule = lastMatch.rule;
          throw err;
        }
        return 1;
      }
      lastMatch = match;

      if (match.type === "begin") {
        return doBeginMatch(match);
      } else if (match.type === "illegal" && !ignoreIllegals) {
        // illegal match, we do not continue processing
        /** @type {AnnotatedError} */
        const err = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.className || '<unnamed>') + '"');
        err.mode = top;
        throw err;
      } else if (match.type === "end") {
        const processed = doEndMatch(match);
        if (processed !== NO_MATCH) {
          return processed;
        }
      }

      // edge case for when illegal matches $ (end of line) which is technically
      // a 0 width match but not a begin/end match so it's not caught by the
      // first handler (when ignoreIllegals is true)
      if (match.type === "illegal" && lexeme === "") {
        // advance so we aren't stuck in an infinite loop
        return 1;
      }

      // infinite loops are BAD, this is a last ditch catch all. if we have a
      // decent number of iterations yet our index (cursor position in our
      // parsing) still 3x behind our index then something is very wrong
      // so we bail
      if (iterations > 100000 && iterations > match.index * 3) {
        const err = new Error('potential infinite loop, way more iterations than matches');
        throw err;
      }

      /*
      Why might be find ourselves here?  Only one occasion now.  An end match that was
      triggered but could not be completed.  When might this happen?  When an `endSameasBegin`
      rule sets the end rule to a specific match.  Since the overall mode termination rule that's
      being used to scan the text isn't recompiled that means that any match that LOOKS like
      the end (but is not, because it is not an exact match to the beginning) will
      end up here.  A definite end match, but when `doEndMatch` tries to "reapply"
      the end rule and fails to match, we wind up here, and just silently ignore the end.

      This causes no real harm other than stopping a few times too many.
      */

      modeBuffer += lexeme;
      return lexeme.length;
    }

    const language = getLanguage(languageName);
    if (!language) {
      error$1(LANGUAGE_NOT_FOUND.replace("{}", languageName));
      throw new Error('Unknown language: "' + languageName + '"');
    }

    const md = compileLanguage(language, { plugins });
    let result = '';
    /** @type {CompiledMode} */
    let top = continuation || md;
    /** @type Record<string,CompiledMode> */
    const continuations = {}; // keep continuations for sub-languages
    const emitter = new options.__emitter(options);
    processContinuations();
    let modeBuffer = '';
    let relevance = 0;
    let index = 0;
    let iterations = 0;
    let resumeScanAtSamePosition = false;

    try {
      top.matcher.considerAll();

      for (;;) {
        iterations++;
        if (resumeScanAtSamePosition) {
          // only regexes not matched previously will now be
          // considered for a potential match
          resumeScanAtSamePosition = false;
        } else {
          top.matcher.considerAll();
        }
        top.matcher.lastIndex = index;

        const match = top.matcher.exec(codeToHighlight);
        // console.log("match", match[0], match.rule && match.rule.begin)

        if (!match) break;

        const beforeMatch = codeToHighlight.substring(index, match.index);
        const processedCount = processLexeme(beforeMatch, match);
        index = match.index + processedCount;
      }
      processLexeme(codeToHighlight.substr(index));
      emitter.closeAllNodes();
      emitter.finalize();
      result = emitter.toHTML();

      return {
        // avoid possible breakage with v10 clients expecting
        // this to always be an integer
        relevance: Math.floor(relevance),
        value: result,
        language: languageName,
        illegal: false,
        emitter: emitter,
        top: top
      };
    } catch (err) {
      if (err.message && err.message.includes('Illegal')) {
        return {
          illegal: true,
          illegalBy: {
            msg: err.message,
            context: codeToHighlight.slice(index - 100, index + 100),
            mode: err.mode
          },
          sofar: result,
          relevance: 0,
          value: escape$1(codeToHighlight),
          emitter: emitter
        };
      } else if (SAFE_MODE) {
        return {
          illegal: false,
          relevance: 0,
          value: escape$1(codeToHighlight),
          emitter: emitter,
          language: languageName,
          top: top,
          errorRaised: err
        };
      } else {
        throw err;
      }
    }
  }

  /**
   * returns a valid highlight result, without actually doing any actual work,
   * auto highlight starts with this and it's possible for small snippets that
   * auto-detection may not find a better match
   * @param {string} code
   * @returns {HighlightResult}
   */
  function justTextHighlightResult(code) {
    const result = {
      relevance: 0,
      emitter: new options.__emitter(options),
      value: escape$1(code),
      illegal: false,
      top: PLAINTEXT_LANGUAGE
    };
    result.emitter.addText(code);
    return result;
  }

  /**
  Highlighting with language detection. Accepts a string with the code to
  highlight. Returns an object with the following properties:

  - language (detected language)
  - relevance (int)
  - value (an HTML string with highlighting markup)
  - second_best (object with the same structure for second-best heuristically
    detected language, may be absent)

    @param {string} code
    @param {Array<string>} [languageSubset]
    @returns {AutoHighlightResult}
  */
  function highlightAuto(code, languageSubset) {
    languageSubset = languageSubset || options.languages || Object.keys(languages);
    const plaintext = justTextHighlightResult(code);

    const results = languageSubset.filter(getLanguage).filter(autoDetection).map(name =>
      _highlight(name, code, false)
    );
    results.unshift(plaintext); // plaintext is always an option

    const sorted = results.sort((a, b) => {
      // sort base on relevance
      if (a.relevance !== b.relevance) return b.relevance - a.relevance;

      // always award the tie to the base language
      // ie if C++ and Arduino are tied, it's more likely to be C++
      if (a.language && b.language) {
        if (getLanguage(a.language).supersetOf === b.language) {
          return 1;
        } else if (getLanguage(b.language).supersetOf === a.language) {
          return -1;
        }
      }

      // otherwise say they are equal, which has the effect of sorting on
      // relevance while preserving the original ordering - which is how ties
      // have historically been settled, ie the language that comes first always
      // wins in the case of a tie
      return 0;
    });

    const [best, secondBest] = sorted;

    /** @type {AutoHighlightResult} */
    const result = best;
    result.second_best = secondBest;

    return result;
  }

  /**
  Post-processing of the highlighted markup:

  - replace TABs with something more useful
  - replace real line-breaks with '<br>' for non-pre containers

    @param {string} html
    @returns {string}
  */
  function fixMarkup(html) {
    if (!(options.tabReplace || options.useBR)) {
      return html;
    }

    return html.replace(fixMarkupRe, match => {
      if (match === '\n') {
        return options.useBR ? '<br>' : match;
      } else if (options.tabReplace) {
        return match.replace(/\t/g, options.tabReplace);
      }
      return match;
    });
  }

  /**
   * Builds new class name for block given the language name
   *
   * @param {HTMLElement} element
   * @param {string} [currentLang]
   * @param {string} [resultLang]
   */
  function updateClassName(element, currentLang, resultLang) {
    const language = currentLang ? aliases[currentLang] : resultLang;

    element.classList.add("hljs");
    if (language) element.classList.add(language);
  }

  /** @type {HLJSPlugin} */
  const brPlugin = {
    "before:highlightBlock": ({ block }) => {
      if (options.useBR) {
        block.innerHTML = block.innerHTML.replace(/\n/g, '').replace(/<br[ /]*>/g, '\n');
      }
    },
    "after:highlightBlock": ({ result }) => {
      if (options.useBR) {
        result.value = result.value.replace(/\n/g, "<br>");
      }
    }
  };

  const TAB_REPLACE_RE = /^(<[^>]+>|\t)+/gm;
  /** @type {HLJSPlugin} */
  const tabReplacePlugin = {
    "after:highlightBlock": ({ result }) => {
      if (options.tabReplace) {
        result.value = result.value.replace(TAB_REPLACE_RE, (m) =>
          m.replace(/\t/g, options.tabReplace)
        );
      }
    }
  };

  /**
   * Applies highlighting to a DOM node containing code. Accepts a DOM node and
   * two optional parameters for fixMarkup.
   *
   * @param {HighlightedHTMLElement} element - the HTML element to highlight
  */
  function highlightBlock(element) {
    /** @type HTMLElement */
    let node = null;
    const language = blockLanguage(element);

    if (shouldNotHighlight(language)) return;

    fire("before:highlightBlock",
      { block: element, language: language });

    node = element;
    const text = node.textContent;
    const result = language ? highlight(language, text, true) : highlightAuto(text);

    fire("after:highlightBlock", { block: element, result, text });

    element.innerHTML = result.value;
    updateClassName(element, language, result.language);
    element.result = {
      language: result.language,
      // TODO: remove with version 11.0
      re: result.relevance,
      relavance: result.relevance
    };
    if (result.second_best) {
      element.second_best = {
        language: result.second_best.language,
        // TODO: remove with version 11.0
        re: result.second_best.relevance,
        relavance: result.second_best.relevance
      };
    }
  }

  /**
   * Updates highlight.js global options with the passed options
   *
   * @param {Partial<HLJSOptions>} userOptions
   */
  function configure(userOptions) {
    if (userOptions.useBR) {
      deprecated$1("10.3.0", "'useBR' will be removed entirely in v11.0");
      deprecated$1("10.3.0", "Please see https://github.com/highlightjs/highlight.js/issues/2559");
    }
    options = inherit$1(options, userOptions);
  }

  /**
   * Highlights to all <pre><code> blocks on a page
   *
   * @type {Function & {called?: boolean}}
   */
  // TODO: remove v12, deprecated
  const initHighlighting = () => {
    if (initHighlighting.called) return;
    initHighlighting.called = true;

    deprecated$1("10.6.0", "initHighlighting() is deprecated.  Use highlightAll() instead.");

    const blocks = document.querySelectorAll('pre code');
    blocks.forEach(highlightBlock);
  };

  // Higlights all when DOMContentLoaded fires
  // TODO: remove v12, deprecated
  function initHighlightingOnLoad() {
    deprecated$1("10.6.0", "initHighlightingOnLoad() is deprecated.  Use highlightAll() instead.");
    wantsHighlight = true;
  }

  let wantsHighlight = false;
  let domLoaded = false;

  /**
   * auto-highlights all pre>code elements on the page
   */
  function highlightAll() {
    // if we are called too early in the loading process
    if (!domLoaded) { wantsHighlight = true; return; }

    const blocks = document.querySelectorAll('pre code');
    blocks.forEach(highlightBlock);
  }

  function boot() {
    domLoaded = true;
    // if a highlight was requested before DOM was loaded, do now
    if (wantsHighlight) highlightAll();
  }

  // make sure we are in the browser environment
  if (typeof window !== 'undefined' && window.addEventListener) {
    window.addEventListener('DOMContentLoaded', boot, false);
  }

  /**
   * Register a language grammar module
   *
   * @param {string} languageName
   * @param {LanguageFn} languageDefinition
   */
  function registerLanguage(languageName, languageDefinition) {
    let lang = null;
    try {
      lang = languageDefinition(hljs);
    } catch (error$1$1) {
      error$1("Language definition for '{}' could not be registered.".replace("{}", languageName));
      // hard or soft error
      if (!SAFE_MODE) { throw error$1$1; } else { error$1(error$1$1); }
      // languages that have serious errors are replaced with essentially a
      // "plaintext" stand-in so that the code blocks will still get normal
      // css classes applied to them - and one bad language won't break the
      // entire highlighter
      lang = PLAINTEXT_LANGUAGE;
    }
    // give it a temporary name if it doesn't have one in the meta-data
    if (!lang.name) lang.name = languageName;
    languages[languageName] = lang;
    lang.rawDefinition = languageDefinition.bind(null, hljs);

    if (lang.aliases) {
      registerAliases(lang.aliases, { languageName });
    }
  }

  /**
   * @returns {string[]} List of language internal names
   */
  function listLanguages() {
    return Object.keys(languages);
  }

  /**
    intended usage: When one language truly requires another

    Unlike `getLanguage`, this will throw when the requested language
    is not available.

    @param {string} name - name of the language to fetch/require
    @returns {Language | never}
  */
  function requireLanguage(name) {
    deprecated$1("10.4.0", "requireLanguage will be removed entirely in v11.");
    deprecated$1("10.4.0", "Please see https://github.com/highlightjs/highlight.js/pull/2844");

    const lang = getLanguage(name);
    if (lang) { return lang; }

    const err = new Error('The \'{}\' language is required, but not loaded.'.replace('{}', name));
    throw err;
  }

  /**
   * @param {string} name - name of the language to retrieve
   * @returns {Language | undefined}
   */
  function getLanguage(name) {
    name = (name || '').toLowerCase();
    return languages[name] || languages[aliases[name]];
  }

  /**
   *
   * @param {string|string[]} aliasList - single alias or list of aliases
   * @param {{languageName: string}} opts
   */
  function registerAliases(aliasList, { languageName }) {
    if (typeof aliasList === 'string') {
      aliasList = [aliasList];
    }
    aliasList.forEach(alias => { aliases[alias] = languageName; });
  }

  /**
   * Determines if a given language has auto-detection enabled
   * @param {string} name - name of the language
   */
  function autoDetection(name) {
    const lang = getLanguage(name);
    return lang && !lang.disableAutodetect;
  }

  /**
   * @param {HLJSPlugin} plugin
   */
  function addPlugin(plugin) {
    plugins.push(plugin);
  }

  /**
   *
   * @param {PluginEvent} event
   * @param {any} args
   */
  function fire(event, args) {
    const cb = event;
    plugins.forEach(function(plugin) {
      if (plugin[cb]) {
        plugin[cb](args);
      }
    });
  }

  /**
  Note: fixMarkup is deprecated and will be removed entirely in v11

  @param {string} arg
  @returns {string}
  */
  function deprecateFixMarkup(arg) {
    deprecated$1("10.2.0", "fixMarkup will be removed entirely in v11.0");
    deprecated$1("10.2.0", "Please see https://github.com/highlightjs/highlight.js/issues/2534");

    return fixMarkup(arg);
  }

  /* Interface definition */
  Object.assign(hljs, {
    highlight,
    highlightAuto,
    highlightAll,
    fixMarkup: deprecateFixMarkup,
    highlightBlock,
    configure,
    initHighlighting,
    initHighlightingOnLoad,
    registerLanguage,
    listLanguages,
    getLanguage,
    registerAliases,
    requireLanguage,
    autoDetection,
    inherit: inherit$1,
    addPlugin,
    // plugins for frameworks
    vuePlugin: BuildVuePlugin(hljs).VuePlugin
  });

  hljs.debugMode = function() { SAFE_MODE = false; };
  hljs.safeMode = function() { SAFE_MODE = true; };
  hljs.versionString = version$2;

  for (const key in MODES) {
    // @ts-ignore
    if (typeof MODES[key] === "object") {
      // @ts-ignore
      deepFreezeEs6(MODES[key]);
    }
  }

  // merge all the modes/regexs into our main object
  Object.assign(hljs, MODES);

  // built-in plugins, likely to be moved out of core in the future
  hljs.addPlugin(brPlugin); // slated to be removed in v11
  hljs.addPlugin(mergeHTMLPlugin);
  hljs.addPlugin(tabReplacePlugin);
  return hljs;
};

// export an "instance" of the highlighter
var highlight = HLJS({});

var core = highlight;

const IDENT_RE$1 = '[A-Za-z$_][0-9A-Za-z$_]*';
const KEYWORDS = [
  "as", // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends"
];
const LITERALS = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
];

const TYPES = [
  "Intl",
  "DataView",
  "Number",
  "Math",
  "Date",
  "String",
  "RegExp",
  "Object",
  "Function",
  "Boolean",
  "Error",
  "Symbol",
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  "Proxy",
  "Reflect",
  "JSON",
  "Promise",
  "Float64Array",
  "Int16Array",
  "Int32Array",
  "Int8Array",
  "Uint16Array",
  "Uint32Array",
  "Float32Array",
  "Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "ArrayBuffer"
];

const ERROR_TYPES = [
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
];

const BUILT_IN_GLOBALS = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",

  "require",
  "exports",

  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
];

const BUILT_IN_VARIABLES = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "module",
  "global" // Node.js
];

const BUILT_INS = [].concat(
  BUILT_IN_GLOBALS,
  BUILT_IN_VARIABLES,
  TYPES,
  ERROR_TYPES
);

/**
 * @param {string} value
 * @returns {RegExp}
 * */

/**
 * @param {RegExp | string } re
 * @returns {string}
 */
function source$1(re) {
  if (!re) return null;
  if (typeof re === "string") return re;

  return re.source;
}

/**
 * @param {RegExp | string } re
 * @returns {string}
 */
function lookahead(re) {
  return concat$1('(?=', re, ')');
}

/**
 * @param {...(RegExp | string) } args
 * @returns {string}
 */
function concat$1(...args) {
  const joined = args.map((x) => source$1(x)).join("");
  return joined;
}

/*
Language: JavaScript
Description: JavaScript (JS) is a lightweight, interpreted, or just-in-time compiled programming language with first-class functions.
Category: common, scripting
Website: https://developer.mozilla.org/en-US/docs/Web/JavaScript
*/

/** @type LanguageFn */
function javascript$1(hljs) {
  /**
   * Takes a string like "<Booger" and checks to see
   * if we can find a matching "</Booger" later in the
   * content.
   * @param {RegExpMatchArray} match
   * @param {{after:number}} param1
   */
  const hasClosingTag = (match, { after }) => {
    const tag = "</" + match[0].slice(1);
    const pos = match.input.indexOf(tag, after);
    return pos !== -1;
  };

  const IDENT_RE$1$1 = IDENT_RE$1;
  const FRAGMENT = {
    begin: '<>',
    end: '</>'
  };
  const XML_TAG = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (match, response) => {
      const afterMatchIndex = match[0].length + match.index;
      const nextChar = match.input[afterMatchIndex];
      // nested type?
      // HTML should not include another raw `<` inside a tag
      // But a type might: `<Array<Array<number>>`, etc.
      if (nextChar === "<") {
        response.ignoreMatch();
        return;
      }
      // <something>
      // This is now either a tag or a type.
      if (nextChar === ">") {
        // if we cannot find a matching closing tag, then we
        // will ignore it
        if (!hasClosingTag(match, { after: afterMatchIndex })) {
          response.ignoreMatch();
        }
      }
    }
  };
  const KEYWORDS$1 = {
    $pattern: IDENT_RE$1,
    keyword: KEYWORDS,
    literal: LITERALS,
    built_in: BUILT_INS
  };

  // https://tc39.es/ecma262/#sec-literals-numeric-literals
  const decimalDigits = '[0-9](_?[0-9])*';
  const frac = `\\.(${decimalDigits})`;
  // DecimalIntegerLiteral, including Annex B NonOctalDecimalIntegerLiteral
  // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
  const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
  const NUMBER = {
    className: 'number',
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${decimalInteger})((${frac})|\\.)?|(${frac}))` +
        `[eE][+-]?(${decimalDigits})\\b` },
      { begin: `\\b(${decimalInteger})\\b((${frac})\\b|\\.)?|(${frac})\\b` },

      // DecimalBigIntegerLiteral
      { begin: `\\b(0|[1-9](_?[0-9])*)n\\b` },

      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },

      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" },
    ],
    relevance: 0
  };

  const SUBST = {
    className: 'subst',
    begin: '\\$\\{',
    end: '\\}',
    keywords: KEYWORDS$1,
    contains: [] // defined later
  };
  const HTML_TEMPLATE = {
    begin: 'html`',
    end: '',
    starts: {
      end: '`',
      returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: 'xml'
    }
  };
  const CSS_TEMPLATE = {
    begin: 'css`',
    end: '',
    starts: {
      end: '`',
      returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: 'css'
    }
  };
  const TEMPLATE_STRING = {
    className: 'string',
    begin: '`',
    end: '`',
    contains: [
      hljs.BACKSLASH_ESCAPE,
      SUBST
    ]
  };
  const JSDOC_COMMENT = hljs.COMMENT(
    /\/\*\*(?!\/)/,
    '\\*/',
    {
      relevance: 0,
      contains: [
        {
          className: 'doctag',
          begin: '@[A-Za-z]+',
          contains: [
            {
              className: 'type',
              begin: '\\{',
              end: '\\}',
              relevance: 0
            },
            {
              className: 'variable',
              begin: IDENT_RE$1$1 + '(?=\\s*(-)|$)',
              endsParent: true,
              relevance: 0
            },
            // eat spaces (not newlines) so we can find
            // types or variables
            {
              begin: /(?=[^\n])\s/,
              relevance: 0
            }
          ]
        }
      ]
    }
  );
  const COMMENT = {
    className: "comment",
    variants: [
      JSDOC_COMMENT,
      hljs.C_BLOCK_COMMENT_MODE,
      hljs.C_LINE_COMMENT_MODE
    ]
  };
  const SUBST_INTERNALS = [
    hljs.APOS_STRING_MODE,
    hljs.QUOTE_STRING_MODE,
    HTML_TEMPLATE,
    CSS_TEMPLATE,
    TEMPLATE_STRING,
    NUMBER,
    hljs.REGEXP_MODE
  ];
  SUBST.contains = SUBST_INTERNALS
    .concat({
      // we need to pair up {} inside our subst to prevent
      // it from ending too early by matching another }
      begin: /\{/,
      end: /\}/,
      keywords: KEYWORDS$1,
      contains: [
        "self"
      ].concat(SUBST_INTERNALS)
    });
  const SUBST_AND_COMMENTS = [].concat(COMMENT, SUBST.contains);
  const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
    // eat recursive parens in sub expressions
    {
      begin: /\(/,
      end: /\)/,
      keywords: KEYWORDS$1,
      contains: ["self"].concat(SUBST_AND_COMMENTS)
    }
  ]);
  const PARAMS = {
    className: 'params',
    begin: /\(/,
    end: /\)/,
    excludeBegin: true,
    excludeEnd: true,
    keywords: KEYWORDS$1,
    contains: PARAMS_CONTAINS
  };

  return {
    name: 'Javascript',
    aliases: ['js', 'jsx', 'mjs', 'cjs'],
    keywords: KEYWORDS$1,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS },
    illegal: /#(?![$_A-z])/,
    contains: [
      hljs.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      {
        label: "use_strict",
        className: 'meta',
        relevance: 10,
        begin: /^\s*['"]use (strict|asm)['"]/
      },
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      HTML_TEMPLATE,
      CSS_TEMPLATE,
      TEMPLATE_STRING,
      COMMENT,
      NUMBER,
      { // object attr container
        begin: concat$1(/[{,\n]\s*/,
          // we need to look ahead to make sure that we actually have an
          // attribute coming up so we don't steal a comma from a potential
          // "value" container
          //
          // NOTE: this might not work how you think.  We don't actually always
          // enter this mode and stay.  Instead it might merely match `,
          // <comments up next>` and then immediately end after the , because it
          // fails to find any actual attrs. But this still does the job because
          // it prevents the value contain rule from grabbing this instead and
          // prevening this rule from firing when we actually DO have keys.
          lookahead(concat$1(
            // we also need to allow for multiple possible comments inbetween
            // the first key:value pairing
            /(((\/\/.*$)|(\/\*(\*[^/]|[^*])*\*\/))\s*)*/,
            IDENT_RE$1$1 + '\\s*:'))),
        relevance: 0,
        contains: [
          {
            className: 'attr',
            begin: IDENT_RE$1$1 + lookahead('\\s*:'),
            relevance: 0
          }
        ]
      },
      { // "value" container
        begin: '(' + hljs.RE_STARTERS_RE + '|\\b(case|return|throw)\\b)\\s*',
        keywords: 'return throw case',
        contains: [
          COMMENT,
          hljs.REGEXP_MODE,
          {
            className: 'function',
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: '(\\(' +
            '[^()]*(\\(' +
            '[^()]*(\\(' +
            '[^()]*' +
            '\\)[^()]*)*' +
            '\\)[^()]*)*' +
            '\\)|' + hljs.UNDERSCORE_IDENT_RE + ')\\s*=>',
            returnBegin: true,
            end: '\\s*=>',
            contains: [
              {
                className: 'params',
                variants: [
                  {
                    begin: hljs.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: true
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: true,
                    excludeEnd: true,
                    keywords: KEYWORDS$1,
                    contains: PARAMS_CONTAINS
                  }
                ]
              }
            ]
          },
          { // could be a comma delimited list of params to a function call
            begin: /,/, relevance: 0
          },
          {
            className: '',
            begin: /\s/,
            end: /\s*/,
            skip: true
          },
          { // JSX
            variants: [
              { begin: FRAGMENT.begin, end: FRAGMENT.end },
              {
                begin: XML_TAG.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                'on:begin': XML_TAG.isTrulyOpeningTag,
                end: XML_TAG.end
              }
            ],
            subLanguage: 'xml',
            contains: [
              {
                begin: XML_TAG.begin,
                end: XML_TAG.end,
                skip: true,
                contains: ['self']
              }
            ]
          }
        ],
        relevance: 0
      },
      {
        className: 'function',
        beginKeywords: 'function',
        end: /[{;]/,
        excludeEnd: true,
        keywords: KEYWORDS$1,
        contains: [
          'self',
          hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1$1 }),
          PARAMS
        ],
        illegal: /%/
      },
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        className: 'function',
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: hljs.UNDERSCORE_IDENT_RE +
          '\\(' + // first parens
          '[^()]*(\\(' +
            '[^()]*(\\(' +
              '[^()]*' +
            '\\)[^()]*)*' +
          '\\)[^()]*)*' +
          '\\)\\s*\\{', // end parens
        returnBegin:true,
        contains: [
          PARAMS,
          hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1$1 }),
        ]
      },
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        variants: [
          { begin: '\\.' + IDENT_RE$1$1 },
          { begin: '\\$' + IDENT_RE$1$1 }
        ],
        relevance: 0
      },
      { // ES6 class
        className: 'class',
        beginKeywords: 'class',
        end: /[{;=]/,
        excludeEnd: true,
        illegal: /[:"[\]]/,
        contains: [
          { beginKeywords: 'extends' },
          hljs.UNDERSCORE_TITLE_MODE
        ]
      },
      {
        begin: /\b(?=constructor)/,
        end: /[{;]/,
        excludeEnd: true,
        contains: [
          hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1$1 }),
          'self',
          PARAMS
        ]
      },
      {
        begin: '(get|set)\\s+(?=' + IDENT_RE$1$1 + '\\()',
        end: /\{/,
        keywords: "get set",
        contains: [
          hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1$1 }),
          { begin: /\(\)/ }, // eat to avoid empty params
          PARAMS
        ]
      },
      {
        begin: /\$[(.]/ // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}

var javascript_1 = javascript$1;

/* src/components/widgets/DSPCode.svelte generated by Svelte v3.31.0 */

function add_css$B() {
	var style = element("style");
	style.id = "svelte-18csuml-style";
	style.textContent = ".container-dsp-code-output.svelte-18csuml{position:relative;width:100%;height:100%;border:none}.scrollable.svelte-18csuml{flex:1 1 auto;margin:0 0 0.5em 0;overflow-y:auto}.prewrap.svelte-18csuml{display:inline-flexbox;width:100%;overflow-x:auto;white-space:pre-wrap;white-space:-moz-pre-wrap;white-space:-pre-wrap;white-space:-o-pre-wrap;word-wrap:break-word;margin:5px 0px 15px 5px;font-size:medium;-moz-user-select:text;-khtml-user-select:text;-webkit-user-select:text;-ms-user-select:text;user-select:text}.dspCode-function-bloc-header.svelte-18csuml{margin:25px 10px 5px 5px}";
	append(document.head, style);
}

// (108:2) {#if $dspCode}
function create_if_block$l(ctx) {
	let span0;
	let t1;
	let pre0;
	let t2_value = js$2(/*$dspCode*/ ctx[0].setup, /*beautifyOptions*/ ctx[1]) + "";
	let t2;
	let t3;
	let span1;
	let t5;
	let pre1;
	let t6_value = js$2(/*$dspCode*/ ctx[0].loop, /*beautifyOptions*/ ctx[1]) + "";
	let t6;

	return {
		c() {
			span0 = element("span");
			span0.textContent = "Setup:";
			t1 = space();
			pre0 = element("pre");
			t2 = text$1(t2_value);
			t3 = space();
			span1 = element("span");
			span1.textContent = "Loop:";
			t5 = space();
			pre1 = element("pre");
			t6 = text$1(t6_value);
			attr(span0, "class", "dspCode-function-bloc-header svelte-18csuml");
			attr(pre0, "class", "prewrap svelte-18csuml");
			attr(span1, "class", "dspCode-function-bloc-header svelte-18csuml");
			attr(pre1, "class", "prewrap svelte-18csuml");
		},
		m(target, anchor) {
			insert(target, span0, anchor);
			insert(target, t1, anchor);
			insert(target, pre0, anchor);
			append(pre0, t2);
			insert(target, t3, anchor);
			insert(target, span1, anchor);
			insert(target, t5, anchor);
			insert(target, pre1, anchor);
			append(pre1, t6);
		},
		p(ctx, dirty) {
			if (dirty & /*$dspCode*/ 1 && t2_value !== (t2_value = js$2(/*$dspCode*/ ctx[0].setup, /*beautifyOptions*/ ctx[1]) + "")) set_data(t2, t2_value);
			if (dirty & /*$dspCode*/ 1 && t6_value !== (t6_value = js$2(/*$dspCode*/ ctx[0].loop, /*beautifyOptions*/ ctx[1]) + "")) set_data(t6, t6_value);
		},
		d(detaching) {
			if (detaching) detach(span0);
			if (detaching) detach(t1);
			if (detaching) detach(pre0);
			if (detaching) detach(t3);
			if (detaching) detach(span1);
			if (detaching) detach(t5);
			if (detaching) detach(pre1);
		}
	};
}

function create_fragment$M(ctx) {
	let div;
	let if_block = /*$dspCode*/ ctx[0] && create_if_block$l(ctx);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			attr(div, "class", "container-dsp-code-output scrollable svelte-18csuml");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
		},
		p(ctx, [dirty]) {
			if (/*$dspCode*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$l(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
		}
	};
}

function instance$L($$self, $$props, $$invalidate) {
	let $dspCode;
	component_subscribe($$self, dspCode, $$value => $$invalidate(0, $dspCode = $$value));
	let { id } = $$props;
	let { name } = $$props;
	let { type } = $$props;
	let { hasFocus } = $$props;
	let { background } = $$props;
	let { theme } = $$props;
	let { component } = $$props;
	let { class: className } = $$props;

	core.registerLanguage("javascript", javascript_1);

	// export let items;
	let beautifyOptions = {
		"indent_size": "2",
		"indent_char": " ",
		"max_preserve_newlines": "1",
		"preserve_newlines": true,
		"keep_array_indentation": true,
		"break_chained_methods": true,
		"indent_scripts": "normal",
		"brace_style": "collapse",
		"space_in_empty_paren": true,
		"space_before_conditional": true,
		"unescape_strings": true,
		"jslint_happy": false,
		"end_with_newline": false,
		"wrap_line_length": "70",
		"indent_inner_html": false,
		"comma_first": true,
		"e4x": false,
		"indent_empty_lines": false
	};

	onMount(async () => {
	});

	$$self.$$set = $$props => {
		if ("id" in $$props) $$invalidate(2, id = $$props.id);
		if ("name" in $$props) $$invalidate(3, name = $$props.name);
		if ("type" in $$props) $$invalidate(4, type = $$props.type);
		if ("hasFocus" in $$props) $$invalidate(5, hasFocus = $$props.hasFocus);
		if ("background" in $$props) $$invalidate(6, background = $$props.background);
		if ("theme" in $$props) $$invalidate(7, theme = $$props.theme);
		if ("component" in $$props) $$invalidate(8, component = $$props.component);
		if ("class" in $$props) $$invalidate(9, className = $$props.class);
	};

	return [
		$dspCode,
		beautifyOptions,
		id,
		name,
		type,
		hasFocus,
		background,
		theme,
		component,
		className
	];
}

class DSPCode extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-18csuml-style")) add_css$B();

		init(this, options, instance$L, create_fragment$M, safe_not_equal, {
			id: 2,
			name: 3,
			type: 4,
			hasFocus: 5,
			background: 6,
			theme: 7,
			component: 8,
			class: 9
		});
	}
}

const mouseActivated = writable(false);
const isMouseOverlayVisible = writable(false);

const siteMode = writable('dark');
const fullScreen = writable(true);
const sideBarVisible = writable(true);

const engineStatus = writable('no-audio');
const engineSoundLevel = writable(0.5);
const inputStreamConnected = writable(false);


// export const grammarEditorValue = writable(initGrammarEditorValue());
const grammarEditorValue = writable("");

// export const grammarCompiledParser = writable(compile(default_grammar).output);
const grammarCompiledParser = writable("");

const grammarCompilationErrors = writable("");

// export const liveCodeEditorValue = writable(initLiveCodeEditorValue());
const liveCodeEditorValue = writable("");

const liveCodeParseResults = writable("");

const liveCodeParseErrors = writable("");

const liveCodeAbstractSyntaxTree = writable("");

const dspCode = writable("");

// export const modelEditorValue = writable(initModelEditorValue());
const modelEditorValue = writable("");


// export const populateStoresWithFetchedProps = async (newItem) => {


async function updateLiveCodeEditorPropsWithFetchedValues(item){

  if (item !== undefined && item.data !== undefined) {
      if (
				item.data.liveCodeSource &&
				item.data.liveCodeSource !== `` &&
				!item.data.content
			) {
				// liveCodeEditor with language source, FIRST load
				try {
					item.data.content = await fetchFrom(item.data.liveCodeSource);
					item.data.liveCodeSource = ``; // set RELOAD from local storage;
				} catch (error) {
					console.error('Error fetching props for Live Code Editor item');
				}
			} else if (item.data.liveCodeSource === ``) {
				// if liveCodeSource is empty string "", reload fetch data from localStorage
				if (
					localStorage.liveCodeEditorValue &&
					localStorage.liveCodeEditorValue !== ``
				) {
					item.data.content = localStorage.liveCodeEditorValue;
        }
        else if (item.data.content) ; else
					console.error(
						'Error fetching props for Live Code Editor item: Local store empty'
					);
			} else if (!item.data.liveCodeSource) {
				// if liveCodeSource is undefined, it is a 'new' live code editor, set data empty
				item.data.content = '';
			}
		// else if(item.data !== undefined && item.liveCodeSource) return; // first load, hardcoded defaults

		if (item.data.grammarSource !== ``) {
			try {
				// liveCodeEditor with language source
				const fetchedGrammar = await fetchFrom(item.data.grammarSource);
				item.data.grammar = fetchedGrammar;
				// item.data.grammarSource = ``; // CAN'T USE THIS TO signal next LOAD from local storage, ITEM PROPS will send event with these props
				// localStorage.grammarEditorValue = fetchedGrammar;
			} catch (error) {
				console.error("Error fetching props for Live Code Editor item");
			}
		}
    else if(item.data.grammarSource === ''
            && localStorage.grammarEditorValue
            && localStorage.grammarEditorValue !== ``
    ){
			try {
        // if liveCodeSource is empty string "", reload fetch data from localStorage
        item.data.grammar = localStorage.grammarEditorValue;
			} catch (error) {
				console.error('Error fetching props for Live Code Editor item');
			}
    }
	}
}

async function updateGrammarEditorPropsWithFetchedValues(item) {
	if (item && item.data) {
    if (item.data.content && item.data.content !== ``)
    {
      return;
    }
		else if (item.data.grammarSource && item.data.grammarSource !== ``) {
			try {
				// liveCodeEditor with language source
				item.data.content = await fetchFrom(item.data.grammarSource);
				item.data.grammarSource = ``; // set next RELOAD from local storage;
			} catch (error) {
				console.error('Error fetching props for Grammar Editor item', error);
			}
		} else if (!item.data.grammarSource || item.data.grammarSource === ``) {
			// fetch data from localStorage
			// liveCodeEditor with language source
			item.data.content = localStorage.grammarEditorValue;
		}
	}
  // else if(item.data !== undefined && item.grammarSource) return; // first load, hardcoded defaults
}


async function updateItemPropsWithFetchedValues(item){

  if(item && item !== undefined ){
    try{
      switch (item.data.type) {
        case "liveCodeEditor":
          await updateLiveCodeEditorPropsWithFetchedValues(item);
          break;
        case "grammarEditor":
          await updateGrammarEditorPropsWithFetchedValues(item);
          break;
        default:
          break;
      }
    }
    catch(error){
      console.error("Error updating item's props with fetched values.", error);
    }
  }
  else
    console.error("Error updating item's props with fetched values: item null.");
}


const populateCommonStoresWithFetchedProps = async (item) => {

  if(item !== null){
    try{
      switch (item.data.type) {
				case "liveCodeEditor":
					liveCodeEditorValue.set(item.data.content);
					grammarEditorValue.set(item.data.grammar);
					grammarCompiledParser.set(compile(item.data.grammar).output);
					break;
				case "grammarEditor":
          grammarEditorValue.set(item.data.content);
					break;
				default:
					break;
			}
    }
    catch(error){
      console.error("Error Populating stores from fetched LiveCode props", error);
    }
  }
  else
    console.error("Error Populating stores from fetched LiveCode props: item null");
};


const updateItemPropsWithCommonStoreValues = (item) => {

  if(item){
    try{
      switch (item.data.type) {
				case "liveCodeEditor":
					item.data.content = get_store_value(liveCodeEditorValue);
					break;
				case "grammarEditor":
					item.data.content = get_store_value(grammarEditorValue);
					break;
				default:
					break;
			}
    }
    catch(error){
      console.error("Error updating item's props with common store values.", error);
    }
  }
  else
    console.error(
			"Error updating item's props with common store values: item null."
		);
};

const resetStores = () => {
  grammarEditorValue.set("");
  grammarCompiledParser.set("");
  grammarCompilationErrors.set("");
  liveCodeEditorValue.set("");
  liveCodeParseResults.set("");
  liveCodeParseErrors.set("");
  liveCodeAbstractSyntaxTree.set("");
  dspCode.set("");
  modelEditorValue.set("");
};

/**
 * The Controller is a singleton class that encapsulates signal engine (sema-engine)
 * and implements the dependency inversion principle
 * @class AudioEngine
 */
class Controller {
	/**
	 * @constructor
	 */
	constructor(engine) {
		if (Controller.instance) {
			return Controller.instance // Singleton pattern, only one instance in sema
		}
		Controller.instance = this;

		// Constructor dependency injection of a sema-engine singleton instance
		this.engine = engine;
    this.initializing = false;
		this.samplesLoaded = false;
    this.isStopped = false;
	}

	/**
	 * Handler of the Pub/Sub message events
	 * whose topics are subscribed to in the audio engine constructor
	 * @onMessagingEventHandler
	 */
	onMessagingEventHandler(event) {
		if (event !== undefined) {
			// Receive notification from "model-output-data" topic
			console.log('DEBUG:AudioEngine:onMessagingEventHandler:');
			console.log(event);
			this.audioWorkletNode.port.postMessage(event);
		}
	}

	/**
	 * Handler of audio worklet processor events
	 * @onProcessorAsyncMessageHandler
	 * @param event
	 */
	onProcessorAsyncMessage(event) {
		if (event !== undefined && event.data !== undefined) ;
	}

	/**
	 * Initialises audio context and sets worklet processor code
	 * @init
	 * @param audioworletURL
	 * TODO removing numClockPeers, should be added to a specialised function
	 */
	async init(audioWorkletURL) {
		if (this.engine) {
			try {
        this.initializing = true;
				await this.engine.init(audioWorkletURL);

				// Subscribe async messages from the Audio Worklet Processor scope
				// this.engine.subscribeAsyncMessage(this.onProcessorAsyncMessage)
				// const channelId = 'mxy',
				// 	ttype = 'mouseXY',
				// 	blockSize = 2

				// // Create SharedArrayBuffer for mouse data
				// this.engine.createSharedBuffer(channelId, ttype, blockSize)

				// Lazy load all samples imported from assets
				this.samplesLoaded = await this.importSamplesAsync();
				console.log('samples loaded');

				// Connect Analysers loaded from the store need to pass callbacks after they load
				this.engine.connectAnalysers();

        this.initializing = false;
				// Change engine status on settings bar
				engineStatus.set('running');

			} catch (error) {
				console.error('Error initialising engine', error);
			}
		}
	}

	async stop() {
		if (this.engine && !this.engine.isHushed) {
			await this.engine.hush();
			engineStatus.set('paused');
		}
	}

	onAudioInputFail(error) {
		console.error(
			`Engine Controller: AudioInputFail  ${error.message} ${error.name}`
		);
	}

	/**
	 * Sets up an AudioIn WAAPI sub-graph
	 * @connectMediaStreamSourceInput
	 */
	async connectMediaStream() {
		const constraints = (window.constraints = {
			audio: true,
			video: false,
		});

		navigator.mediaDevices
			.getUserMedia(constraints)
			.then((s) => this.onAudioInputInit(s))
			.catch(this.onAudioInputFail);
	}

	/**
	 * ! Deprecated until I have time to make a Rollup plugin
	 * @returns list of all imports from a folder specified by context
	 */
	getSamplesNames() {
		const r = require.context('../../assets/samples', false, /\.wav$/);

		// return an array list of filenames (with extension)
		const importAll = (r) => r.keys().map((file) => file.match(/[^\/]+$/)[0]);

		return importAll(r)
	}

	/**
	 *
	 * @returns
	 */
	async importSamplesAsync(sampleList) {
		return await new Promise(async (resolve, reject) => {
			// let sampleCounter = sampleList.length;
			let sampleCounter = 9;
			await import('./909-3311150f.js') // need to use the samples relative path to the src, not in public,
				.then((e) => {
					this.engine.loadSample(e.default, `/samples/${e.default}`);
					if (--sampleCounter <= 0) resolve(true);
					console.log(`loading sample: ${e.default}`);
				})
				.catch((err) => {
					console.error(`Error Engine lazy loading sample: ${err}`);
					reject(err);
				});
			// sampleCounter++;

			await import('./909b-765385cf.js') // need to use the samples relative path to the src, not in public,
				.then((e) => {
					this.engine.loadSample(e.default, `/samples/${e.default}`);
					if (--sampleCounter <= 0) resolve(true);
					console.log(`loading sample: ${e.default}`);
				})
				.catch((err) => {
					console.error(`Error Engine lazy loading sample: ${err}`);
					reject(err);
				});
			// sampleCounter++;

			await import('./909closed-d7d0e5d9.js') // need to use the samples relative path to the src, not in public,
				.then((e) => {
					this.engine.loadSample(e.default, `/samples/${e.default}`);
					if (--sampleCounter <= 0) resolve(true);
					console.log(`loading sample: ${e.default}`);
				})
				.catch((err) => {
					console.error(`Error Engine lazy loading sample: ${err}`);
					reject(err);
				});
			// sampleCounter++;

			await import('./909open-fa621cc9.js') // need to use the samples relative path to the src, not in public,
				.then((e) => {
					this.engine.loadSample(e.default, `/samples/${e.default}`);
					if (--sampleCounter <= 0) resolve(true);
					console.log(`loading sample: ${e.default}`);
				})
				.catch((err) => {
					console.error(`Error Engine lazy loading sample: ${err}`);
					reject(err);
				});
			// sampleCounter++;

			await import('./click-5b446941.js') // need to use the samples relative path to the src, not in public,
				.then((e) => {
					this.engine.loadSample(e.default, `/samples/${e.default}`);
					if (--sampleCounter <= 0) resolve(true);
					console.log(`loading sample: ${e.default}`);
				})
				.catch((err) => {
					console.error(`Error Engine lazy loading sample: ${err}`);
					reject(err);
				});

			await import('./spade-22206798.js') // need to use the samples relative path to the src, not in public,
				.then((e) => {
					this.engine.loadSample(e.default, `/samples/${e.default}`);
					if (--sampleCounter <= 0) resolve(true);
					console.log(`loading sample: ${e.default}`);
				})
				.catch((err) => {
					console.error(`Error Engine lazy loading sample: ${err}`);
					reject(err);
				});

			await import('./boom2-5388a395.js') // need to use the samples relative path to the src, not in public,
				.then((e) => {
					this.engine.loadSample(e.default, `/samples/${e.default}`);
					if (--sampleCounter <= 0) resolve(true);
					console.log(`loading sample: ${e.default}`);
				})
				.catch((err) => {
					console.error(`Error Engine lazy loading sample: ${err}`);
					reject(err);
				});

			await import('./boom-eb364a73.js') // need to use the samples relative path to the src, not in public,
				.then((e) => {
					this.engine.loadSample(e.default, `/samples/${e.default}`);
					if (--sampleCounter <= 0) resolve(true);
					console.log(`loading sample: ${e.default}`);
				})
				.catch((err) => {
					console.error(`Error Engine lazy loading sample: ${err}`);
					reject(err);
				});

			await import('./machine-bc636a75.js') // need to use the samples relative path to the src, not in public,
				.then((e) => {
					this.engine.loadSample(e.default, `/samples/${e.default}`);
					if (--sampleCounter <= 0) resolve(true);
					console.log(`loading sample: ${e.default}`);
				})
				.catch((err) => {
					console.error(`Error Engine lazy loading sample: ${err}`);
					reject(err);
				});

			await import('./patterndrone2-10be29a1.js') // need to use the samples relative path to the src, not in public,
				.then((e) => {
					this.engine.loadSample(e.default, `/samples/${e.default}`);
					if (--sampleCounter <= 0) resolve(true);
					console.log(`loading sample: ${e.default}`);
				})
				.catch((err) => {
					console.error(`Error Engine lazy loading sample: ${err}`);
					reject(err);
				});

			await import('./convol5-6b6cbdac.js') // need to use the samples relative path to the src, not in public,
				.then((e) => {
					this.engine.loadSample(e.default, `/samples/${e.default}`);
					if (--sampleCounter <= 0) resolve(true);
					console.log(`loading sample: ${e.default}`);
				})
				.catch((err) => {
					console.error(`Error Engine lazy loading sample: ${err}`);
					reject(err);
				});

			// sampleCounter++;
		})
	}
}

/*
notes:
localStorage doesn't allow objects so there's no way to add items to an array of history iitesm, unless you keep parsing it an unparsing it
which could bring in performance issues

instead: each history item is added as a separate localStorage entry, we'll need to add some utility functions to this class to organise
them an query them.

you can access all the keys in localStorage using Object.entries(localStoage) and then take things from there. Functions we need:

- clear history
- export history to document in date order (in a window) (supercollider style)


*/

function getHistoryItemsFromLocalStorage() {

  var items = {},
		keys = Object.keys(localStorage),
		i = keys.length;

	while (i--) {
		if (keys[i].startsWith("model-history-") || keys[i].startsWith("live-code-history") )
			items[keys[i]] = JSON.parse(window.localStorage.getItem(keys[i]));
	}

	return items;
}

function addToHistory$1(itemKey, item) {
	let nowdate = Date.now();
	let nowstr = new Date(nowdate).toISOString();

	// e.g. Key: lchist_2020-03-02T15:48:31.080Z,
	// Value: {"t":1583164111080,"code":":b:{{1,0.25}imp}\\909b; \n:s:{{1,0.25}imp}\\909; \n:c:{{{1,0.66}imp,{1,0.8}imp}add}\\909closed; \n:o:{{0.25,0.75}imp}\\909open; \n:tri:{40}tri; \n:sin:{45}sin; \n:saw:{4}saw; \n{:tri:, :saw:, {:sin:,0.4}mul, :b:, :o:, :c:, :s:}sum"}

	window.localStorage[itemKey + nowstr] = JSON.stringify(item);

	// window.localStorage[itemKey + nowstr] = JSON.stringify({
	// 	t: nowdate,
	// 	code: item,
	// });
}

function exportHistory() {

  console.log("DEBUG:History:ExportHistory: " );
  console.log(getHistoryItemsFromLocalStorage());
}

function clearHistory() {

  let items = Object.keys(getHistoryItemsFromLocalStorage());
  items.forEach(item => window.localStorage.removeItem(item));
}

var history$1 = { addToHistory: addToHistory$1, clearHistory, exportHistory };

/* src/components/editors/ModelEditor.svelte generated by Svelte v3.31.0 */

function add_css$C() {
	var style = element("style");
	style.id = "svelte-hrinf8-style";
	style.textContent = ".cm-s-material-ocean.CodeMirror{background-color:#0F111A;color:#8F93A2}.cm-s-material-ocean .CodeMirror-gutters{background:#0F111A;color:#464B5D;border:none}.cm-s-material-ocean .CodeMirror-guttermarker,.cm-s-material-ocean .CodeMirror-guttermarker-subtle,.cm-s-material-ocean .CodeMirror-linenumber{color:#464B5D}.cm-s-material-ocean .CodeMirror-cursor{border-left:1px solid #FFCC00}.cm-s-material-ocean div.CodeMirror-selected{background:rgba(113, 124, 180, 0.2)}.cm-s-material-ocean.CodeMirror-focused div.CodeMirror-selected{background:rgba(113, 124, 180, 0.2)}.cm-s-material-ocean .CodeMirror-line::selection,.cm-s-material-ocean .CodeMirror-line>span::selection,.cm-s-material-ocean .CodeMirror-line>span>span::selection{background:rgba(128, 203, 196, 0.2)}.cm-s-material-ocean .CodeMirror-line::-moz-selection,.cm-s-material-ocean .CodeMirror-line>span::-moz-selection,.cm-s-material-ocean .CodeMirror-line>span>span::-moz-selection{background:rgba(128, 203, 196, 0.2)}.cm-s-material-ocean .CodeMirror-activeline-background{background:rgba(0, 0, 0, 0.5)}.cm-s-material-ocean .cm-keyword{color:#C792EA}.cm-s-material-ocean .cm-operator{color:#89DDFF}.cm-s-material-ocean .cm-variable-2{color:#EEFFFF}.cm-s-material-ocean .cm-variable-3,.cm-s-material-ocean .cm-type{color:#f07178}.cm-s-material-ocean .cm-builtin{color:#FFCB6B}.cm-s-material-ocean .cm-atom{color:#F78C6C}.cm-s-material-ocean .cm-number{color:#FF5370}.cm-s-material-ocean .cm-def{color:#82AAFF}.cm-s-material-ocean .cm-string{color:#C3E88D}.cm-s-material-ocean .cm-string-2{color:#f07178}.cm-comment{color:#ccc}.cm-s-material-ocean .cm-variable{color:#f07178}.cm-s-material-ocean .cm-tag{color:#FF5370}.cm-s-material-ocean .cm-meta{color:#FFCB6B}.cm-s-material-ocean .cm-attribute{color:#C792EA}.cm-s-material-ocean .cm-property{color:#C792EA}.cm-s-material-ocean .cm-qualifier{color:#DECB6B}.cm-s-material-ocean .cm-variable-3,.cm-s-material-ocean .cm-type{color:#DECB6B}.cm-s-material-ocean .cm-error{color:rgba(255, 255, 255, 1.0);background-color:#FF5370}.cm-s-material-ocean .CodeMirror-matchingbracket{text-decoration:underline;color:white !important}.layout-template-container{height:100vh}.scrollable{flex:1 1 auto;margin:0 0 0.5em 0;overflow-y:auto}.codemirror-container{position:relative;width:100%;height:100%;border:none;line-height:1.4;overflow:hidden;font-family:monospace}.codemirror-container .CodeMirror{height:100%;background:transparent;font:400 14px/1.7 var(--font-mono);color:var(--base)}";
	append(document.head, style);
}

function create_fragment$N(ctx) {
	let div;
	let codemirror;
	let updating_value;
	let t;
	let textarea;
	let current;

	function codemirror_value_binding(value) {
		/*codemirror_value_binding*/ ctx[21].call(null, value);
	}

	let codemirror_props = {
		tab: true,
		lineNumbers: true,
		ctrlEnter: /*evalModelEditorExpressionBlock*/ ctx[10],
		cmdEnter: /*evalModelEditorExpressionBlock*/ ctx[10],
		shiftEnter: /*evalModelEditorExpression*/ ctx[9]
	};

	if (/*content*/ ctx[0] !== void 0) {
		codemirror_props.value = /*content*/ ctx[0];
	}

	codemirror = new CodeMirror_1({ props: codemirror_props });
	/*codemirror_binding*/ ctx[20](codemirror);
	binding_callbacks.push(() => bind(codemirror, "value", codemirror_value_binding));
	codemirror.$on("change", /*change_handler*/ ctx[22]);
	codemirror.$on("focus", /*focus_handler*/ ctx[23]);
	codemirror.$on("blur", /*blur_handler*/ ctx[24]);
	codemirror.$on("refresh", /*refresh_handler*/ ctx[25]);
	codemirror.$on("gutterClick", /*gutterClick_handler*/ ctx[26]);
	codemirror.$on("viewportChange", /*viewportChange_handler*/ ctx[27]);

	return {
		c() {
			div = element("div");
			create_component(codemirror.$$.fragment);
			t = space();
			textarea = element("textarea");
			attr(div, "class", "codemirror-container layout-template-container scrollable");
			attr(textarea, "aria-hidden", "true");
			attr(textarea, "id", "hiddenCopyField");
			set_style(textarea, "position", "absolute");
			set_style(textarea, "left", "-999em");
			textarea.value = "";
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(codemirror, div, null);
			/*div_binding*/ ctx[28](div);
			insert(target, t, anchor);
			insert(target, textarea, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const codemirror_changes = {};

			if (!updating_value && dirty[0] & /*content*/ 1) {
				updating_value = true;
				codemirror_changes.value = /*content*/ ctx[0];
				add_flush_callback(() => updating_value = false);
			}

			codemirror.$set(codemirror_changes);
		},
		i(local) {
			if (current) return;
			transition_in(codemirror.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(codemirror.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			/*codemirror_binding*/ ctx[20](null);
			destroy_component(codemirror);
			/*div_binding*/ ctx[28](null);
			if (detaching) detach(t);
			if (detaching) detach(textarea);
		}
	};
}

if (typeof window !== "undefined") {
	import('./codeMirrorPlugins-47b81358.js');
}
// window.localStorage.setItem("modelEditorValue", codeMirror.getValue());

function instance$M($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let controller = new Controller(); // this will return the previously created Singleton instance
	let { id } = $$props;
	let { name } = $$props;
	let { type } = $$props;
	let { lineNumbers } = $$props;
	let { hasFocus } = $$props;
	let { theme } = $$props;
	let { background } = $$props;
	let { content } = $$props;
	let { component } = $$props;
	let { class: className } = $$props;
	let engine, learner, codeMirror, container, resizeObserver;
	let messaging = new PubSub();

	let log = e => {
		
	}; /* console.log(...e); */

	let onChange = e => {
		try {
			let value = codeMirror.getValue();
			dispatch("change", { prop: "content", value });
		} catch(error) {
			console.error("Error Model Editor get value from code Mirror");
		}
	};

	let onFocus = e => {
		$$invalidate(11, hasFocus = true);

		// console.log("onfocus")
		dispatch("change", { prop: "hasFocus", value: true });
	};

	let onBlur = e => {
		$$invalidate(11, hasFocus = false);

		// console.log("onBlur")
		dispatch("change", { prop: "hasFocus", value: false });
	};

	let onRefresh = e => {
		
	}; // console.log("onRefresh")
	// dispatch('change', {
	//   prop:'hasFocus',
	//   value: true

	// });
	let onGutterCick = e => {
		
	}; // console.log("onGutterCick")
	// dispatch('change', {
	//   prop:'hasFocus',
	//   value: true

	// });
	let onViewportChange = e => {
		
	}; // console.log("onViewportChange")
	// console.log(e)

	let evalDomCode = code => {
		try {
			let evalRes = eval(code);
		} catch(e) {
			
		} // if (evalRes != undefined) {
		// console.log(`DOM Code eval exception: ${e}`);
	};

	// addToHistory("model-history-", modelCode);
	function evalModelEditorExpression() {
		let code = codeMirror.getSelection();
		learner.eval(code);

		//console.log("DEBUG:ModelEditor:evalModelEditorExpression: " + code);
		window.localStorage.setItem("modelEditorValue", code);

		history$1.addToHistory("model-history-", code);
	}

	function evalModelEditorExpressionBlock() {
		let code = codeMirror.getBlock();

		// console.log(modelCode);
		let linebreakPos = code.indexOf("\n");

		let firstLine = code.substr(0, linebreakPos);

		// console.log(firstLine);
		if (firstLine == "//--DOM") {
			code = code.substr(linebreakPos);
			evalDomCode(code);
			history$1.addToHistory("dom-history-", code);
		} else {
			learner.eval(code);
			window.localStorage.setItem("modelEditorValue", codeMirror.getValue());
			history$1.addToHistory("model-history-", code);
		}
	}

	onMount(async () => {
		try {
			if (!engine) engine = new Engine$1();
			codeMirror.set(content, "js", "material-ocean");
			resizeObserver = new ResizeObserver(e => codeMirror && codeMirror.setSize("100%", "100%"));
			resizeObserver.observe(container);

			// In Tutorial re-use learner
			if (Object.keys(engine.learners).length > 0) {
				learner = engine.learners[Object.keys(engine.learners)];
			} else {
				learner = new Learner();
				await engine.addLearner(id, learner);
			}

			log(id, name, type, lineNumbers, className, hasFocus, theme, background, content, component);
		} catch(error) {
			console.error(error);
		}
	});

	onDestroy(async () => {
		if (!learner) learner = engine.learners[id];
		learner.terminate();
		engine.removeLearner(id);
		console.info("disposing Learner");
		resizeObserver.disconnect();
		resizeObserver = null;
	});

	function codemirror_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			codeMirror = $$value;
			$$invalidate(1, codeMirror);
		});
	}

	function codemirror_value_binding(value) {
		content = value;
		$$invalidate(0, content);
	}

	const change_handler = e => onChange();
	const focus_handler = e => onFocus();
	const blur_handler = e => onBlur();
	const refresh_handler = e => onRefresh();
	const gutterClick_handler = e => onGutterCick();
	const viewportChange_handler = e => onViewportChange();

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			container = $$value;
			$$invalidate(2, container);
		});
	}

	$$self.$$set = $$props => {
		if ("id" in $$props) $$invalidate(12, id = $$props.id);
		if ("name" in $$props) $$invalidate(13, name = $$props.name);
		if ("type" in $$props) $$invalidate(14, type = $$props.type);
		if ("lineNumbers" in $$props) $$invalidate(15, lineNumbers = $$props.lineNumbers);
		if ("hasFocus" in $$props) $$invalidate(11, hasFocus = $$props.hasFocus);
		if ("theme" in $$props) $$invalidate(16, theme = $$props.theme);
		if ("background" in $$props) $$invalidate(17, background = $$props.background);
		if ("content" in $$props) $$invalidate(0, content = $$props.content);
		if ("component" in $$props) $$invalidate(18, component = $$props.component);
		if ("class" in $$props) $$invalidate(19, className = $$props.class);
	};

	return [
		content,
		codeMirror,
		container,
		onChange,
		onFocus,
		onBlur,
		onRefresh,
		onGutterCick,
		onViewportChange,
		evalModelEditorExpression,
		evalModelEditorExpressionBlock,
		hasFocus,
		id,
		name,
		type,
		lineNumbers,
		theme,
		background,
		component,
		className,
		codemirror_binding,
		codemirror_value_binding,
		change_handler,
		focus_handler,
		blur_handler,
		refresh_handler,
		gutterClick_handler,
		viewportChange_handler,
		div_binding
	];
}

class ModelEditor extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-hrinf8-style")) add_css$C();

		init(
			this,
			options,
			instance$M,
			create_fragment$N,
			safe_not_equal,
			{
				id: 12,
				name: 13,
				type: 14,
				lineNumbers: 15,
				hasFocus: 11,
				theme: 16,
				background: 17,
				content: 0,
				component: 18,
				class: 19
			},
			[-1, -1]
		);
	}
}

/* src/components/widgets/Visualiser.svelte generated by Svelte v3.31.0 */

function add_css$D() {
	var style = element("style");
	style.id = "svelte-10y0e9v-style";
	style.textContent = "canvas.svelte-10y0e9v{background-color:rgb(16, 16, 16);height:100%;width:100%;visibility:visible;border-radius:1px;vertical-align:baseline}";
	append(document.head, style);
}

function create_fragment$O(ctx) {
	let canvas_1;

	return {
		c() {
			canvas_1 = element("canvas");
			attr(canvas_1, "class", "canvas svelte-10y0e9v");
		},
		m(target, anchor) {
			insert(target, canvas_1, anchor);
			/*canvas_1_binding*/ ctx[12](canvas_1);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(canvas_1);
			/*canvas_1_binding*/ ctx[12](null);
		}
	};
}

function instance$N($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let engine;
	let messaging = new PubSub();
	let { id } = $$props;
	let { name } = $$props;
	let { type } = $$props;
	let { mode } = $$props;
	let { hasFocus } = $$props;
	let { background } = $$props;
	let { lineNumbers } = $$props;
	let { theme } = $$props;
	let { component } = $$props;
	let { channelID = 1 } = $$props;
	let { class: className } = $$props;

	let frequencyBinCount = 128,
		frequencyBinCounter = 128,
		frequencyDataArray = [],
		timeDataArray = [],
		shift = false;

	let canvas;
	let frame;
	let isRendering = true;

	const drawFrequencyData = drawContext => {
		for (let i = 0; i < frequencyBinCount; i++) {
			let value = frequencyDataArray[i];
			let percent = value / 255;
			let height = canvas.offsetHeight * percent;
			let offset = canvas.offsetHeight - height - 1;
			let barWidth = canvas.offsetWidth / frequencyBinCount;
			let hue = i / frequencyBinCount * 255;
			drawContext.fillStyle = "hsl(" + hue + ", 100%, 75%)";
			drawContext.fillRect(i * barWidth, offset, barWidth, canvas.offsetHeight);
		}
	};

	const drawTimeData = drawContext => {
		for (let i = 0; i < frequencyBinCount; i++) {
			let value = timeDataArray[i];
			let percent = value;
			let height = canvas.offsetHeight * percent;
			let offset = canvas.offsetHeight - height - 1;
			let barWidth = canvas.offsetWidth / frequencyBinCount;
			drawContext.fillStyle = "white";
			drawContext.fillRect(i * barWidth, offset, barWidth, 2);
		}
	};

	const renderLoop = () => {
		if (isRendering) {
			frame = requestAnimationFrame(renderLoop);
			let drawContext = canvas.getContext("2d");
			drawContext.canvas.width = canvas.offsetWidth; // needed for 'automatic' resizing the canvas to current size
			drawContext.canvas.height = canvas.offsetHeight; // TODO: Optimise by doing this only on canvas resize call
			drawContext.clearRect(0, 0, canvas.offsetWidth, canvas.offsetHeight);
			sabRender();

			if (mode === "oscilloscope") {
				drawTimeData(drawContext);
			} else if (mode === "spectrogram") drawFrequencyData(drawContext); else {
				drawFrequencyData(drawContext);
				drawTimeData(drawContext);
			}
		} else return;
	};

	function sabRender() {
		try {
			// for (let v in engine.sharedArrayBuffers) {
			if (engine.sharedArrayBuffers[channelID].ttype === "scope") {
				let avail = engine.sharedArrayBuffers[channelID].rb.available_read();

				if (avail > 0 && avail != engine.sharedArrayBuffers[channelID].rb.capacity) {
					for (let i = 0; i < avail; i += engine.sharedArrayBuffers[channelID].blocksize) {
						let val = new Float64Array(engine.sharedArrayBuffers[channelID].blocksize);

						!shift && 0 === frequencyBinCounter--
						? shift = true
						: undefined;

						shift ? timeDataArray.shift() : undefined;
						timeDataArray.push(val);
						engine.sharedArrayBuffers[channelID].rb.pop(val);
					}
				}
			}
		} catch(error) {
			console.error("ERROR on sabRender");
		}
	}

	const toggleRendering = () => {
		console.log("toggleRender");

		if (isRendering) {
			cancelAnimationFrame(frame);
		} else {
			frame = requestAnimationFrame(renderLoop);
		}

		isRendering = !isRendering;
		$$invalidate(1, hasFocus = true);
		console.log("click");
		dispatch("change", { prop: "hasFocus", value: true });
	};

	onMount(async () => {
		if (!engine) {
			engine = new Engine$1();
		}

		// sabRender()
		// Request the creation of an WAAPI analyser to the Audio Engine
		// messaging.publish("add-engine-analyser", { id } );
		canvas.addEventListener("click", () => toggleRendering(), false);

		renderLoop();
	});

	onDestroy(async () => {
		isRendering = false;
		return () => cancelAnimationFrame(frame);
	});

	function canvas_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			canvas = $$value;
			$$invalidate(0, canvas);
		});
	}

	$$self.$$set = $$props => {
		if ("id" in $$props) $$invalidate(2, id = $$props.id);
		if ("name" in $$props) $$invalidate(3, name = $$props.name);
		if ("type" in $$props) $$invalidate(4, type = $$props.type);
		if ("mode" in $$props) $$invalidate(5, mode = $$props.mode);
		if ("hasFocus" in $$props) $$invalidate(1, hasFocus = $$props.hasFocus);
		if ("background" in $$props) $$invalidate(6, background = $$props.background);
		if ("lineNumbers" in $$props) $$invalidate(7, lineNumbers = $$props.lineNumbers);
		if ("theme" in $$props) $$invalidate(8, theme = $$props.theme);
		if ("component" in $$props) $$invalidate(9, component = $$props.component);
		if ("channelID" in $$props) $$invalidate(10, channelID = $$props.channelID);
		if ("class" in $$props) $$invalidate(11, className = $$props.class);
	};

	return [
		canvas,
		hasFocus,
		id,
		name,
		type,
		mode,
		background,
		lineNumbers,
		theme,
		component,
		channelID,
		className,
		canvas_1_binding
	];
}

class Visualiser extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-10y0e9v-style")) add_css$D();

		init(
			this,
			options,
			instance$N,
			create_fragment$O,
			safe_not_equal,
			{
				id: 2,
				name: 3,
				type: 4,
				mode: 5,
				hasFocus: 1,
				background: 6,
				lineNumbers: 7,
				theme: 8,
				component: 9,
				channelID: 10,
				class: 11
			},
			[-1, -1]
		);
	}
}

var webmidi_min = createCommonjsModule(function (module) {
/*

WebMidi v2.5.2

WebMidi.js helps you tame the Web MIDI API. Send and receive MIDI messages with ease. Control instruments with user-friendly functions (playNote, sendPitchBend, etc.). React to MIDI input with simple event listeners (noteon, pitchbend, controlchange, etc.).
https://github.com/djipco/webmidi


The MIT License (MIT)

Copyright (c) 2015-2019, Jean-Philippe Ct

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
associated documentation files (the "Software"), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify, merge, publish, distribute,
sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial
portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/


!function(scope){function WebMidi(){if(WebMidi.prototype._singleton)throw new Error("WebMidi is a singleton, it cannot be instantiated directly.");(WebMidi.prototype._singleton=this)._inputs=[],this._outputs=[],this._userHandlers={},this._stateChangeQueue=[],this._processingStateChange=!1,this._midiInterfaceEvents=["connected","disconnected"],this._nrpnBuffer=[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],this._nrpnEventsEnabled=!0,this._nrpnTypes=["entry","increment","decrement"],this._notes=["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"],this._semitones={C:0,D:2,E:4,F:5,G:7,A:9,B:11},Object.defineProperties(this,{MIDI_SYSTEM_MESSAGES:{value:{sysex:240,timecode:241,songposition:242,songselect:243,tuningrequest:246,sysexend:247,clock:248,start:250,continue:251,stop:252,activesensing:254,reset:255,midimessage:0,unknownsystemmessage:-1},writable:!1,enumerable:!0,configurable:!1},MIDI_CHANNEL_MESSAGES:{value:{noteoff:8,noteon:9,keyaftertouch:10,controlchange:11,channelmode:11,nrpn:11,programchange:12,channelaftertouch:13,pitchbend:14},writable:!1,enumerable:!0,configurable:!1},MIDI_REGISTERED_PARAMETER:{value:{pitchbendrange:[0,0],channelfinetuning:[0,1],channelcoarsetuning:[0,2],tuningprogram:[0,3],tuningbank:[0,4],modulationrange:[0,5],azimuthangle:[61,0],elevationangle:[61,1],gain:[61,2],distanceratio:[61,3],maximumdistance:[61,4],maximumdistancegain:[61,5],referencedistanceratio:[61,6],panspreadangle:[61,7],rollangle:[61,8]},writable:!1,enumerable:!0,configurable:!1},MIDI_CONTROL_CHANGE_MESSAGES:{value:{bankselectcoarse:0,modulationwheelcoarse:1,breathcontrollercoarse:2,footcontrollercoarse:4,portamentotimecoarse:5,dataentrycoarse:6,volumecoarse:7,balancecoarse:8,pancoarse:10,expressioncoarse:11,effectcontrol1coarse:12,effectcontrol2coarse:13,generalpurposeslider1:16,generalpurposeslider2:17,generalpurposeslider3:18,generalpurposeslider4:19,bankselectfine:32,modulationwheelfine:33,breathcontrollerfine:34,footcontrollerfine:36,portamentotimefine:37,dataentryfine:38,volumefine:39,balancefine:40,panfine:42,expressionfine:43,effectcontrol1fine:44,effectcontrol2fine:45,holdpedal:64,portamento:65,sustenutopedal:66,softpedal:67,legatopedal:68,hold2pedal:69,soundvariation:70,resonance:71,soundreleasetime:72,soundattacktime:73,brightness:74,soundcontrol6:75,soundcontrol7:76,soundcontrol8:77,soundcontrol9:78,soundcontrol10:79,generalpurposebutton1:80,generalpurposebutton2:81,generalpurposebutton3:82,generalpurposebutton4:83,reverblevel:91,tremololevel:92,choruslevel:93,celestelevel:94,phaserlevel:95,databuttonincrement:96,databuttondecrement:97,nonregisteredparametercoarse:98,nonregisteredparameterfine:99,registeredparametercoarse:100,registeredparameterfine:101},writable:!1,enumerable:!0,configurable:!1},MIDI_NRPN_MESSAGES:{value:{entrymsb:6,entrylsb:38,increment:96,decrement:97,paramlsb:98,parammsb:99,nullactiveparameter:127},writable:!1,enumerable:!0,configurable:!1},MIDI_CHANNEL_MODE_MESSAGES:{value:{allsoundoff:120,resetallcontrollers:121,localcontrol:122,allnotesoff:123,omnimodeoff:124,omnimodeon:125,monomodeon:126,polymodeon:127},writable:!1,enumerable:!0,configurable:!1},octaveOffset:{value:0,writable:!0,enumerable:!0,configurable:!1}}),Object.defineProperties(this,{supported:{enumerable:!0,get:function(){return "requestMIDIAccess"in navigator}},enabled:{enumerable:!0,get:function(){return void 0!==this.interface}.bind(this)},inputs:{enumerable:!0,get:function(){return this._inputs}.bind(this)},outputs:{enumerable:!0,get:function(){return this._outputs}.bind(this)},sysexEnabled:{enumerable:!0,get:function(){return !(!this.interface||!this.interface.sysexEnabled)}.bind(this)},nrpnEventsEnabled:{enumerable:!0,get:function(){return !!this._nrpnEventsEnabled}.bind(this),set:function(enabled){return this._nrpnEventsEnabled=enabled,this._nrpnEventsEnabled}},nrpnTypes:{enumerable:!0,get:function(){return this._nrpnTypes}.bind(this)},time:{enumerable:!0,get:function(){return performance.now()}}});}var wm=new WebMidi;function Input(midiInput){var that=this;this._userHandlers={channel:{},system:{}},this._midiInput=midiInput,Object.defineProperties(this,{connection:{enumerable:!0,get:function(){return that._midiInput.connection}},id:{enumerable:!0,get:function(){return that._midiInput.id}},manufacturer:{enumerable:!0,get:function(){return that._midiInput.manufacturer}},name:{enumerable:!0,get:function(){return that._midiInput.name}},state:{enumerable:!0,get:function(){return that._midiInput.state}},type:{enumerable:!0,get:function(){return that._midiInput.type}}}),this._initializeUserHandlers(),this._midiInput.onmidimessage=this._onMidiMessage.bind(this);}function Output(midiOutput){var that=this;this._midiOutput=midiOutput,Object.defineProperties(this,{connection:{enumerable:!0,get:function(){return that._midiOutput.connection}},id:{enumerable:!0,get:function(){return that._midiOutput.id}},manufacturer:{enumerable:!0,get:function(){return that._midiOutput.manufacturer}},name:{enumerable:!0,get:function(){return that._midiOutput.name}},state:{enumerable:!0,get:function(){return that._midiOutput.state}},type:{enumerable:!0,get:function(){return that._midiOutput.type}}});}WebMidi.prototype.enable=function(callback,sysex){this.enabled||(this.supported?navigator.requestMIDIAccess({sysex:sysex}).then(function(midiAccess){var promiseTimeout,events=[],promises=[];this.interface=midiAccess,this._resetInterfaceUserHandlers(),this.interface.onstatechange=function(e){events.push(e);};for(var inputs=midiAccess.inputs.values(),input=inputs.next();input&&!input.done;input=inputs.next())promises.push(input.value.open());for(var outputs=midiAccess.outputs.values(),output=outputs.next();output&&!output.done;output=outputs.next())promises.push(output.value.open());function onPortsOpen(){clearTimeout(promiseTimeout),this._updateInputsAndOutputs(),this.interface.onstatechange=this._onInterfaceStateChange.bind(this),"function"==typeof callback&&callback.call(this),events.forEach(function(event){this._onInterfaceStateChange(event);}.bind(this));}promiseTimeout=setTimeout(onPortsOpen.bind(this),200),Promise&&Promise.all(promises).catch(function(err){}).then(onPortsOpen.bind(this));}.bind(this),function(err){"function"==typeof callback&&callback.call(this,err);}.bind(this)):"function"==typeof callback&&callback(new Error("The Web MIDI API is not supported by your browser.")));},WebMidi.prototype.disable=function(){if(!this.supported)throw new Error("The Web MIDI API is not supported by your browser.");this.enabled&&(this.removeListener(),this.inputs.forEach(function(input){input.removeListener();})),this.interface&&(this.interface.onstatechange=void 0),this.interface=void 0,this._inputs=[],this._outputs=[],this._nrpnEventsEnabled=!0,this._resetInterfaceUserHandlers();},WebMidi.prototype.addListener=function(type,listener){if(!this.enabled)throw new Error("WebMidi must be enabled before adding event listeners.");if("function"!=typeof listener)throw new TypeError("The 'listener' parameter must be a function.");if(!(0<=this._midiInterfaceEvents.indexOf(type)))throw new TypeError("The specified event type is not supported.");return this._userHandlers[type].push(listener),this},WebMidi.prototype.hasListener=function(type,listener){if(!this.enabled)throw new Error("WebMidi must be enabled before checking event listeners.");if("function"!=typeof listener)throw new TypeError("The 'listener' parameter must be a function.");if(!(0<=this._midiInterfaceEvents.indexOf(type)))throw new TypeError("The specified event type is not supported.");for(var o=0;o<this._userHandlers[type].length;o++)if(this._userHandlers[type][o]===listener)return !0;return !1},WebMidi.prototype.removeListener=function(type,listener){if(!this.enabled)throw new Error("WebMidi must be enabled before removing event listeners.");if(void 0!==listener&&"function"!=typeof listener)throw new TypeError("The 'listener' parameter must be a function.");if(0<=this._midiInterfaceEvents.indexOf(type))if(listener)for(var o=0;o<this._userHandlers[type].length;o++)this._userHandlers[type][o]===listener&&this._userHandlers[type].splice(o,1);else this._userHandlers[type]=[];else {if(void 0!==type)throw new TypeError("The specified event type is not supported.");this._resetInterfaceUserHandlers();}return this},WebMidi.prototype.toMIDIChannels=function(channel){var channels;if("all"===channel||void 0===channel)channels=["all"];else {if("none"===channel)return channels=[];channels=Array.isArray(channel)?channel:[channel];}return -1<channels.indexOf("all")&&(channels=[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]),channels.map(function(ch){return parseInt(ch)}).filter(function(ch){return 1<=ch&&ch<=16})},WebMidi.prototype.getInputById=function(id){if(!this.enabled)throw new Error("WebMidi is not enabled.");id=String(id);for(var i=0;i<this.inputs.length;i++)if(this.inputs[i].id===id)return this.inputs[i];return !1},WebMidi.prototype.getOutputById=function(id){if(!this.enabled)throw new Error("WebMidi is not enabled.");id=String(id);for(var i=0;i<this.outputs.length;i++)if(this.outputs[i].id===id)return this.outputs[i];return !1},WebMidi.prototype.getInputByName=function(name){if(!this.enabled)throw new Error("WebMidi is not enabled.");for(var i=0;i<this.inputs.length;i++)if(~this.inputs[i].name.indexOf(name))return this.inputs[i];return !1},WebMidi.prototype.getOctave=function(number){if(null!=number&&0<=number&&number<=127)return Math.floor(Math.floor(number)/12-1)+Math.floor(wm.octaveOffset)},WebMidi.prototype.getOutputByName=function(name){if(!this.enabled)throw new Error("WebMidi is not enabled.");for(var i=0;i<this.outputs.length;i++)if(~this.outputs[i].name.indexOf(name))return this.outputs[i];return !1},WebMidi.prototype.guessNoteNumber=function(input){var output=!1;if(input&&input.toFixed&&0<=input&&input<=127?output=Math.round(input):0<=parseInt(input)&&parseInt(input)<=127?output=parseInt(input):("string"==typeof input||input instanceof String)&&(output=this.noteNameToNumber(input)),!1===output)throw new Error("Invalid input value ("+input+").");return output},WebMidi.prototype.noteNameToNumber=function(name){"string"!=typeof name&&(name="");var matches=name.match(/([CDEFGAB])(#{0,2}|b{0,2})(-?\d+)/i);if(!matches)throw new RangeError("Invalid note name.");var semitones=wm._semitones[matches[1].toUpperCase()],result=12*(parseInt(matches[3])+1-Math.floor(wm.octaveOffset))+semitones;if(-1<matches[2].toLowerCase().indexOf("b")?result-=matches[2].length:-1<matches[2].toLowerCase().indexOf("#")&&(result+=matches[2].length),result<0||127<result)throw new RangeError("Invalid note name or note outside valid range.");return result},WebMidi.prototype._updateInputsAndOutputs=function(){this._updateInputs(),this._updateOutputs();},WebMidi.prototype._updateInputs=function(){for(var i=0;i<this._inputs.length;i++){for(var remove=!0,updated=this.interface.inputs.values(),input=updated.next();input&&!input.done;input=updated.next())if(this._inputs[i]._midiInput===input.value){remove=!1;break}remove&&this._inputs.splice(i,1);}this.interface&&this.interface.inputs.forEach(function(nInput){for(var add=!0,j=0;j<this._inputs.length;j++)this._inputs[j]._midiInput===nInput&&(add=!1);add&&this._inputs.push(new Input(nInput));}.bind(this));},WebMidi.prototype._updateOutputs=function(){for(var i=0;i<this._outputs.length;i++){for(var remove=!0,updated=this.interface.outputs.values(),output=updated.next();output&&!output.done;output=updated.next())if(this._outputs[i]._midiOutput===output.value){remove=!1;break}remove&&this._outputs.splice(i,1);}this.interface&&this.interface.outputs.forEach(function(nOutput){for(var add=!0,j=0;j<this._outputs.length;j++)this._outputs[j]._midiOutput===nOutput&&(add=!1);add&&this._outputs.push(new Output(nOutput));}.bind(this));},WebMidi.prototype._onInterfaceStateChange=function(e){this._updateInputsAndOutputs();var event={timestamp:e.timeStamp,type:e.port.state};this.interface&&"connected"===e.port.state?"output"===e.port.type?event.port=this.getOutputById(e.port.id):"input"===e.port.type&&(event.port=this.getInputById(e.port.id)):event.port={connection:"closed",id:e.port.id,manufacturer:e.port.manufacturer,name:e.port.name,state:e.port.state,type:e.port.type},this._userHandlers[e.port.state].forEach(function(handler){handler(event);});},WebMidi.prototype._resetInterfaceUserHandlers=function(){for(var i=0;i<this._midiInterfaceEvents.length;i++)this._userHandlers[this._midiInterfaceEvents[i]]=[];},Input.prototype.on=Input.prototype.addListener=function(type,channel,listener){var that=this;if(void 0===channel&&(channel="all"),Array.isArray(channel)||(channel=[channel]),channel.forEach(function(item){if("all"!==item&&!(1<=item&&item<=16))throw new RangeError("The 'channel' parameter is invalid.")}),"function"!=typeof listener)throw new TypeError("The 'listener' parameter must be a function.");if(void 0!==wm.MIDI_SYSTEM_MESSAGES[type])this._userHandlers.system[type]||(this._userHandlers.system[type]=[]),this._userHandlers.system[type].push(listener);else {if(void 0===wm.MIDI_CHANNEL_MESSAGES[type])throw new TypeError("The specified event type is not supported.");if(-1<channel.indexOf("all")){channel=[];for(var j=1;j<=16;j++)channel.push(j);}this._userHandlers.channel[type]||(this._userHandlers.channel[type]=[]),channel.forEach(function(ch){that._userHandlers.channel[type][ch]||(that._userHandlers.channel[type][ch]=[]),that._userHandlers.channel[type][ch].push(listener);});}return this},Input.prototype.hasListener=function(type,channel,listener){var that=this;if("function"!=typeof listener)throw new TypeError("The 'listener' parameter must be a function.");if(void 0===channel&&(channel="all"),channel.constructor!==Array&&(channel=[channel]),void 0!==wm.MIDI_SYSTEM_MESSAGES[type]){for(var o=0;o<this._userHandlers.system[type].length;o++)if(this._userHandlers.system[type][o]===listener)return !0}else if(void 0!==wm.MIDI_CHANNEL_MESSAGES[type]){if(-1<channel.indexOf("all")){channel=[];for(var j=1;j<=16;j++)channel.push(j);}return !!this._userHandlers.channel[type]&&channel.every(function(chNum){var listeners=that._userHandlers.channel[type][chNum];return listeners&&-1<listeners.indexOf(listener)})}return !1},Input.prototype.removeListener=function(type,channel,listener){var that=this;if(void 0!==listener&&"function"!=typeof listener)throw new TypeError("The 'listener' parameter must be a function.");if(void 0===channel&&(channel="all"),channel.constructor!==Array&&(channel=[channel]),void 0!==wm.MIDI_SYSTEM_MESSAGES[type])if(void 0===listener)this._userHandlers.system[type]=[];else for(var o=0;o<this._userHandlers.system[type].length;o++)this._userHandlers.system[type][o]===listener&&this._userHandlers.system[type].splice(o,1);else if(void 0!==wm.MIDI_CHANNEL_MESSAGES[type]){if(-1<channel.indexOf("all")){channel=[];for(var j=1;j<=16;j++)channel.push(j);}if(!this._userHandlers.channel[type])return this;channel.forEach(function(chNum){var listeners=that._userHandlers.channel[type][chNum];if(listeners)if(void 0===listener)that._userHandlers.channel[type][chNum]=[];else for(var l=0;l<listeners.length;l++)listeners[l]===listener&&listeners.splice(l,1);});}else {if(void 0!==type)throw new TypeError("The specified event type is not supported.");this._initializeUserHandlers();}return this},Input.prototype._initializeUserHandlers=function(){for(var prop1 in wm.MIDI_CHANNEL_MESSAGES)Object.prototype.hasOwnProperty.call(wm.MIDI_CHANNEL_MESSAGES,prop1)&&(this._userHandlers.channel[prop1]={});for(var prop2 in wm.MIDI_SYSTEM_MESSAGES)Object.prototype.hasOwnProperty.call(wm.MIDI_SYSTEM_MESSAGES,prop2)&&(this._userHandlers.system[prop2]=[]);},Input.prototype._onMidiMessage=function(e){if(0<this._userHandlers.system.midimessage.length){var event={target:this,data:e.data,timestamp:e.timeStamp,type:"midimessage"};this._userHandlers.system.midimessage.forEach(function(callback){callback(event);});}e.data[0]<240?(this._parseChannelEvent(e),this._parseNrpnEvent(e)):e.data[0]<=255&&this._parseSystemEvent(e);},Input.prototype._parseNrpnEvent=function(e){var data1,data2,command=e.data[0]>>4,channelBufferIndex=15&e.data[0],channel=1+channelBufferIndex;if(1<e.data.length&&(data1=e.data[1],data2=2<e.data.length?e.data[2]:void 0),wm.nrpnEventsEnabled&&command===wm.MIDI_CHANNEL_MESSAGES.controlchange&&(data1>=wm.MIDI_NRPN_MESSAGES.increment&&data1<=wm.MIDI_NRPN_MESSAGES.parammsb||data1===wm.MIDI_NRPN_MESSAGES.entrymsb||data1===wm.MIDI_NRPN_MESSAGES.entrylsb)){var ccEvent={target:this,type:"controlchange",data:e.data,timestamp:e.timeStamp,channel:channel,controller:{number:data1,name:this.getCcNameByNumber(data1)},value:data2};if(ccEvent.controller.number===wm.MIDI_NRPN_MESSAGES.parammsb&&ccEvent.value!=wm.MIDI_NRPN_MESSAGES.nullactiveparameter)wm._nrpnBuffer[channelBufferIndex]=[],wm._nrpnBuffer[channelBufferIndex][0]=ccEvent;else if(1===wm._nrpnBuffer[channelBufferIndex].length&&ccEvent.controller.number===wm.MIDI_NRPN_MESSAGES.paramlsb)wm._nrpnBuffer[channelBufferIndex].push(ccEvent);else if(2!==wm._nrpnBuffer[channelBufferIndex].length||ccEvent.controller.number!==wm.MIDI_NRPN_MESSAGES.increment&&ccEvent.controller.number!==wm.MIDI_NRPN_MESSAGES.decrement&&ccEvent.controller.number!==wm.MIDI_NRPN_MESSAGES.entrymsb)if(3===wm._nrpnBuffer[channelBufferIndex].length&&wm._nrpnBuffer[channelBufferIndex][2].number===wm.MIDI_NRPN_MESSAGES.entrymsb&&ccEvent.controller.number===wm.MIDI_NRPN_MESSAGES.entrylsb)wm._nrpnBuffer[channelBufferIndex].push(ccEvent);else if(3<=wm._nrpnBuffer[channelBufferIndex].length&&wm._nrpnBuffer[channelBufferIndex].length<=4&&ccEvent.controller.number===wm.MIDI_NRPN_MESSAGES.parammsb&&ccEvent.value===wm.MIDI_NRPN_MESSAGES.nullactiveparameter)wm._nrpnBuffer[channelBufferIndex].push(ccEvent);else if(4<=wm._nrpnBuffer[channelBufferIndex].length&&wm._nrpnBuffer[channelBufferIndex].length<=5&&ccEvent.controller.number===wm.MIDI_NRPN_MESSAGES.paramlsb&&ccEvent.value===wm.MIDI_NRPN_MESSAGES.nullactiveparameter){wm._nrpnBuffer[channelBufferIndex].push(ccEvent);var rawData=[];wm._nrpnBuffer[channelBufferIndex].forEach(function(ev){rawData.push(ev.data);});var nrpnNumber=wm._nrpnBuffer[channelBufferIndex][0].value<<7|wm._nrpnBuffer[channelBufferIndex][1].value,nrpnValue=wm._nrpnBuffer[channelBufferIndex][2].value;6===wm._nrpnBuffer[channelBufferIndex].length&&(nrpnValue=wm._nrpnBuffer[channelBufferIndex][2].value<<7|wm._nrpnBuffer[channelBufferIndex][3].value);var nrpnControllerType="";switch(wm._nrpnBuffer[channelBufferIndex][2].controller.number){case wm.MIDI_NRPN_MESSAGES.entrymsb:nrpnControllerType=wm._nrpnTypes[0];break;case wm.MIDI_NRPN_MESSAGES.increment:nrpnControllerType=wm._nrpnTypes[1];break;case wm.MIDI_NRPN_MESSAGES.decrement:nrpnControllerType=wm._nrpnTypes[2];break;default:throw new Error("The NPRN type was unidentifiable.")}var nrpnEvent={timestamp:ccEvent.timestamp,channel:ccEvent.channel,type:"nrpn",data:rawData,controller:{number:nrpnNumber,type:nrpnControllerType,name:"Non-Registered Parameter "+nrpnNumber},value:nrpnValue};wm._nrpnBuffer[channelBufferIndex]=[],this._userHandlers.channel[nrpnEvent.type]&&this._userHandlers.channel[nrpnEvent.type][nrpnEvent.channel]&&this._userHandlers.channel[nrpnEvent.type][nrpnEvent.channel].forEach(function(callback){callback(nrpnEvent);});}else wm._nrpnBuffer[channelBufferIndex]=[];else wm._nrpnBuffer[channelBufferIndex].push(ccEvent);}},Input.prototype._parseChannelEvent=function(e){var data1,data2,command=e.data[0]>>4,channel=1+(15&e.data[0]);1<e.data.length&&(data1=e.data[1],data2=2<e.data.length?e.data[2]:void 0);var event={target:this,data:e.data,timestamp:e.timeStamp,channel:channel};command===wm.MIDI_CHANNEL_MESSAGES.noteoff||command===wm.MIDI_CHANNEL_MESSAGES.noteon&&0===data2?(event.type="noteoff",event.note={number:data1,name:wm._notes[data1%12],octave:wm.getOctave(data1)},event.velocity=data2/127,event.rawVelocity=data2):command===wm.MIDI_CHANNEL_MESSAGES.noteon?(event.type="noteon",event.note={number:data1,name:wm._notes[data1%12],octave:wm.getOctave(data1)},event.velocity=data2/127,event.rawVelocity=data2):command===wm.MIDI_CHANNEL_MESSAGES.keyaftertouch?(event.type="keyaftertouch",event.note={number:data1,name:wm._notes[data1%12],octave:wm.getOctave(data1)},event.value=data2/127):command===wm.MIDI_CHANNEL_MESSAGES.controlchange&&0<=data1&&data1<=119?(event.type="controlchange",event.controller={number:data1,name:this.getCcNameByNumber(data1)},event.value=data2):command===wm.MIDI_CHANNEL_MESSAGES.channelmode&&120<=data1&&data1<=127?(event.type="channelmode",event.controller={number:data1,name:this.getChannelModeByNumber(data1)},event.value=data2):command===wm.MIDI_CHANNEL_MESSAGES.programchange?(event.type="programchange",event.value=data1):command===wm.MIDI_CHANNEL_MESSAGES.channelaftertouch?(event.type="channelaftertouch",event.value=data1/127):command===wm.MIDI_CHANNEL_MESSAGES.pitchbend?(event.type="pitchbend",event.value=((data2<<7)+data1-8192)/8192):event.type="unknownchannelmessage",this._userHandlers.channel[event.type]&&this._userHandlers.channel[event.type][channel]&&this._userHandlers.channel[event.type][channel].forEach(function(callback){callback(event);});},Input.prototype.getCcNameByNumber=function(number){if(!(0<=(number=Math.floor(number))&&number<=119))throw new RangeError("The control change number must be between 0 and 119.");for(var cc in wm.MIDI_CONTROL_CHANGE_MESSAGES)if(Object.prototype.hasOwnProperty.call(wm.MIDI_CONTROL_CHANGE_MESSAGES,cc)&&number===wm.MIDI_CONTROL_CHANGE_MESSAGES[cc])return cc},Input.prototype.getChannelModeByNumber=function(number){if(!(120<=(number=Math.floor(number))&&status<=127))throw new RangeError("The control change number must be between 120 and 127.");for(var cm in wm.MIDI_CHANNEL_MODE_MESSAGES)if(Object.prototype.hasOwnProperty.call(wm.MIDI_CHANNEL_MODE_MESSAGES,cm)&&number===wm.MIDI_CHANNEL_MODE_MESSAGES[cm])return cm},Input.prototype._parseSystemEvent=function(e){var command=e.data[0],event={target:this,data:e.data,timestamp:e.timeStamp};command===wm.MIDI_SYSTEM_MESSAGES.sysex?event.type="sysex":command===wm.MIDI_SYSTEM_MESSAGES.timecode?event.type="timecode":command===wm.MIDI_SYSTEM_MESSAGES.songposition?event.type="songposition":command===wm.MIDI_SYSTEM_MESSAGES.songselect?(event.type="songselect",event.song=e.data[1]):command===wm.MIDI_SYSTEM_MESSAGES.tuningrequest?event.type="tuningrequest":command===wm.MIDI_SYSTEM_MESSAGES.clock?event.type="clock":command===wm.MIDI_SYSTEM_MESSAGES.start?event.type="start":command===wm.MIDI_SYSTEM_MESSAGES.continue?event.type="continue":command===wm.MIDI_SYSTEM_MESSAGES.stop?event.type="stop":command===wm.MIDI_SYSTEM_MESSAGES.activesensing?event.type="activesensing":command===wm.MIDI_SYSTEM_MESSAGES.reset?event.type="reset":event.type="unknownsystemmessage",this._userHandlers.system[event.type]&&this._userHandlers.system[event.type].forEach(function(callback){callback(event);});},Output.prototype.send=function(status,data,timestamp){if(!(128<=status&&status<=255))throw new RangeError("The status byte must be an integer between 128 (0x80) and 255 (0xFF).");void 0===data&&(data=[]),Array.isArray(data)||(data=[data]);var message=[];return data.forEach(function(item){var parsed=Math.floor(item);if(!(0<=parsed&&parsed<=255))throw new RangeError("Data bytes must be integers between 0 (0x00) and 255 (0xFF).");message.push(parsed);}),this._midiOutput.send([status].concat(message),parseFloat(timestamp)||0),this},Output.prototype.sendSysex=function(manufacturer,data,options){if(!wm.sysexEnabled)throw new Error("Sysex message support must first be activated.");return options=options||{},manufacturer=[].concat(manufacturer),data.forEach(function(item){if(item<0||127<item)throw new RangeError("The data bytes of a sysex message must be integers between 0 (0x00) and 127 (0x7F).")}),data=manufacturer.concat(data,wm.MIDI_SYSTEM_MESSAGES.sysexend),this.send(wm.MIDI_SYSTEM_MESSAGES.sysex,data,this._parseTimeParameter(options.time)),this},Output.prototype.sendTimecodeQuarterFrame=function(value,options){return options=options||{},this.send(wm.MIDI_SYSTEM_MESSAGES.timecode,value,this._parseTimeParameter(options.time)),this},Output.prototype.sendSongPosition=function(value,options){options=options||{};var msb=(value=Math.floor(value)||0)>>7&127,lsb=127&value;return this.send(wm.MIDI_SYSTEM_MESSAGES.songposition,[msb,lsb],this._parseTimeParameter(options.time)),this},Output.prototype.sendSongSelect=function(value,options){if(options=options||{},!(0<=(value=Math.floor(value))&&value<=127))throw new RangeError("The song number must be between 0 and 127.");return this.send(wm.MIDI_SYSTEM_MESSAGES.songselect,[value],this._parseTimeParameter(options.time)),this},Output.prototype.sendTuningRequest=function(options){return options=options||{},this.send(wm.MIDI_SYSTEM_MESSAGES.tuningrequest,void 0,this._parseTimeParameter(options.time)),this},Output.prototype.sendClock=function(options){return options=options||{},this.send(wm.MIDI_SYSTEM_MESSAGES.clock,void 0,this._parseTimeParameter(options.time)),this},Output.prototype.sendStart=function(options){return options=options||{},this.send(wm.MIDI_SYSTEM_MESSAGES.start,void 0,this._parseTimeParameter(options.time)),this},Output.prototype.sendContinue=function(options){return options=options||{},this.send(wm.MIDI_SYSTEM_MESSAGES.continue,void 0,this._parseTimeParameter(options.time)),this},Output.prototype.sendStop=function(options){return options=options||{},this.send(wm.MIDI_SYSTEM_MESSAGES.stop,void 0,this._parseTimeParameter(options.time)),this},Output.prototype.sendActiveSensing=function(options){return options=options||{},this.send(wm.MIDI_SYSTEM_MESSAGES.activesensing,[],this._parseTimeParameter(options.time)),this},Output.prototype.sendReset=function(options){return options=options||{},this.send(wm.MIDI_SYSTEM_MESSAGES.reset,void 0,this._parseTimeParameter(options.time)),this},Output.prototype.stopNote=function(note,channel,options){if("all"===note)return this.sendChannelMode("allnotesoff",0,channel,options);var nVelocity=64;return (options=options||{}).rawVelocity?!isNaN(options.velocity)&&0<=options.velocity&&options.velocity<=127&&(nVelocity=options.velocity):!isNaN(options.velocity)&&0<=options.velocity&&options.velocity<=1&&(nVelocity=127*options.velocity),this._convertNoteToArray(note).forEach(function(item){wm.toMIDIChannels(channel).forEach(function(ch){this.send((wm.MIDI_CHANNEL_MESSAGES.noteoff<<4)+(ch-1),[item,Math.round(nVelocity)],this._parseTimeParameter(options.time));}.bind(this));}.bind(this)),this},Output.prototype.playNote=function(note,channel,options){var time,nVelocity=64;if((options=options||{}).rawVelocity?!isNaN(options.velocity)&&0<=options.velocity&&options.velocity<=127&&(nVelocity=options.velocity):!isNaN(options.velocity)&&0<=options.velocity&&options.velocity<=1&&(nVelocity=127*options.velocity),time=this._parseTimeParameter(options.time),this._convertNoteToArray(note).forEach(function(item){wm.toMIDIChannels(channel).forEach(function(ch){this.send((wm.MIDI_CHANNEL_MESSAGES.noteon<<4)+(ch-1),[item,Math.round(nVelocity)],time);}.bind(this));}.bind(this)),!isNaN(options.duration)){options.duration<=0&&(options.duration=0);var nRelease=64;options.rawVelocity?!isNaN(options.release)&&0<=options.release&&options.release<=127&&(nRelease=options.release):!isNaN(options.release)&&0<=options.release&&options.release<=1&&(nRelease=127*options.release),this._convertNoteToArray(note).forEach(function(item){wm.toMIDIChannels(channel).forEach(function(ch){this.send((wm.MIDI_CHANNEL_MESSAGES.noteoff<<4)+(ch-1),[item,Math.round(nRelease)],(time||wm.time)+options.duration);}.bind(this));}.bind(this));}return this},Output.prototype.sendKeyAftertouch=function(note,channel,pressure,options){var that=this;if(options=options||{},channel<1||16<channel)throw new RangeError("The channel must be between 1 and 16.");(isNaN(pressure)||pressure<0||1<pressure)&&(pressure=.5);var nPressure=Math.round(127*pressure);return this._convertNoteToArray(note).forEach(function(item){wm.toMIDIChannels(channel).forEach(function(ch){that.send((wm.MIDI_CHANNEL_MESSAGES.keyaftertouch<<4)+(ch-1),[item,nPressure],that._parseTimeParameter(options.time));});}),this},Output.prototype.sendControlChange=function(controller,value,channel,options){if(options=options||{},"string"==typeof controller){if(void 0===(controller=wm.MIDI_CONTROL_CHANGE_MESSAGES[controller]))throw new TypeError("Invalid controller name.")}else if(!(0<=(controller=Math.floor(controller))&&controller<=119))throw new RangeError("Controller numbers must be between 0 and 119.");if(!(0<=(value=Math.floor(value)||0)&&value<=127))throw new RangeError("Controller value must be between 0 and 127.");return wm.toMIDIChannels(channel).forEach(function(ch){this.send((wm.MIDI_CHANNEL_MESSAGES.controlchange<<4)+(ch-1),[controller,value],this._parseTimeParameter(options.time));}.bind(this)),this},Output.prototype._selectRegisteredParameter=function(parameter,channel,time){var that=this;if(parameter[0]=Math.floor(parameter[0]),!(0<=parameter[0]&&parameter[0]<=127))throw new RangeError("The control65 value must be between 0 and 127");if(parameter[1]=Math.floor(parameter[1]),!(0<=parameter[1]&&parameter[1]<=127))throw new RangeError("The control64 value must be between 0 and 127");return wm.toMIDIChannels(channel).forEach(function(){that.sendControlChange(101,parameter[0],channel,{time:time}),that.sendControlChange(100,parameter[1],channel,{time:time});}),this},Output.prototype._selectNonRegisteredParameter=function(parameter,channel,time){var that=this;if(parameter[0]=Math.floor(parameter[0]),!(0<=parameter[0]&&parameter[0]<=127))throw new RangeError("The control63 value must be between 0 and 127");if(parameter[1]=Math.floor(parameter[1]),!(0<=parameter[1]&&parameter[1]<=127))throw new RangeError("The control62 value must be between 0 and 127");return wm.toMIDIChannels(channel).forEach(function(){that.sendControlChange(99,parameter[0],channel,{time:time}),that.sendControlChange(98,parameter[1],channel,{time:time});}),this},Output.prototype._setCurrentRegisteredParameter=function(data,channel,time){var that=this;if((data=[].concat(data))[0]=Math.floor(data[0]),!(0<=data[0]&&data[0]<=127))throw new RangeError("The msb value must be between 0 and 127");return wm.toMIDIChannels(channel).forEach(function(){that.sendControlChange(6,data[0],channel,{time:time});}),data[1]=Math.floor(data[1]),0<=data[1]&&data[1]<=127&&wm.toMIDIChannels(channel).forEach(function(){that.sendControlChange(38,data[1],channel,{time:time});}),this},Output.prototype._deselectRegisteredParameter=function(channel,time){var that=this;return wm.toMIDIChannels(channel).forEach(function(){that.sendControlChange(101,127,channel,{time:time}),that.sendControlChange(100,127,channel,{time:time});}),this},Output.prototype.setRegisteredParameter=function(parameter,data,channel,options){var that=this;if(options=options||{},!Array.isArray(parameter)){if(!wm.MIDI_REGISTERED_PARAMETER[parameter])throw new Error("The specified parameter is not available.");parameter=wm.MIDI_REGISTERED_PARAMETER[parameter];}return wm.toMIDIChannels(channel).forEach(function(){that._selectRegisteredParameter(parameter,channel,options.time),that._setCurrentRegisteredParameter(data,channel,options.time),that._deselectRegisteredParameter(channel,options.time);}),this},Output.prototype.setNonRegisteredParameter=function(parameter,data,channel,options){var that=this;if(options=options||{},!(0<=parameter[0]&&parameter[0]<=127&&0<=parameter[1]&&parameter[1]<=127))throw new Error("Position 0 and 1 of the 2-position parameter array must both be between 0 and 127.");return data=[].concat(data),wm.toMIDIChannels(channel).forEach(function(){that._selectNonRegisteredParameter(parameter,channel,options.time),that._setCurrentRegisteredParameter(data,channel,options.time),that._deselectRegisteredParameter(channel,options.time);}),this},Output.prototype.incrementRegisteredParameter=function(parameter,channel,options){var that=this;if(options=options||{},!Array.isArray(parameter)){if(!wm.MIDI_REGISTERED_PARAMETER[parameter])throw new Error("The specified parameter is not available.");parameter=wm.MIDI_REGISTERED_PARAMETER[parameter];}return wm.toMIDIChannels(channel).forEach(function(){that._selectRegisteredParameter(parameter,channel,options.time),that.sendControlChange(96,0,channel,{time:options.time}),that._deselectRegisteredParameter(channel,options.time);}),this},Output.prototype.decrementRegisteredParameter=function(parameter,channel,options){if(options=options||{},!Array.isArray(parameter)){if(!wm.MIDI_REGISTERED_PARAMETER[parameter])throw new TypeError("The specified parameter is not available.");parameter=wm.MIDI_REGISTERED_PARAMETER[parameter];}return wm.toMIDIChannels(channel).forEach(function(){this._selectRegisteredParameter(parameter,channel,options.time),this.sendControlChange(97,0,channel,{time:options.time}),this._deselectRegisteredParameter(channel,options.time);}.bind(this)),this},Output.prototype.setPitchBendRange=function(semitones,cents,channel,options){var that=this;if(options=options||{},!(0<=(semitones=Math.floor(semitones)||0)&&semitones<=127))throw new RangeError("The semitones value must be between 0 and 127");if(!(0<=(cents=Math.floor(cents)||0)&&cents<=127))throw new RangeError("The cents value must be between 0 and 127");return wm.toMIDIChannels(channel).forEach(function(){that.setRegisteredParameter("pitchbendrange",[semitones,cents],channel,{time:options.time});}),this},Output.prototype.setModulationRange=function(semitones,cents,channel,options){var that=this;if(options=options||{},!(0<=(semitones=Math.floor(semitones)||0)&&semitones<=127))throw new RangeError("The semitones value must be between 0 and 127");if(!(0<=(cents=Math.floor(cents)||0)&&cents<=127))throw new RangeError("The cents value must be between 0 and 127");return wm.toMIDIChannels(channel).forEach(function(){that.setRegisteredParameter("modulationrange",[semitones,cents],channel,{time:options.time});}),this},Output.prototype.setMasterTuning=function(value,channel,options){var that=this;if(options=options||{},(value=parseFloat(value)||0)<=-65||64<=value)throw new RangeError("The value must be a decimal number larger than -65 and smaller than 64.");var coarse=Math.floor(value)+64,fine=value-Math.floor(value),msb=(fine=Math.round((fine+1)/2*16383))>>7&127,lsb=127&fine;return wm.toMIDIChannels(channel).forEach(function(){that.setRegisteredParameter("channelcoarsetuning",coarse,channel,{time:options.time}),that.setRegisteredParameter("channelfinetuning",[msb,lsb],channel,{time:options.time});}),this},Output.prototype.setTuningProgram=function(value,channel,options){var that=this;if(options=options||{},!(0<=(value=Math.floor(value))&&value<=127))throw new RangeError("The program value must be between 0 and 127");return wm.toMIDIChannels(channel).forEach(function(){that.setRegisteredParameter("tuningprogram",value,channel,{time:options.time});}),this},Output.prototype.setTuningBank=function(value,channel,options){var that=this;if(options=options||{},!(0<=(value=Math.floor(value)||0)&&value<=127))throw new RangeError("The bank value must be between 0 and 127");return wm.toMIDIChannels(channel).forEach(function(){that.setRegisteredParameter("tuningbank",value,channel,{time:options.time});}),this},Output.prototype.sendChannelMode=function(command,value,channel,options){if(options=options||{},"string"==typeof command){if(!(command=wm.MIDI_CHANNEL_MODE_MESSAGES[command]))throw new TypeError("Invalid channel mode message name.")}else if(!(120<=(command=Math.floor(command))&&command<=127))throw new RangeError("Channel mode numerical identifiers must be between 120 and 127.");if((value=Math.floor(value)||0)<0||127<value)throw new RangeError("Value must be an integer between 0 and 127.");return wm.toMIDIChannels(channel).forEach(function(ch){this.send((wm.MIDI_CHANNEL_MESSAGES.channelmode<<4)+(ch-1),[command,value],this._parseTimeParameter(options.time));}.bind(this)),this},Output.prototype.sendProgramChange=function(program,channel,options){var that=this;if(options=options||{},program=Math.floor(program),isNaN(program)||program<0||127<program)throw new RangeError("Program numbers must be between 0 and 127.");return wm.toMIDIChannels(channel).forEach(function(ch){that.send((wm.MIDI_CHANNEL_MESSAGES.programchange<<4)+(ch-1),[program],that._parseTimeParameter(options.time));}),this},Output.prototype.sendChannelAftertouch=function(pressure,channel,options){var that=this;options=options||{},pressure=parseFloat(pressure),(isNaN(pressure)||pressure<0||1<pressure)&&(pressure=.5);var nPressure=Math.round(127*pressure);return wm.toMIDIChannels(channel).forEach(function(ch){that.send((wm.MIDI_CHANNEL_MESSAGES.channelaftertouch<<4)+(ch-1),[nPressure],that._parseTimeParameter(options.time));}),this},Output.prototype.sendPitchBend=function(bend,channel,options){var that=this;if(options=options||{},isNaN(bend)||bend<-1||1<bend)throw new RangeError("Pitch bend value must be between -1 and 1.");var nLevel=Math.round((bend+1)/2*16383),msb=nLevel>>7&127,lsb=127&nLevel;return wm.toMIDIChannels(channel).forEach(function(ch){that.send((wm.MIDI_CHANNEL_MESSAGES.pitchbend<<4)+(ch-1),[lsb,msb],that._parseTimeParameter(options.time));}),this},Output.prototype._parseTimeParameter=function(time){var value,parsed=parseFloat(time);return "string"==typeof time&&"+"===time.substring(0,1)?parsed&&0<parsed&&(value=wm.time+parsed):parsed>wm.time&&(value=parsed),value},Output.prototype._convertNoteToArray=function(note){var notes=[];return Array.isArray(note)||(note=[note]),note.forEach(function(item){notes.push(wm.guessNoteNumber(item));}),notes},module.exports?module.exports=wm:scope.WebMidi||(scope.WebMidi=wm);}(commonjsGlobal);
});

var libtimidity = createCommonjsModule(function (module, exports) {
var LibTimidity = (function() {
  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
  
  return (
function(LibTimidity) {
  LibTimidity = LibTimidity || {};
var Module=typeof LibTimidity!=="undefined"?LibTimidity:{};var readyPromiseResolve,readyPromiseReject;Module["ready"]=new Promise(function(resolve,reject){readyPromiseResolve=resolve;readyPromiseReject=reject;});var moduleOverrides={};var key;for(key in Module){if(Module.hasOwnProperty(key)){moduleOverrides[key]=Module[key];}}var arguments_=[];var thisProgram="./this.program";var quit_=function(status,toThrow){throw toThrow};var ENVIRONMENT_IS_WEB=true;var scriptDirectory="";function locateFile(path){if(Module["locateFile"]){return Module["locateFile"](path,scriptDirectory)}return scriptDirectory+path}var read_,readBinary;{if(document.currentScript){scriptDirectory=document.currentScript.src;}if(_scriptDir){scriptDirectory=_scriptDir;}if(scriptDirectory.indexOf("blob:")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.lastIndexOf("/")+1);}else {scriptDirectory="";}{read_=function shell_read(url){var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.send(null);return xhr.responseText};}}var out=Module["print"]||console.log.bind(console);var err=Module["printErr"]||console.warn.bind(console);for(key in moduleOverrides){if(moduleOverrides.hasOwnProperty(key)){Module[key]=moduleOverrides[key];}}moduleOverrides=null;if(Module["arguments"])arguments_=Module["arguments"];if(Module["thisProgram"])thisProgram=Module["thisProgram"];if(Module["quit"])quit_=Module["quit"];var STACK_ALIGN=16;function alignMemory(size,factor){if(!factor)factor=STACK_ALIGN;return Math.ceil(size/factor)*factor}var wasmBinary;if(Module["wasmBinary"])wasmBinary=Module["wasmBinary"];var noExitRuntime;if(Module["noExitRuntime"])noExitRuntime=Module["noExitRuntime"];if(typeof WebAssembly!=="object"){abort("no native wasm support detected");}var wasmMemory;var wasmTable;var ABORT=false;function assert(condition,text){if(!condition){abort("Assertion failed: "+text);}}var UTF8Decoder=typeof TextDecoder!=="undefined"?new TextDecoder("utf8"):undefined;function UTF8ArrayToString(heap,idx,maxBytesToRead){var endIdx=idx+maxBytesToRead;var endPtr=idx;while(heap[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&heap.subarray&&UTF8Decoder){return UTF8Decoder.decode(heap.subarray(idx,endPtr))}else {var str="";while(idx<endPtr){var u0=heap[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heap[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=heap[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2;}else {u0=(u0&7)<<18|u1<<12|u2<<6|heap[idx++]&63;}if(u0<65536){str+=String.fromCharCode(u0);}else {var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023);}}}return str}function UTF8ToString(ptr,maxBytesToRead){return ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):""}function stringToUTF8Array(str,heap,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023;}if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++]=u;}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++]=192|u>>6;heap[outIdx++]=128|u&63;}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++]=224|u>>12;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63;}else {if(outIdx+3>=endIdx)break;heap[outIdx++]=240|u>>18;heap[outIdx++]=128|u>>12&63;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63;}}heap[outIdx]=0;return outIdx-startIdx}function stringToUTF8(str,outPtr,maxBytesToWrite){return stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite)}function lengthBytesUTF8(str){var len=0;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343)u=65536+((u&1023)<<10)|str.charCodeAt(++i)&1023;if(u<=127)++len;else if(u<=2047)len+=2;else if(u<=65535)len+=3;else len+=4;}return len}var WASM_PAGE_SIZE=65536;function alignUp(x,multiple){if(x%multiple>0){x+=multiple-x%multiple;}return x}var buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateGlobalBufferAndViews(buf){buffer=buf;Module["HEAP8"]=HEAP8=new Int8Array(buf);Module["HEAP16"]=HEAP16=new Int16Array(buf);Module["HEAP32"]=HEAP32=new Int32Array(buf);Module["HEAPU8"]=HEAPU8=new Uint8Array(buf);Module["HEAPU16"]=HEAPU16=new Uint16Array(buf);Module["HEAPU32"]=HEAPU32=new Uint32Array(buf);Module["HEAPF32"]=HEAPF32=new Float32Array(buf);Module["HEAPF64"]=HEAPF64=new Float64Array(buf);}var INITIAL_INITIAL_MEMORY=Module["INITIAL_MEMORY"]||16777216;if(Module["wasmMemory"]){wasmMemory=Module["wasmMemory"];}else {wasmMemory=new WebAssembly.Memory({"initial":INITIAL_INITIAL_MEMORY/WASM_PAGE_SIZE,"maximum":2147483648/WASM_PAGE_SIZE});}if(wasmMemory){buffer=wasmMemory.buffer;}INITIAL_INITIAL_MEMORY=buffer.byteLength;updateGlobalBufferAndViews(buffer);var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATPOSTRUN__=[];function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift());}}callRuntimeCallbacks(__ATPRERUN__);}function initRuntime(){if(!Module["noFSInit"]&&!FS.init.initialized)FS.init();TTY.init();callRuntimeCallbacks(__ATINIT__);}function preMain(){FS.ignorePermissions=false;callRuntimeCallbacks(__ATMAIN__);}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift());}}callRuntimeCallbacks(__ATPOSTRUN__);}function addOnPreRun(cb){__ATPRERUN__.unshift(cb);}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb);}var runDependencies=0;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies);}}function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies);}if(runDependencies==0){if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback();}}}Module["preloadedImages"]={};Module["preloadedAudios"]={};function abort(what){if(Module["onAbort"]){Module["onAbort"](what);}what+="";err(what);ABORT=true;what="abort("+what+"). Build with -s ASSERTIONS=1 for more info.";var e=new WebAssembly.RuntimeError(what);readyPromiseReject(e);throw e}function hasPrefix(str,prefix){return String.prototype.startsWith?str.startsWith(prefix):str.indexOf(prefix)===0}var dataURIPrefix="data:application/octet-stream;base64,";function isDataURI(filename){return hasPrefix(filename,dataURIPrefix)}var wasmBinaryFile="libtimidity.wasm";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile);}function getBinary(){try{if(wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary);else {throw "both async and sync fetching of the wasm failed"}}catch(err){abort(err);}}function getBinaryPromise(){if(!wasmBinary&&(ENVIRONMENT_IS_WEB)&&typeof fetch==="function"){return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){if(!response["ok"]){throw "failed to load wasm binary file at '"+wasmBinaryFile+"'"}return response["arrayBuffer"]()}).catch(function(){return getBinary()})}return Promise.resolve().then(getBinary)}function createWasm(){var info={"a":asmLibraryArg};function receiveInstance(instance,module){var exports=instance.exports;Module["asm"]=exports;wasmTable=Module["asm"]["k"];removeRunDependency();}addRunDependency();function receiveInstantiatedSource(output){receiveInstance(output["instance"]);}function instantiateArrayBuffer(receiver){return getBinaryPromise().then(function(binary){return WebAssembly.instantiate(binary,info)}).then(receiver,function(reason){err("failed to asynchronously prepare wasm: "+reason);abort(reason);})}function instantiateAsync(){if(!wasmBinary&&typeof WebAssembly.instantiateStreaming==="function"&&!isDataURI(wasmBinaryFile)&&typeof fetch==="function"){fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){var result=WebAssembly.instantiateStreaming(response,info);return result.then(receiveInstantiatedSource,function(reason){err("wasm streaming compile failed: "+reason);err("falling back to ArrayBuffer instantiation");return instantiateArrayBuffer(receiveInstantiatedSource)})});}else {return instantiateArrayBuffer(receiveInstantiatedSource)}}if(Module["instantiateWasm"]){try{var exports=Module["instantiateWasm"](info,receiveInstance);return exports}catch(e){err("Module.instantiateWasm callback failed with error: "+e);return false}}instantiateAsync();return {}}var tempDouble;var tempI64;function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback=="function"){callback(Module);continue}var func=callback.func;if(typeof func==="number"){if(callback.arg===undefined){wasmTable.get(func)();}else {wasmTable.get(func)(callback.arg);}}else {func(callback.arg===undefined?null:callback.arg);}}}function demangle(func){return func}function demangleAll(text){var regex=/\b_Z[\w\d_]+/g;return text.replace(regex,function(x){var y=demangle(x);return x===y?x:y+" ["+x+"]"})}function jsStackTrace(){var error=new Error;if(!error.stack){try{throw new Error}catch(e){error=e;}if(!error.stack){return "(no stack trace available)"}}return error.stack.toString()}function stackTrace(){var js=jsStackTrace();if(Module["extraStackTrace"])js+="\n"+Module["extraStackTrace"]();return demangleAll(js)}function setErrNo(value){HEAP32[___errno_location()>>2]=value;return value}var PATH={splitPath:function(filename){var splitPathRe=/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;return splitPathRe.exec(filename).slice(1)},normalizeArray:function(parts,allowAboveRoot){var up=0;for(var i=parts.length-1;i>=0;i--){var last=parts[i];if(last==="."){parts.splice(i,1);}else if(last===".."){parts.splice(i,1);up++;}else if(up){parts.splice(i,1);up--;}}if(allowAboveRoot){for(;up;up--){parts.unshift("..");}}return parts},normalize:function(path){var isAbsolute=path.charAt(0)==="/",trailingSlash=path.substr(-1)==="/";path=PATH.normalizeArray(path.split("/").filter(function(p){return !!p}),!isAbsolute).join("/");if(!path&&!isAbsolute){path=".";}if(path&&trailingSlash){path+="/";}return (isAbsolute?"/":"")+path},dirname:function(path){var result=PATH.splitPath(path),root=result[0],dir=result[1];if(!root&&!dir){return "."}if(dir){dir=dir.substr(0,dir.length-1);}return root+dir},basename:function(path){if(path==="/")return "/";path=PATH.normalize(path);path=path.replace(/\/$/,"");var lastSlash=path.lastIndexOf("/");if(lastSlash===-1)return path;return path.substr(lastSlash+1)},extname:function(path){return PATH.splitPath(path)[3]},join:function(){var paths=Array.prototype.slice.call(arguments,0);return PATH.normalize(paths.join("/"))},join2:function(l,r){return PATH.normalize(l+"/"+r)}};function getRandomDevice(){if(typeof crypto==="object"&&typeof crypto["getRandomValues"]==="function"){var randomBuffer=new Uint8Array(1);return function(){crypto.getRandomValues(randomBuffer);return randomBuffer[0]}}else return function(){abort("randomDevice");}}var PATH_FS={resolve:function(){var resolvedPath="",resolvedAbsolute=false;for(var i=arguments.length-1;i>=-1&&!resolvedAbsolute;i--){var path=i>=0?arguments[i]:FS.cwd();if(typeof path!=="string"){throw new TypeError("Arguments to path.resolve must be strings")}else if(!path){return ""}resolvedPath=path+"/"+resolvedPath;resolvedAbsolute=path.charAt(0)==="/";}resolvedPath=PATH.normalizeArray(resolvedPath.split("/").filter(function(p){return !!p}),!resolvedAbsolute).join("/");return (resolvedAbsolute?"/":"")+resolvedPath||"."},relative:function(from,to){from=PATH_FS.resolve(from).substr(1);to=PATH_FS.resolve(to).substr(1);function trim(arr){var start=0;for(;start<arr.length;start++){if(arr[start]!=="")break}var end=arr.length-1;for(;end>=0;end--){if(arr[end]!=="")break}if(start>end)return [];return arr.slice(start,end-start+1)}var fromParts=trim(from.split("/"));var toParts=trim(to.split("/"));var length=Math.min(fromParts.length,toParts.length);var samePartsLength=length;for(var i=0;i<length;i++){if(fromParts[i]!==toParts[i]){samePartsLength=i;break}}var outputParts=[];for(var i=samePartsLength;i<fromParts.length;i++){outputParts.push("..");}outputParts=outputParts.concat(toParts.slice(samePartsLength));return outputParts.join("/")}};var TTY={ttys:[],init:function(){},shutdown:function(){},register:function(dev,ops){TTY.ttys[dev]={input:[],output:[],ops:ops};FS.registerDevice(dev,TTY.stream_ops);},stream_ops:{open:function(stream){var tty=TTY.ttys[stream.node.rdev];if(!tty){throw new FS.ErrnoError(43)}stream.tty=tty;stream.seekable=false;},close:function(stream){stream.tty.ops.flush(stream.tty);},flush:function(stream){stream.tty.ops.flush(stream.tty);},read:function(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.get_char){throw new FS.ErrnoError(60)}var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=stream.tty.ops.get_char(stream.tty);}catch(e){throw new FS.ErrnoError(29)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(6)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result;}if(bytesRead){stream.node.timestamp=Date.now();}return bytesRead},write:function(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.put_char){throw new FS.ErrnoError(60)}try{for(var i=0;i<length;i++){stream.tty.ops.put_char(stream.tty,buffer[offset+i]);}}catch(e){throw new FS.ErrnoError(29)}if(length){stream.node.timestamp=Date.now();}return i}},default_tty_ops:{get_char:function(tty){if(!tty.input.length){var result=null;if(typeof window!="undefined"&&typeof window.prompt=="function"){result=window.prompt("Input: ");if(result!==null){result+="\n";}}else if(typeof readline=="function"){result=readline();if(result!==null){result+="\n";}}if(!result){return null}tty.input=intArrayFromString(result,true);}return tty.input.shift()},put_char:function(tty,val){if(val===null||val===10){out(UTF8ArrayToString(tty.output,0));tty.output=[];}else {if(val!=0)tty.output.push(val);}},flush:function(tty){if(tty.output&&tty.output.length>0){out(UTF8ArrayToString(tty.output,0));tty.output=[];}}},default_tty1_ops:{put_char:function(tty,val){if(val===null||val===10){err(UTF8ArrayToString(tty.output,0));tty.output=[];}else {if(val!=0)tty.output.push(val);}},flush:function(tty){if(tty.output&&tty.output.length>0){err(UTF8ArrayToString(tty.output,0));tty.output=[];}}}};function mmapAlloc(size){var alignedSize=alignMemory(size,16384);var ptr=_malloc(alignedSize);while(size<alignedSize)HEAP8[ptr+size++]=0;return ptr}var MEMFS={ops_table:null,mount:function(mount){return MEMFS.createNode(null,"/",16384|511,0)},createNode:function(parent,name,mode,dev){if(FS.isBlkdev(mode)||FS.isFIFO(mode)){throw new FS.ErrnoError(63)}if(!MEMFS.ops_table){MEMFS.ops_table={dir:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,lookup:MEMFS.node_ops.lookup,mknod:MEMFS.node_ops.mknod,rename:MEMFS.node_ops.rename,unlink:MEMFS.node_ops.unlink,rmdir:MEMFS.node_ops.rmdir,readdir:MEMFS.node_ops.readdir,symlink:MEMFS.node_ops.symlink},stream:{llseek:MEMFS.stream_ops.llseek}},file:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:{llseek:MEMFS.stream_ops.llseek,read:MEMFS.stream_ops.read,write:MEMFS.stream_ops.write,allocate:MEMFS.stream_ops.allocate,mmap:MEMFS.stream_ops.mmap,msync:MEMFS.stream_ops.msync}},link:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,readlink:MEMFS.node_ops.readlink},stream:{}},chrdev:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:FS.chrdev_stream_ops}};}var node=FS.createNode(parent,name,mode,dev);if(FS.isDir(node.mode)){node.node_ops=MEMFS.ops_table.dir.node;node.stream_ops=MEMFS.ops_table.dir.stream;node.contents={};}else if(FS.isFile(node.mode)){node.node_ops=MEMFS.ops_table.file.node;node.stream_ops=MEMFS.ops_table.file.stream;node.usedBytes=0;node.contents=null;}else if(FS.isLink(node.mode)){node.node_ops=MEMFS.ops_table.link.node;node.stream_ops=MEMFS.ops_table.link.stream;}else if(FS.isChrdev(node.mode)){node.node_ops=MEMFS.ops_table.chrdev.node;node.stream_ops=MEMFS.ops_table.chrdev.stream;}node.timestamp=Date.now();if(parent){parent.contents[name]=node;}return node},getFileDataAsRegularArray:function(node){if(node.contents&&node.contents.subarray){var arr=[];for(var i=0;i<node.usedBytes;++i)arr.push(node.contents[i]);return arr}return node.contents},getFileDataAsTypedArray:function(node){if(!node.contents)return new Uint8Array(0);if(node.contents.subarray)return node.contents.subarray(0,node.usedBytes);return new Uint8Array(node.contents)},expandFileStorage:function(node,newCapacity){var prevCapacity=node.contents?node.contents.length:0;if(prevCapacity>=newCapacity)return;var CAPACITY_DOUBLING_MAX=1024*1024;newCapacity=Math.max(newCapacity,prevCapacity*(prevCapacity<CAPACITY_DOUBLING_MAX?2:1.125)>>>0);if(prevCapacity!=0)newCapacity=Math.max(newCapacity,256);var oldContents=node.contents;node.contents=new Uint8Array(newCapacity);if(node.usedBytes>0)node.contents.set(oldContents.subarray(0,node.usedBytes),0);return},resizeFileStorage:function(node,newSize){if(node.usedBytes==newSize)return;if(newSize==0){node.contents=null;node.usedBytes=0;return}if(!node.contents||node.contents.subarray){var oldContents=node.contents;node.contents=new Uint8Array(newSize);if(oldContents){node.contents.set(oldContents.subarray(0,Math.min(newSize,node.usedBytes)));}node.usedBytes=newSize;return}if(!node.contents)node.contents=[];if(node.contents.length>newSize)node.contents.length=newSize;else while(node.contents.length<newSize)node.contents.push(0);node.usedBytes=newSize;},node_ops:{getattr:function(node){var attr={};attr.dev=FS.isChrdev(node.mode)?node.id:1;attr.ino=node.id;attr.mode=node.mode;attr.nlink=1;attr.uid=0;attr.gid=0;attr.rdev=node.rdev;if(FS.isDir(node.mode)){attr.size=4096;}else if(FS.isFile(node.mode)){attr.size=node.usedBytes;}else if(FS.isLink(node.mode)){attr.size=node.link.length;}else {attr.size=0;}attr.atime=new Date(node.timestamp);attr.mtime=new Date(node.timestamp);attr.ctime=new Date(node.timestamp);attr.blksize=4096;attr.blocks=Math.ceil(attr.size/attr.blksize);return attr},setattr:function(node,attr){if(attr.mode!==undefined){node.mode=attr.mode;}if(attr.timestamp!==undefined){node.timestamp=attr.timestamp;}if(attr.size!==undefined){MEMFS.resizeFileStorage(node,attr.size);}},lookup:function(parent,name){throw FS.genericErrors[44]},mknod:function(parent,name,mode,dev){return MEMFS.createNode(parent,name,mode,dev)},rename:function(old_node,new_dir,new_name){if(FS.isDir(old_node.mode)){var new_node;try{new_node=FS.lookupNode(new_dir,new_name);}catch(e){}if(new_node){for(var i in new_node.contents){throw new FS.ErrnoError(55)}}}delete old_node.parent.contents[old_node.name];old_node.name=new_name;new_dir.contents[new_name]=old_node;old_node.parent=new_dir;},unlink:function(parent,name){delete parent.contents[name];},rmdir:function(parent,name){var node=FS.lookupNode(parent,name);for(var i in node.contents){throw new FS.ErrnoError(55)}delete parent.contents[name];},readdir:function(node){var entries=[".",".."];for(var key in node.contents){if(!node.contents.hasOwnProperty(key)){continue}entries.push(key);}return entries},symlink:function(parent,newname,oldpath){var node=MEMFS.createNode(parent,newname,511|40960,0);node.link=oldpath;return node},readlink:function(node){if(!FS.isLink(node.mode)){throw new FS.ErrnoError(28)}return node.link}},stream_ops:{read:function(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=stream.node.usedBytes)return 0;var size=Math.min(stream.node.usedBytes-position,length);if(size>8&&contents.subarray){buffer.set(contents.subarray(position,position+size),offset);}else {for(var i=0;i<size;i++)buffer[offset+i]=contents[position+i];}return size},write:function(stream,buffer,offset,length,position,canOwn){if(buffer.buffer===HEAP8.buffer){canOwn=false;}if(!length)return 0;var node=stream.node;node.timestamp=Date.now();if(buffer.subarray&&(!node.contents||node.contents.subarray)){if(canOwn){node.contents=buffer.subarray(offset,offset+length);node.usedBytes=length;return length}else if(node.usedBytes===0&&position===0){node.contents=buffer.slice(offset,offset+length);node.usedBytes=length;return length}else if(position+length<=node.usedBytes){node.contents.set(buffer.subarray(offset,offset+length),position);return length}}MEMFS.expandFileStorage(node,position+length);if(node.contents.subarray&&buffer.subarray){node.contents.set(buffer.subarray(offset,offset+length),position);}else {for(var i=0;i<length;i++){node.contents[position+i]=buffer[offset+i];}}node.usedBytes=Math.max(node.usedBytes,position+length);return length},llseek:function(stream,offset,whence){var position=offset;if(whence===1){position+=stream.position;}else if(whence===2){if(FS.isFile(stream.node.mode)){position+=stream.node.usedBytes;}}if(position<0){throw new FS.ErrnoError(28)}return position},allocate:function(stream,offset,length){MEMFS.expandFileStorage(stream.node,offset+length);stream.node.usedBytes=Math.max(stream.node.usedBytes,offset+length);},mmap:function(stream,address,length,position,prot,flags){assert(address===0);if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(43)}var ptr;var allocated;var contents=stream.node.contents;if(!(flags&2)&&contents.buffer===buffer){allocated=false;ptr=contents.byteOffset;}else {if(position>0||position+length<contents.length){if(contents.subarray){contents=contents.subarray(position,position+length);}else {contents=Array.prototype.slice.call(contents,position,position+length);}}allocated=true;ptr=mmapAlloc(length);if(!ptr){throw new FS.ErrnoError(48)}HEAP8.set(contents,ptr);}return {ptr:ptr,allocated:allocated}},msync:function(stream,buffer,offset,length,mmapFlags){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(43)}if(mmapFlags&2){return 0}var bytesWritten=MEMFS.stream_ops.write(stream,buffer,0,length,offset,false);return 0}}};var FS={root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,trackingDelegate:{},tracking:{openFlags:{READ:1,WRITE:2}},ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,handleFSError:function(e){if(!(e instanceof FS.ErrnoError))throw e+" : "+stackTrace();return setErrNo(e.errno)},lookupPath:function(path,opts){path=PATH_FS.resolve(FS.cwd(),path);opts=opts||{};if(!path)return {path:"",node:null};var defaults={follow_mount:true,recurse_count:0};for(var key in defaults){if(opts[key]===undefined){opts[key]=defaults[key];}}if(opts.recurse_count>8){throw new FS.ErrnoError(32)}var parts=PATH.normalizeArray(path.split("/").filter(function(p){return !!p}),false);var current=FS.root;var current_path="/";for(var i=0;i<parts.length;i++){var islast=i===parts.length-1;if(islast&&opts.parent){break}current=FS.lookupNode(current,parts[i]);current_path=PATH.join2(current_path,parts[i]);if(FS.isMountpoint(current)){if(!islast||islast&&opts.follow_mount){current=current.mounted.root;}}if(!islast||opts.follow){var count=0;while(FS.isLink(current.mode)){var link=FS.readlink(current_path);current_path=PATH_FS.resolve(PATH.dirname(current_path),link);var lookup=FS.lookupPath(current_path,{recurse_count:opts.recurse_count});current=lookup.node;if(count++>40){throw new FS.ErrnoError(32)}}}}return {path:current_path,node:current}},getPath:function(node){var path;while(true){if(FS.isRoot(node)){var mount=node.mount.mountpoint;if(!path)return mount;return mount[mount.length-1]!=="/"?mount+"/"+path:mount+path}path=path?node.name+"/"+path:node.name;node=node.parent;}},hashName:function(parentid,name){var hash=0;for(var i=0;i<name.length;i++){hash=(hash<<5)-hash+name.charCodeAt(i)|0;}return (parentid+hash>>>0)%FS.nameTable.length},hashAddNode:function(node){var hash=FS.hashName(node.parent.id,node.name);node.name_next=FS.nameTable[hash];FS.nameTable[hash]=node;},hashRemoveNode:function(node){var hash=FS.hashName(node.parent.id,node.name);if(FS.nameTable[hash]===node){FS.nameTable[hash]=node.name_next;}else {var current=FS.nameTable[hash];while(current){if(current.name_next===node){current.name_next=node.name_next;break}current=current.name_next;}}},lookupNode:function(parent,name){var errCode=FS.mayLookup(parent);if(errCode){throw new FS.ErrnoError(errCode,parent)}var hash=FS.hashName(parent.id,name);for(var node=FS.nameTable[hash];node;node=node.name_next){var nodeName=node.name;if(node.parent.id===parent.id&&nodeName===name){return node}}return FS.lookup(parent,name)},createNode:function(parent,name,mode,rdev){var node=new FS.FSNode(parent,name,mode,rdev);FS.hashAddNode(node);return node},destroyNode:function(node){FS.hashRemoveNode(node);},isRoot:function(node){return node===node.parent},isMountpoint:function(node){return !!node.mounted},isFile:function(mode){return (mode&61440)===32768},isDir:function(mode){return (mode&61440)===16384},isLink:function(mode){return (mode&61440)===40960},isChrdev:function(mode){return (mode&61440)===8192},isBlkdev:function(mode){return (mode&61440)===24576},isFIFO:function(mode){return (mode&61440)===4096},isSocket:function(mode){return (mode&49152)===49152},flagModes:{"r":0,"rs":1052672,"r+":2,"w":577,"wx":705,"xw":705,"w+":578,"wx+":706,"xw+":706,"a":1089,"ax":1217,"xa":1217,"a+":1090,"ax+":1218,"xa+":1218},modeStringToFlags:function(str){var flags=FS.flagModes[str];if(typeof flags==="undefined"){throw new Error("Unknown file open mode: "+str)}return flags},flagsToPermissionString:function(flag){var perms=["r","w","rw"][flag&3];if(flag&512){perms+="w";}return perms},nodePermissions:function(node,perms){if(FS.ignorePermissions){return 0}if(perms.indexOf("r")!==-1&&!(node.mode&292)){return 2}else if(perms.indexOf("w")!==-1&&!(node.mode&146)){return 2}else if(perms.indexOf("x")!==-1&&!(node.mode&73)){return 2}return 0},mayLookup:function(dir){var errCode=FS.nodePermissions(dir,"x");if(errCode)return errCode;if(!dir.node_ops.lookup)return 2;return 0},mayCreate:function(dir,name){try{var node=FS.lookupNode(dir,name);return 20}catch(e){}return FS.nodePermissions(dir,"wx")},mayDelete:function(dir,name,isdir){var node;try{node=FS.lookupNode(dir,name);}catch(e){return e.errno}var errCode=FS.nodePermissions(dir,"wx");if(errCode){return errCode}if(isdir){if(!FS.isDir(node.mode)){return 54}if(FS.isRoot(node)||FS.getPath(node)===FS.cwd()){return 10}}else {if(FS.isDir(node.mode)){return 31}}return 0},mayOpen:function(node,flags){if(!node){return 44}if(FS.isLink(node.mode)){return 32}else if(FS.isDir(node.mode)){if(FS.flagsToPermissionString(flags)!=="r"||flags&512){return 31}}return FS.nodePermissions(node,FS.flagsToPermissionString(flags))},MAX_OPEN_FDS:4096,nextfd:function(fd_start,fd_end){fd_start=fd_start||0;fd_end=fd_end||FS.MAX_OPEN_FDS;for(var fd=fd_start;fd<=fd_end;fd++){if(!FS.streams[fd]){return fd}}throw new FS.ErrnoError(33)},getStream:function(fd){return FS.streams[fd]},createStream:function(stream,fd_start,fd_end){if(!FS.FSStream){FS.FSStream=function(){};FS.FSStream.prototype={object:{get:function(){return this.node},set:function(val){this.node=val;}},isRead:{get:function(){return (this.flags&2097155)!==1}},isWrite:{get:function(){return (this.flags&2097155)!==0}},isAppend:{get:function(){return this.flags&1024}}};}var newStream=new FS.FSStream;for(var p in stream){newStream[p]=stream[p];}stream=newStream;var fd=FS.nextfd(fd_start,fd_end);stream.fd=fd;FS.streams[fd]=stream;return stream},closeStream:function(fd){FS.streams[fd]=null;},chrdev_stream_ops:{open:function(stream){var device=FS.getDevice(stream.node.rdev);stream.stream_ops=device.stream_ops;if(stream.stream_ops.open){stream.stream_ops.open(stream);}},llseek:function(){throw new FS.ErrnoError(70)}},major:function(dev){return dev>>8},minor:function(dev){return dev&255},makedev:function(ma,mi){return ma<<8|mi},registerDevice:function(dev,ops){FS.devices[dev]={stream_ops:ops};},getDevice:function(dev){return FS.devices[dev]},getMounts:function(mount){var mounts=[];var check=[mount];while(check.length){var m=check.pop();mounts.push(m);check.push.apply(check,m.mounts);}return mounts},syncfs:function(populate,callback){if(typeof populate==="function"){callback=populate;populate=false;}FS.syncFSRequests++;if(FS.syncFSRequests>1){err("warning: "+FS.syncFSRequests+" FS.syncfs operations in flight at once, probably just doing extra work");}var mounts=FS.getMounts(FS.root.mount);var completed=0;function doCallback(errCode){FS.syncFSRequests--;return callback(errCode)}function done(errCode){if(errCode){if(!done.errored){done.errored=true;return doCallback(errCode)}return}if(++completed>=mounts.length){doCallback(null);}}mounts.forEach(function(mount){if(!mount.type.syncfs){return done(null)}mount.type.syncfs(mount,populate,done);});},mount:function(type,opts,mountpoint){var root=mountpoint==="/";var pseudo=!mountpoint;var node;if(root&&FS.root){throw new FS.ErrnoError(10)}else if(!root&&!pseudo){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});mountpoint=lookup.path;node=lookup.node;if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}if(!FS.isDir(node.mode)){throw new FS.ErrnoError(54)}}var mount={type:type,opts:opts,mountpoint:mountpoint,mounts:[]};var mountRoot=type.mount(mount);mountRoot.mount=mount;mount.root=mountRoot;if(root){FS.root=mountRoot;}else if(node){node.mounted=mount;if(node.mount){node.mount.mounts.push(mount);}}return mountRoot},unmount:function(mountpoint){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});if(!FS.isMountpoint(lookup.node)){throw new FS.ErrnoError(28)}var node=lookup.node;var mount=node.mounted;var mounts=FS.getMounts(mount);Object.keys(FS.nameTable).forEach(function(hash){var current=FS.nameTable[hash];while(current){var next=current.name_next;if(mounts.indexOf(current.mount)!==-1){FS.destroyNode(current);}current=next;}});node.mounted=null;var idx=node.mount.mounts.indexOf(mount);node.mount.mounts.splice(idx,1);},lookup:function(parent,name){return parent.node_ops.lookup(parent,name)},mknod:function(path,mode,dev){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);if(!name||name==="."||name===".."){throw new FS.ErrnoError(28)}var errCode=FS.mayCreate(parent,name);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.mknod){throw new FS.ErrnoError(63)}return parent.node_ops.mknod(parent,name,mode,dev)},create:function(path,mode){mode=mode!==undefined?mode:438;mode&=4095;mode|=32768;return FS.mknod(path,mode,0)},mkdir:function(path,mode){mode=mode!==undefined?mode:511;mode&=511|512;mode|=16384;return FS.mknod(path,mode,0)},mkdirTree:function(path,mode){var dirs=path.split("/");var d="";for(var i=0;i<dirs.length;++i){if(!dirs[i])continue;d+="/"+dirs[i];try{FS.mkdir(d,mode);}catch(e){if(e.errno!=20)throw e}}},mkdev:function(path,mode,dev){if(typeof dev==="undefined"){dev=mode;mode=438;}mode|=8192;return FS.mknod(path,mode,dev)},symlink:function(oldpath,newpath){if(!PATH_FS.resolve(oldpath)){throw new FS.ErrnoError(44)}var lookup=FS.lookupPath(newpath,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(44)}var newname=PATH.basename(newpath);var errCode=FS.mayCreate(parent,newname);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.symlink){throw new FS.ErrnoError(63)}return parent.node_ops.symlink(parent,newname,oldpath)},rename:function(old_path,new_path){var old_dirname=PATH.dirname(old_path);var new_dirname=PATH.dirname(new_path);var old_name=PATH.basename(old_path);var new_name=PATH.basename(new_path);var lookup,old_dir,new_dir;lookup=FS.lookupPath(old_path,{parent:true});old_dir=lookup.node;lookup=FS.lookupPath(new_path,{parent:true});new_dir=lookup.node;if(!old_dir||!new_dir)throw new FS.ErrnoError(44);if(old_dir.mount!==new_dir.mount){throw new FS.ErrnoError(75)}var old_node=FS.lookupNode(old_dir,old_name);var relative=PATH_FS.relative(old_path,new_dirname);if(relative.charAt(0)!=="."){throw new FS.ErrnoError(28)}relative=PATH_FS.relative(new_path,old_dirname);if(relative.charAt(0)!=="."){throw new FS.ErrnoError(55)}var new_node;try{new_node=FS.lookupNode(new_dir,new_name);}catch(e){}if(old_node===new_node){return}var isdir=FS.isDir(old_node.mode);var errCode=FS.mayDelete(old_dir,old_name,isdir);if(errCode){throw new FS.ErrnoError(errCode)}errCode=new_node?FS.mayDelete(new_dir,new_name,isdir):FS.mayCreate(new_dir,new_name);if(errCode){throw new FS.ErrnoError(errCode)}if(!old_dir.node_ops.rename){throw new FS.ErrnoError(63)}if(FS.isMountpoint(old_node)||new_node&&FS.isMountpoint(new_node)){throw new FS.ErrnoError(10)}if(new_dir!==old_dir){errCode=FS.nodePermissions(old_dir,"w");if(errCode){throw new FS.ErrnoError(errCode)}}try{if(FS.trackingDelegate["willMovePath"]){FS.trackingDelegate["willMovePath"](old_path,new_path);}}catch(e){err("FS.trackingDelegate['willMovePath']('"+old_path+"', '"+new_path+"') threw an exception: "+e.message);}FS.hashRemoveNode(old_node);try{old_dir.node_ops.rename(old_node,new_dir,new_name);}catch(e){throw e}finally{FS.hashAddNode(old_node);}try{if(FS.trackingDelegate["onMovePath"])FS.trackingDelegate["onMovePath"](old_path,new_path);}catch(e){err("FS.trackingDelegate['onMovePath']('"+old_path+"', '"+new_path+"') threw an exception: "+e.message);}},rmdir:function(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var errCode=FS.mayDelete(parent,name,true);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.rmdir){throw new FS.ErrnoError(63)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}try{if(FS.trackingDelegate["willDeletePath"]){FS.trackingDelegate["willDeletePath"](path);}}catch(e){err("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: "+e.message);}parent.node_ops.rmdir(parent,name);FS.destroyNode(node);try{if(FS.trackingDelegate["onDeletePath"])FS.trackingDelegate["onDeletePath"](path);}catch(e){err("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: "+e.message);}},readdir:function(path){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;if(!node.node_ops.readdir){throw new FS.ErrnoError(54)}return node.node_ops.readdir(node)},unlink:function(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var errCode=FS.mayDelete(parent,name,false);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.unlink){throw new FS.ErrnoError(63)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}try{if(FS.trackingDelegate["willDeletePath"]){FS.trackingDelegate["willDeletePath"](path);}}catch(e){err("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: "+e.message);}parent.node_ops.unlink(parent,name);FS.destroyNode(node);try{if(FS.trackingDelegate["onDeletePath"])FS.trackingDelegate["onDeletePath"](path);}catch(e){err("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: "+e.message);}},readlink:function(path){var lookup=FS.lookupPath(path);var link=lookup.node;if(!link){throw new FS.ErrnoError(44)}if(!link.node_ops.readlink){throw new FS.ErrnoError(28)}return PATH_FS.resolve(FS.getPath(link.parent),link.node_ops.readlink(link))},stat:function(path,dontFollow){var lookup=FS.lookupPath(path,{follow:!dontFollow});var node=lookup.node;if(!node){throw new FS.ErrnoError(44)}if(!node.node_ops.getattr){throw new FS.ErrnoError(63)}return node.node_ops.getattr(node)},lstat:function(path){return FS.stat(path,true)},chmod:function(path,mode,dontFollow){var node;if(typeof path==="string"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node;}else {node=path;}if(!node.node_ops.setattr){throw new FS.ErrnoError(63)}node.node_ops.setattr(node,{mode:mode&4095|node.mode&~4095,timestamp:Date.now()});},lchmod:function(path,mode){FS.chmod(path,mode,true);},fchmod:function(fd,mode){var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(8)}FS.chmod(stream.node,mode);},chown:function(path,uid,gid,dontFollow){var node;if(typeof path==="string"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node;}else {node=path;}if(!node.node_ops.setattr){throw new FS.ErrnoError(63)}node.node_ops.setattr(node,{timestamp:Date.now()});},lchown:function(path,uid,gid){FS.chown(path,uid,gid,true);},fchown:function(fd,uid,gid){var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(8)}FS.chown(stream.node,uid,gid);},truncate:function(path,len){if(len<0){throw new FS.ErrnoError(28)}var node;if(typeof path==="string"){var lookup=FS.lookupPath(path,{follow:true});node=lookup.node;}else {node=path;}if(!node.node_ops.setattr){throw new FS.ErrnoError(63)}if(FS.isDir(node.mode)){throw new FS.ErrnoError(31)}if(!FS.isFile(node.mode)){throw new FS.ErrnoError(28)}var errCode=FS.nodePermissions(node,"w");if(errCode){throw new FS.ErrnoError(errCode)}node.node_ops.setattr(node,{size:len,timestamp:Date.now()});},ftruncate:function(fd,len){var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(28)}FS.truncate(stream.node,len);},utime:function(path,atime,mtime){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;node.node_ops.setattr(node,{timestamp:Math.max(atime,mtime)});},open:function(path,flags,mode,fd_start,fd_end){if(path===""){throw new FS.ErrnoError(44)}flags=typeof flags==="string"?FS.modeStringToFlags(flags):flags;mode=typeof mode==="undefined"?438:mode;if(flags&64){mode=mode&4095|32768;}else {mode=0;}var node;if(typeof path==="object"){node=path;}else {path=PATH.normalize(path);try{var lookup=FS.lookupPath(path,{follow:!(flags&131072)});node=lookup.node;}catch(e){}}var created=false;if(flags&64){if(node){if(flags&128){throw new FS.ErrnoError(20)}}else {node=FS.mknod(path,mode,0);created=true;}}if(!node){throw new FS.ErrnoError(44)}if(FS.isChrdev(node.mode)){flags&=~512;}if(flags&65536&&!FS.isDir(node.mode)){throw new FS.ErrnoError(54)}if(!created){var errCode=FS.mayOpen(node,flags);if(errCode){throw new FS.ErrnoError(errCode)}}if(flags&512){FS.truncate(node,0);}flags&=~(128|512|131072);var stream=FS.createStream({node:node,path:FS.getPath(node),flags:flags,seekable:true,position:0,stream_ops:node.stream_ops,ungotten:[],error:false},fd_start,fd_end);if(stream.stream_ops.open){stream.stream_ops.open(stream);}if(Module["logReadFiles"]&&!(flags&1)){if(!FS.readFiles)FS.readFiles={};if(!(path in FS.readFiles)){FS.readFiles[path]=1;err("FS.trackingDelegate error on read file: "+path);}}try{if(FS.trackingDelegate["onOpenFile"]){var trackingFlags=0;if((flags&2097155)!==1){trackingFlags|=FS.tracking.openFlags.READ;}if((flags&2097155)!==0){trackingFlags|=FS.tracking.openFlags.WRITE;}FS.trackingDelegate["onOpenFile"](path,trackingFlags);}}catch(e){err("FS.trackingDelegate['onOpenFile']('"+path+"', flags) threw an exception: "+e.message);}return stream},close:function(stream){if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(stream.getdents)stream.getdents=null;try{if(stream.stream_ops.close){stream.stream_ops.close(stream);}}catch(e){throw e}finally{FS.closeStream(stream.fd);}stream.fd=null;},isClosed:function(stream){return stream.fd===null},llseek:function(stream,offset,whence){if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(!stream.seekable||!stream.stream_ops.llseek){throw new FS.ErrnoError(70)}if(whence!=0&&whence!=1&&whence!=2){throw new FS.ErrnoError(28)}stream.position=stream.stream_ops.llseek(stream,offset,whence);stream.ungotten=[];return stream.position},read:function(stream,buffer,offset,length,position){if(length<0||position<0){throw new FS.ErrnoError(28)}if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(8)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(31)}if(!stream.stream_ops.read){throw new FS.ErrnoError(28)}var seeking=typeof position!=="undefined";if(!seeking){position=stream.position;}else if(!stream.seekable){throw new FS.ErrnoError(70)}var bytesRead=stream.stream_ops.read(stream,buffer,offset,length,position);if(!seeking)stream.position+=bytesRead;return bytesRead},write:function(stream,buffer,offset,length,position,canOwn){if(length<0||position<0){throw new FS.ErrnoError(28)}if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(8)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(31)}if(!stream.stream_ops.write){throw new FS.ErrnoError(28)}if(stream.seekable&&stream.flags&1024){FS.llseek(stream,0,2);}var seeking=typeof position!=="undefined";if(!seeking){position=stream.position;}else if(!stream.seekable){throw new FS.ErrnoError(70)}var bytesWritten=stream.stream_ops.write(stream,buffer,offset,length,position,canOwn);if(!seeking)stream.position+=bytesWritten;try{if(stream.path&&FS.trackingDelegate["onWriteToFile"])FS.trackingDelegate["onWriteToFile"](stream.path);}catch(e){err("FS.trackingDelegate['onWriteToFile']('"+stream.path+"') threw an exception: "+e.message);}return bytesWritten},allocate:function(stream,offset,length){if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(offset<0||length<=0){throw new FS.ErrnoError(28)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(8)}if(!FS.isFile(stream.node.mode)&&!FS.isDir(stream.node.mode)){throw new FS.ErrnoError(43)}if(!stream.stream_ops.allocate){throw new FS.ErrnoError(138)}stream.stream_ops.allocate(stream,offset,length);},mmap:function(stream,address,length,position,prot,flags){if((prot&2)!==0&&(flags&2)===0&&(stream.flags&2097155)!==2){throw new FS.ErrnoError(2)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(2)}if(!stream.stream_ops.mmap){throw new FS.ErrnoError(43)}return stream.stream_ops.mmap(stream,address,length,position,prot,flags)},msync:function(stream,buffer,offset,length,mmapFlags){if(!stream||!stream.stream_ops.msync){return 0}return stream.stream_ops.msync(stream,buffer,offset,length,mmapFlags)},munmap:function(stream){return 0},ioctl:function(stream,cmd,arg){if(!stream.stream_ops.ioctl){throw new FS.ErrnoError(59)}return stream.stream_ops.ioctl(stream,cmd,arg)},readFile:function(path,opts){opts=opts||{};opts.flags=opts.flags||"r";opts.encoding=opts.encoding||"binary";if(opts.encoding!=="utf8"&&opts.encoding!=="binary"){throw new Error('Invalid encoding type "'+opts.encoding+'"')}var ret;var stream=FS.open(path,opts.flags);var stat=FS.stat(path);var length=stat.size;var buf=new Uint8Array(length);FS.read(stream,buf,0,length,0);if(opts.encoding==="utf8"){ret=UTF8ArrayToString(buf,0);}else if(opts.encoding==="binary"){ret=buf;}FS.close(stream);return ret},writeFile:function(path,data,opts){opts=opts||{};opts.flags=opts.flags||"w";var stream=FS.open(path,opts.flags,opts.mode);if(typeof data==="string"){var buf=new Uint8Array(lengthBytesUTF8(data)+1);var actualNumBytes=stringToUTF8Array(data,buf,0,buf.length);FS.write(stream,buf,0,actualNumBytes,undefined,opts.canOwn);}else if(ArrayBuffer.isView(data)){FS.write(stream,data,0,data.byteLength,undefined,opts.canOwn);}else {throw new Error("Unsupported data type")}FS.close(stream);},cwd:function(){return FS.currentPath},chdir:function(path){var lookup=FS.lookupPath(path,{follow:true});if(lookup.node===null){throw new FS.ErrnoError(44)}if(!FS.isDir(lookup.node.mode)){throw new FS.ErrnoError(54)}var errCode=FS.nodePermissions(lookup.node,"x");if(errCode){throw new FS.ErrnoError(errCode)}FS.currentPath=lookup.path;},createDefaultDirectories:function(){FS.mkdir("/tmp");FS.mkdir("/home");FS.mkdir("/home/web_user");},createDefaultDevices:function(){FS.mkdir("/dev");FS.registerDevice(FS.makedev(1,3),{read:function(){return 0},write:function(stream,buffer,offset,length,pos){return length}});FS.mkdev("/dev/null",FS.makedev(1,3));TTY.register(FS.makedev(5,0),TTY.default_tty_ops);TTY.register(FS.makedev(6,0),TTY.default_tty1_ops);FS.mkdev("/dev/tty",FS.makedev(5,0));FS.mkdev("/dev/tty1",FS.makedev(6,0));var random_device=getRandomDevice();FS.createDevice("/dev","random",random_device);FS.createDevice("/dev","urandom",random_device);FS.mkdir("/dev/shm");FS.mkdir("/dev/shm/tmp");},createSpecialDirectories:function(){FS.mkdir("/proc");FS.mkdir("/proc/self");FS.mkdir("/proc/self/fd");FS.mount({mount:function(){var node=FS.createNode("/proc/self","fd",16384|511,73);node.node_ops={lookup:function(parent,name){var fd=+name;var stream=FS.getStream(fd);if(!stream)throw new FS.ErrnoError(8);var ret={parent:null,mount:{mountpoint:"fake"},node_ops:{readlink:function(){return stream.path}}};ret.parent=ret;return ret}};return node}},{},"/proc/self/fd");},createStandardStreams:function(){if(Module["stdin"]){FS.createDevice("/dev","stdin",Module["stdin"]);}else {FS.symlink("/dev/tty","/dev/stdin");}if(Module["stdout"]){FS.createDevice("/dev","stdout",null,Module["stdout"]);}else {FS.symlink("/dev/tty","/dev/stdout");}if(Module["stderr"]){FS.createDevice("/dev","stderr",null,Module["stderr"]);}else {FS.symlink("/dev/tty1","/dev/stderr");}var stdin=FS.open("/dev/stdin","r");var stdout=FS.open("/dev/stdout","w");var stderr=FS.open("/dev/stderr","w");},ensureErrnoError:function(){if(FS.ErrnoError)return;FS.ErrnoError=function ErrnoError(errno,node){this.node=node;this.setErrno=function(errno){this.errno=errno;};this.setErrno(errno);this.message="FS error";};FS.ErrnoError.prototype=new Error;FS.ErrnoError.prototype.constructor=FS.ErrnoError;[44].forEach(function(code){FS.genericErrors[code]=new FS.ErrnoError(code);FS.genericErrors[code].stack="<generic error, no stack>";});},staticInit:function(){FS.ensureErrnoError();FS.nameTable=new Array(4096);FS.mount(MEMFS,{},"/");FS.createDefaultDirectories();FS.createDefaultDevices();FS.createSpecialDirectories();FS.filesystems={"MEMFS":MEMFS};},init:function(input,output,error){FS.init.initialized=true;FS.ensureErrnoError();Module["stdin"]=input||Module["stdin"];Module["stdout"]=output||Module["stdout"];Module["stderr"]=error||Module["stderr"];FS.createStandardStreams();},quit:function(){FS.init.initialized=false;var fflush=Module["_fflush"];if(fflush)fflush(0);for(var i=0;i<FS.streams.length;i++){var stream=FS.streams[i];if(!stream){continue}FS.close(stream);}},getMode:function(canRead,canWrite){var mode=0;if(canRead)mode|=292|73;if(canWrite)mode|=146;return mode},findObject:function(path,dontResolveLastLink){var ret=FS.analyzePath(path,dontResolveLastLink);if(ret.exists){return ret.object}else {setErrNo(ret.error);return null}},analyzePath:function(path,dontResolveLastLink){try{var lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});path=lookup.path;}catch(e){}var ret={isRoot:false,exists:false,error:0,name:null,path:null,object:null,parentExists:false,parentPath:null,parentObject:null};try{var lookup=FS.lookupPath(path,{parent:true});ret.parentExists=true;ret.parentPath=lookup.path;ret.parentObject=lookup.node;ret.name=PATH.basename(path);lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});ret.exists=true;ret.path=lookup.path;ret.object=lookup.node;ret.name=lookup.node.name;ret.isRoot=lookup.path==="/";}catch(e){ret.error=e.errno;}return ret},createPath:function(parent,path,canRead,canWrite){parent=typeof parent==="string"?parent:FS.getPath(parent);var parts=path.split("/").reverse();while(parts.length){var part=parts.pop();if(!part)continue;var current=PATH.join2(parent,part);try{FS.mkdir(current);}catch(e){}parent=current;}return current},createFile:function(parent,name,properties,canRead,canWrite){var path=PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name);var mode=FS.getMode(canRead,canWrite);return FS.create(path,mode)},createDataFile:function(parent,name,data,canRead,canWrite,canOwn){var path=name?PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name):parent;var mode=FS.getMode(canRead,canWrite);var node=FS.create(path,mode);if(data){if(typeof data==="string"){var arr=new Array(data.length);for(var i=0,len=data.length;i<len;++i)arr[i]=data.charCodeAt(i);data=arr;}FS.chmod(node,mode|146);var stream=FS.open(node,"w");FS.write(stream,data,0,data.length,0,canOwn);FS.close(stream);FS.chmod(node,mode);}return node},createDevice:function(parent,name,input,output){var path=PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name);var mode=FS.getMode(!!input,!!output);if(!FS.createDevice.major)FS.createDevice.major=64;var dev=FS.makedev(FS.createDevice.major++,0);FS.registerDevice(dev,{open:function(stream){stream.seekable=false;},close:function(stream){if(output&&output.buffer&&output.buffer.length){output(10);}},read:function(stream,buffer,offset,length,pos){var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=input();}catch(e){throw new FS.ErrnoError(29)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(6)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result;}if(bytesRead){stream.node.timestamp=Date.now();}return bytesRead},write:function(stream,buffer,offset,length,pos){for(var i=0;i<length;i++){try{output(buffer[offset+i]);}catch(e){throw new FS.ErrnoError(29)}}if(length){stream.node.timestamp=Date.now();}return i}});return FS.mkdev(path,mode,dev)},forceLoadFile:function(obj){if(obj.isDevice||obj.isFolder||obj.link||obj.contents)return true;var success=true;if(typeof XMLHttpRequest!=="undefined"){throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.")}else if(read_){try{obj.contents=intArrayFromString(read_(obj.url),true);obj.usedBytes=obj.contents.length;}catch(e){success=false;}}else {throw new Error("Cannot load without read() or XMLHttpRequest.")}if(!success)setErrNo(29);return success},createLazyFile:function(parent,name,url,canRead,canWrite){function LazyUint8Array(){this.lengthKnown=false;this.chunks=[];}LazyUint8Array.prototype.get=function LazyUint8Array_get(idx){if(idx>this.length-1||idx<0){return undefined}var chunkOffset=idx%this.chunkSize;var chunkNum=idx/this.chunkSize|0;return this.getter(chunkNum)[chunkOffset]};LazyUint8Array.prototype.setDataGetter=function LazyUint8Array_setDataGetter(getter){this.getter=getter;};LazyUint8Array.prototype.cacheLength=function LazyUint8Array_cacheLength(){var xhr=new XMLHttpRequest;xhr.open("HEAD",url,false);xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error("Couldn't load "+url+". Status: "+xhr.status);var datalength=Number(xhr.getResponseHeader("Content-length"));var header;var hasByteServing=(header=xhr.getResponseHeader("Accept-Ranges"))&&header==="bytes";var usesGzip=(header=xhr.getResponseHeader("Content-Encoding"))&&header==="gzip";var chunkSize=1024*1024;if(!hasByteServing)chunkSize=datalength;var doXHR=function(from,to){if(from>to)throw new Error("invalid range ("+from+", "+to+") or no bytes requested!");if(to>datalength-1)throw new Error("only "+datalength+" bytes available! programmer error!");var xhr=new XMLHttpRequest;xhr.open("GET",url,false);if(datalength!==chunkSize)xhr.setRequestHeader("Range","bytes="+from+"-"+to);if(typeof Uint8Array!="undefined")xhr.responseType="arraybuffer";if(xhr.overrideMimeType){xhr.overrideMimeType("text/plain; charset=x-user-defined");}xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error("Couldn't load "+url+". Status: "+xhr.status);if(xhr.response!==undefined){return new Uint8Array(xhr.response||[])}else {return intArrayFromString(xhr.responseText||"",true)}};var lazyArray=this;lazyArray.setDataGetter(function(chunkNum){var start=chunkNum*chunkSize;var end=(chunkNum+1)*chunkSize-1;end=Math.min(end,datalength-1);if(typeof lazyArray.chunks[chunkNum]==="undefined"){lazyArray.chunks[chunkNum]=doXHR(start,end);}if(typeof lazyArray.chunks[chunkNum]==="undefined")throw new Error("doXHR failed!");return lazyArray.chunks[chunkNum]});if(usesGzip||!datalength){chunkSize=datalength=1;datalength=this.getter(0).length;chunkSize=datalength;out("LazyFiles on gzip forces download of the whole file when length is accessed");}this._length=datalength;this._chunkSize=chunkSize;this.lengthKnown=true;};if(typeof XMLHttpRequest!=="undefined"){throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";var lazyArray=new LazyUint8Array;var properties={isDevice:false,contents:lazyArray};}else {var properties={isDevice:false,url:url};}var node=FS.createFile(parent,name,properties,canRead,canWrite);if(properties.contents){node.contents=properties.contents;}else if(properties.url){node.contents=null;node.url=properties.url;}Object.defineProperties(node,{usedBytes:{get:function(){return this.contents.length}}});var stream_ops={};var keys=Object.keys(node.stream_ops);keys.forEach(function(key){var fn=node.stream_ops[key];stream_ops[key]=function forceLoadLazyFile(){if(!FS.forceLoadFile(node)){throw new FS.ErrnoError(29)}return fn.apply(null,arguments)};});stream_ops.read=function stream_ops_read(stream,buffer,offset,length,position){if(!FS.forceLoadFile(node)){throw new FS.ErrnoError(29)}var contents=stream.node.contents;if(position>=contents.length)return 0;var size=Math.min(contents.length-position,length);if(contents.slice){for(var i=0;i<size;i++){buffer[offset+i]=contents[position+i];}}else {for(var i=0;i<size;i++){buffer[offset+i]=contents.get(position+i);}}return size};node.stream_ops=stream_ops;return node},createPreloadedFile:function(parent,name,url,canRead,canWrite,onload,onerror,dontCreateFile,canOwn,preFinish){Browser.init();var fullname=name?PATH_FS.resolve(PATH.join2(parent,name)):parent;function processData(byteArray){function finish(byteArray){if(preFinish)preFinish();if(!dontCreateFile){FS.createDataFile(parent,name,byteArray,canRead,canWrite,canOwn);}if(onload)onload();removeRunDependency();}var handled=false;Module["preloadPlugins"].forEach(function(plugin){if(handled)return;if(plugin["canHandle"](fullname)){plugin["handle"](byteArray,fullname,finish,function(){if(onerror)onerror();removeRunDependency();});handled=true;}});if(!handled)finish(byteArray);}addRunDependency();if(typeof url=="string"){Browser.asyncLoad(url,function(byteArray){processData(byteArray);},onerror);}else {processData(url);}},indexedDB:function(){return window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB},DB_NAME:function(){return "EM_FS_"+window.location.pathname},DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:function(paths,onload,onerror){onload=onload||function(){};onerror=onerror||function(){};var indexedDB=FS.indexedDB();try{var openRequest=indexedDB.open(FS.DB_NAME(),FS.DB_VERSION);}catch(e){return onerror(e)}openRequest.onupgradeneeded=function openRequest_onupgradeneeded(){out("creating db");var db=openRequest.result;db.createObjectStore(FS.DB_STORE_NAME);};openRequest.onsuccess=function openRequest_onsuccess(){var db=openRequest.result;var transaction=db.transaction([FS.DB_STORE_NAME],"readwrite");var files=transaction.objectStore(FS.DB_STORE_NAME);var ok=0,fail=0,total=paths.length;function finish(){if(fail==0)onload();else onerror();}paths.forEach(function(path){var putRequest=files.put(FS.analyzePath(path).object.contents,path);putRequest.onsuccess=function putRequest_onsuccess(){ok++;if(ok+fail==total)finish();};putRequest.onerror=function putRequest_onerror(){fail++;if(ok+fail==total)finish();};});transaction.onerror=onerror;};openRequest.onerror=onerror;},loadFilesFromDB:function(paths,onload,onerror){onload=onload||function(){};onerror=onerror||function(){};var indexedDB=FS.indexedDB();try{var openRequest=indexedDB.open(FS.DB_NAME(),FS.DB_VERSION);}catch(e){return onerror(e)}openRequest.onupgradeneeded=onerror;openRequest.onsuccess=function openRequest_onsuccess(){var db=openRequest.result;try{var transaction=db.transaction([FS.DB_STORE_NAME],"readonly");}catch(e){onerror(e);return}var files=transaction.objectStore(FS.DB_STORE_NAME);var ok=0,fail=0,total=paths.length;function finish(){if(fail==0)onload();else onerror();}paths.forEach(function(path){var getRequest=files.get(path);getRequest.onsuccess=function getRequest_onsuccess(){if(FS.analyzePath(path).exists){FS.unlink(path);}FS.createDataFile(PATH.dirname(path),PATH.basename(path),getRequest.result,true,true,true);ok++;if(ok+fail==total)finish();};getRequest.onerror=function getRequest_onerror(){fail++;if(ok+fail==total)finish();};});transaction.onerror=onerror;};openRequest.onerror=onerror;}};var SYSCALLS={mappings:{},DEFAULT_POLLMASK:5,umask:511,calculateAt:function(dirfd,path){if(path[0]!=="/"){var dir;if(dirfd===-100){dir=FS.cwd();}else {var dirstream=FS.getStream(dirfd);if(!dirstream)throw new FS.ErrnoError(8);dir=dirstream.path;}path=PATH.join2(dir,path);}return path},doStat:function(func,path,buf){try{var stat=func(path);}catch(e){if(e&&e.node&&PATH.normalize(path)!==PATH.normalize(FS.getPath(e.node))){return -54}throw e}HEAP32[buf>>2]=stat.dev;HEAP32[buf+4>>2]=0;HEAP32[buf+8>>2]=stat.ino;HEAP32[buf+12>>2]=stat.mode;HEAP32[buf+16>>2]=stat.nlink;HEAP32[buf+20>>2]=stat.uid;HEAP32[buf+24>>2]=stat.gid;HEAP32[buf+28>>2]=stat.rdev;HEAP32[buf+32>>2]=0;tempI64=[stat.size>>>0,(tempDouble=stat.size,+Math.abs(tempDouble)>=1?tempDouble>0?(Math.min(+Math.floor(tempDouble/4294967296),4294967295)|0)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+40>>2]=tempI64[0],HEAP32[buf+44>>2]=tempI64[1];HEAP32[buf+48>>2]=4096;HEAP32[buf+52>>2]=stat.blocks;HEAP32[buf+56>>2]=stat.atime.getTime()/1e3|0;HEAP32[buf+60>>2]=0;HEAP32[buf+64>>2]=stat.mtime.getTime()/1e3|0;HEAP32[buf+68>>2]=0;HEAP32[buf+72>>2]=stat.ctime.getTime()/1e3|0;HEAP32[buf+76>>2]=0;tempI64=[stat.ino>>>0,(tempDouble=stat.ino,+Math.abs(tempDouble)>=1?tempDouble>0?(Math.min(+Math.floor(tempDouble/4294967296),4294967295)|0)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+80>>2]=tempI64[0],HEAP32[buf+84>>2]=tempI64[1];return 0},doMsync:function(addr,stream,len,flags,offset){var buffer=HEAPU8.slice(addr,addr+len);FS.msync(stream,buffer,offset,len,flags);},doMkdir:function(path,mode){path=PATH.normalize(path);if(path[path.length-1]==="/")path=path.substr(0,path.length-1);FS.mkdir(path,mode,0);return 0},doMknod:function(path,mode,dev){switch(mode&61440){case 32768:case 8192:case 24576:case 4096:case 49152:break;default:return -28}FS.mknod(path,mode,dev);return 0},doReadlink:function(path,buf,bufsize){if(bufsize<=0)return -28;var ret=FS.readlink(path);var len=Math.min(bufsize,lengthBytesUTF8(ret));var endChar=HEAP8[buf+len];stringToUTF8(ret,buf,bufsize+1);HEAP8[buf+len]=endChar;return len},doAccess:function(path,amode){if(amode&~7){return -28}var node;var lookup=FS.lookupPath(path,{follow:true});node=lookup.node;if(!node){return -44}var perms="";if(amode&4)perms+="r";if(amode&2)perms+="w";if(amode&1)perms+="x";if(perms&&FS.nodePermissions(node,perms)){return -2}return 0},doDup:function(path,flags,suggestFD){var suggest=FS.getStream(suggestFD);if(suggest)FS.close(suggest);return FS.open(path,flags,0,suggestFD,suggestFD).fd},doReadv:function(stream,iov,iovcnt,offset){var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAP32[iov+i*8>>2];var len=HEAP32[iov+(i*8+4)>>2];var curr=FS.read(stream,HEAP8,ptr,len,offset);if(curr<0)return -1;ret+=curr;if(curr<len)break}return ret},doWritev:function(stream,iov,iovcnt,offset){var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAP32[iov+i*8>>2];var len=HEAP32[iov+(i*8+4)>>2];var curr=FS.write(stream,HEAP8,ptr,len,offset);if(curr<0)return -1;ret+=curr;}return ret},varargs:undefined,get:function(){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret},getStr:function(ptr){var ret=UTF8ToString(ptr);return ret},getStreamFromFD:function(fd){var stream=FS.getStream(fd);if(!stream)throw new FS.ErrnoError(8);return stream},get64:function(low,high){return low}};function ___sys_fcntl64(fd,cmd,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(fd);switch(cmd){case 0:{var arg=SYSCALLS.get();if(arg<0){return -28}var newStream;newStream=FS.open(stream.path,stream.flags,0,arg);return newStream.fd}case 1:case 2:return 0;case 3:return stream.flags;case 4:{var arg=SYSCALLS.get();stream.flags|=arg;return 0}case 12:{var arg=SYSCALLS.get();var offset=0;HEAP16[arg+offset>>1]=2;return 0}case 13:case 14:return 0;case 16:case 8:return -28;case 9:setErrNo(28);return -1;default:{return -28}}}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function ___sys_ioctl(fd,op,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(fd);switch(op){case 21509:case 21505:{if(!stream.tty)return -59;return 0}case 21510:case 21511:case 21512:case 21506:case 21507:case 21508:{if(!stream.tty)return -59;return 0}case 21519:{if(!stream.tty)return -59;var argp=SYSCALLS.get();HEAP32[argp>>2]=0;return 0}case 21520:{if(!stream.tty)return -59;return -28}case 21531:{var argp=SYSCALLS.get();return FS.ioctl(stream,op,argp)}case 21523:{if(!stream.tty)return -59;return 0}case 21524:{if(!stream.tty)return -59;return 0}default:abort("bad ioctl syscall "+op);}}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function ___sys_open(path,flags,varargs){SYSCALLS.varargs=varargs;try{var pathname=SYSCALLS.getStr(path);var mode=SYSCALLS.get();var stream=FS.open(pathname,flags,mode);return stream.fd}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function _emscripten_memcpy_big(dest,src,num){HEAPU8.copyWithin(dest,src,src+num);}function _emscripten_get_heap_size(){return HEAPU8.length}function emscripten_realloc_buffer(size){try{wasmMemory.grow(size-buffer.byteLength+65535>>>16);updateGlobalBufferAndViews(wasmMemory.buffer);return 1}catch(e){}}function _emscripten_resize_heap(requestedSize){requestedSize=requestedSize>>>0;var oldSize=_emscripten_get_heap_size();var maxHeapSize=2147483648;if(requestedSize>maxHeapSize){return false}var minHeapSize=16777216;for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignUp(Math.max(minHeapSize,requestedSize,overGrownHeapSize),65536));var replacement=emscripten_realloc_buffer(newSize);if(replacement){return true}}return false}function _fd_close(fd){try{var stream=SYSCALLS.getStreamFromFD(fd);FS.close(stream);return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return e.errno}}function _fd_read(fd,iov,iovcnt,pnum){try{var stream=SYSCALLS.getStreamFromFD(fd);var num=SYSCALLS.doReadv(stream,iov,iovcnt);HEAP32[pnum>>2]=num;return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return e.errno}}function _fd_seek(fd,offset_low,offset_high,whence,newOffset){try{var stream=SYSCALLS.getStreamFromFD(fd);var HIGH_OFFSET=4294967296;var offset=offset_high*HIGH_OFFSET+(offset_low>>>0);var DOUBLE_LIMIT=9007199254740992;if(offset<=-DOUBLE_LIMIT||offset>=DOUBLE_LIMIT){return -61}FS.llseek(stream,offset,whence);tempI64=[stream.position>>>0,(tempDouble=stream.position,+Math.abs(tempDouble)>=1?tempDouble>0?(Math.min(+Math.floor(tempDouble/4294967296),4294967295)|0)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[newOffset>>2]=tempI64[0],HEAP32[newOffset+4>>2]=tempI64[1];if(stream.getdents&&offset===0&&whence===0)stream.getdents=null;return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return e.errno}}function _fd_write(fd,iov,iovcnt,pnum){try{var stream=SYSCALLS.getStreamFromFD(fd);var num=SYSCALLS.doWritev(stream,iov,iovcnt);HEAP32[pnum>>2]=num;return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return e.errno}}var FSNode=function(parent,name,mode,rdev){if(!parent){parent=this;}this.parent=parent;this.mount=parent.mount;this.mounted=null;this.id=FS.nextInode++;this.name=name;this.mode=mode;this.node_ops={};this.stream_ops={};this.rdev=rdev;};var readMode=292|73;var writeMode=146;Object.defineProperties(FSNode.prototype,{read:{get:function(){return (this.mode&readMode)===readMode},set:function(val){val?this.mode|=readMode:this.mode&=~readMode;}},write:{get:function(){return (this.mode&writeMode)===writeMode},set:function(val){val?this.mode|=writeMode:this.mode&=~writeMode;}},isFolder:{get:function(){return FS.isDir(this.mode)}},isDevice:{get:function(){return FS.isChrdev(this.mode)}}});FS.FSNode=FSNode;FS.staticInit();Module["FS_createPath"]=FS.createPath;Module["FS_createDataFile"]=FS.createDataFile;Module["FS_createPreloadedFile"]=FS.createPreloadedFile;Module["FS_createLazyFile"]=FS.createLazyFile;Module["FS_createDevice"]=FS.createDevice;Module["FS_unlink"]=FS.unlink;function intArrayFromString(stringy,dontAddNull,length){var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array}__ATINIT__.push({func:function(){___wasm_call_ctors();}});var asmLibraryArg={"c":___sys_fcntl64,"i":___sys_ioctl,"j":___sys_open,"f":_emscripten_memcpy_big,"g":_emscripten_resize_heap,"d":_fd_close,"h":_fd_read,"e":_fd_seek,"b":_fd_write,"a":wasmMemory};var asm=createWasm();var ___wasm_call_ctors=Module["___wasm_call_ctors"]=function(){return (___wasm_call_ctors=Module["___wasm_call_ctors"]=Module["asm"]["l"]).apply(null,arguments)};var _malloc=Module["_malloc"]=function(){return (_malloc=Module["_malloc"]=Module["asm"]["m"]).apply(null,arguments)};var _free=Module["_free"]=function(){return (_free=Module["_free"]=Module["asm"]["n"]).apply(null,arguments)};var _mid_song_start=Module["_mid_song_start"]=function(){return (_mid_song_start=Module["_mid_song_start"]=Module["asm"]["o"]).apply(null,arguments)};var _mid_song_seek=Module["_mid_song_seek"]=function(){return (_mid_song_seek=Module["_mid_song_seek"]=Module["asm"]["p"]).apply(null,arguments)};var _mid_song_get_total_time=Module["_mid_song_get_total_time"]=function(){return (_mid_song_get_total_time=Module["_mid_song_get_total_time"]=Module["asm"]["q"]).apply(null,arguments)};var _mid_song_get_time=Module["_mid_song_get_time"]=function(){return (_mid_song_get_time=Module["_mid_song_get_time"]=Module["asm"]["r"]).apply(null,arguments)};var _mid_song_read_wave=Module["_mid_song_read_wave"]=function(){return (_mid_song_read_wave=Module["_mid_song_read_wave"]=Module["asm"]["s"]).apply(null,arguments)};var _mid_istream_open_mem=Module["_mid_istream_open_mem"]=function(){return (_mid_istream_open_mem=Module["_mid_istream_open_mem"]=Module["asm"]["t"]).apply(null,arguments)};var _mid_istream_close=Module["_mid_istream_close"]=function(){return (_mid_istream_close=Module["_mid_istream_close"]=Module["asm"]["u"]).apply(null,arguments)};var _mid_exit=Module["_mid_exit"]=function(){return (_mid_exit=Module["_mid_exit"]=Module["asm"]["v"]).apply(null,arguments)};var _mid_init=Module["_mid_init"]=function(){return (_mid_init=Module["_mid_init"]=Module["asm"]["w"]).apply(null,arguments)};var _mid_song_load=Module["_mid_song_load"]=function(){return (_mid_song_load=Module["_mid_song_load"]=Module["asm"]["x"]).apply(null,arguments)};var _mid_song_free=Module["_mid_song_free"]=function(){return (_mid_song_free=Module["_mid_song_free"]=Module["asm"]["y"]).apply(null,arguments)};var _mid_alloc_options=Module["_mid_alloc_options"]=function(){return (_mid_alloc_options=Module["_mid_alloc_options"]=Module["asm"]["z"]).apply(null,arguments)};var _mid_get_load_request_count=Module["_mid_get_load_request_count"]=function(){return (_mid_get_load_request_count=Module["_mid_get_load_request_count"]=Module["asm"]["A"]).apply(null,arguments)};var _mid_get_load_request=Module["_mid_get_load_request"]=function(){return (_mid_get_load_request=Module["_mid_get_load_request"]=Module["asm"]["B"]).apply(null,arguments)};var ___errno_location=Module["___errno_location"]=function(){return (___errno_location=Module["___errno_location"]=Module["asm"]["C"]).apply(null,arguments)};Module["UTF8ToString"]=UTF8ToString;Module["addRunDependency"]=addRunDependency;Module["removeRunDependency"]=removeRunDependency;Module["FS_createPath"]=FS.createPath;Module["FS_createDataFile"]=FS.createDataFile;Module["FS_createPreloadedFile"]=FS.createPreloadedFile;Module["FS_createLazyFile"]=FS.createLazyFile;Module["FS_createDevice"]=FS.createDevice;Module["FS_unlink"]=FS.unlink;Module["FS"]=FS;var calledRun;dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller;};function run(args){if(runDependencies>0){return}preRun();if(runDependencies>0)return;function doRun(){if(calledRun)return;calledRun=true;Module["calledRun"]=true;if(ABORT)return;initRuntime();preMain();readyPromiseResolve(Module);if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();postRun();}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout(function(){setTimeout(function(){Module["setStatus"]("");},1);doRun();},1);}else {doRun();}}Module["run"]=run;if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()();}}noExitRuntime=true;run();


  return LibTimidity.ready
}
);
})();
module.exports = LibTimidity;
});

/* src/components/widgets/MIDI.svelte generated by Svelte v3.31.0 */

function instance$O($$self) {
	const subscribeMidiEvents = input => {
		input.addListener("pitchbend", "all", function (e) {
			console.log("Pitch value: " + e.value);
		});

		// Listen for a 'note on' message on all channels
		input.addListener("noteon", "all", e => console.log("Received 'noteon' message (" + e.note.name + e.note.octave + ")."));

		// Listen to pitch bend message on channel 3
		input.addListener("pitchbend", 3, e => console.log("Received 'pitchbend' message.", e));

		// Listen to control change message on all channels
		input.addListener("controlchange", "all", e => console.log("Received 'controlchange' message.", e));

		// Listen to NRPN message on all channels
		input.addListener("nrpn", "all", e => {
			if (e.controller.type === "entry") {
				console.log("Received 'nrpn' 'entry' message.", e);
			}

			if (e.controller.type === "decrement") {
				console.log("Received 'nrpn' 'decrement' message.", e);
			}

			if (e.controller.type === "increment") {
				console.log("Received 'nrpn' 'increment' message.", e);
			}

			console.log("message value: " + e.controller.value + ".", e);
		});

		input.addListener("programchange", "12", e => console.log("Received 'programchange' message.", e));
	};

	const enableMidi = () => {
		webmidi_min.enable(err => {
			if (err) console.log("WebMidi could not be enabled.", err); else {
				console.log("WebMidi enabled!");
				webmidi_min.inputs.map(i => console.log(i.name));
				webmidi_min.outputs.map(o => console.log(o.name));

				// let input = WebMidi.getInputByName("Axiom Pro 25 USB A In");
				let input_xtone = webmidi_min.getInputByName("XTONE");

				let input_mio = webmidi_min.getInputByName("mio");
				if (input_xtone) subscribeMidiEvents(input_xtone);
				if (input_mio) subscribeMidiEvents(input_mio);
			}

			
		});
	};

	const enableTimidity = () => {
		// (hex 0x7FFF); dec number 32767; binary, 01111111 11111111
		console.log(libtimidity);

		// console.log(Timidity);
		// let player = new Timidity(this.baseUrl)
		libtimidity({
			locateFile: file => new URL(file, "/").href
		}).then(lib => {
			this._lib = lib;
			this._onLibReady();
		});
	}; // const player = new Timidity()
	// player.load('../static/deadmau5-Deus-Ex-Machina.mid')
	// player.play()
	// player.on('playing', () => {

	//   console.log(player.duration) // => 351.521
	// })
	onMount(async () => {
		enableMidi();
		enableTimidity();
	});

	return [];
}

class MIDI extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$O, null, safe_not_equal, {});
	}
}

var default_playground_layout = [
	{
		"2": {
			fixed: false,
			resizable: true,
			draggable: true,
			customDragger: false,
			customResizer: false,
			min: {
				w: 1,
				h: 1
			},
			max: {
			},
			x: 1,
			y: 0,
			w: 1,
			h: 2
		},
		"3": {
			fixed: false,
			resizable: true,
			draggable: true,
			customDragger: false,
			customResizer: false,
			min: {
				w: 1,
				h: 1
			},
			max: {
			},
			x: 2,
			y: 0,
			w: 1,
			h: 2
		},
		"6": {
			fixed: false,
			resizable: true,
			draggable: true,
			customDragger: false,
			customResizer: false,
			min: {
				w: 1,
				h: 1
			},
			max: {
			},
			x: 4,
			y: 0,
			w: 2,
			h: 2,
			id: "_mtcxvez7a"
		},
		"8": {
			fixed: false,
			resizable: true,
			draggable: true,
			customDragger: false,
			customResizer: false,
			min: {
				w: 1,
				h: 1
			},
			max: {
			},
			x: 5,
			y: 0,
			w: 3,
			h: 2,
			id: "_mtcxvez7a"
		},
		"12": {
			fixed: false,
			resizable: true,
			draggable: true,
			customDragger: false,
			customResizer: false,
			min: {
				w: 1,
				h: 1
			},
			max: {
			},
			x: 7,
			y: 0,
			w: 5,
			h: 2,
			id: "_mtcxvez7a"
		},
		id: "_mtcxvez7a",
		data: {
			id: "_mtcxvez7a",
			type: "analyser",
			name: "analyser_mtcxvez7a",
			background: "#000000",
			lineNumbers: true,
			hasFocus: true,
			theme: "icecoder",
			mode: ""
		},
		hasFocus: false
	},
	{
		"2": {
			fixed: false,
			resizable: true,
			draggable: true,
			customDragger: false,
			customResizer: false,
			min: {
				w: 1,
				h: 1
			},
			max: {
			},
			x: 0,
			y: 2,
			w: 1,
			h: 2
		},
		"3": {
			fixed: false,
			resizable: true,
			draggable: true,
			customDragger: false,
			customResizer: false,
			min: {
				w: 1,
				h: 1
			},
			max: {
			},
			x: 2,
			y: 2,
			w: 1,
			h: 5,
			id: "_ae99mi2yd"
		},
		"6": {
			fixed: false,
			resizable: true,
			draggable: true,
			customDragger: false,
			customResizer: false,
			min: {
				w: 1,
				h: 1
			},
			max: {
			},
			x: 4,
			y: 2,
			w: 2,
			h: 5,
			id: "_ae99mi2yd"
		},
		"8": {
			fixed: false,
			resizable: true,
			draggable: true,
			customDragger: false,
			customResizer: false,
			min: {
				w: 1,
				h: 1
			},
			max: {
			},
			x: 5,
			y: 2,
			w: 3,
			h: 5,
			id: "_ae99mi2yd"
		},
		"12": {
			fixed: false,
			resizable: true,
			draggable: true,
			customDragger: false,
			customResizer: false,
			min: {
				w: 1,
				h: 1
			},
			max: {
			},
			x: 7,
			y: 2,
			w: 5,
			h: 5,
			id: "_ae99mi2yd"
		},
		id: "_ae99mi2yd",
		data: {
			id: "_ae99mi2yd",
			type: "grammarEditor",
			name: "grammarEditor_ae99mi2yd",
			background: "#151515",
			lineNumbers: true,
			hasFocus: true,
			theme: "monokai",
			grammarSource: "/languages/default/grammar.ne",
			content: "# GRAMMAR EDITOR\n\n# Lexer [or tokenizer] definition with language lexemes [or tokens]\n@{%\n\nconst lexer = moo.compile({\n  separator:      /,/,\n  paramEnd:       /}/,\n  paramBegin:     /{/,\n  listEnd:        /\\]/,\n  listBegin:      /\\[/,\n  dacoutCh:       /\\>[0-9]+/,\n  dacout:         /\\>/,\n  variable:       /:[a-zA-Z0-9]+:/,\n  sample:         { match: /\\\\[a-zA-Z0-9]+/, lineBreaks: true, value: x => x.slice(1, x.length)},\n  slice:          { match: /\\|[a-zA-Z0-9]+/, lineBreaks: true, value: x => x.slice(1, x.length)},\n  stretch:        { match: /\\@[a-zA-Z0-9]+/, lineBreaks: true, value: x => x.slice(1, x.length)},\n  clockTrig:      /0t-?(?:[0-9]|[1-9][0-9]+)(?:\\.[0-9]+)?\\b/,\n\tnumber:         /-?(?:[0-9]|[1-9][0-9]+)(?:\\.[0-9]+)?\\b/,\n  semicolon:      /;/,\n  funcName:       /[a-zA-Z][a-zA-Z0-9]*/,\n\tstring:\t\t\t\t\t{ match: /'[a-zA-Z0-9]+'/, value: x => x.slice(1,x.length-1)},\n  comment:        /\\/\\/[^\\n]*/,\n  ws:             { match: /\\s+/, lineBreaks: true},\n});\n\n%}\n\n# Pass your lexer object using the @lexer option\n@lexer lexer\n\n# Grammar definition in the Extended Backus Naur Form (EBNF)\nmain -> _ Statement _\n{% d => ( { '@lang' : d[1] } )  %}\n\nStatement ->\n  %comment _ Statement\n  {% d => d[2] %}\n\t|\n  Expression _ %semicolon _ Statement\n  {% d => [ { '@spawn': d[0] } ].concat(d[4]) %}\n  |\n  Expression _ %semicolon (_ %comment):*\n  {% d => [ { '@spawn': d[0] } ] %}\n\n\nExpression ->\n  ParameterList _ %funcName\n  {% d => sema.synth( d[2].value, d[0]['@params'] ) %}\n  |\n  ParameterList _ %sample\n  {% d => sema.synth( 'sampler', d[0]['@params'].concat( [ sema.str( d[2].value ) ] ) ) %}\n  |\n  ParameterList _ %slice\n  {% d => sema.synth( 'slice', d[0]['@params'].concat( [ sema.str( d[2].value ) ] ) ) %}\n  |\n  ParameterList _ %stretch\n  {% d => sema.synth( 'stretch', d[0]['@params'].concat( [ sema.str( d[2].value ) ] ) ) %}\n  |\n  %variable _ Expression\n  {% d => sema.setvar( d[0].value, d[2] ) %}\n  |\n  %dacout _ Expression\n  {% d => sema.synth( 'dac', [d[2]] ) %}\n  |\n  %dacoutCh _ Expression\n  {% d => sema.synth( 'dac', [d[2], sema.num(d[0].value.substr(1))] ) %}\n\nParameterList ->\n  %paramBegin Params %paramEnd\n  {% d => ( { 'paramBegin': d[0], '@params': d[1], 'paramEnd': d[2] } ) %}\n\t|\n\t%paramBegin _ %paramEnd\n  {% d => ( { 'paramBegin': d[0], '@params': [], 'paramEnd': d[2] } ) %}\n\n\nParams ->\n  ParamElement\n  {% d => ( [ d[0] ] ) %}\n  |\n  ParamElement _ %separator _ Params\n  {% d => [ d[0] ].concat(d[4]) %}\n\nParamElement ->\n  %number\n  {% d => ( { '@num': d[0] } ) %}\n\t|\n\t%string\n  {% d => ( { '@string': d[0].value } ) %}\n  |\n  Expression\n  {% id %}\n  |\n  %variable\n  {% d => sema.getvar( d[0].value ) %}\n  |\n  %listBegin Params  %listEnd\n  {% d => ( { '@list': d[1] } )%}\n\n\n# Whitespace\n\n_  -> wschar:*\n{% function(d) {return null;} %}\n\n__ -> wschar:+\n{% function(d) {return null;} %}\n\nwschar -> %ws\n{% id %}\n"
		},
		hasFocus: false
	},
	{
		"2": {
			fixed: false,
			resizable: true,
			draggable: true,
			customDragger: false,
			customResizer: false,
			min: {
				w: 1,
				h: 1
			},
			max: {
			},
			x: 0,
			y: 0,
			w: 1,
			h: 2
		},
		"3": {
			fixed: false,
			resizable: true,
			draggable: true,
			customDragger: false,
			customResizer: false,
			min: {
				w: 1,
				h: 1
			},
			max: {
			},
			x: 0,
			y: 0,
			w: 2,
			h: 7,
			id: "_cctdhevvf"
		},
		"6": {
			fixed: false,
			resizable: true,
			draggable: true,
			customDragger: false,
			customResizer: false,
			min: {
				w: 1,
				h: 1
			},
			max: {
			},
			x: 0,
			y: 0,
			w: 4,
			h: 7,
			id: "_cctdhevvf"
		},
		"8": {
			fixed: false,
			resizable: true,
			draggable: true,
			customDragger: false,
			customResizer: false,
			min: {
				w: 1,
				h: 1
			},
			max: {
			},
			x: 0,
			y: 0,
			w: 5,
			h: 7,
			id: "_cctdhevvf"
		},
		"12": {
			fixed: false,
			resizable: true,
			draggable: true,
			customDragger: false,
			customResizer: false,
			min: {
				w: 1,
				h: 1
			},
			max: {
			},
			x: 0,
			y: 0,
			w: 7,
			h: 7,
			id: "_cctdhevvf"
		},
		id: "_cctdhevvf",
		data: {
			id: "_cctdhevvf",
			type: "liveCodeEditor",
			name: "liveCodeEditor_cctdhevvf",
			background: "#151515",
			lineNumbers: true,
			hasFocus: true,
			theme: "icecoder",
			grammarSource: "/languages/default/grammar.ne",
			liveCodeSource: "",
			content: "// STORMZY - VOSSI BOP\n\n:arp:{{3}clp, [1,1], [932,784,932,1174,932,739,932,1174]}rsq;\n:tune:{:arp:}sin;\n\n:bass:{{2}clp, [1,0,1,1], [50,0,50,50,0]}rsq;\n:sub:{:bass:}tri;\n{{20000}clt, 1,:sub:}scop;\t\t\t \n\t\t\t \n:trig1:{{2}clp, [1,1]}rsq;\n:speed:{{3}clp, [1,2], [1,2, {0.1}pha]}rsq;\n:closed:{:trig1:,:speed:}\\909closed;\n\n:trig3:{{1}clp, [3,1,3,3,1,1]}rsq;\n:beat:{:trig3:,1}\\909b;\n\n>{{:closed:,0.9}mul,{:tune:,0.1}mul,{:beat:,0.5}mul,{:sub:,0.5}mul}mix;\n\n// Press cmd-Enter [Mac] OR ctrl-Enter [Win/Linux] to evaluate this code and playback sound!\n\n// Press cmd-. [Mac] OR ctrl-. [Win/Linux] to stop sound! ",
			grammar: "# GRAMMAR EDITOR\n\n# Lexer [or tokenizer] definition with language lexemes [or tokens]\n@{%\n\nconst lexer = moo.compile({\n  separator:      /,/,\n  paramEnd:       /}/,\n  paramBegin:     /{/,\n  listEnd:        /\\]/,\n  listBegin:      /\\[/,\n  dacoutCh:       /\\>[0-9]+/,\n  dacout:         /\\>/,\n  variable:       /:[a-zA-Z0-9]+:/,\n  sample:         { match: /\\\\[a-zA-Z0-9]+/, lineBreaks: true, value: x => x.slice(1, x.length)},\n  slice:          { match: /\\|[a-zA-Z0-9]+/, lineBreaks: true, value: x => x.slice(1, x.length)},\n  stretch:        { match: /\\@[a-zA-Z0-9]+/, lineBreaks: true, value: x => x.slice(1, x.length)},\n  clockTrig:      /0t-?(?:[0-9]|[1-9][0-9]+)(?:\\.[0-9]+)?\\b/,\n\tnumber:         /-?(?:[0-9]|[1-9][0-9]+)(?:\\.[0-9]+)?\\b/,\n  semicolon:      /;/,\n  funcName:       /[a-zA-Z][a-zA-Z0-9]*/,\n\tstring:\t\t\t\t\t{ match: /'[a-zA-Z0-9]+'/, value: x => x.slice(1,x.length-1)},\n  comment:        /\\/\\/[^\\n]*/,\n  ws:             { match: /\\s+/, lineBreaks: true},\n});\n\n%}\n\n# Pass your lexer object using the @lexer option\n@lexer lexer\n\n# Grammar definition in the Extended Backus Naur Form (EBNF)\nmain -> _ Statement _\n{% d => ( { '@lang' : d[1] } )  %}\n\nStatement ->\n  %comment _ Statement\n  {% d => d[2] %}\n\t|\n  Expression _ %semicolon _ Statement\n  {% d => [ { '@spawn': d[0] } ].concat(d[4]) %}\n  |\n  Expression _ %semicolon (_ %comment):*\n  {% d => [ { '@spawn': d[0] } ] %}\n\n\nExpression ->\n  ParameterList _ %funcName\n  {% d => sema.synth( d[2].value, d[0]['@params'] ) %}\n  |\n  ParameterList _ %sample\n  {% d => sema.synth( 'sampler', d[0]['@params'].concat( [ sema.str( d[2].value ) ] ) ) %}\n  |\n  ParameterList _ %slice\n  {% d => sema.synth( 'slice', d[0]['@params'].concat( [ sema.str( d[2].value ) ] ) ) %}\n  |\n  ParameterList _ %stretch\n  {% d => sema.synth( 'stretch', d[0]['@params'].concat( [ sema.str( d[2].value ) ] ) ) %}\n  |\n  %variable _ Expression\n  {% d => sema.setvar( d[0].value, d[2] ) %}\n  |\n  %dacout _ Expression\n  {% d => sema.synth( 'dac', [d[2]] ) %}\n  |\n  %dacoutCh _ Expression\n  {% d => sema.synth( 'dac', [d[2], sema.num(d[0].value.substr(1))] ) %}\n\nParameterList ->\n  %paramBegin Params %paramEnd\n  {% d => ( { 'paramBegin': d[0], '@params': d[1], 'paramEnd': d[2] } ) %}\n\t|\n\t%paramBegin _ %paramEnd\n  {% d => ( { 'paramBegin': d[0], '@params': [], 'paramEnd': d[2] } ) %}\n\n\nParams ->\n  ParamElement\n  {% d => ( [ d[0] ] ) %}\n  |\n  ParamElement _ %separator _ Params\n  {% d => [ d[0] ].concat(d[4]) %}\n\nParamElement ->\n  %number\n  {% d => ( { '@num': d[0] } ) %}\n\t|\n\t%string\n  {% d => ( { '@string': d[0].value } ) %}\n  |\n  Expression\n  {% id %}\n  |\n  %variable\n  {% d => sema.getvar( d[0].value ) %}\n  |\n  %listBegin Params  %listEnd\n  {% d => ( { '@list': d[1] } )%}\n\n\n# Whitespace\n\n_  -> wschar:*\n{% function(d) {return null;} %}\n\n__ -> wschar:+\n{% function(d) {return null;} %}\n\nwschar -> %ws\n{% id %}\n"
		},
		hasFocus: true
	}
];

var hello_world_code_example = "importScripts(\"https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/dist/tf.min.js\");\n____\n//js  Linear model for regression (tfjs)\n\n//create the model\nvar model = tf.sequential();\nmodel.add(tf.layers.dense({ units: 1, inputShape: [1] }));\nmodel.compile({ loss: 'meanSquaredError', optimizer: 'sgd' });\n\n//set up the training data set\nvar xs = tf.tensor2d([0, 1, 2, 3, 4, 5], [6, 1]);\nvar ys = tf.tensor2d([0, 50, 100, 150, 200, 250], [6, 1]);\n\n//train the model on the data set\nmodel.fit(xs, ys, { epochs: 150 }).then(result => {console.log(`DEBUG:ml.model: Model trained`); console.dir(result)});\n\n//defining the callback for testing the model on new data\nvar test = (x) => { return model.predict(tf.tensor2d([x], [1, 1])).dataSync()[0]; }\n__________\n\n//route the test data into the model\nvar w = 0;\ninput = (x, id) => {\n\tconsole.log(\">toModel: \"+[id,x]);\n\tlet prediction = test(x);\n\tconsole.log('pred: ',prediction);\n\toutput(prediction, 0)\n};\n";

var two_layer_non_linear_code_example = "importScripts(\"https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/dist/tf.min.js\");\n____\n//js  Two-layer non linear model for regression (tfjs)\n\nvar model = tf.sequential();\nmodel.add(tf.layers.dense({\n  inputShape: [1],\n  units: 50,\n  activation: 'sigmoid',\n  kernelInitialiser: 'leCunNormal' }));\nmodel.add(tf.layers.dense({ units: 1 }));\nmodel.compile({ loss: 'meanSquaredError', optimizer: 'sgd' });\n\n//set up the training data set\nvar xs = tf.tensor2d([-1, 0, 1, 2, 3, 4], [6, 1]);\nvar ys = tf.tensor2d([-3, -1, 1, 3, 500, 70], [6, 1]);\n\n//train the model on the data set\nmodel.fit(xs, ys, { epochs: 50 }).then(result => {console.log(`INFO:ml.model: Model trained`); console.dir(result)});\n\n//define the callback for testing the model on new data\nvar test = (x) => { return model.predict(tf.tensor2d([x], [1, 1])).dataSync()[0]; }\n____\n//route the test data into the model\n\nvar w = 0;\ninput = (x,id) => {\n\tconsole.log(\">toModel:   \"+[id,x]);\n\tlet p = test(x);\n\toutput(p, 0);\n};\n";

var binary_classification_code_example = "importScripts(\"https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/dist/tf.min.js\");\n___\n//js - Three-layer model for binary classification (tfjs)\n\nvar model = tf.sequential();\nmodel.add(tf.layers.dense({\n  inputShape: [1],\n  units: 100,\n  activation: 'sigmoid'\n}));\nmodel.add(tf.layers.dense({ units: 100, activation: 'sigmoid' }));\nmodel.add(tf.layers.dense({ units: 1, activation: 'sigmoid' }));\nmodel.compile({\n  optimizer: 'adam',\n  loss: 'binaryCrossentropy',\n  metrics: ['accuracy']\n});\n\n//set up the training data set\nvar xs = tf.tensor2d([-1, 0, 1, 2, 3, 4], [6, 1]);\nvar ys = tf.tensor2d([1, 0, 1, 0, 0, 1], [6, 1]);\n\n//train the model on the data set\nmodel.fit(xs, ys, { epochs: 50 }).then( result => {\n  console.log(`DEBUG:ml.model: Model trained`); console.dir(result)\n});\n\n//define the callback for testing the model on new data\nvar test = (x) => {\n  return model.predict(tf.tensor2d([x], [1, 1])).dataSync()[0];\n}\n\n___\n//route the test data into the model\n\nvar w = 0;\nvar w = 0;\ninput = (x,id) => {\n\tconsole.log(\">toModel:   \"+[id,x]);\n\tlet p = test(x);\n\toutput(p, 0);\n};\n";

var echo_state_network_code_example = "// MODEL EDITOR\n\n//js - Echo state network (tfjs)\nvar esn = {};\nesn.N = 10;\nesn.NOut = 1;\nesn.x = tf.randomUniform([esn.N,1]);\nesn.res = tf.randomNormal([esn.N, esn.N],0, 1.9);\nesn.wout = tf.randomUniform([esn.NOut,esn.N]);\nesn.output = tf.zeros([esn.Nout])\nesn.leakRate = tf.scalar(0.5);\nesn.leakRateInv = tf.sub(tf.scalar(1.0), esn.leakRate);\nesn.leakRateInv.dataSync()\nesn.xold = tf.clone(esn.x);\n\nesn.calc = () => {\n tf.tidy(() => {\n     tf.dispose(esn.xold);\n     esn.xold = esn.x;\n     let xnew =  tf.matMul(esn.res, esn.x);\n     xnew = tf.add(tf.mul(tf.tanh(xnew), esn.leakRate), tf.mul(tf.tanh(esn.xold), esn.leakRateInv));\n     esn.x = tf.keep(xnew);\n     let newOutput = tf.keep(tf.matMul(esn.wout, esn.x));\n     tf.dispose(esn.output);\n     esn.output = tf.keep(newOutput);\n     return 0;\n });\n};\n__________\nesn.calc()\nesn.output.dataSync()\n//esn.res.dataSync()\n__________\nnext = () => {return 0;}\n__________\nnext = () => {\n   esn.calc()\n   return ((esn.output.dataSync()[0] + 1) * 100) + 100;\n}\n__________\n";

var lstm_txt_gen_code_example = "importScripts(\"https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/dist/tf.min.js\");\n___\n//js - Long-short-term-memory (LSTM) model for text generation (tfjs)\n\n// Hyperparameters of LSTM model\nvar lstmLayerSizes;\nvar learningRate;\nvar numEpochs;\nvar examplesPerEpoch;\nvar batchSize;\nvar validationSplit;\nvar sentenceIndices;\nvar length;\nvar temperature;\n\n//create the model\ncreateModel(lstmLayerSizes) {\n  if (!Array.isArray(lstmLayerSizes)) {\n    lstmLayerSizes = [lstmLayerSizes];\n  }\n  this.model = tf.sequential();\n  for (let i = 0; i < lstmLayerSizes.length; ++i) {\n    const lstmLayerSize = lstmLayerSizes[i];\n    this.model.add(tf.layers.lstm({\n      units: lstmLayerSize,\n      returnSequences: i < lstmLayerSizes.length - 1,\n      inputShape: i === 0 ? [this.sampleLen_, this.charSetSize_] : undefined\n    }));\n  }\n  this.model.add(\n      tf.layers.dense({units: this.charSetSize_, activation: 'softmax'}));\n}\n\ncompileModel(learningRate) {\n  const optimizer = tf.train.rmsprop(learningRate);\n  this.model.compile({optimizer: optimizer, loss: 'categoricalCrossentropy'});\n  console.log(`Compiled model with learning rate ${learningRate}`);\n  this.model.summary();\n}\n\nasync fitModel(numEpochs, examplesPerEpoch, batchSize, validationSplit) {\n  let batchCount = 0;\n  const batchesPerEpoch = examplesPerEpoch / batchSize;\n  const totalBatches = numEpochs * batchesPerEpoch;\n  onTrainBegin();\n  await tf.nextFrame();\n  let t = new Date().getTime();\n  for (let i = 0; i < numEpochs; ++i) {\n    const [xs, ys] = this.textData_.nextDataEpoch(examplesPerEpoch);\n    await this.model.fit(xs, ys, {\n      epochs: 1,\n      batchSize: batchSize,\n      validationSplit,\n      callbacks: {\n        onBatchEnd: async (batch, logs) => {\n          // Calculate the training speed in the current batch, in # of\n          // examples per second.\n          const t1 = new Date().getTime();\n          const examplesPerSec = batchSize / ((t1 - t) / 1e3);\n          t = t1;\n          onTrainBatchEnd(logs, ++batchCount / totalBatches, examplesPerSec);\n        },\n        onEpochEnd: async (epoch, logs) => {\n          onTrainEpochEnd(logs);\n        },\n      }\n    });\n    xs.dispose();\n    ys.dispose();\n  }\n}\nasync generateText(sentenceIndices, length, temperature) {\n  onTextGenerationBegin();\n  const temperatureScalar = tf.scalar(temperature);\n  let generated = '';\n  while (generated.length < length) {\n    // Encode the current input sequence as a one-hot Tensor.\n    const inputBuffer =\n        new tf.TensorBuffer([1, this.sampleLen_, this.charSetSize_]);\n    for (let i = 0; i < this.sampleLen_; ++i) {\n      inputBuffer.set(1, 0, i, sentenceIndices[i]);\n    }\n    const input = inputBuffer.toTensor();\n    // Call model.predict() to get the probability values of the next\n    // character.\n    const output = this.model.predict(input);\n    // Sample randomly based on the probability values.\n    const winnerIndex = sample(tf.squeeze(output), temperatureScalar);\n    const winnerChar = this.textData_.getFromCharSet(winnerIndex);\n    await onTextGenerationChar(winnerChar);\n    generated += winnerChar;\n    sentenceIndices = sentenceIndices.slice(1);\n    sentenceIndices.push(winnerIndex);\n    input.dispose();\n    output.dispose();\n  }\n  temperatureScalar.dispose();\n  return generated;\n}\n";

var new_learner_template = "importScripts(\"https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/dist/tf.min.js\");\n____\n//route the test data into the model\n\nvar w = 0;\ninput = (x,id) => {\n\tconsole.log(\">toModel:   \"+[id,x]);\n\tlet p = test(x);\n\toutput(p, 0);\n};\n";

// import music_rnn_example                  from "../machineLearning/magenta/music-rnn.tf";



const isUploadOverlayVisible = writable(false);
const isSaveOverlayVisible = writable(false);
const isDeleteOverlayVisible = writable(false);

// Dashboard Store for Live Code Editor options in Sidebar component
const sidebarLiveCodeOptions = writable([
	{ id: 0, disabled: false, text: `livecode`, content: "" },
  // { id: 1, disabled: false, text: `new`, content: {
  //     grammar:  `/languages/default/grammar.ne`,
  //     livecode: undefined
  //   }
  // },
	// { id: 0, disabled: true, text: `LiveCode Editor`, content: "" },
	// { id: 1, disabled: false, text: `+ default`, content: default_liveCode },
	// { id: 2, disabled: false, text: `+ nibble`, content: nibble_liveCode },
	// { id: 3, disabled: false, text: `+ gabber`, content: gabber_liveCode }
]);

const selectedLiveCodeOption = writable(sidebarLiveCodeOptions[1]);
const isSelectLiveCodeEditorDisabled = writable(false);


// Store for TFJS model options in Sidebar component
// export const sidebarModelOptions = writable([]);
const sidebarModelOptions = writable([
	{ id: 0, disabled: false, text: `Javascript`, content: "" },
	{ id: 1, disabled: false, text: `hello-world`, content: hello_world_code_example },
	{
		id: 2,
    disabled: false,
		text: `two-layer-non-linear`,
		content: two_layer_non_linear_code_example,
	},
	{
		id: 3,
    disabled: false,
		text: `binary-classification`,
		content: binary_classification_code_example,
	},
	{
		id: 4,
    disabled: false,
		text: `echo-state-network`,
		content: echo_state_network_code_example,
	},
	{
		id: 5,
    disabled: false,
		text: `lstm-text-gen`,
		content: lstm_txt_gen_code_example,
	},
	{
		id: 6,
    disabled: false,
		text: `* new *`,
		content: new_learner_template,
	}
]);


const selectedModelOption = writable(sidebarModelOptions[1]);
const isSelectModelEditorDisabled = writable(false);

const isAddGrammarEditorDisabled = writable(false);


// Dashboard Store for Live Code Editor options in Sidebar component
const sidebarDebuggerOptions = writable([
	{ id: 0, disabled: false, type: ``, text: `debug`, content: "" },
	{
		id: 1,
		disabled: false,
		type: `console`,
		text: `Console`,
		content: "",
	},
	{
		id: 1,
		disabled: false,
		type: `liveCodeParseOutput`,
		text: `Live Code Parser`,
		content: "",
	},
	{
		id: 2,
		disabled: false,
		type: `dspCode`,
		text: `DSP Code`,
		content: "",
	},
	{
		id: 3,
		disabled: false,
		type: `grammarCompileOutput`,
		text: `Grammar Compiler`,
		content: "",
	},
	// {
	// 	id: 5,
	// 	disabled: false,
	// 	type: `storeInspector`,
	// 	text: `Store Inspector`,
	// 	content: "",
	// },
]);

let selectedDebuggerOption = writable({});


const loadEnvironmentOptions  = writable([
	{ id: 0, disabled: false, text: `load`, content: "" },
	// { id: 0, disabled: false, text: `Load`, content: "" },
	// { id: 0, disabled: false, text: `Load`, content: "" },
	// { id: 1, disabled: false, text: `new`, content: {
	//     grammar:  `/languages/default/grammar.ne`,
	//     livecode: undefined
	//   }
	// },
]);

const selectedLoadEnvironmentOption = writable(loadEnvironmentOptions[1]);
const isLoadEnvironmentOptionsDisabled = writable(false);

const isAddAnalyserDisabled = writable(false);

/*******                                        ********/
/*******       Playground Sidebar Stores        ********/
/*******                                        ********/
/*******                                        ********/
/*******                                        ********/
/*******                                        ********/
/*******                                        ********/
/*******                                        ********/
/*******                                        ********/
/*******   Playground Language Design Stores    ********/
/*******                                        ********/

// // export const grammarEditorValue = writable(initGrammarEditorValue());
// export const grammarEditorValue = writable("");

// // export const grammarCompiledParser = writable(compile(default_grammar).output);
// export const grammarCompiledParser = writable("");

// export const grammarCompilationErrors = writable("");

// // export const liveCodeEditorValue = writable(initLiveCodeEditorValue());
// export const liveCodeEditorValue = writable("");

// export const liveCodeParseResults = writable("");

// export const liveCodeParseErrors = writable("");

// export const liveCodeAbstractSyntaxTree = writable("");

// export const dspCode = writable("");

// // export const modelEditorValue = writable(initModelEditorValue());
// export const modelEditorValue = writable("");

/*******                                        ********/
/*******   Playground Language Design Stores    ********/
/*******                                        ********/
/*******                                        ********/
/*******                                        ********/
/*******                                        ********/
/*******                                        ********/
/*******                                        ********/
/*******                                        ********/
/*******                                        ********/
/*******                                        ********/
/*******   Playground Dashboard Items Stores    ********/
/*******                                        ********/



/**
 * * Test items to study responsive system
 *
 *
 *
 */
const testItems = [
	{
		id: id(),
		12: gridHelp.item({ x: 2, y: 0, w: 2, h: 2 }),
		8: gridHelp.item({ x: 0, y: 0, w: 2, h: 2 }),
		6: gridHelp.item({ x: 0, y: 0, w: 2, h: 2 }),
		3: gridHelp.item({ x: 0, y: 0, w: 1, h: 2 }),
		2: gridHelp.item({
			x: 0,
			y: 0,
			w: 1,
			h: 2,
		}),
		data: {
			type: "liveCodeEditor",
			name: "hello-world",
			background: "#151515",
			lineNumbers: true,
			hasFocus: false,
			background: "#151515",
			theme: "icecoder",
			component: LiveCodeEditor,
			content: "#lc-1",
			grammarSource: "/languages/default/grammar.ne",
		},
	},
	{
		id: id(),
		12: gridHelp.item({ x: 2, y: 0, w: 2, h: 2 }),
		8: gridHelp.item({ x: 2, y: 0, w: 2, h: 2 }),
		6: gridHelp.item({ x: 2, y: 0, w: 2, h: 2 }),
		3: gridHelp.item({ x: 2, y: 0, w: 1, h: 2 }),
		2: gridHelp.item({
			x: 0,
			y: 0,
			w: 1,
			h: 2,
		}),
		data: {
			type: "grammarEditor",
			name: "hello-world",
			background: "#151515",
			lineNumbers: true,
			hasFocus: false,
			background: "#151515",
			theme: "icecoder",
			component: GrammarEditor,
			content: "#ge-1",
			grammarSource: "/languages/default/grammar.ne",
		},
	},

	// {
	// 	6: gridHelp.item({
	// 		x: 0,
	// 		y: 0,
	// 		w: 2,
	// 		h: 2,
	// 	}),
	// 	id: id(),
	// },

	/*
	{
		...gridHelp.item({ x: 10, y: 2, w: 2, h: 1, id: id() }),
		...{
			name: "hello world",
			type: "grammarEditor",
			lineNumbers: true,
			hasFocus: false,
			theme: "monokai",
			background: "#AAAAAA",
			component: GrammarEditor,
			data: "#g-1",
		},
		...{
			breakpoints: {
				10: { x: 0, y: 0, w: 2, h: 2 },
				2: { x: 0, y: 0, w: 1, h: 2 },
				1: { x: 0, y: 0, w: 1, h: 2 },
			},
		},
	},

	{
		...gridHelp.item({ x: 0, y: 4, w: 3, h: 1, id: id() }),
		...{
			name: "hello world",
			type: "modelEditor",
			lineNumbers: true,
			hasFocus: false,
			theme: "monokai",
			background: "#f0f0f0",
			component: ModelEditor,
			data: "//m-1\nsema.env.saveLocal('1')",
		},
		...{
			breakpoints: {
				10: { x: 0, y: 0, w: 2, h: 2 },
				2: { x: 0, y: 0, w: 1, h: 2 },
				1: { x: 0, y: 0, w: 1, h: 2 },
			},
		},
	},

	{
		...gridHelp.item({ x: 0, y: 8, w: 1, h: 1, id: id() }),
		...{
			name: "hello world",
			type: "analyser",
			lineNumbers: true,
			hasFocus: false,
			theme: "monokai",
			background: "#f0f0f0",
			component: Analyser,
			mode: "spectrogram",
			data: "1",
		},
		...{
			breakpoints: {
				10: { x: 0, y: 0, w: 2, h: 2 },
				2: { x: 0, y: 0, w: 2, h: 2 },
				1: { x: 0, y: 0, w: 2, h: 2 },
			},
		},
	}
  */
];


// export const populateStoresWithFetchedProps = async (newItem) => {

//   if(newItem.type === 'liveCodeEditor')
//     try{
//       newItem.data = await fetchFrom(newItem.liveCodeSource);
//       liveCodeEditorValue.set(newItem.data);
//       let grammar = await fetchFrom(newItem.grammarSource);
//       grammarEditorValue.set(grammar);
//       let compileOutput = compile(grammar).output;
//       grammarCompiledParser.set(compileOutput);
//     }
//     catch(error){
//       console.error("Error Populating stores with fetched liveCode props")
//     }
//   else if (newItem.type === 'grammarEditor')
//     grammarEditorValue.set(item.data);
// }

/**
 * @createNewItem creates a new widget as new grid item object with properties that will be (de)serialized to the layout
 * wraps up components (e.g. LiveCodeEditor) which may have considerable load time and needs to be asynchronous
 * ! NEED TO use traditional function declaration to prevent Temporal Dead Zone issue
 * TODO: Refactor to TS to apply inheritance and define parameter types
 * @param widget type (e.g 'liveCodeEditor')
 * @param content data hold held by the widget (e.g. liveCodeSource)
 */
async function createNewItem (type, content){
	let data, layout;
	switch (type) {
		case "storeInspector":
			data = {
				component: StoreInspector,
				background: "#d1d5ff",
			};
			layout = {
				12: gridHelp.item({ x: 0, y: 0, w: 9, h: 5 }),
				8: gridHelp.item({ x: 0, y: 0, w: 7, h: 5 }),
				6: gridHelp.item({ x: 0, y: 0, w: 5, h: 3 }),
				3: gridHelp.item({ x: 0, y: 0, w: 3, h: 2 }),
				2: gridHelp.item({ x: 0, y: 0, w: 2, h: 2 }),
			};
			break;
		case "liveCodeEditor":
			data = {
				component: LiveCodeEditor,
				background: "#151515",
				theme: "icecoder",
				grammarSource: content.grammar,
				liveCodeSource: content.livecode,
				content: content.code, // changed from `data`
			};
			layout = {
				12: gridHelp.item({ x: 0, y: 0, w: 8, h: 5 }),
				8: gridHelp.item({ x: 0, y: 0, w: 7, h: 5 }),
				6: gridHelp.item({ x: 0, y: 0, w: 4, h: 3 }),
				3: gridHelp.item({ x: 0, y: 0, w: 2, h: 2 }),
				2: gridHelp.item({ x: 0, y: 0, w: 1, h: 2 }),
			};
			// await populateStoresWithFetchedProps(component);
			break;
		case "grammarEditor":
			data = {
				component: GrammarEditor,
				background: '#151515',
				theme: 'monokai',
				grammarSource: content.grammarSource,
				content: content.grammar, // Get the store value with Svelte's get
			};
			layout = {
				12: gridHelp.item({ x: 0, y: 0, w: 8, h: 5 }),
				8: gridHelp.item({ x: 0, y: 0, w: 7, h: 5 }),
				6: gridHelp.item({ x: 0, y: 0, w: 4, h: 3 }),
				3: gridHelp.item({ x: 0, y: 0, w: 2, h: 2 }),
				2: gridHelp.item({ x: 0, y: 0, w: 1, h: 2 })
			};
  		// data.data = content.grammar; // Get the store value with Svelte's get
			break;
		case "modelEditor":
			data = {
				component: ModelEditor,
				background: '#151515',
				theme: 'monokai',
				content: content,
			};
			layout = {
				12: gridHelp.item({ x: 0, y: 0, w: 8, h: 5 }),
				8: gridHelp.item({ x: 0, y: 0, w: 7, h: 5 }),
				6: gridHelp.item({ x: 0, y: 0, w: 4, h: 3 }),
				3: gridHelp.item({ x: 0, y: 0, w: 2, h: 2 }),
				2: gridHelp.item({ x: 0, y: 0, w: 1, h: 2 })
			};
			break;
		case "liveCodeParseOutput":
			data = {
				component: LiveCodeParseOutput,
				background: 'rgba(25, 25, 25, 0.3)',
			};
			layout = {
				12: gridHelp.item({ x: 0, y: 0, w: 4, h: 1 }),
				8: gridHelp.item({ x: 0, y: 0, w: 4, h: 1 }),
				6: gridHelp.item({ x: 0, y: 0, w: 3, h: 1 }),
				3: gridHelp.item({ x: 0, y: 0, w: 1, h: 1 }),
				2: gridHelp.item({ x: 0, y: 0, w: 1, h: 1 }),
			};
			break;
		case "grammarCompileOutput":
			data = {
				component: GrammarCompileOutput,
				background: 'rgba(20, 20, 20, 0.3)',
			};
			layout = {
				12: gridHelp.item({ x: 0, y: 0, w: 9, h: 5 }),
				8: gridHelp.item({ x: 0, y: 0, w: 7, h: 5 }),
				6: gridHelp.item({ x: 0, y: 0, w: 5, h: 3 }),
				3: gridHelp.item({ x: 0, y: 0, w: 3, h: 2 }),
				2: gridHelp.item({ x: 0, y: 0, w: 2, h: 2 }),
			};
			break;
		case "analyser":
			data = {
				component: Analyser,
				background: '#191919',
				mode: '',
			};
			layout = {
				12: gridHelp.item({ x: 0, y: 0, w: 4, h: 4 }),
				8: gridHelp.item({ x: 0, y: 0, w: 4, h: 4 }),
				6: gridHelp.item({ x: 0, y: 0, w: 3, h: 3 }),
				3: gridHelp.item({ x: 0, y: 0, w: 1, h: 2 }),
				2: gridHelp.item({ x: 0, y: 0, w: 1, h: 2 }),
			};
			break;
		case "visualiser":
			data = {
				component: Visualiser,
				background: '#191919',
				mode: '',
				channelID: '0',
			};
			layout = {
				12: gridHelp.item({ x: 0, y: 0, w: 9, h: 5 }),
				8: gridHelp.item({ x: 0, y: 0, w: 7, h: 5 }),
				6: gridHelp.item({ x: 0, y: 0, w: 5, h: 3 }),
				3: gridHelp.item({ x: 0, y: 0, w: 3, h: 2 }),
				2: gridHelp.item({ x: 0, y: 0, w: 2, h: 2 }),
			};
			break;
		case "console":
			data = {
				component: Console,
				background: 'rgba(20, 20, 20, 0.3)',
			};
			layout = {
				12: gridHelp.item({ x: 0, y: 0, w: 9, h: 5 }),
				8: gridHelp.item({ x: 0, y: 0, w: 7, h: 5 }),
				6: gridHelp.item({ x: 0, y: 0, w: 5, h: 3 }),
				3: gridHelp.item({ x: 0, y: 0, w: 3, h: 2 }),
				2: gridHelp.item({ x: 0, y: 0, w: 2, h: 2 }),
			};
			break;
		case "dspCode":
			data = {
				component: DSPCode,
				background: 'rgba(25, 25, 25, 0.3)',
			};
			layout = {
				12: gridHelp.item({ x: 0, y: 0, w: 9, h: 5 }),
				8: gridHelp.item({ x: 0, y: 0, w: 7, h: 5 }),
				6: gridHelp.item({ x: 0, y: 0, w: 5, h: 3 }),
				3: gridHelp.item({ x: 0, y: 0, w: 3, h: 2 }),
				2: gridHelp.item({ x: 0, y: 0, w: 2, h: 2 }),
			};
			break;
		case "MIDI":
			data = {
				component: MIDI,
				background: 'rgba(25, 25, 25, 0.3)',
			};
			layout = {
				12: gridHelp.item({ x: 0, y: 0, w: 9, h: 5 }),
				8: gridHelp.item({ x: 0, y: 0, w: 7, h: 5 }),
				6: gridHelp.item({ x: 0, y: 0, w: 5, h: 3 }),
				3: gridHelp.item({ x: 0, y: 0, w: 3, h: 2 }),
				2: gridHelp.item({ x: 0, y: 0, w: 2, h: 2 }),
			};			break;
		case "visor":
			data = {
				// component: Visor,
				background: 'rgba(25, 25, 25, 0.3)',
			};
			layout = {
				12: gridHelp.item({ x: 0, y: 0, w: 9, h: 5 }),
				8: gridHelp.item({ x: 0, y: 0, w: 7, h: 5 }),
				6: gridHelp.item({ x: 0, y: 0, w: 5, h: 3 }),
				3: gridHelp.item({ x: 0, y: 0, w: 3, h: 2 }),
				2: gridHelp.item({ x: 0, y: 0, w: 2, h: 2 }),
			};
			break;
	}

  let itemId = id();

	// return component template
	return {
    id: itemId,
		...layout,
		data: {
      id: itemId,
			type: type,
			name: type + itemId,
			background: "#151515",
			lineNumbers: true,
			hasFocus: true,
			background: "#151515",
			theme: "icecoder",
    	...data
		},
	};
}
/**
 * @hydrateJSONcomponent receives a JSON description for a grid item and creates a 'live' Svelte component for the grid as new grid item object
 * TODO: Refactor to TS to apply inheritance and define parameter types
 * @param item JSON grid item component description
 */
function hydrateJSONcomponent (item){
	if ( item && item.data && item.data.type ) {
		switch (item.data.type) {
			case 'liveCodeEditor':
				item.data.component = LiveCodeEditor;
				break
			case 'grammarEditor':
				item.data.component = GrammarEditor;
				break
			case 'modelEditor':
				item.data.component = ModelEditor;
				break
			case 'liveCodeParseOutput':
				item.data.component = LiveCodeParseOutput;
				break
			case 'grammarCompileOutput':
				item.data.component = GrammarCompileOutput;
				break
			case 'storeInspector':
				item.data.component = StoreInspector;
				break
			case 'analyser':
				item.data.component = Analyser;
				break
			case 'visualiser':
				item.data.component = Visualiser;
				break
			case 'console':
				item.data.component = Console;
				break
			case 'dspCode':
				item.data.component = DSPCode;
				break
		}
		// NOTE
		// if(!item.id){
		item.id = id();
		item.data.name = item.data.type + item.id;
		item.data.id = item.id;
		// }
		return item
	}
  else
    throw Error("hydrateJSONcomponent: undefined item");
}
const fastStart = writable(true);


/**
 * @storable wraps the Svelte "writable store" pattern to automatically synchronize a store with local storage
 * * synchronize here is bidirectional which means both serializing the store value
 * * to a corresponding local storage item
 * * and reading from a local storage item and hydrating the JSON descriptors
 * ! HANDLE WITH CARE requires a good understading of the Svelte store mechanism,
 * ! the concepts of serialisation and hydration
 * ! and local storage
 * @key text descriptor for the store in the local storage
 * @initialValue initial default value for store
 */
function storable(key, initialValue) {
	const store = writable(initialValue); // create an underlying store
	const { subscribe, set, update } = store;

	let json = localStorage.getItem(key); // get the last value from localStorage
	if (json) {
		set(JSON.parse(json).map(item => hydrateJSONcomponent(item))); // use the value from localStorage if it exists
	}

	// return an object with the same interface as Svelte's writable() store interface
	return {
		set(value) {
			localStorage.setItem(key, JSON.stringify(value));
			set(value); // capture set and write to localStorage
		},

		update(cb) {
			const value = cb(get_store_value(store)); // passes items to callback for invocation e.g items => items.concat(new)
			this.set(value); // capture updates and write to localStore
		},

		get() {
			return localStorage.getItem(key);
			// return get(store);
		},

		subscribe, // punt subscriptions to underlying store
	};
}



// Dashboard layout in items list
// export const items = storable('playground', testItems) // localStorageWrapper
const items = storable(
	'playground',
	default_playground_layout.map((item) => hydrateJSONcomponent(item))
); // localStorageWrapper
// export const items = storable("playground", originalItems); // localStorageWrapper

// Dashboard SELECTED item which receives focus and has item controls loaded
const focusedItem = writable({});


const focusedItemProperties = writable([]);

function loadEnvironmentSnapshotEntries() {

	let dateLength = new Date(Date.now()).toISOString().length;

  let localStorageItemPrefix = "playground-";
	// Load local storage items filtered by "playground-" prefix
	let keys = Object.keys(localStorage)
		.filter((key) => key.includes(localStorageItemPrefix))
		.sort(
			(a, b) =>
				Date.parse(
					b.substring(
						localStorageItemPrefix.length,
						localStorageItemPrefix.length + dateLength
					)
				) - Date.parse(
					a.substring(
						localStorageItemPrefix.length,
						localStorageItemPrefix.length + dateLength
				))
		);

	// Create a list of sidebar Load combox items with local storage substring, including the default "load"
	loadEnvironmentOptions.set(
		keys.reduce(
			(acc, val, i) => [
				...acc,
				{
					id: i + 1, // item starts with 0 when reducer is passed a first item (see below)
					disabled: false,
					text: val.substring(
						localStorageItemPrefix.length + dateLength + 1, val.length
					),
					content: val,
				},
			],
			[{ id: 0, disabled: false, text: `load` }]
		)
	);
}

/* src/components/overlays/Delete.svelte generated by Svelte v3.31.0 */

function add_css$E() {
	var style = element("style");
	style.id = "svelte-sbeyn2-style";
	style.textContent = ".button-dark.svelte-sbeyn2{width:5.5em;height:2.5em;padding:0.2em 0.2em 0.8em 0.8em;display:block;font-family:sans-serif;font-weight:400;cursor:pointer;line-height:1.3;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;margin-right:5px;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;-webkit-box-shadow:2px 2px 3px rgb(0, 0, 0), -0.5px -0.5px 3px #ffffff61;-moz-box-shadow:2px 2px 3px rgb(0, 0, 0), -0.5px -0.5px 3px #ffffff61;box-shadow:2px 2px 3px rgb(0, 0, 0), -0.5px -0.5px 3px #ffffff61}.button-dark.svelte-sbeyn2:active{width:10.5em;height:2.5em;padding:0.2em 0.2em 0.8em 0.8em;display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:red;line-height:1.3;max-width:100%;box-sizing:border-box;margin-right:5px;text-align:left;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-size:.65em auto, 100%;box-shadow:-1px -1px 3px rgba(16, 16, 16, 0.4), 0.5px 0.5px 0.5px rgba(16, 16, 16, 0.04)}.delete-overlay-button-container.svelte-sbeyn2{display:inline-flex}.delete-overlay-component.svelte-sbeyn2{width:100%;height:100%;display:flex;justify-content:center;align-items:center;flex-direction:column;font-size:16px}.delete-overlay-text.svelte-sbeyn2{color:#FFF}";
	append(document.head, style);
}

function create_fragment$P(ctx) {
	let div1;
	let svg;
	let t0;
	let p;
	let t2;
	let div0;
	let button0;
	let t4;
	let button1;
	let mounted;
	let dispose;

	return {
		c() {
			div1 = element("div");
			svg = svg_element("svg");
			t0 = space();
			p = element("p");
			p.innerHTML = `<span style="font-weight: 1500;">Are you sure you want to delete your content?</span>`;
			t2 = space();
			div0 = element("div");
			button0 = element("button");
			button0.textContent = "Delete";
			t4 = space();
			button1 = element("button");
			button1.textContent = "Cancel";
			attr(svg, "class", "box-icon");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", "50");
			attr(svg, "height", "43");
			attr(svg, "viewBox", "0 0 50 43");
			attr(p, "class", "delete-overlay-text svelte-sbeyn2");
			attr(button0, "class", "button-dark svelte-sbeyn2");
			attr(button1, "class", "button-dark svelte-sbeyn2");
			attr(div0, "class", "delete-overlay-button-container svelte-sbeyn2");
			attr(div1, "class", "delete-overlay-component svelte-sbeyn2");

			set_style(div1, "visibility", /*$isDeleteOverlayVisible*/ ctx[0]
			? "visible"
			: "hidden");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, svg);
			append(div1, t0);
			append(div1, p);
			append(div1, t2);
			append(div1, div0);
			append(div0, button0);
			append(div0, t4);
			append(div0, button1);

			if (!mounted) {
				dispose = [
					listen(button0, "click", /*resetEnvironment*/ ctx[2]),
					listen(button1, "click", /*closeOverlay*/ ctx[1])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*$isDeleteOverlayVisible*/ 1) {
				set_style(div1, "visibility", /*$isDeleteOverlayVisible*/ ctx[0]
				? "visible"
				: "hidden");
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div1);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$P($$self, $$props, $$invalidate) {
	let $isDeleteOverlayVisible;
	let $items;
	let $isUploadOverlayVisible;
	let $isSaveOverlayVisible;
	let $isSelectLiveCodeEditorDisabled;
	let $isSelectModelEditorDisabled;
	let $isAddGrammarEditorDisabled;
	let $isAddAnalyserDisabled;
	let $sidebarDebuggerOptions;
	component_subscribe($$self, isDeleteOverlayVisible, $$value => $$invalidate(0, $isDeleteOverlayVisible = $$value));
	component_subscribe($$self, items, $$value => $$invalidate(4, $items = $$value));
	component_subscribe($$self, isUploadOverlayVisible, $$value => $$invalidate(5, $isUploadOverlayVisible = $$value));
	component_subscribe($$self, isSaveOverlayVisible, $$value => $$invalidate(6, $isSaveOverlayVisible = $$value));
	component_subscribe($$self, isSelectLiveCodeEditorDisabled, $$value => $$invalidate(7, $isSelectLiveCodeEditorDisabled = $$value));
	component_subscribe($$self, isSelectModelEditorDisabled, $$value => $$invalidate(8, $isSelectModelEditorDisabled = $$value));
	component_subscribe($$self, isAddGrammarEditorDisabled, $$value => $$invalidate(9, $isAddGrammarEditorDisabled = $$value));
	component_subscribe($$self, isAddAnalyserDisabled, $$value => $$invalidate(10, $isAddAnalyserDisabled = $$value));
	component_subscribe($$self, sidebarDebuggerOptions, $$value => $$invalidate(11, $sidebarDebuggerOptions = $$value));
	let engine;

	const closeOverlay = () => {
		set_store_value(isDeleteOverlayVisible, $isDeleteOverlayVisible = false, $isDeleteOverlayVisible);
	};

	const resetEnvironment = () => {
		if (!engine) engine = new Engine$1();
		engine.hush();
		set_store_value(items, $items = $items.slice($items.length), $items);
		set_store_value(isUploadOverlayVisible, $isUploadOverlayVisible = false, $isUploadOverlayVisible);
		set_store_value(isSaveOverlayVisible, $isSaveOverlayVisible = false, $isSaveOverlayVisible);
		set_store_value(isDeleteOverlayVisible, $isDeleteOverlayVisible = false, $isDeleteOverlayVisible);
		set_store_value(isSelectLiveCodeEditorDisabled, $isSelectLiveCodeEditorDisabled = false, $isSelectLiveCodeEditorDisabled);
		set_store_value(isSelectModelEditorDisabled, $isSelectModelEditorDisabled = false, $isSelectModelEditorDisabled);
		set_store_value(isAddGrammarEditorDisabled, $isAddGrammarEditorDisabled = false, $isAddGrammarEditorDisabled);
		set_store_value(isAddAnalyserDisabled, $isAddAnalyserDisabled = false, $isAddAnalyserDisabled);
		$sidebarDebuggerOptions.map(option => option.disabled = false);
	};

	onMount(async () => {
		// engine = new Engine();
		console.log("delete");
	});

	onDestroy(() => {
		
	}); // engine = null;

	return [$isDeleteOverlayVisible, closeOverlay, resetEnvironment];
}

class Delete extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-sbeyn2-style")) add_css$E();
		init(this, options, instance$P, create_fragment$P, safe_not_equal, {});
	}
}

/* src/components/overlays/Save.svelte generated by Svelte v3.31.0 */

function add_css$F() {
	var style = element("style");
	style.id = "svelte-1t8ebii-style";
	style.textContent = "input[type=text].svelte-1t8ebii{width:33%;padding:12px 20px;margin:8px 0;box-sizing:border-box;border:1px solid #aaa;-webkit-transition:0.5s;transition:0.5s;outline:none;color:white;background-color:rgba(16, 16, 16, 0.04)}input[type=text].svelte-1t8ebii:focus{border:1px solid #555}.button-dark.svelte-1t8ebii{width:5.5em;height:2.5em;padding:0.2em 0.2em 0.8em 0.8em;display:block;font-family:sans-serif;font-weight:400;cursor:pointer;line-height:1.3;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;margin-right:5px;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;-webkit-box-shadow:2px 2px 3px rgb(0, 0, 0), -0.5px -0.5px 3px #ffffff61;-moz-box-shadow:2px 2px 3px rgb(0, 0, 0), -0.5px -0.5px 3px #ffffff61;box-shadow:2px 2px 3px rgb(0, 0, 0), -0.5px -0.5px 3px #ffffff61}.button-dark.svelte-1t8ebii:active{width:10.5em;height:2.5em;padding:0.2em 0.2em 0.8em 0.8em;display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:red;line-height:1.3;max-width:100%;box-sizing:border-box;margin-right:5px;text-align:left;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-size:.65em auto, 100%;box-shadow:-1px -1px 3px rgba(16, 16, 16, 0.4), 0.5px 0.5px 0.5px rgba(16, 16, 16, 0.04)}.save-overlay-component.svelte-1t8ebii{width:100%;height:100%;display:flex;justify-content:center;align-items:center;flex-direction:column;font-size:16px}.save-overlay-button-container.svelte-1t8ebii{display:inline-flex}input.svelte-1t8ebii:invalid{border:2px dashed red}";
	append(document.head, style);
}

function create_fragment$Q(ctx) {
	let div1;
	let svg;
	let path;
	let t0;
	let label;
	let t2;
	let input_1;
	let t3;
	let div0;
	let button0;
	let t5;
	let button1;
	let mounted;
	let dispose;

	return {
		c() {
			div1 = element("div");
			svg = svg_element("svg");
			path = svg_element("path");
			t0 = space();
			label = element("label");
			label.textContent = "Enter a name for the record (8 to 15 alphanumeric characters):";
			t2 = space();
			input_1 = element("input");
			t3 = space();
			div0 = element("div");
			button0 = element("button");
			button0.textContent = "Save";
			t5 = space();
			button1 = element("button");
			button1.textContent = "Cancel";
			attr(path, "d", "M48.4 26.5c-.9 0-1.7.7-1.7 1.7v11.6h-43.3v-11.6c0-.9-.7-1.7-1.7-1.7s-1.7.7-1.7 1.7v13.2c0 .9.7 1.7 1.7 1.7h46.7c.9 0 1.7-.7 1.7-1.7v-13.2c0-1-.7-1.7-1.7-1.7zm-24.5 6.1c.3.3.8.5 1.2.5.4 0 .9-.2 1.2-.5l10-11.6c.7-.7.7-1.7 0-2.4s-1.7-.7-2.4 0l-7.1 8.3v-25.3c0-.9-.7-1.7-1.7-1.7s-1.7.7-1.7 1.7v25.3l-7.1-8.3c-.7-.7-1.7-.7-2.4 0s-.7 1.7 0 2.4l10 11.6z");
			attr(svg, "class", "box-icon");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", "50");
			attr(svg, "height", "43");
			attr(svg, "viewBox", "0 0 50 43");
			attr(label, "for", "name");
			attr(input_1, "type", "text");
			attr(input_1, "id", "name");
			attr(input_1, "name", "name");
			input_1.required = true;
			attr(input_1, "minlength", "8");
			attr(input_1, "maxlength", "15");
			attr(input_1, "size", "10");
			attr(input_1, "class", "svelte-1t8ebii");
			attr(button0, "class", "button-dark svelte-1t8ebii");
			attr(button1, "class", "button-dark svelte-1t8ebii");
			attr(div0, "class", "save-overlay-button-container svelte-1t8ebii");
			attr(div1, "class", "save-overlay-component svelte-1t8ebii");
			set_style(div1, "visibility", /*$isSaveOverlayVisible*/ ctx[2] ? "visible" : "hidden");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, svg);
			append(svg, path);
			append(div1, t0);
			append(div1, label);
			append(div1, t2);
			append(div1, input_1);
			/*input_1_binding*/ ctx[5](input_1);
			set_input_value(input_1, /*filename*/ ctx[0]);
			append(div1, t3);
			append(div1, div0);
			append(div0, button0);
			append(div0, t5);
			append(div0, button1);

			if (!mounted) {
				dispose = [
					listen(input_1, "input", /*input_1_input_handler*/ ctx[6]),
					listen(button0, "click", /*saveEnvironment*/ ctx[4]),
					listen(button1, "click", /*closeOverlay*/ ctx[3])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*filename*/ 1 && input_1.value !== /*filename*/ ctx[0]) {
				set_input_value(input_1, /*filename*/ ctx[0]);
			}

			if (dirty & /*$isSaveOverlayVisible*/ 4) {
				set_style(div1, "visibility", /*$isSaveOverlayVisible*/ ctx[2] ? "visible" : "hidden");
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div1);
			/*input_1_binding*/ ctx[5](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$Q($$self, $$props, $$invalidate) {
	let $isSaveOverlayVisible;
	let $items;
	component_subscribe($$self, isSaveOverlayVisible, $$value => $$invalidate(2, $isSaveOverlayVisible = $$value));
	component_subscribe($$self, items, $$value => $$invalidate(7, $items = $$value));
	let filename, input;

	const closeOverlay = () => {
		set_store_value(isSaveOverlayVisible, $isSaveOverlayVisible = false, $isSaveOverlayVisible);
	};

	const saveEnvironment = () => {
		let localStorageEntry = "playground-" + new Date(Date.now()).toISOString() + "-" + filename;

		if (filename && !window.localStorage[localStorageEntry]) {
			window.localStorage[localStorageEntry] = JSON.stringify($items);
			loadEnvironmentSnapshotEntries();
			set_store_value(isSaveOverlayVisible, $isSaveOverlayVisible = false, $isSaveOverlayVisible);
		}
	};

	onMount(async () => {
		// engine = new Engine();
		console.log("save");
	});

	onDestroy(() => {
		
	}); // engine = null;

	function input_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			input = $$value;
			$$invalidate(1, input);
		});
	}

	function input_1_input_handler() {
		filename = this.value;
		$$invalidate(0, filename);
	}

	return [
		filename,
		input,
		$isSaveOverlayVisible,
		closeOverlay,
		saveEnvironment,
		input_1_binding,
		input_1_input_handler
	];
}

class Save extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1t8ebii-style")) add_css$F();
		init(this, options, instance$Q, create_fragment$Q, safe_not_equal, {});
	}
}

/* src/components/overlays/Upload.svelte generated by Svelte v3.31.0 */

const { document: document_1$1 } = globals;

function add_css$G() {
	var style = element("style");
	style.id = "svelte-ck76jb-style";
	style.textContent = ".label-underline.svelte-ck76jb{text-decoration:underline;display:inline-flex}#file-input.svelte-ck76jb{display:none}.light-mode.svelte-ck76jb{fill:rgb(133, 130, 130);enable-background:new 0 0 512 512;padding-bottom:3px;width:15px}.upload-overlay-component.svelte-ck76jb{height:100%;display:flex;justify-content:center;align-items:center;flex-direction:column;font-size:16px}.upload-overlay-text.svelte-ck76jb{position:absolute;color:#FFF}";
	append(document_1$1.head, style);
}

function create_fragment$R(ctx) {
	let div;
	let svg;
	let g;
	let path0;
	let path1;
	let t0;
	let p;
	let label;
	let t2;
	let input;
	let t3;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			svg = svg_element("svg");
			g = svg_element("g");
			path0 = svg_element("path");
			path1 = svg_element("path");
			t0 = space();
			p = element("p");
			label = element("label");
			label.textContent = "Choose your .json file";
			t2 = space();
			input = element("input");
			t3 = text$1(" or drag'n'drop it here to upload a new environment!");
			attr(path0, "d", "M50.283,44.999l-5.453-6.498c-0.016-0.019-0.038-0.032-0.055-0.051c-0.086-0.095-0.178-0.18-0.278-0.259\n        c-0.012-0.01-0.022-0.021-0.036-0.029c-0.377-0.286-0.841-0.463-1.351-0.463c-0.511,0-0.974,0.177-1.351,0.463\n        c-0.013,0.009-0.023,0.019-0.037,0.029c-0.099,0.079-0.192,0.164-0.276,0.259c-0.017,0.019-0.039,0.032-0.056,0.051l-5.453,6.498\n        c-0.797,0.948-0.673,2.364,0.276,3.162c0.95,0.795,2.366,0.672,3.162-0.277l1.49-1.774v27.765c0,1.239,1.004,2.244,2.244,2.244\n        c1.239,0,2.243-1.005,2.243-2.244V46.108l1.49,1.775c0.443,0.528,1.08,0.801,1.721,0.801c0.508,0,1.021-0.172,1.44-0.523\n        C50.956,47.362,51.08,45.947,50.283,44.999z");
			attr(path1, "d", "M62.393,18.133c-0.832,0-1.664,0.062-2.489,0.181c-3.216-3.36-7.267-5.723-11.81-6.874\n        c-0.059-0.016-0.119-0.029-0.18-0.04l-2.93-0.554c-3.584-4.482-9.01-7.117-14.803-7.117c-9.962,0-18.153,7.723-18.9,17.496\n        C4.534,23.771,0,30.194,0,37.582c0,9.653,7.854,17.507,17.509,17.507c2.491,0,4.93-0.525,7.169-1.535\n        c3.032,2.925,6.745,4.978,10.766,6.062v-6.255c-3.007-1.095-5.712-2.921-7.884-5.47c-0.587-0.69-1.427-1.053-2.279-1.053\n        c-0.554,0-1.114,0.153-1.611,0.473c-1.834,1.173-3.964,1.792-6.161,1.792c-6.355,0-11.525-5.169-11.525-11.523\n        c0-5.31,3.761-10.027,8.943-11.219c1.412-0.325,2.389-1.615,2.318-3.063l-0.02-0.32c-0.006-0.098-0.015-0.197-0.015-0.297\n        c0-7.152,5.819-12.97,12.971-12.97c4.325,0,8.351,2.146,10.77,5.74c0.557,0.827,1.486,1.322,2.482,1.322c0.004,0,0.008,0,0.014,0\n        l0.675-0.003l2.589,0.488c3.858,0.998,7.245,3.15,9.794,6.229c0.741,0.896,1.931,1.281,3.052,0.989\n        c0.933-0.241,1.887-0.362,2.836-0.362c6.324,0,11.471,5.146,11.471,11.471c0,6.325-5.146,11.468-11.471,11.468\n        c-0.949,0-1.903-0.121-2.834-0.361c-1.125-0.292-2.313,0.095-3.053,0.988c-1.605,1.938-3.564,3.474-5.726,4.613v6.59\n        c3.419-1.297,6.542-3.332,9.123-6.025c0.825,0.12,1.657,0.182,2.489,0.182c9.625,0,17.455-7.83,17.455-17.455\n        C79.848,25.963,72.016,18.133,62.393,18.133z");
			attr(svg, "version", "1.1");
			attr(svg, "id", "Capa_1");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "x", "0px");
			attr(svg, "y", "0px");
			attr(svg, "viewBox", "0 0 512 512");
			attr(svg, "class", "light-mode svelte-ck76jb");
			set_style(svg, "enable-background", "new 0 0 512 512");
			set_style(svg, "width", "350px");
			attr(svg, "xml:space", "preserve");
			attr(label, "class", "label-underline svelte-ck76jb");
			attr(label, "for", "file-input");
			attr(input, "type", "file");
			attr(input, "id", "file-input");
			attr(input, "accept", ".json");
			attr(input, "class", "svelte-ck76jb");
			attr(p, "class", "upload-overlay-text svelte-ck76jb");
			attr(div, "class", "upload-overlay-component svelte-ck76jb");

			set_style(div, "visibility", /*$isUploadOverlayVisible*/ ctx[0]
			? "visible"
			: "hidden");

			attr(div, "ondragover", "return false");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, svg);
			append(svg, g);
			append(g, path0);
			append(g, path1);
			append(div, t0);
			append(div, p);
			append(p, label);
			append(p, t2);
			append(p, input);
			append(p, t3);

			if (!mounted) {
				dispose = [
					listen(input, "change", /*handleSelectJSONFile*/ ctx[2]),
					listen(div, "drop", /*handleDragDrop*/ ctx[1]),
					listen(div, "dragenter", handleDragEnter)
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*$isUploadOverlayVisible*/ 1) {
				set_style(div, "visibility", /*$isUploadOverlayVisible*/ ctx[0]
				? "visible"
				: "hidden");
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			run_all(dispose);
		}
	};
}

function handleDragEnter(e) {
	
}

function instance$R($$self, $$props, $$invalidate) {
	let $items;
	let $isUploadOverlayVisible;
	component_subscribe($$self, items, $$value => $$invalidate(3, $items = $$value));
	component_subscribe($$self, isUploadOverlayVisible, $$value => $$invalidate(0, $isUploadOverlayVisible = $$value));

	function handleDragDrop(e) {
		try {
			e.preventDefault();
			let reader = new FileReader();
			reader.readAsText(e.dataTransfer.files[0]);
			reader.onload = e => set_store_value(items, $items = JSON.parse(e.target.result).map(item => hydrateJSONcomponent(item)), $items);
			set_store_value(isUploadOverlayVisible, $isUploadOverlayVisible = false, $isUploadOverlayVisible);
		} catch(error) {
			
		}
	}

	function handleSelectJSONFile(e) {
		try {
			const input = document.querySelector("input[type=file]");
			let reader = new FileReader();
			reader.readAsText(input.files[0]);

			reader.onloadend = e => {
				set_store_value(items, $items = JSON.parse(reader.result).map(item => hydrateJSONcomponent(item)), $items);
				input.value = "";
				input.type = "file";
				input.accept = ".json";
			};

			set_store_value(isUploadOverlayVisible, $isUploadOverlayVisible = false, $isUploadOverlayVisible);
		} catch(err) {
			
		}
	}

	onMount(async () => {
		// engine = new Engine();
		console.log("upload");
	});

	onDestroy(() => {
		
	}); // engine = null;

	return [$isUploadOverlayVisible, handleDragDrop, handleSelectJSONFile];
}

class Upload extends SvelteComponent {
	constructor(options) {
		super();
		if (!document_1$1.getElementById("svelte-ck76jb-style")) add_css$G();
		init(this, options, instance$R, create_fragment$R, safe_not_equal, {});
	}
}

/* src/components/playground/ItemProps.svelte generated by Svelte v3.31.0 */

function add_css$H() {
	var style = element("style");
	style.id = "svelte-1ixcfmg-style";
	style.textContent = ".controls.svelte-1ixcfmg{margin-bottom:10px;margin-left:3px;margin-right:5px}.button-dark.svelte-1ixcfmg{display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:#ccc;line-height:1.3;padding:0.7em 1em 0.7em 1em;width:8em;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;-webkit-box-shadow:2px 2px 3px rgb(0, 0, 0), -0.5px -0.5px 3px #ffffff61;-moz-box-shadow:2px 2px 3px rgb(0, 0, 0), -0.5px -0.5px 3px #ffffff61;box-shadow:2px 2px 3px rgb(0, 0, 0), -0.5px -0.5px 3px #ffffff61}.button-dark.svelte-1ixcfmg:hover{display:block;font-size:medium;font-family:sans-serif;font-weight:500;cursor:pointer;color:#fff;line-height:1.3;padding:0.7em 1em 0.7em 1em;width:8em;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:linear-gradient(rgba(16, 16, 16, 0.8), rgba(16, 16, 16, 0.08));background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;-webkit-box-shadow:2px 2px 5px rgba(0,0,0),-0.5px -0.5px 3px rgb(34, 34, 34);-moz-box-shadow:2px 2px 5px rgba(0,0,0), -0.5px -0.5px 3px rgb(34, 34, 34);box-shadow:2px 2px 3px rgb(0, 0, 0), -1px -1px 3px #ffffff61}.number-input.svelte-1ixcfmg{width:35px;height:2.5em;margin-left:5px;padding:2px}.button-dark.svelte-1ixcfmg:active{display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:#888;line-height:1.3;width:8em;max-width:100%;box-sizing:border-box;text-align:left;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-size:.65em auto, 100%;box-shadow:-1px -1px 3px rgba(16, 16, 16, 0.4), 0.5px 0.5px 0.5px rgba(16, 16, 16, 0.04)}.input-dark.svelte-1ixcfmg{height:2.5em;display:inline-flex;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:#fff;line-height:1.3;padding:0.7em 0em 0.7em 1em;width:8em;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;-webkit-box-shadow:2px 2px 5px rgba(0,0,0),-1px -1px 1px rgb(34, 34, 34);-moz-box-shadow:2px 2px 5px rgba(0,0,0), -1px -1px 1px rgb(34, 34, 34);box-shadow:2px 2px 3px rgb(0, 0, 0), -1px -1px 3px #ffffff61}.checkbox-input.svelte-1ixcfmg{margin-left:5px}.button-light.svelte-1ixcfmg{display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:black;line-height:1.3;padding:0.7em 1em 0.7em 1em;width:8em;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-moz-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-webkit-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0)}.button-light.svelte-1ixcfmg:active{display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:black;line-height:1.3;padding:0.7em 1em 0.7em 1em;width:8em;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-moz-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-webkit-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0)\n  }.button-light.svelte-1ixcfmg:disabled{display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:#888;line-height:1.3;padding:0.7em 1em 0.7em 1em;width:8em;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-moz-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-webkit-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0)\n  }";
	append(document.head, style);
}

function get_each_context$d(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[16] = list[i];
	return child_ctx;
}

// (476:34) 
function create_if_block_5(ctx) {
	let div;
	let button;
	let t0;
	let button_class_value;
	let t1;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			button = element("button");
			t0 = text$1("grammar");
			t1 = space();

			attr(button, "class", button_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[3] === "dark"
			? "button-dark"
			: "button-light") + " svelte-1ixcfmg"));

			button.disabled = /*$isAddGrammarEditorDisabled*/ ctx[2];
			attr(div, "class", "controls svelte-1ixcfmg");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, button);
			append(button, t0);
			append(div, t1);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler_2*/ ctx[10]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*$siteMode*/ 8 && button_class_value !== (button_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[3] === "dark"
			? "button-dark"
			: "button-light") + " svelte-1ixcfmg"))) {
				attr(button, "class", button_class_value);
			}

			if (dirty & /*$isAddGrammarEditorDisabled*/ 4) {
				button.disabled = /*$isAddGrammarEditorDisabled*/ ctx[2];
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			dispose();
		}
	};
}

// (465:32) 
function create_if_block_4$1(ctx) {
	let div;
	let button;
	let t0;
	let button_class_value;
	let t1;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			button = element("button");
			t0 = text$1("visor");
			t1 = space();

			attr(button, "class", button_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[3] === "dark"
			? "button-dark"
			: "button-light") + " svelte-1ixcfmg"));

			attr(div, "class", "controls svelte-1ixcfmg");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, button);
			append(button, t0);
			append(div, t1);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler_1*/ ctx[9]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*$siteMode*/ 8 && button_class_value !== (button_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[3] === "dark"
			? "button-dark"
			: "button-light") + " svelte-1ixcfmg"))) {
				attr(button, "class", button_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			dispose();
		}
	};
}

// (455:34) 
function create_if_block_3$1(ctx) {
	let div;
	let button;
	let t0;
	let button_class_value;
	let t1;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			button = element("button");
			t0 = text$1("restart");
			t1 = space();

			attr(button, "class", button_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[3] === "dark"
			? "button-dark"
			: "button-light") + " svelte-1ixcfmg"));

			attr(div, "class", "controls svelte-1ixcfmg");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, button);
			append(button, t0);
			append(div, t1);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler*/ ctx[8]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*$siteMode*/ 8 && button_class_value !== (button_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[3] === "dark"
			? "button-dark"
			: "button-light") + " svelte-1ixcfmg"))) {
				attr(button, "class", button_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			dispose();
		}
	};
}

// (449:31) 
function create_if_block_2$3(ctx) {
	let t0;
	let t1_value = /*itemProp*/ ctx[16] + "";
	let t1;
	let t2;
	let br;

	return {
		c() {
			t0 = text$1("mode\n        ");
			t1 = text$1(t1_value);
			t2 = space();
			br = element("br");
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
			insert(target, t2, anchor);
			insert(target, br, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*$focusedItemProperties*/ 1 && t1_value !== (t1_value = /*itemProp*/ ctx[16] + "")) set_data(t1, t1_value);
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
			if (detaching) detach(t2);
			if (detaching) detach(br);
		}
	};
}

// (435:36) 
function create_if_block_1$c(ctx) {
	let div;
	let label;
	let t0;
	let input;
	let input_value_value;
	let t1;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			label = element("label");
			t0 = text$1("channel\n            ");
			input = element("input");
			t1 = space();
			attr(input, "type", "number");
			attr(input, "class", "number-input svelte-1ixcfmg");
			attr(input, "name", "channel");
			input.value = input_value_value = /*$focusedItem*/ ctx[1].channelID;
			attr(label, "class", "input-dark svelte-1ixcfmg");
			attr(div, "class", "controls svelte-1ixcfmg");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, label);
			append(label, t0);
			append(label, input);
			append(div, t1);

			if (!mounted) {
				dispose = listen(input, "change", /*change_handler*/ ctx[7]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*$focusedItem*/ 2 && input_value_value !== (input_value_value = /*$focusedItem*/ ctx[1].channelID)) {
				input.value = input_value_value;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			dispose();
		}
	};
}

// (422:6) {#if itemProp.lineNumbers }
function create_if_block$m(ctx) {
	let div;
	let label;
	let t0;
	let input;
	let input_value_value;
	let t1;
	let span;
	let t2;

	return {
		c() {
			div = element("div");
			label = element("label");
			t0 = text$1("numbers\n            ");
			input = element("input");
			t1 = space();
			span = element("span");
			t2 = space();
			attr(input, "type", "checkbox");
			attr(input, "class", "checkbox-input svelte-1ixcfmg");
			input.checked = "checked";
			input.value = input_value_value = /*$focusedItem*/ ctx[1].lineNumbers;
			attr(span, "class", "checkbox-span");
			attr(label, "class", "input-dark svelte-1ixcfmg");
			attr(div, "class", "controls svelte-1ixcfmg");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, label);
			append(label, t0);
			append(label, input);
			append(label, t1);
			append(label, span);
			append(div, t2);
		},
		p(ctx, dirty) {
			if (dirty & /*$focusedItem*/ 2 && input_value_value !== (input_value_value = /*$focusedItem*/ ctx[1].lineNumbers)) {
				input.value = input_value_value;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (420:4) {#each $focusedItemProperties as itemProp }
function create_each_block$d(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*itemProp*/ ctx[16].lineNumbers) return create_if_block$m;
		if (/*itemProp*/ ctx[16].channelID) return create_if_block_1$c;
		if (/*itemProp*/ ctx[16].mode) return create_if_block_2$3;
		if (/*itemProp*/ ctx[16].restart) return create_if_block_3$1;
		if (/*itemProp*/ ctx[16].visor) return create_if_block_4$1;
		if (/*itemProp*/ ctx[16].grammar) return create_if_block_5;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if (if_block) {
				if_block.d(detaching);
			}

			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment$S(ctx) {
	let div1;
	let div0;
	let each_value = /*$focusedItemProperties*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$d(get_each_context$d(ctx, each_value, i));
	}

	return {
		c() {
			div1 = element("div");
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div1, "class", "item-props-container");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div0, null);
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*$focusedItem, $focusedItemProperties, changeVisualyzerChannelID, $siteMode, messaging, $isAddGrammarEditorDisabled, dispatchAdd*/ 127) {
				each_value = /*$focusedItemProperties*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$d(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$d(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div1);
			destroy_each(each_blocks, detaching);
		}
	};
}

function instance$S($$self, $$props, $$invalidate) {
	let $focusedItemProperties;
	let $focusedItem;
	let $isAddGrammarEditorDisabled;
	let $isAddAnalyserDisabled;
	let $siteMode;
	component_subscribe($$self, focusedItemProperties, $$value => $$invalidate(0, $focusedItemProperties = $$value));
	component_subscribe($$self, focusedItem, $$value => $$invalidate(1, $focusedItem = $$value));
	component_subscribe($$self, isAddGrammarEditorDisabled, $$value => $$invalidate(2, $isAddGrammarEditorDisabled = $$value));
	component_subscribe($$self, isAddAnalyserDisabled, $$value => $$invalidate(11, $isAddAnalyserDisabled = $$value));
	component_subscribe($$self, siteMode, $$value => $$invalidate(3, $siteMode = $$value));
	const messaging = new PubSub();
	const dispatch = createEventDispatcher();

	const changeVisualyzerChannelID = e => {
		console.log(e.target.value);
	};

	function dispatchAdd(type, selected) {
		// console.log(`DEBUG:Sidebar:dispatchAdd: /add/${type}/${selected.id}`);
		// console.log(selected.content);
		switch (type) {
			case "grammar":
				messaging.publish("playground-add", {
					type: "grammarEditor",
					data: {
						grammar: $focusedItemProperties[2].grammar,
						grammarSource: $focusedItem.data.grammarSource
					}
				});
				// selectedGrammarOption = sidebarGrammarOptions[0];
				set_store_value(isAddGrammarEditorDisabled, $isAddGrammarEditorDisabled = true, $isAddGrammarEditorDisabled);
				break;
			case "analyser":
				messaging.publish("playground-add", { type: "analyser" });
				set_store_value(isAddAnalyserDisabled, $isAddAnalyserDisabled = true, $isAddAnalyserDisabled);
				break;
		}
	}

	onMount(() => {
		
	}); // console.log("DEBUG:routes/playground:sidebar:onMount")
	// itemDeletionSubscriptionToken = messaging.subscribe("plaground-item-deletion", activateSelectOnItemDeletion);

	onDestroy(() => {
		
	}); // console.log("DEBUG:routes/playground:sidebar:onDestroy")
	// messaging.unsubscribe(itemDeletionSubscriptionToken);

	const change_handler = e => changeVisualyzerChannelID(e);
	const click_handler = () => messaging.publish("restart-ml");
	const click_handler_1 = () => messaging.publish("playground-add", { type: "visor" });
	const click_handler_2 = () => dispatchAdd("grammar");

	return [
		$focusedItemProperties,
		$focusedItem,
		$isAddGrammarEditorDisabled,
		$siteMode,
		messaging,
		changeVisualyzerChannelID,
		dispatchAdd,
		change_handler,
		click_handler,
		click_handler_1,
		click_handler_2
	];
}

class ItemProps extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1ixcfmg-style")) add_css$H();
		init(this, options, instance$S, create_fragment$S, safe_not_equal, {});
	}
}

const table = [];
for (let n = 0; n < 256; n++) {
	let c = n;
	for (let k = 0; k < 8; k++) {
		c = c & 1 ? 0xEDB88320 ^ (c >>> 1) : c >>> 1;
	}
	table[n] = c;
}

var crc32 = bytes => {
	let sum = -1;
	for (const byte of bytes) {
		sum = (sum >>> 8) ^ table[(sum ^ byte) & 0xFF];
	}
	return sum ^ -1;
};

const int = (n, length) => {
	const out = [];
	while (length--) {
		out.push(n & 0xFF);
		n >>>= 8;
	}
	return out;
};

const toBytes = data => typeof data === 'string' ? [...data].map(char => char.charCodeAt(0)) : data;

var toArray$1 = files => {
	let fileData = [];
	const centralDirectory = [];
	for (const { path, data } of files) {
		const dataBytes = toBytes(data);
		const pathBytes = toBytes(path);
		const commonHeader = [0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, ...int(crc32(dataBytes), 4), ...int(dataBytes.length, 4), ...int(dataBytes.length, 4), ...int(pathBytes.length, 2), 0x00, 0x00];
		centralDirectory.push(0x50, 0x4B, 0x01, 0x02, 0x14, 0x00, ...commonHeader, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, ...int(fileData.length, 4), ...pathBytes);
		fileData = [...fileData, 0x50, 0x4B, 0x03, 0x04, ...commonHeader, ...pathBytes, ...dataBytes];
	}
	return [...fileData, ...centralDirectory, 0x50, 0x4B, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, ...int(files.length, 2), ...int(files.length, 2), ...int(centralDirectory.length, 4), ...int(fileData.length, 4), 0x00, 0x00];
};

var toBlob = files => new Blob([Uint8Array.from(toArray$1(files))], { type: 'application/zip' });

var downloadBlob = (blob, filename) => {
	const url = URL.createObjectURL(blob);
	const link = document.createElement("a");
	link.href = url;
	link.download = filename;
	link.style.display = "none";
	document.body.appendChild(link);
	link.click();
	URL.revokeObjectURL(url);
	link.remove();
};

/* src/components/playground/Sidebar.svelte generated by Svelte v3.31.0 */

function add_css$I() {
	var style = element("style");
	style.id = "svelte-1d6r0ws-style";
	style.textContent = ".sidebar.svelte-1d6r0ws{height:100%;margin-top:0px;display:flex;flex-direction:column;justify-content:flex-start}.controls.svelte-1d6r0ws{margin-bottom:10px;margin-left:3px;margin-right:5px}.layout-sidebar-group-widgets-container.svelte-1d6r0ws{padding-top:15px;margin-left:3px;margin-right:2px}.layout-sidebar-group-properties-container.svelte-1d6r0ws{padding-top:3px;margin-left:3px;margin-right:2px}.combobox-light.svelte-1d6r0ws{display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;line-height:1.3;padding:0.7em 1em 0.7em 1em;width:8em;box-sizing:border-box;margin:0;border:0 solid #333;text-align:left;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-moz-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-webkit-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0)}.combobox-dark.svelte-1d6r0ws{display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:white;line-height:1.3;padding:0.7em 1em 0.7em 1em;width:8em;box-sizing:border-box;margin:0;border:0 solid #333;text-align:left;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;-webkit-box-shadow:2px 2px 3px rgb(0, 0, 0), -0.5px -0.5px 3px #ffffff61;-moz-box-shadow:2px 2px 3px rgb(0, 0, 0), -0.5px -0.5px 3px #ffffff61;box-shadow:2px 2px 3px rgb(0, 0, 0), -0.5px -0.5px 3px #ffffff61}.combobox-dark.svelte-1d6r0ws:hover{display:block;font-size:medium;font-family:sans-serif;font-weight:500;cursor:pointer;color:white;line-height:1.3;padding:0.7em 1em 0.7em 1em;width:8em;box-sizing:border-box;margin:0;border:0 solid #333;text-align:left;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:linear-gradient(rgba(16, 16, 16, 1), rgba(16, 16, 16, 0.2));background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;-webkit-box-shadow:5px 5px 20px -5px rgba(0,0,0,0.75), -5px -5px 20px rgba(255, 255, 255, 0.954);-moz-box-shadow:5px 5px 20px -5px rgba(0,0,0,0.75), -5px -5px 20px rgba(255, 255, 255, 0.954);box-shadow:2px 2px 3px rgb(0, 0, 0), -1px -1px 3px #ffffff61}.combobox-dark.svelte-1d6r0ws:focus{display:block;font-size:medium;font-family:sans-serif;font-weight:500;cursor:pointer;color:#fff;line-height:1.3;padding:0.7em 1em 0.7em 1em;width:8em;box-sizing:border-box;margin:0;border:0 solid #333;text-align:left;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;-webkit-box-shadow:5px 5px 20px -5px rgba(0,0,0,0.75), -5px -5px 20px rgba(255, 255, 255, 0.954);-moz-box-shadow:5px 5px 20px -5px rgba(0,0,0,0.75), -5px -5px 20px rgba(255, 255, 255, 0.954);box-shadow:2px 2px 3px rgb(0, 0, 0), -1px -1px 3px #ffffff61}.button-dark.svelte-1d6r0ws{display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:white;line-height:1.3;padding:0.7em 1em 0.7em 1em;width:8em;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;-webkit-box-shadow:2px 2px 3px rgb(0, 0, 0), -0.5px -0.5px 3px #ffffff61;-moz-box-shadow:2px 2px 3px rgb(0, 0, 0), -0.5px -0.5px 3px #ffffff61;box-shadow:2px 2px 3px rgb(0, 0, 0), -0.5px -0.5px 3px #ffffff61}.button-dark.svelte-1d6r0ws:hover{display:block;font-size:medium;font-family:sans-serif;font-weight:500;cursor:pointer;color:white;line-height:1.3;padding:0.7em 1em 0.7em 1em;width:8em;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:linear-gradient(rgba(16, 16, 16, 0.8), rgba(16, 16, 16, 0.08));background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;-webkit-box-shadow:2px 2px 5px rgba(0,0,0),-0.5px -0.5px 3px rgb(34, 34, 34);-moz-box-shadow:2px 2px 5px rgba(0,0,0), -0.5px -0.5px 3px rgb(34, 34, 34);box-shadow:2px 2px 3px rgb(0, 0, 0), -1px -1px 3px #ffffff61}.button-dark.svelte-1d6r0ws:active{display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:white;line-height:1.3;width:8em;max-width:100%;box-sizing:border-box;text-align:left;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-size:.65em auto, 100%;box-shadow:-1px -1px 3px rgba(16, 16, 16, 0.4), 0.5px 0.5px 0.5px rgba(16, 16, 16, 0.04)}.group-labels.svelte-1d6r0ws{padding-left:5px;margin-bottom:10px}.group-label.svelte-1d6r0ws{font-size:medium;font-family:sans-serif;font-weight:400\n  }.button-dark.svelte-1d6r0ws:disabled{display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:#888;line-height:1.3;padding:0.7em 1em 0.7em 1em;width:8em;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;box-shadow:2px 2px 3px rgb(0, 0, 0), -1px -1px 3px #ffffff61;-moz-box-shadow:2px 2px 3px rgb(0, 0, 0), -1px -1px 3px #ffffff61;-webkit-box-shadow:2px 2px 3px rgb(0, 0, 0), -1px -1px 3px #ffffff61}.button-light.svelte-1d6r0ws{display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:black;line-height:1.3;padding:0.7em 1em 0.7em 1em;width:8em;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-moz-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-webkit-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0)}.button-light.svelte-1d6r0ws:active{display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:black;line-height:1.3;padding:0.7em 1em 0.7em 1em;width:8em;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-moz-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-webkit-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0)\n  }.button-light.svelte-1d6r0ws:disabled{display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:#888;line-height:1.3;padding:0.7em 1em 0.7em 1em;width:8em;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-moz-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-webkit-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0)\n  }";
	append(document.head, style);
}

function get_each_context$e(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[45] = list[i];
	return child_ctx;
}

function get_each_context_1$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[48] = list[i];
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[51] = list[i];
	return child_ctx;
}

// (658:8) {#each $sidebarLiveCodeOptions as liveCodeOption}
function create_each_block_2(ctx) {
	let option;
	let t0_value = /*liveCodeOption*/ ctx[51].text + "";
	let t0;
	let t1;
	let option_disabled_value;
	let option_value_value;

	return {
		c() {
			option = element("option");
			t0 = text$1(t0_value);
			t1 = space();
			option.disabled = option_disabled_value = /*liveCodeOption*/ ctx[51].disabled;
			option.__value = option_value_value = /*liveCodeOption*/ ctx[51];
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t0);
			append(option, t1);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$sidebarLiveCodeOptions*/ 32 && t0_value !== (t0_value = /*liveCodeOption*/ ctx[51].text + "")) set_data(t0, t0_value);

			if (dirty[0] & /*$sidebarLiveCodeOptions*/ 32 && option_disabled_value !== (option_disabled_value = /*liveCodeOption*/ ctx[51].disabled)) {
				option.disabled = option_disabled_value;
			}

			if (dirty[0] & /*$sidebarLiveCodeOptions*/ 32 && option_value_value !== (option_value_value = /*liveCodeOption*/ ctx[51])) {
				option.__value = option_value_value;
				option.value = option.__value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (680:8) {#each $sidebarModelOptions as modelOption}
function create_each_block_1$3(ctx) {
	let option;
	let t0_value = /*modelOption*/ ctx[48].text + "";
	let t0;
	let t1;
	let option_disabled_value;
	let option_value_value;

	return {
		c() {
			option = element("option");
			t0 = text$1(t0_value);
			t1 = space();
			option.disabled = option_disabled_value = /*modelOption*/ ctx[48].disabled;
			option.__value = option_value_value = /*modelOption*/ ctx[48];
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t0);
			append(option, t1);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$sidebarModelOptions*/ 128 && t0_value !== (t0_value = /*modelOption*/ ctx[48].text + "")) set_data(t0, t0_value);

			if (dirty[0] & /*$sidebarModelOptions*/ 128 && option_disabled_value !== (option_disabled_value = /*modelOption*/ ctx[48].disabled)) {
				option.disabled = option_disabled_value;
			}

			if (dirty[0] & /*$sidebarModelOptions*/ 128 && option_value_value !== (option_value_value = /*modelOption*/ ctx[48])) {
				option.__value = option_value_value;
				option.value = option.__value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (699:8) {#each $sidebarDebuggerOptions as debuggerOption}
function create_each_block$e(ctx) {
	let option;
	let t0_value = /*debuggerOption*/ ctx[45].text + "";
	let t0;
	let t1;
	let option_disabled_value;
	let option_value_value;

	return {
		c() {
			option = element("option");
			t0 = text$1(t0_value);
			t1 = space();
			option.disabled = option_disabled_value = /*debuggerOption*/ ctx[45].disabled;
			option.__value = option_value_value = /*debuggerOption*/ ctx[45];
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t0);
			append(option, t1);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$sidebarDebuggerOptions*/ 8 && t0_value !== (t0_value = /*debuggerOption*/ ctx[45].text + "")) set_data(t0, t0_value);

			if (dirty[0] & /*$sidebarDebuggerOptions*/ 8 && option_disabled_value !== (option_disabled_value = /*debuggerOption*/ ctx[45].disabled)) {
				option.disabled = option_disabled_value;
			}

			if (dirty[0] & /*$sidebarDebuggerOptions*/ 8 && option_value_value !== (option_value_value = /*debuggerOption*/ ctx[45])) {
				option.__value = option_value_value;
				option.value = option.__value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

function create_fragment$T(ctx) {
	let div11;
	let div7;
	let div0;
	let t1;
	let div1;
	let select0;
	let select0_class_value;
	let select0_cursor_value;
	let t2;
	let div2;
	let select1;
	let select1_class_value;
	let select1_cursor_value;
	let t3;
	let div3;
	let select2;
	let select2_class_value;
	let t4;
	let div4;
	let button0;
	let t5;
	let button0_class_value;
	let t6;
	let div5;
	let button1;
	let t7;
	let button1_class_value;
	let t8;
	let div6;
	let button2;
	let t9;
	let button2_class_value;
	let t10;
	let br0;
	let t11;
	let div10;
	let div8;
	let t13;
	let div9;
	let itemprops;
	let t14;
	let br1;
	let current;
	let mounted;
	let dispose;
	let each_value_2 = /*$sidebarLiveCodeOptions*/ ctx[5];
	let each_blocks_2 = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks_2[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	let each_value_1 = /*$sidebarModelOptions*/ ctx[7];
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks_1[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
	}

	let each_value = /*$sidebarDebuggerOptions*/ ctx[3];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$e(get_each_context$e(ctx, each_value, i));
	}

	itemprops = new ItemProps({});

	return {
		c() {
			div11 = element("div");
			div7 = element("div");
			div0 = element("div");
			div0.innerHTML = `<span class="group-label svelte-1d6r0ws">Windows</span>`;
			t1 = space();
			div1 = element("div");
			select0 = element("select");

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].c();
			}

			t2 = space();
			div2 = element("div");
			select1 = element("select");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t3 = space();
			div3 = element("div");
			select2 = element("select");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t4 = space();
			div4 = element("div");
			button0 = element("button");
			t5 = text$1("analyser");
			t6 = space();
			div5 = element("div");
			button1 = element("button");
			t7 = text$1("visualiser");
			t8 = space();
			div6 = element("div");
			button2 = element("button");
			t9 = text$1("MIDI");
			t10 = space();
			br0 = element("br");
			t11 = space();
			div10 = element("div");
			div8 = element("div");
			div8.innerHTML = `<span class="group-label svelte-1d6r0ws">Window Settings</span>`;
			t13 = space();
			div9 = element("div");
			create_component(itemprops.$$.fragment);
			t14 = space();
			br1 = element("br");
			attr(div0, "class", "group-labels svelte-1d6r0ws");

			attr(select0, "class", select0_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[9] === "dark"
			? "combobox-dark"
			: "combobox-light") + " svelte-1d6r0ws"));

			select0.disabled = /*$isSelectLiveCodeEditorDisabled*/ ctx[0];
			attr(select0, "cursor", select0_cursor_value = /*func*/ ctx[11]);
			if (/*$selectedLiveCodeOption*/ ctx[4] === void 0) add_render_callback(() => /*select0_change_handler*/ ctx[12].call(select0));
			attr(div1, "class", "controls svelte-1d6r0ws");

			attr(select1, "class", select1_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[9] === "dark"
			? "combobox-dark"
			: "combobox-light") + " svelte-1d6r0ws"));

			select1.disabled = /*$isSelectModelEditorDisabled*/ ctx[1];
			attr(select1, "cursor", select1_cursor_value = /*func_1*/ ctx[15]);
			if (/*$selectedModelOption*/ ctx[6] === void 0) add_render_callback(() => /*select1_change_handler*/ ctx[16].call(select1));
			attr(div2, "class", "controls svelte-1d6r0ws");

			attr(select2, "class", select2_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[9] === "dark"
			? "combobox-dark"
			: "combobox-light") + " svelte-1d6r0ws"));

			if (/*$selectedDebuggerOption*/ ctx[8] === void 0) add_render_callback(() => /*select2_change_handler*/ ctx[19].call(select2));
			attr(div3, "class", "controls svelte-1d6r0ws");

			attr(button0, "class", button0_class_value = "" + ((/*$siteMode*/ ctx[9] === "dark"
			? "button-dark"
			: "button-light") + " controls" + " svelte-1d6r0ws"));

			button0.disabled = /*$isAddAnalyserDisabled*/ ctx[2];

			attr(button1, "class", button1_class_value = "" + ((/*$siteMode*/ ctx[9] === "dark"
			? "button-dark"
			: "button-light") + " controls" + " svelte-1d6r0ws"));

			attr(button2, "class", button2_class_value = "" + ((/*$siteMode*/ ctx[9] === "dark"
			? "button-dark"
			: "button-light") + " controls" + " svelte-1d6r0ws"));

			attr(div7, "class", "layout-sidebar-group-widgets-container svelte-1d6r0ws");
			attr(div8, "class", "group-labels svelte-1d6r0ws");
			attr(div10, "class", "layout-sidebar-group-properties-container svelte-1d6r0ws");
			attr(div11, "class", "sidebar svelte-1d6r0ws");
		},
		m(target, anchor) {
			insert(target, div11, anchor);
			append(div11, div7);
			append(div7, div0);
			append(div7, t1);
			append(div7, div1);
			append(div1, select0);

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].m(select0, null);
			}

			select_option(select0, /*$selectedLiveCodeOption*/ ctx[4]);
			append(div7, t2);
			append(div7, div2);
			append(div2, select1);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(select1, null);
			}

			select_option(select1, /*$selectedModelOption*/ ctx[6]);
			append(div7, t3);
			append(div7, div3);
			append(div3, select2);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(select2, null);
			}

			select_option(select2, /*$selectedDebuggerOption*/ ctx[8]);
			append(div7, t4);
			append(div7, div4);
			append(div4, button0);
			append(button0, t5);
			append(div7, t6);
			append(div7, div5);
			append(div5, button1);
			append(button1, t7);
			append(div7, t8);
			append(div7, div6);
			append(div6, button2);
			append(button2, t9);
			append(div7, t10);
			append(div7, br0);
			append(div11, t11);
			append(div11, div10);
			append(div10, div8);
			append(div10, t13);
			append(div10, div9);
			mount_component(itemprops, div9, null);
			append(div10, t14);
			append(div10, br1);
			current = true;

			if (!mounted) {
				dispose = [
					listen(select0, "change", /*select0_change_handler*/ ctx[12]),
					listen(select0, "change", /*change_handler*/ ctx[13]),
					listen(select0, "click", /*click_handler*/ ctx[14]),
					listen(select1, "change", /*select1_change_handler*/ ctx[16]),
					listen(select1, "change", /*change_handler_1*/ ctx[17]),
					listen(select1, "click", /*click_handler_1*/ ctx[18]),
					listen(select2, "change", /*select2_change_handler*/ ctx[19]),
					listen(select2, "change", /*change_handler_2*/ ctx[20]),
					listen(select2, "click", /*click_handler_2*/ ctx[21]),
					listen(button0, "click", /*click_handler_3*/ ctx[22]),
					listen(button1, "click", /*click_handler_4*/ ctx[23]),
					listen(button2, "click", /*click_handler_5*/ ctx[24])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$sidebarLiveCodeOptions*/ 32) {
				each_value_2 = /*$sidebarLiveCodeOptions*/ ctx[5];
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks_2[i]) {
						each_blocks_2[i].p(child_ctx, dirty);
					} else {
						each_blocks_2[i] = create_each_block_2(child_ctx);
						each_blocks_2[i].c();
						each_blocks_2[i].m(select0, null);
					}
				}

				for (; i < each_blocks_2.length; i += 1) {
					each_blocks_2[i].d(1);
				}

				each_blocks_2.length = each_value_2.length;
			}

			if (!current || dirty[0] & /*$siteMode*/ 512 && select0_class_value !== (select0_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[9] === "dark"
			? "combobox-dark"
			: "combobox-light") + " svelte-1d6r0ws"))) {
				attr(select0, "class", select0_class_value);
			}

			if (!current || dirty[0] & /*$isSelectLiveCodeEditorDisabled*/ 1) {
				select0.disabled = /*$isSelectLiveCodeEditorDisabled*/ ctx[0];
			}

			if (!current || dirty[0] & /*$isSelectLiveCodeEditorDisabled*/ 1 && select0_cursor_value !== (select0_cursor_value = /*func*/ ctx[11])) {
				attr(select0, "cursor", select0_cursor_value);
			}

			if (dirty[0] & /*$selectedLiveCodeOption, $sidebarLiveCodeOptions*/ 48) {
				select_option(select0, /*$selectedLiveCodeOption*/ ctx[4]);
			}

			if (dirty[0] & /*$sidebarModelOptions*/ 128) {
				each_value_1 = /*$sidebarModelOptions*/ ctx[7];
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$3(ctx, each_value_1, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_1$3(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(select1, null);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_1.length;
			}

			if (!current || dirty[0] & /*$siteMode*/ 512 && select1_class_value !== (select1_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[9] === "dark"
			? "combobox-dark"
			: "combobox-light") + " svelte-1d6r0ws"))) {
				attr(select1, "class", select1_class_value);
			}

			if (!current || dirty[0] & /*$isSelectModelEditorDisabled*/ 2) {
				select1.disabled = /*$isSelectModelEditorDisabled*/ ctx[1];
			}

			if (!current || dirty[0] & /*$isSelectModelEditorDisabled*/ 2 && select1_cursor_value !== (select1_cursor_value = /*func_1*/ ctx[15])) {
				attr(select1, "cursor", select1_cursor_value);
			}

			if (dirty[0] & /*$selectedModelOption, $sidebarModelOptions*/ 192) {
				select_option(select1, /*$selectedModelOption*/ ctx[6]);
			}

			if (dirty[0] & /*$sidebarDebuggerOptions*/ 8) {
				each_value = /*$sidebarDebuggerOptions*/ ctx[3];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$e(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$e(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(select2, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (!current || dirty[0] & /*$siteMode*/ 512 && select2_class_value !== (select2_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[9] === "dark"
			? "combobox-dark"
			: "combobox-light") + " svelte-1d6r0ws"))) {
				attr(select2, "class", select2_class_value);
			}

			if (dirty[0] & /*$selectedDebuggerOption, $sidebarDebuggerOptions*/ 264) {
				select_option(select2, /*$selectedDebuggerOption*/ ctx[8]);
			}

			if (!current || dirty[0] & /*$siteMode*/ 512 && button0_class_value !== (button0_class_value = "" + ((/*$siteMode*/ ctx[9] === "dark"
			? "button-dark"
			: "button-light") + " controls" + " svelte-1d6r0ws"))) {
				attr(button0, "class", button0_class_value);
			}

			if (!current || dirty[0] & /*$isAddAnalyserDisabled*/ 4) {
				button0.disabled = /*$isAddAnalyserDisabled*/ ctx[2];
			}

			if (!current || dirty[0] & /*$siteMode*/ 512 && button1_class_value !== (button1_class_value = "" + ((/*$siteMode*/ ctx[9] === "dark"
			? "button-dark"
			: "button-light") + " controls" + " svelte-1d6r0ws"))) {
				attr(button1, "class", button1_class_value);
			}

			if (!current || dirty[0] & /*$siteMode*/ 512 && button2_class_value !== (button2_class_value = "" + ((/*$siteMode*/ ctx[9] === "dark"
			? "button-dark"
			: "button-light") + " controls" + " svelte-1d6r0ws"))) {
				attr(button2, "class", button2_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(itemprops.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(itemprops.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div11);
			destroy_each(each_blocks_2, detaching);
			destroy_each(each_blocks_1, detaching);
			destroy_each(each_blocks, detaching);
			destroy_component(itemprops);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$T($$self, $$props, $$invalidate) {
	let $items;
	let $isSelectLiveCodeEditorDisabled;
	let $isSelectModelEditorDisabled;
	let $isAddGrammarEditorDisabled;
	let $isAddAnalyserDisabled;
	let $sidebarDebuggerOptions;
	let $selectedLoadEnvironmentOption;
	let $loadEnvironmentOptions;
	let $isLoadEnvironmentOptionsDisabled;
	let $isUploadOverlayVisible;
	let $selectedLiveCodeOption;
	let $sidebarLiveCodeOptions;
	let $selectedModelOption;
	let $sidebarModelOptions;
	let $selectedDebuggerOption;
	let $siteMode;
	component_subscribe($$self, items, $$value => $$invalidate(26, $items = $$value));
	component_subscribe($$self, isSelectLiveCodeEditorDisabled, $$value => $$invalidate(0, $isSelectLiveCodeEditorDisabled = $$value));
	component_subscribe($$self, isSelectModelEditorDisabled, $$value => $$invalidate(1, $isSelectModelEditorDisabled = $$value));
	component_subscribe($$self, isAddGrammarEditorDisabled, $$value => $$invalidate(27, $isAddGrammarEditorDisabled = $$value));
	component_subscribe($$self, isAddAnalyserDisabled, $$value => $$invalidate(2, $isAddAnalyserDisabled = $$value));
	component_subscribe($$self, sidebarDebuggerOptions, $$value => $$invalidate(3, $sidebarDebuggerOptions = $$value));
	component_subscribe($$self, selectedLoadEnvironmentOption, $$value => $$invalidate(28, $selectedLoadEnvironmentOption = $$value));
	component_subscribe($$self, loadEnvironmentOptions, $$value => $$invalidate(29, $loadEnvironmentOptions = $$value));
	component_subscribe($$self, isLoadEnvironmentOptionsDisabled, $$value => $$invalidate(30, $isLoadEnvironmentOptionsDisabled = $$value));
	component_subscribe($$self, isUploadOverlayVisible, $$value => $$invalidate(31, $isUploadOverlayVisible = $$value));
	component_subscribe($$self, selectedLiveCodeOption, $$value => $$invalidate(4, $selectedLiveCodeOption = $$value));
	component_subscribe($$self, sidebarLiveCodeOptions, $$value => $$invalidate(5, $sidebarLiveCodeOptions = $$value));
	component_subscribe($$self, selectedModelOption, $$value => $$invalidate(6, $selectedModelOption = $$value));
	component_subscribe($$self, sidebarModelOptions, $$value => $$invalidate(7, $sidebarModelOptions = $$value));
	component_subscribe($$self, selectedDebuggerOption, $$value => $$invalidate(8, $selectedDebuggerOption = $$value));
	component_subscribe($$self, siteMode, $$value => $$invalidate(9, $siteMode = $$value));
	const messaging = new PubSub();
	let itemDeletionSubscriptionToken;
	const dispatch = createEventDispatcher();

	function dispatchAdd(type, selected) {
		// console.log(`DEBUG:Sidebar:dispatchAdd: /add/${type}/${selected.id}`);
		// console.log(selected.content);
		switch (type) {
			case "live":
				messaging.publish("playground-add", {
					type: "liveCodeEditor",
					data: selected.content
				});
				set_store_value(selectedLiveCodeOption, $selectedLiveCodeOption = $sidebarLiveCodeOptions[0], $selectedLiveCodeOption);
				set_store_value(isSelectLiveCodeEditorDisabled, $isSelectLiveCodeEditorDisabled = true, $isSelectLiveCodeEditorDisabled);
				break;
			case "model":
				messaging.publish("playground-add", {
					type: "modelEditor",
					data: selected.content
				});
				set_store_value(selectedModelOption, $selectedModelOption = $sidebarModelOptions[0], $selectedModelOption);
				set_store_value(isSelectModelEditorDisabled, $isSelectModelEditorDisabled = true, $isSelectModelEditorDisabled);
				break;
			case "analyser":
				messaging.publish("playground-add", { type: "analyser" });
				set_store_value(isAddAnalyserDisabled, $isAddAnalyserDisabled = true, $isAddAnalyserDisabled);
				break;
			case "visualiser":
				messaging.publish("playground-add", { type: "visualiser" });
				// $isAddAnalyserDisabled = true;
				break;
			case "MIDI":
				messaging.publish("playground-add", { type: "MIDI" });
				break;
			case "debugger":
				messaging.publish("playground-add", { type: selected.type });
				disableSelectDebuggerOption(selected.type);
				set_store_value(selectedDebuggerOption, $selectedDebuggerOption = $sidebarDebuggerOptions[0], $selectedDebuggerOption);
				break;
		}
	}

	function disableSelectDebuggerOption(itemType) {
		if (itemType !== undefined) if (itemType === "grammarCompileOutput") {
			set_store_value(sidebarDebuggerOptions, $sidebarDebuggerOptions[1].disabled = true, $sidebarDebuggerOptions);
		} else if (itemType === "liveCodeParseOutput") {
			set_store_value(sidebarDebuggerOptions, $sidebarDebuggerOptions[2].disabled = true, $sidebarDebuggerOptions);
		} else if (itemType === "dspCode") {
			set_store_value(sidebarDebuggerOptions, $sidebarDebuggerOptions[3].disabled = true, $sidebarDebuggerOptions);
		} else if (itemType === "console") {
			set_store_value(sidebarDebuggerOptions, $sidebarDebuggerOptions[4].disabled = true, $sidebarDebuggerOptions);
		} else if (itemType === "storeInspector") {
			set_store_value(sidebarDebuggerOptions, $sidebarDebuggerOptions[5].disabled = true, $sidebarDebuggerOptions);
		} else throw new Error("Disable Select Debugger Option: itemType undefined");
	}

	function setDisabledOnSelectDebuggerOption(itemType, state) {
		if (itemType !== undefined) if (itemType === "grammarCompileOutput") {
			set_store_value(sidebarDebuggerOptions, $sidebarDebuggerOptions[1].disabled = state, $sidebarDebuggerOptions);
		} else if (itemType === "liveCodeParseOutput") {
			set_store_value(sidebarDebuggerOptions, $sidebarDebuggerOptions[2].disabled = state, $sidebarDebuggerOptions);
		} else if (itemType === "dspCode") {
			set_store_value(sidebarDebuggerOptions, $sidebarDebuggerOptions[3].disabled = state, $sidebarDebuggerOptions);
		} else if (itemType === "console") {
			set_store_value(sidebarDebuggerOptions, $sidebarDebuggerOptions[4].disabled = state, $sidebarDebuggerOptions);
		} else if (itemType === "storeInspector") {
			set_store_value(sidebarDebuggerOptions, $sidebarDebuggerOptions[5].disabled = state, $sidebarDebuggerOptions);
		} else throw new Error("Enable Select Debugger Option On Item Deletion: itemType undefined");
	}

	function activateSelectOnItemDeletion(itemType) {
		// console.log("DEBUG:routes/playground:sidebar:activateSelectOnItemDeletion:")
		if (itemType !== null) {
			switch (itemType) {
				case "liveCodeEditor":
					set_store_value(isSelectLiveCodeEditorDisabled, $isSelectLiveCodeEditorDisabled = false, $isSelectLiveCodeEditorDisabled);
					break;
				case "modelEditor":
					set_store_value(isSelectModelEditorDisabled, $isSelectModelEditorDisabled = false, $isSelectModelEditorDisabled);
					break;
				case "grammarEditor":
					set_store_value(isAddGrammarEditorDisabled, $isAddGrammarEditorDisabled = false, $isAddGrammarEditorDisabled);
					break;
				case "analyser":
					set_store_value(isAddAnalyserDisabled, $isAddAnalyserDisabled = false, $isAddAnalyserDisabled);
					break;
				case "grammarCompileOutput":
				case "liveCodeParseOutput":
				case "dspCode":
				case "console":
				case "storeInspector":
					setDisabledOnSelectDebuggerOption(itemType, false);
					break;
			}
		} else throw new Error("Activate Select On Item Deletion: itemType undefined");
	}

	function setButtonsStateOnLoad() {
		if ($items.length > 0) {
			for (const item of $items) {
				switch (item.data.type) {
					case "liveCodeEditor":
						set_store_value(isSelectLiveCodeEditorDisabled, $isSelectLiveCodeEditorDisabled = true, $isSelectLiveCodeEditorDisabled);
						break;
					case "modelEditor":
						set_store_value(isSelectModelEditorDisabled, $isSelectModelEditorDisabled = true, $isSelectModelEditorDisabled);
						break;
					case "grammarEditor":
						set_store_value(isAddGrammarEditorDisabled, $isAddGrammarEditorDisabled = true, $isAddGrammarEditorDisabled);
						break;
					case "analyser":
						set_store_value(isAddAnalyserDisabled, $isAddAnalyserDisabled = true, $isAddAnalyserDisabled);
						break;
					case "grammarCompileOutput":
					case "liveCodeParseOutput":
					case "dspCode":
					case "console":
					case "storeInspector":
						setDisabledOnSelectDebuggerOption(item.data.type, true);
						break;
				}
			}
		}
	}

	onMount(() => {
		setButtonsStateOnLoad();
		itemDeletionSubscriptionToken = messaging.subscribe("plaground-item-deletion", activateSelectOnItemDeletion);
	});

	onDestroy(() => {
		messaging.unsubscribe(itemDeletionSubscriptionToken);
	});

	const func = () => $isSelectLiveCodeEditorDisabled
	? "not-allowed"
	: "pointer";

	function select0_change_handler() {
		$selectedLiveCodeOption = select_value(this);
		selectedLiveCodeOption.set($selectedLiveCodeOption);
	}

	const change_handler = () => dispatchAdd("live", $selectedLiveCodeOption);
	const click_handler = () => set_store_value(sidebarLiveCodeOptions, $sidebarLiveCodeOptions[0].disabled = true, $sidebarLiveCodeOptions);
	const func_1 = () => $isSelectModelEditorDisabled ? "not-allowed" : "pointer";

	function select1_change_handler() {
		$selectedModelOption = select_value(this);
		selectedModelOption.set($selectedModelOption);
	}

	const change_handler_1 = () => dispatchAdd("model", $selectedModelOption);
	const click_handler_1 = () => set_store_value(sidebarModelOptions, $sidebarModelOptions[0].disabled = true, $sidebarModelOptions);

	function select2_change_handler() {
		$selectedDebuggerOption = select_value(this);
		selectedDebuggerOption.set($selectedDebuggerOption);
	}

	const change_handler_2 = () => dispatchAdd("debugger", $selectedDebuggerOption);
	const click_handler_2 = () => set_store_value(sidebarDebuggerOptions, $sidebarDebuggerOptions[0].disabled = true, $sidebarDebuggerOptions);
	const click_handler_3 = () => dispatchAdd("analyser");
	const click_handler_4 = () => dispatchAdd("visualiser");
	const click_handler_5 = () => dispatchAdd("MIDI");

	return [
		$isSelectLiveCodeEditorDisabled,
		$isSelectModelEditorDisabled,
		$isAddAnalyserDisabled,
		$sidebarDebuggerOptions,
		$selectedLiveCodeOption,
		$sidebarLiveCodeOptions,
		$selectedModelOption,
		$sidebarModelOptions,
		$selectedDebuggerOption,
		$siteMode,
		dispatchAdd,
		func,
		select0_change_handler,
		change_handler,
		click_handler,
		func_1,
		select1_change_handler,
		change_handler_1,
		click_handler_1,
		select2_change_handler,
		change_handler_2,
		click_handler_2,
		click_handler_3,
		click_handler_4,
		click_handler_5
	];
}

class Sidebar extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1d6r0ws-style")) add_css$I();
		init(this, options, instance$T, create_fragment$T, safe_not_equal, {}, [-1, -1]);
	}
}

/* src/components/settings/group/Engine.svelte generated by Svelte v3.31.0 */

function add_css$J() {
	var style = element("style");
	style.id = "svelte-18uk55n-style";
	style.textContent = ".icon-container.svelte-18uk55n{width:10px;height:10px}.button-dark.svelte-18uk55n{width:2.5em;height:2.5em;padding:0.3em 0.25em 0.7em 0.85em;display:block;font-family:sans-serif;font-weight:400;cursor:pointer;color:red;line-height:1.3;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;-webkit-box-shadow:2px 2px 3px rgb(0, 0, 0), -0.5px -0.5px 3px #ffffff61;-moz-box-shadow:2px 2px 3px rgb(0, 0, 0), -0.5px -0.5px 3px #ffffff61;box-shadow:2px 2px 3px rgb(0, 0, 0), -0.5px -0.5px 3px #ffffff61}.button-dark.svelte-18uk55n:hover{width:2.5em;height:2.5em;padding:0.3em 0.25em 0.7em 0.85em;display:block;font-family:sans-serif;font-weight:500;cursor:pointer;color:red;line-height:1.3;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:linear-gradient(rgba(16, 16, 16, 1), rgba(16, 16, 16, 0.08));background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;-webkit-box-shadow:2px 2px 5px rgba(0,0,0),-0.5px -0.5px 3px rgb(34, 34, 34);-moz-box-shadow:2px 2px 5px rgba(0,0,0), -0.5px -0.5px 3px rgb(34, 34, 34);box-shadow:2px 2px 3px rgb(0, 0, 0), -1px -1px 3px #ffffff61}.button-dark.svelte-18uk55n:active{width:2.5em;height:2.5em;display:block;padding:0.3em 0.25em 0.7em 0.85em;font-family:sans-serif;font-weight:400;cursor:pointer;color:red;line-height:1.3;max-width:100%;box-sizing:border-box;text-align:left;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-size:.65em auto, 100%;box-shadow:-1px -1px 3px rgba(16, 16, 16, 0.4), 0.5px 0.5px 0.5px rgba(16, 16, 16, 0.04)}.button-light.svelte-18uk55n{width:2.5em;height:2.5em;display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:black;line-height:1.3;padding:0.7em 1em 0.7em 1em;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-moz-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-webkit-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0)}.button-light.svelte-18uk55n:active{width:2.5em;height:2.5em;display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:black;line-height:1.3;padding:0.7em 1em 0.7em 1em;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-moz-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-webkit-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0)\n  }.button-light.svelte-18uk55n:disabled{width:2.5em;height:2.5em;display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:#888;line-height:1.3;padding:0.7em 1em 0.7em 1em;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-moz-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-webkit-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0)\n  }path.svelte-18uk55n{transform:translate(-3px, -5px)\n  }.audio-active.svelte-18uk55n{fill:#0050A0}.audio-inactive.svelte-18uk55n{fill:rgb(133, 130, 130)}.no-audio.svelte-18uk55n{fill:red}.mute-audio.svelte-18uk55n{padding:0.1em 0px 0em 0.1em;fill:rgb(133, 130, 130)}.engine-sound-level-text-container.svelte-18uk55n{width:2em;margin:0em 0.1em 0em 0em;display:flex;align-items:center;align-content:flex-end}.engine-sound-level-text.svelte-18uk55n{user-select:none;color:#ccc;font-size:medium}";
	append(document.head, style);
}

// (364:42) 
function create_if_block_5$1(ctx) {
	let svg;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			set_style(path, "text-indent", "0");
			set_style(path, "text-align", "start");
			set_style(path, "line-height", "normal");
			set_style(path, "text-transform", "none");
			set_style(path, "block-progression", "tb");
			set_style(path, "-inkscape-font-specification", "Bitstream Vera Sans");
			attr(path, "d", "M 15 4.59375 L 13.28125 6.28125 L 8.5625 11 L 5 11 L 4 11 L 4 12 L 4 20 L 4 21 L 5 21 L 8.5625 21 L 13.28125 25.71875 L 15 27.40625 L 15 25 L 15 7 L 15 4.59375 z M 13 9.4375 L 13 22.5625 L 9.71875 19.28125 L 9.40625 19 L 9 19 L 6 19 L 6 13 L 9 13 L 9.40625 13 L 9.71875 12.71875 L 13 9.4375 z M 20.21875 11.78125 L 18.78125 13.21875 L 21.5625 16 L 18.78125 18.78125 L 20.21875 20.21875 L 23 17.4375 L 25.78125 20.21875 L 27.21875 18.78125 L 24.4375 16 L 27.21875 13.21875 L 25.78125 11.78125 L 23 14.5625 L 20.21875 11.78125 z");
			attr(path, "overflow", "visible");
			attr(path, "font-family", "Bitstream Vera Sans");
			attr(path, "class", "svelte-18uk55n");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "class", "path mute-audio svelte-18uk55n");
			attr(svg, "width", "20");
			attr(svg, "height", "20");
			attr(svg, "viewBox", "0 0 32 32");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (356:45) 
function create_if_block_4$2(ctx) {
	let svg;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			set_style(path, "text-indent", "0");
			set_style(path, "text-align", "start");
			set_style(path, "line-height", "normal");
			set_style(path, "text-transform", "none");
			set_style(path, "block-progression", "tb");
			set_style(path, "-inkscape-font-specification", "Bitstream Vera Sans");
			attr(path, "d", "M 15 4.59375 L 13.28125 6.28125 L 8.5625 11 L 5 11 L 4 11 L 4 12 L 4 20 L 4 21 L 5 21 L 8.5625 21 L 13.28125 25.71875 L 15 27.40625 L 15 25 L 15 7 L 15 4.59375 z M 13 9.4375 L 13 22.5625 L 9.71875 19.28125 L 9.40625 19 L 9 19 L 6 19 L 6 13 L 9 13 L 9.40625 13 L 9.71875 12.71875 L 13 9.4375 z M 20.21875 11.78125 L 18.78125 13.21875 L 21.5625 16 L 18.78125 18.78125 L 20.21875 20.21875 L 23 17.4375 L 25.78125 20.21875 L 27.21875 18.78125 L 24.4375 16 L 27.21875 13.21875 L 25.78125 11.78125 L 23 14.5625 L 20.21875 11.78125 z");
			attr(path, "overflow", "visible");
			attr(path, "font-family", "Bitstream Vera Sans");
			attr(path, "class", "svelte-18uk55n");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "class", "path audio");
			attr(svg, "width", "20");
			attr(svg, "height", "20");
			attr(svg, "viewBox", "0 0 32 32");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (348:48) 
function create_if_block_3$2(ctx) {
	let svg;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			set_style(path, "text-indent", "0");
			set_style(path, "text-align", "start");
			set_style(path, "line-height", "normal");
			set_style(path, "text-transform", "none");
			set_style(path, "block-progression", "tb");
			set_style(path, "-inkscape-font-specification", "Bitstream Vera Sans");
			attr(path, "d", "M 15 4.59375 L 13.28125 6.28125 L 8.5625 11 L 5 11 L 4 11 L 4 12 L 4 20 L 4 21 L 5 21 L 8.5625 21 L 13.28125 25.71875 L 15 27.40625 L 15 25 L 15 7 L 15 4.59375 z M 13 9.4375 L 13 22.5625 L 9.71875 19.28125 L 9.40625 19 L 9 19 L 6 19 L 6 13 L 9 13 L 9.40625 13 L 9.71875 12.71875 L 13 9.4375 z M 20.21875 11.78125 L 18.78125 13.21875 L 21.5625 16 L 18.78125 18.78125 L 20.21875 20.21875 L 23 17.4375 L 25.78125 20.21875 L 27.21875 18.78125 L 24.4375 16 L 27.21875 13.21875 L 25.78125 11.78125 L 23 14.5625 L 20.21875 11.78125 z");
			attr(path, "overflow", "visible");
			attr(path, "font-family", "Bitstream Vera Sans");
			attr(path, "class", "svelte-18uk55n");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "class", "path audio");
			attr(svg, "width", "20");
			attr(svg, "height", "20");
			attr(svg, "viewBox", "0 0 32 32");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (340:46) 
function create_if_block_2$4(ctx) {
	let svg;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			set_style(path, "text-indent", "0");
			set_style(path, "text-align", "start");
			set_style(path, "line-height", "normal");
			set_style(path, "text-transform", "none");
			set_style(path, "block-progression", "tb");
			set_style(path, "-inkscape-font-specification", "Bitstream Vera Sans");
			attr(path, "d", "M 15 4.59375 L 13.28125 6.28125 L 8.5625 11 L 5 11 L 4 11 L 4 12 L 4 20 L 4 21 L 5 21 L 8.5625 21 L 13.28125 25.71875 L 15 27.40625 L 15 25 L 15 7 L 15 4.59375 z M 13 9.4375 L 13 22.5625 L 9.71875 19.28125 L 9.40625 19 L 9 19 L 6 19 L 6 13 L 9 13 L 9.40625 13 L 9.71875 12.71875 L 13 9.4375 z M 20.21875 11.78125 L 18.78125 13.21875 L 21.5625 16 L 18.78125 18.78125 L 20.21875 20.21875 L 23 17.4375 L 25.78125 20.21875 L 27.21875 18.78125 L 24.4375 16 L 27.21875 13.21875 L 25.78125 11.78125 L 23 14.5625 L 20.21875 11.78125 z");
			attr(path, "overflow", "visible");
			attr(path, "font-family", "Bitstream Vera Sans");
			attr(path, "class", "svelte-18uk55n");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "class", "path audio");
			attr(svg, "width", "20");
			attr(svg, "height", "20");
			attr(svg, "viewBox", "0 0 32 32");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (330:44) 
function create_if_block_1$d(ctx) {
	let svg;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			set_style(path, "text-indent", "0");
			set_style(path, "text-align", "start");
			set_style(path, "line-height", "normal");
			set_style(path, "text-transform", "none");
			set_style(path, "block-progression", "tb");
			set_style(path, "-inkscape-font-specification", "Bitstream Vera Sans");
			attr(path, "d", "M 15 4.59375 L 13.28125 6.28125 L 8.5625 11 L 5 11 L 4 11 L 4 12 L 4 20 L 4 21 L 5 21 L 8.5625 21 L 13.28125 25.71875 L 15 27.40625 L 15 25 L 15 7 L 15 4.59375 z M 13 9.4375 L 13 22.5625 L 9.71875 19.28125 L 9.40625 19 L 9 19 L 6 19 L 6 13 L 9 13 L 9.40625 13 L 9.71875 12.71875 L 13 9.4375 z M 20.21875 11.78125 L 18.78125 13.21875 L 21.5625 16 L 18.78125 18.78125 L 20.21875 20.21875 L 23 17.4375 L 25.78125 20.21875 L 27.21875 18.78125 L 24.4375 16 L 27.21875 13.21875 L 25.78125 11.78125 L 23 14.5625 L 20.21875 11.78125 z");
			attr(path, "overflow", "visible");
			attr(path, "font-family", "Bitstream Vera Sans");
			attr(path, "class", "svelte-18uk55n");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "class", "path no-audio svelte-18uk55n");
			attr(svg, "width", "24");
			attr(svg, "viewBox", "0 0 32 32");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (319:4) {#if $engineStatus === 'running' }
function create_if_block$n(ctx) {
	let svg;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			set_style(path, "text-indent", "0");
			set_style(path, "text-align", "start");
			set_style(path, "line-height", "normal");
			set_style(path, "text-transform", "none");
			set_style(path, "block-progression", "tb");
			set_style(path, "-inkscape-font-specification", "Bitstream Vera Sans");
			attr(path, "d", "M 15 4.59375 L 13.28125 6.28125 L 8.5625 11 L 5 11 L 4 11 L 4 12 L 4 20 L 4 21 L 5 21 L 8.5625 21 L 13.28125 25.71875 L 15 27.40625 L 15 25 L 15 7 L 15 4.59375 z M 13 9.4375 L 13 22.5625 L 9.71875 19.28125 L 9.40625 19 L 9 19 L 6 19 L 6 13 L 9 13 L 9.40625 13 L 9.71875 12.71875 L 13 9.4375 z M 20.21875 11.78125 L 18.78125 13.21875  z");
			attr(path, "overflow", "visible");
			attr(path, "class", "svelte-18uk55n");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "class", "path audio-active svelte-18uk55n");
			attr(svg, "width", "24");
			attr(svg, "viewBox", "0 0 32 32");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function create_fragment$U(ctx) {
	let button0;
	let div0;
	let button0_class_value;
	let t0;
	let button1;
	let div1;
	let svg0;
	let path0;
	let svg0_class_value;
	let button1_class_value;
	let t1;
	let div2;
	let span;
	let t2_value = parseInt(/*$engineSoundLevel*/ ctx[1] * 100) + "";
	let t2;
	let t3;
	let t4;
	let button2;
	let div3;
	let svg1;
	let path1;
	let svg1_class_value;
	let button2_class_value;
	let t5;
	let button3;
	let div4;
	let svg2;
	let g;
	let path2;
	let svg2_class_value;
	let button3_class_value;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (/*$engineStatus*/ ctx[0] === "running") return create_if_block$n;
		if (/*$engineStatus*/ ctx[0] === "no-audio") return create_if_block_1$d;
		if (/*$engineStatus*/ ctx[0] === "high-audio") return create_if_block_2$4;
		if (/*$engineStatus*/ ctx[0] === "medium-audio") return create_if_block_3$2;
		if (/*$engineStatus*/ ctx[0] === "low-audio") return create_if_block_4$2;
		if (/*$engineStatus*/ ctx[0] === "paused") return create_if_block_5$1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	return {
		c() {
			button0 = element("button");
			div0 = element("div");
			if (if_block) if_block.c();
			t0 = space();
			button1 = element("button");
			div1 = element("div");
			svg0 = svg_element("svg");
			path0 = svg_element("path");
			t1 = space();
			div2 = element("div");
			span = element("span");
			t2 = text$1(t2_value);
			t3 = text$1("%");
			t4 = space();
			button2 = element("button");
			div3 = element("div");
			svg1 = svg_element("svg");
			path1 = svg_element("path");
			t5 = space();
			button3 = element("button");
			div4 = element("div");
			svg2 = svg_element("svg");
			g = svg_element("g");
			path2 = svg_element("path");
			attr(div0, "class", "icon-container svelte-18uk55n");

			attr(button0, "class", button0_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[3] === "dark"
			? "button-dark"
			: "button-light") + " svelte-18uk55n"));

			attr(button0, "title", "audio status");
			set_style(button0, "padding", "0.22em 0.05em 0.8em 0.95em");
			set_style(path0, "text-indent", "0");
			set_style(path0, "text-align", "start");
			set_style(path0, "line-height", "normal");
			set_style(path0, "text-transform", "none");
			set_style(path0, "block-progression", "tb");
			set_style(path0, "-inkscape-font-specification", "Bitstream Vera Sans");
			attr(path0, "d", "M 15 4.59375 L 13.28125 6.28125 L 8.5625 11 L 5 11 L 4 11 L 4 12 L 4 20 L 4 21 L 5 21 L 8.5625 21 L 13.28125 25.71875 L 15 27.40625 L 15 25 L 15 7 L 15 4.59375 z M 13 9.4375 L 13 22.5625 L 9.71875 19.28125 L 9.40625 19 L 9 19 L 6 19 L 6 13 L 9 13 L 9.40625 13 L 9.71875 12.71875 L 13 9.4375 z M 18.5 12.03125 L 17.0625 13.46875 C 17.6405 14.16275 18 15.028 18 16 C 18 16.972 17.6405 17.83725 17.0625 18.53125 L 18.5 19.96875 C 19.439 18.90975 20 17.523 20 16 C 20 14.477 19.439 13.09025 18.5 12.03125 z");
			attr(path0, "overflow", "visible");
			attr(path0, "font-family", "Bitstream Vera Sans");
			attr(path0, "class", "svelte-18uk55n");
			attr(svg0, "xmlns", "http://www.w3.org/2000/svg");

			attr(svg0, "class", svg0_class_value = "path " + (/*$engineStatus*/ ctx[0] !== "paused"
			? "audio-active"
			: "audio-inactive") + " svelte-18uk55n");

			attr(svg0, "width", "20");
			attr(svg0, "height", "20");
			attr(svg0, "viewBox", "0 0 32 32");
			attr(div1, "class", "icon-container svelte-18uk55n");

			attr(button1, "class", button1_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[3] === "dark"
			? "button-dark"
			: "button-light") + " svelte-18uk55n"));

			attr(button1, "title", "quieter");
			set_style(button1, "padding", "0.3em 0.05em 0.7em 0.95em");
			attr(span, "class", "engine-sound-level-text svelte-18uk55n");
			attr(div2, "class", "engine-sound-level-text-container svelte-18uk55n");
			set_style(path1, "text-indent", "0");
			set_style(path1, "text-align", "start");
			set_style(path1, "line-height", "normal");
			set_style(path1, "text-transform", "none");
			set_style(path1, "block-progression", "tb");
			set_style(path1, "-inkscape-font-specification", "Bitstream Vera Sans");
			attr(path1, "d", "M 15 4.59375 L 13.28125 6.28125 L 8.5625 11 L 5 11 L 4 11 L 4 12 L 4 20 L 4 21 L 5 21 L 8.5625 21 L 13.28125 25.71875 L 15 27.40625 L 15 25 L 15 7 L 15 4.59375 z M 24.125 6.375 L 22.71875 7.78125 C 24.74275 9.92925 26 12.822 26 16 C 26 19.178 24.74275 22.06975 22.71875 24.21875 L 24.125 25.625 C 26.51 23.113 28 19.729 28 16 C 28 12.271 26.51 8.886 24.125 6.375 z M 21.3125 9.1875 L 19.90625 10.625 C 21.20625 12.048 22 13.925 22 16 C 22 18.075 21.20625 19.951 19.90625 21.375 L 21.3125 22.8125 C 22.9735 21.0255 24 18.626 24 16 C 24 13.374 22.9735 10.9735 21.3125 9.1875 z M 13 9.4375 L 13 22.5625 L 9.71875 19.28125 L 9.40625 19 L 9 19 L 6 19 L 6 13 L 9 13 L 9.40625 13 L 9.71875 12.71875 L 13 9.4375 z M 18.5 12.03125 L 17.0625 13.46875 C 17.6405 14.16275 18 15.028 18 16 C 18 16.972 17.6405 17.83725 17.0625 18.53125 L 18.5 19.96875 C 19.439 18.90975 20 17.523 20 16 C 20 14.477 19.439 13.09025 18.5 12.03125 z");
			attr(path1, "overflow", "visible");
			attr(path1, "font-family", "Bitstream Vera Sans");
			attr(path1, "class", "svelte-18uk55n");
			attr(svg1, "xmlns", "http://www.w3.org/2000/svg");

			attr(svg1, "class", svg1_class_value = "path " + (/*$engineStatus*/ ctx[0] !== "paused"
			? "audio-active"
			: "audio-inactive") + " svelte-18uk55n");

			attr(svg1, "width", "20");
			attr(svg1, "height", "20");
			attr(svg1, "viewBox", "0 0 32 32");
			attr(div3, "class", "icon-container svelte-18uk55n");

			attr(button2, "class", button2_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[3] === "dark"
			? "button-dark"
			: "button-light") + " svelte-18uk55n"));

			attr(button2, "title", "louder");
			set_style(button2, "padding", "0.3em 0.15em 0.7em 0.85em");
			attr(path2, "d", "M170.7,234.7h-21.3c0,18.1,2.7,34.1,8.2,48.1c8.1,21,23.1,36.9,40.9,46c17.7,9.2,37.6,12.5,57.6,12.6\n        c26.6,0,53.3-5.9,74.3-23.9c10.4-8.9,18.8-20.7,24.2-34.7c5.5-14,8.2-30,8.2-48.1v-128c0-18.1-2.7-34.1-8.2-48.1\n        c-8.1-21-23.1-36.9-40.9-46C295.9,3.3,276,0,256,0c-26.6,0-53.3,5.9-74.3,23.9c-10.4,8.9-18.8,20.7-24.2,34.7\n        c-5.5,14-8.2,30-8.2,48.1v128H170.7H192v-128c0-13.9,2.1-24.5,5.2-32.5c4.8-12,11.4-18.6,20.9-23.8c9.5-5,22.5-7.7,37.8-7.7\n        c20.5,0,36.4,4.8,46.4,13.5c5.1,4.4,9.2,10,12.4,18c3.1,8,5.2,18.6,5.2,32.5v128c0,13.9-2.1,24.5-5.2,32.5\n        c-4.8,12-11.4,18.6-20.9,23.8c-9.5,5-22.5,7.7-37.8,7.7c-20.5,0-36.4-4.8-46.4-13.5c-5.1-4.4-9.2-10-12.4-18\n        c-3.1-8-5.2-18.6-5.2-32.5H170.7z M64,192v42.7c-0.1,58.4,21.3,107.4,56.6,140.8c35.2,33.5,83.5,51.2,135.4,51.2\n        c51.9,0,100.1-17.7,135.4-51.2c35.3-33.4,56.7-82.4,56.6-140.8V192h-42.7v42.7c-0.1,48.3-16.9,84.6-43.3,109.9\n        c-26.5,25.2-63.6,39.4-106,39.5c-42.4,0-79.5-14.3-106-39.5c-26.5-25.3-43.2-61.6-43.3-109.9l0-42.7H64z M277.3,512V405.3h-42.7\n        V512H277.3z");
			attr(path2, "class", "svelte-18uk55n");
			attr(svg2, "version", "1.1");
			attr(svg2, "id", "Layer_1");
			attr(svg2, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg2, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg2, "x", "0px");
			attr(svg2, "y", "0px");
			attr(svg2, "width", "20");
			attr(svg2, "height", "20");

			attr(svg2, "class", svg2_class_value = "path " + (/*$inputStreamConnected*/ ctx[2]
			? "audio-active"
			: "audio-inactive") + " svelte-18uk55n");

			attr(svg2, "viewBox", "0 0 512 512");
			set_style(svg2, "enable-background", "new 0 0 512 512");
			attr(svg2, "xml:space", "preserve");
			attr(div4, "class", "icon-container svelte-18uk55n");

			attr(button3, "class", button3_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[3] === "dark"
			? "button-dark"
			: "button-light") + " svelte-18uk55n"));

			attr(button3, "title", "microphone");
			set_style(button3, "padding", "0.1em 0.35em 0.9em 0.65em");
		},
		m(target, anchor) {
			insert(target, button0, anchor);
			append(button0, div0);
			if (if_block) if_block.m(div0, null);
			insert(target, t0, anchor);
			insert(target, button1, anchor);
			append(button1, div1);
			append(div1, svg0);
			append(svg0, path0);
			insert(target, t1, anchor);
			insert(target, div2, anchor);
			append(div2, span);
			append(span, t2);
			append(span, t3);
			insert(target, t4, anchor);
			insert(target, button2, anchor);
			append(button2, div3);
			append(div3, svg1);
			append(svg1, path1);
			insert(target, t5, anchor);
			insert(target, button3, anchor);
			append(button3, div4);
			append(div4, svg2);
			append(svg2, g);
			append(g, path2);

			if (!mounted) {
				dispose = [
					listen(button0, "click", /*handleAudioOnOff*/ ctx[4]),
					listen(button1, "click", /*handleLessAudio*/ ctx[5]),
					listen(button2, "click", /*handleMoreAudio*/ ctx[6]),
					listen(button3, "click", /*handleConnectInputStream*/ ctx[7])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div0, null);
				}
			}

			if (dirty & /*$siteMode*/ 8 && button0_class_value !== (button0_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[3] === "dark"
			? "button-dark"
			: "button-light") + " svelte-18uk55n"))) {
				attr(button0, "class", button0_class_value);
			}

			if (dirty & /*$engineStatus*/ 1 && svg0_class_value !== (svg0_class_value = "path " + (/*$engineStatus*/ ctx[0] !== "paused"
			? "audio-active"
			: "audio-inactive") + " svelte-18uk55n")) {
				attr(svg0, "class", svg0_class_value);
			}

			if (dirty & /*$siteMode*/ 8 && button1_class_value !== (button1_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[3] === "dark"
			? "button-dark"
			: "button-light") + " svelte-18uk55n"))) {
				attr(button1, "class", button1_class_value);
			}

			if (dirty & /*$engineSoundLevel*/ 2 && t2_value !== (t2_value = parseInt(/*$engineSoundLevel*/ ctx[1] * 100) + "")) set_data(t2, t2_value);

			if (dirty & /*$engineStatus*/ 1 && svg1_class_value !== (svg1_class_value = "path " + (/*$engineStatus*/ ctx[0] !== "paused"
			? "audio-active"
			: "audio-inactive") + " svelte-18uk55n")) {
				attr(svg1, "class", svg1_class_value);
			}

			if (dirty & /*$siteMode*/ 8 && button2_class_value !== (button2_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[3] === "dark"
			? "button-dark"
			: "button-light") + " svelte-18uk55n"))) {
				attr(button2, "class", button2_class_value);
			}

			if (dirty & /*$inputStreamConnected*/ 4 && svg2_class_value !== (svg2_class_value = "path " + (/*$inputStreamConnected*/ ctx[2]
			? "audio-active"
			: "audio-inactive") + " svelte-18uk55n")) {
				attr(svg2, "class", svg2_class_value);
			}

			if (dirty & /*$siteMode*/ 8 && button3_class_value !== (button3_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[3] === "dark"
			? "button-dark"
			: "button-light") + " svelte-18uk55n"))) {
				attr(button3, "class", button3_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(button0);

			if (if_block) {
				if_block.d();
			}

			if (detaching) detach(t0);
			if (detaching) detach(button1);
			if (detaching) detach(t1);
			if (detaching) detach(div2);
			if (detaching) detach(t4);
			if (detaching) detach(button2);
			if (detaching) detach(t5);
			if (detaching) detach(button3);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$U($$self, $$props, $$invalidate) {
	let $engineStatus;
	let $engineSoundLevel;
	let $inputStreamConnected;
	let $siteMode;
	component_subscribe($$self, engineStatus, $$value => $$invalidate(0, $engineStatus = $$value));
	component_subscribe($$self, engineSoundLevel, $$value => $$invalidate(1, $engineSoundLevel = $$value));
	component_subscribe($$self, inputStreamConnected, $$value => $$invalidate(2, $inputStreamConnected = $$value));
	component_subscribe($$self, siteMode, $$value => $$invalidate(3, $siteMode = $$value));
	let engine;

	let handleAudioOnOff = () => {
		if ($engineStatus === "running") {
			set_store_value(engineStatus, $engineStatus = "paused", $engineStatus);
			engine.hush();
		} else {
			set_store_value(engineStatus, $engineStatus = "running", $engineStatus);
			engine.play();
		}
	};

	let handleLessAudio = () => {
		if ($engineStatus === "paused") return; else {
			if (!engine) {
				engine = new Engine$1();
			}

			set_store_value(engineSoundLevel, $engineSoundLevel = engine.less(), $engineSoundLevel);
		}
	};

	let handleMoreAudio = () => {
		if ($engineStatus === "paused") return; else {
			if (!engine) {
				engine = new Engine$1();
			}

			set_store_value(engineSoundLevel, $engineSoundLevel = engine.more(), $engineSoundLevel);
		}
	};

	let handleConnectInputStream = async () => {
		if (!engine) {
			engine = new Engine$1();
		}

		if (!$inputStreamConnected) {
			set_store_value(inputStreamConnected, $inputStreamConnected = await engine.connectMediaStream(), $inputStreamConnected);
		} else {
			set_store_value(inputStreamConnected, $inputStreamConnected = await engine.disconnectMediaStream(), $inputStreamConnected);
		}
	};

	onMount(async () => {
		engine = new Engine$1();
	});

	onDestroy(() => {
		engine = null;
	});

	return [
		$engineStatus,
		$engineSoundLevel,
		$inputStreamConnected,
		$siteMode,
		handleAudioOnOff,
		handleLessAudio,
		handleMoreAudio,
		handleConnectInputStream
	];
}

class Engine_1 extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-18uk55n-style")) add_css$J();
		init(this, options, instance$U, create_fragment$U, safe_not_equal, {});
	}
}

/* src/components/settings/group/SiteMode.svelte generated by Svelte v3.31.0 */

function add_css$K() {
	var style = element("style");
	style.id = "svelte-1qobigl-style";
	style.textContent = ".icon-container.svelte-1qobigl{width:10px;height:10px}.button-dark.svelte-1qobigl{width:2.5em;height:2.5em;padding:0.2em 0.2em 0.8em 0.8em;display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:red;line-height:1.3;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;margin-right:5px;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;-webkit-box-shadow:2px 2px 3px rgb(0, 0, 0), -0.5px -0.5px 3px #ffffff61;-moz-box-shadow:2px 2px 3px rgb(0, 0, 0), -0.5px -0.5px 3px #ffffff61;box-shadow:2px 2px 3px rgb(0, 0, 0), -0.5px -0.5px 3px #ffffff61}.button-dark.svelte-1qobigl:hover{width:2.5em;height:2.5em;padding:0.2em 0.2em 0.8em 0.8em;display:block;font-size:medium;font-family:sans-serif;font-weight:500;cursor:pointer;color:red;line-height:1.3;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;margin-right:5px;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:linear-gradient(rgba(16, 16, 16, 1), rgba(16, 16, 16, 0.08));background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;-webkit-box-shadow:2px 2px 5px rgba(0,0,0),-0.5px -0.5px 3px rgb(34, 34, 34);-moz-box-shadow:2px 2px 5px rgba(0,0,0), -0.5px -0.5px 3px rgb(34, 34, 34);box-shadow:2px 2px 3px rgb(0, 0, 0), -1px -1px 3px #ffffff61}.button-dark.svelte-1qobigl:active{width:2.5em;height:2.5em;padding:0.2em 0.2em 0.8em 0.8em;display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:red;line-height:1.3;max-width:100%;box-sizing:border-box;margin-right:5px;text-align:left;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-size:.65em auto, 100%;box-shadow:-1px -1px 3px rgba(16, 16, 16, 0.4), 0.5px 0.5px 0.5px rgba(16, 16, 16, 0.04)}.button-light.svelte-1qobigl{width:2.5em;height:2.5em;padding:0.2em 0.2em 0.8em 0.8em;display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:red;line-height:1.3;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;margin-right:5px;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-moz-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-webkit-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0)}.button-light.svelte-1qobigl:hover{width:2.5em;height:2.5em;padding:0.2em 0.2em 0.8em 0.8em;display:block;font-size:medium;font-family:sans-serif;font-weight:500;cursor:pointer;color:red;line-height:1.3;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;margin-right:5px;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:linear-gradient(rgba(16, 16, 16, 1), rgba(16, 16, 16, 0.08));background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-moz-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-webkit-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0)}.button-light.svelte-1qobigl:active{width:2.5em;height:2.5em;padding:0.2em 0.2em 0.8em 0.8em;display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:red;line-height:1.3;max-width:100%;box-sizing:border-box;margin-right:5px;text-align:left;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-size:.65em auto, 100%;box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-moz-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-webkit-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0)}path.svelte-1qobigl{transform:translate(-3px, -5px)\n  }.dark-mode.svelte-1qobigl{fill:rgb(133, 130, 130);enable-background:new 0 0 512 512;padding-bottom:3px;width:16px}.light-mode.svelte-1qobigl{fill:#000;enable-background:new 0 0 512 512;padding-bottom:3px;width:16px}";
	append(document.head, style);
}

// (291:37) 
function create_if_block_1$e(ctx) {
	let svg;
	let g;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			g = svg_element("g");
			path = svg_element("path");
			attr(path, "d", "M179,0C75,34.9,0,132.9,0,248.8C0,394.2,117.8,512,263.2,512c115.8,0,213.9-75,248.8-179c-26.3,8.5-54.6,14.5-84.3,14.5\n            c-145.4,0-263.2-117.8-263.2-263.2C164.5,54.6,169.8,26.3,179,0z");
			attr(path, "class", "svelte-1qobigl");
			attr(svg, "version", "1.1");
			attr(svg, "id", "Layer_1");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "x", "0px");
			attr(svg, "y", "0px");
			attr(svg, "viewBox", "0 0 512 512");
			attr(svg, "class", "light-mode svelte-1qobigl");
			attr(svg, "xml:space", "preserve");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, g);
			append(g, path);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (262:4) {#if $siteMode === 'dark' }
function create_if_block$o(ctx) {
	let svg;
	let g;
	let path0;
	let path1;
	let path2;
	let path3;
	let path4;
	let path5;
	let path6;
	let path7;
	let path8;

	return {
		c() {
			svg = svg_element("svg");
			g = svg_element("g");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			path3 = svg_element("path");
			path4 = svg_element("path");
			path5 = svg_element("path");
			path6 = svg_element("path");
			path7 = svg_element("path");
			path8 = svg_element("path");
			attr(path0, "d", "M256,149.3v21.3c23.6,0,44.8,9.5,60.3,25c15.5,15.5,25,36.7,25,60.3c0,23.6-9.5,44.8-25,60.3c-15.5,15.5-36.7,25-60.3,25\n            c-23.6,0-44.8-9.5-60.3-25c-15.5-15.5-25-36.7-25-60.3c0-23.6,9.5-44.8,25-60.3c15.5-15.5,36.7-25,60.3-25V149.3V128\n            c-70.7,0-128,57.3-128,128c0,70.7,57.3,128,128,128c70.7,0,128-57.3,128-128c0-70.7-57.3-128-128-128V149.3z");
			attr(path0, "class", "svelte-1qobigl");
			attr(path1, "d", "M234.7,21.3V64c0,11.8,9.6,21.3,21.3,21.3s21.3-9.6,21.3-21.3V21.3C277.3,9.6,267.8,0,256,0S234.7,9.6,234.7,21.3");
			attr(path1, "class", "svelte-1qobigl");
			attr(path2, "d", "M234.7,448v42.7c0,11.8,9.6,21.3,21.3,21.3s21.3-9.6,21.3-21.3V448c0-11.8-9.6-21.3-21.3-21.3S234.7,436.2,234.7,448");
			attr(path2, "class", "svelte-1qobigl");
			attr(path3, "d", "M74.9,105.1l30.3,30.3c8.3,8.3,21.8,8.3,30.2,0c8.3-8.3,8.3-21.8,0-30.2l-30.3-30.3c-8.3-8.3-21.8-8.3-30.2,0\n            S66.6,96.8,74.9,105.1");
			attr(path3, "class", "svelte-1qobigl");
			attr(path4, "d", "M376.6,406.8l30.3,30.3c8.3,8.3,21.8,8.3,30.2,0c8.3-8.3,8.3-21.8,0-30.2l-30.3-30.3c-8.3-8.3-21.8-8.3-30.2,0\n            S368.3,398.4,376.6,406.8");
			attr(path4, "class", "svelte-1qobigl");
			attr(path5, "d", "M21.3,277.3H64c11.8,0,21.3-9.6,21.3-21.3c0-11.8-9.6-21.3-21.3-21.3H21.3C9.6,234.7,0,244.2,0,256\n            C0,267.8,9.6,277.3,21.3,277.3");
			attr(path5, "class", "svelte-1qobigl");
			attr(path6, "d", "M448,277.3h42.7c11.8,0,21.3-9.6,21.3-21.3c0-11.8-9.6-21.3-21.3-21.3H448c-11.8,0-21.3,9.6-21.3,21.3\n            C426.7,267.8,436.2,277.3,448,277.3");
			attr(path6, "class", "svelte-1qobigl");
			attr(path7, "d", "M105.1,437.1l30.3-30.3c8.3-8.3,8.3-21.8,0-30.2s-21.8-8.3-30.2,0l-30.3,30.3c-8.3,8.3-8.3,21.8,0,30.2\n            C83.3,445.4,96.8,445.4,105.1,437.1");
			attr(path7, "class", "svelte-1qobigl");
			attr(path8, "d", "M406.8,135.4l30.3-30.3c8.3-8.3,8.3-21.8,0-30.2s-21.8-8.3-30.2,0l-30.3,30.3c-8.3,8.3-8.3,21.8,0,30.2\n            C384.9,143.7,398.4,143.7,406.8,135.4");
			attr(path8, "class", "svelte-1qobigl");
			attr(svg, "version", "1.1");
			attr(svg, "id", "Layer_1");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "x", "0px");
			attr(svg, "y", "0px");
			attr(svg, "viewBox", "0 0 512 512");
			attr(svg, "class", "dark-mode svelte-1qobigl");
			attr(svg, "xml:space", "preserve");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, g);
			append(g, path0);
			append(g, path1);
			append(g, path2);
			append(g, path3);
			append(g, path4);
			append(g, path5);
			append(g, path6);
			append(g, path7);
			append(g, path8);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function create_fragment$V(ctx) {
	let button;
	let div;
	let button_class_value;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (/*$siteMode*/ ctx[0] === "dark") return create_if_block$o;
		if (/*$siteMode*/ ctx[0] === "light") return create_if_block_1$e;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	return {
		c() {
			button = element("button");
			div = element("div");
			if (if_block) if_block.c();
			attr(div, "class", "icon-container svelte-1qobigl");

			attr(button, "class", button_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[0] === "dark"
			? "button-dark"
			: "button-light") + " svelte-1qobigl"));

			attr(button, "title", "dark mode");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, div);
			if (if_block) if_block.m(div, null);

			if (!mounted) {
				dispose = listen(button, "click", /*handleClick*/ ctx[1]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div, null);
				}
			}

			if (dirty & /*$siteMode*/ 1 && button_class_value !== (button_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[0] === "dark"
			? "button-dark"
			: "button-light") + " svelte-1qobigl"))) {
				attr(button, "class", button_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(button);

			if (if_block) {
				if_block.d();
			}

			mounted = false;
			dispose();
		}
	};
}

function instance$V($$self, $$props, $$invalidate) {
	let $siteMode;
	component_subscribe($$self, siteMode, $$value => $$invalidate(0, $siteMode = $$value));

	let handleClick = () => {
		$siteMode === "dark"
		? set_store_value(siteMode, $siteMode = "light", $siteMode)
		: set_store_value(siteMode, $siteMode = "dark", $siteMode);
	};

	return [$siteMode, handleClick];
}

class SiteMode extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1qobigl-style")) add_css$K();
		init(this, options, instance$V, create_fragment$V, safe_not_equal, {});
	}
}

/* src/components/settings/group/Screen.svelte generated by Svelte v3.31.0 */

const { document: document_1$2 } = globals;

function add_css$L() {
	var style = element("style");
	style.id = "svelte-17xnhew-style";
	style.textContent = ".button-dark.svelte-17xnhew{width:2.5em;height:2.5em;display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:red;line-height:1.3;padding:0.6em 1em 0.5em 0.8em;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;margin-right:5px;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;-webkit-box-shadow:2px 2px 3px rgb(0, 0, 0), -0.5px -0.5px 3px #ffffff61;-moz-box-shadow:2px 2px 3px rgb(0, 0, 0), -0.5px -0.5px 3px #ffffff61;box-shadow:2px 2px 3px rgb(0, 0, 0), -0.5px -0.5px 3px #ffffff61}.button-dark.svelte-17xnhew:hover{width:2.5em;height:2.5em;display:block;font-size:medium;font-family:sans-serif;font-weight:500;cursor:pointer;color:red;line-height:1.3;padding:0.6em 1em 0.5em 0.8em;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;margin-right:5px;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:linear-gradient(rgba(16, 16, 16, 1), rgba(16, 16, 16, 0.08));background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;-webkit-box-shadow:2px 2px 5px rgba(0,0,0),-0.5px -0.5px 3px rgb(34, 34, 34);-moz-box-shadow:2px 2px 5px rgba(0,0,0), -0.5px -0.5px 3px rgb(34, 34, 34);box-shadow:2px 2px 3px rgb(0, 0, 0), -1px -1px 3px #ffffff61}.button-dark.svelte-17xnhew:active{width:2.5em;height:2.5em;display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:red;line-height:1.3;padding:0.6em 1em 0.5em 0.8em;max-width:100%;box-sizing:border-box;margin-right:5px;text-align:left;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-size:.65em auto, 100%;box-shadow:-1px -1px 3px rgba(16, 16, 16, 0.4), 0.5px 0.5px 0.5px rgba(16, 16, 16, 0.04)}.button-light.svelte-17xnhew{width:2.5em;height:2.5em;display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:black;line-height:1.3;padding:0.6em 1em 0.5em 0.8em;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-moz-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-webkit-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0)}.button-light.svelte-17xnhew:active{width:2.5em;height:2.5em;display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:black;line-height:1.3;padding:0.6em 1em 0.5em 0.8em;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-moz-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-webkit-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0)\n  }.button-light.svelte-17xnhew:disabled{width:2.5em;height:2.5em;display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:#888;line-height:1.3;padding:0.6em 1em 0.5em 0.8em;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-moz-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-webkit-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0)\n  }path.svelte-17xnhew{transform:translate(-3px, -5px)\n  }.fullscreen.svelte-17xnhew{fill:rgb(133, 130, 130);enable-background:new 0 0 512 512;width:16px}.sidebar.svelte-17xnhew{fill:rgb(133, 130, 130);enable-background:new 0 0 512 512;width:16px}.st0.svelte-17xnhew{fill-rule:evenodd;clip-rule:evenodd}";
	append(document_1$2.head, style);
}

function create_fragment$W(ctx) {
	let button0;
	let svg0;
	let style;
	let g0;
	let path0;
	let rect;
	let button0_class_value;
	let t;
	let button1;
	let svg1;
	let g1;
	let path1;
	let button1_class_value;
	let mounted;
	let dispose;

	return {
		c() {
			button0 = element("button");
			svg0 = svg_element("svg");
			style = svg_element("style");
			g0 = svg_element("g");
			path0 = svg_element("path");
			rect = svg_element("rect");
			t = space();
			button1 = element("button");
			svg1 = svg_element("svg");
			g1 = svg_element("g");
			path1 = svg_element("path");
			attr(style, "type", "text/css");
			attr(path0, "class", "st0 svelte-17xnhew");
			attr(path0, "d", "M448,64H64c-17.7,0-32,14.3-32,32v320c0,17.7,14.3,32,32,32h384c17.7,0,32-14.3,32-32V96\n            C480,78.3,465.7,64,448,64z M64,32C28.6,32,0,60.6,0,96v320c0,35.4,28.6,64,64,64h384c35.4,0,64-28.6,64-64V96\n            c0-35.4-28.6-64-64-64H64z");
			attr(rect, "x", "128");
			attr(rect, "y", "64");
			attr(rect, "class", "st0 svelte-17xnhew");
			attr(rect, "width", "32");
			attr(rect, "height", "384");
			attr(svg0, "version", "1.1");
			attr(svg0, "id", "Layer_1");
			attr(svg0, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg0, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg0, "x", "0px");
			attr(svg0, "y", "0px");
			attr(svg0, "viewBox", "0 0 512 512");
			attr(svg0, "class", "sidebar svelte-17xnhew");
			attr(svg0, "xml:space", "preserve");

			attr(button0, "class", button0_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[0] === "dark"
			? "button-dark"
			: "button-light") + " svelte-17xnhew"));

			attr(button0, "title", "sidebar visibility");
			attr(path1, "class", "st0 svelte-17xnhew");
			attr(path1, "d", "M48,32c-8.8,0-16,7.2-16,16v128c0,8.8-7.2,16-16,16s-16-7.2-16-16V48C0,21.5,21.5,0,48,0h128\n        c8.8,0,16,7.2,16,16s-7.2,16-16,16H48z M320,16c0-8.8,7.2-16,16-16h128c26.5,0,48,21.5,48,48v128c0,8.8-7.2,16-16,16s-16-7.2-16-16\n        V48c0-8.8-7.2-16-16-16H336C327.2,32,320,24.8,320,16z M16,320c8.8,0,16,7.2,16,16v128c0,8.8,7.2,16,16,16h128c8.8,0,16,7.2,16,16\n        s-7.2,16-16,16H48c-26.5,0-48-21.5-48-48V336C0,327.2,7.2,320,16,320z M496,320c8.8,0,16,7.2,16,16v128c0,26.5-21.5,48-48,48H336\n        c-8.8,0-16-7.2-16-16s7.2-16,16-16h128c8.8,0,16-7.2,16-16V336C480,327.2,487.2,320,496,320z");
			attr(svg1, "version", "1.1");
			attr(svg1, "id", "Layer_1");
			attr(svg1, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg1, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg1, "x", "0px");
			attr(svg1, "y", "20px");
			attr(svg1, "viewBox", "0 0 512 512");
			attr(svg1, "class", "fullscreen svelte-17xnhew");
			attr(svg1, "xml:space", "preserve");

			attr(button1, "class", button1_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[0] === "dark"
			? "button-dark"
			: "button-light") + " svelte-17xnhew"));

			attr(button1, "title", "fullscreen mode");
		},
		m(target, anchor) {
			insert(target, button0, anchor);
			append(button0, svg0);
			append(svg0, style);
			append(svg0, g0);
			append(g0, path0);
			append(g0, rect);
			insert(target, t, anchor);
			insert(target, button1, anchor);
			append(button1, svg1);
			append(svg1, g1);
			append(g1, path1);

			if (!mounted) {
				dispose = [
					listen(button0, "click", /*handleClickSideBar*/ ctx[1]),
					listen(button1, "click", /*handleClickFullScreen*/ ctx[2])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*$siteMode*/ 1 && button0_class_value !== (button0_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[0] === "dark"
			? "button-dark"
			: "button-light") + " svelte-17xnhew"))) {
				attr(button0, "class", button0_class_value);
			}

			if (dirty & /*$siteMode*/ 1 && button1_class_value !== (button1_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[0] === "dark"
			? "button-dark"
			: "button-light") + " svelte-17xnhew"))) {
				attr(button1, "class", button1_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(button0);
			if (detaching) detach(t);
			if (detaching) detach(button1);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$W($$self, $$props, $$invalidate) {
	let $sideBarVisible;
	let $fullScreen;
	let $siteMode;
	component_subscribe($$self, sideBarVisible, $$value => $$invalidate(3, $sideBarVisible = $$value));
	component_subscribe($$self, fullScreen, $$value => $$invalidate(4, $fullScreen = $$value));
	component_subscribe($$self, siteMode, $$value => $$invalidate(0, $siteMode = $$value));

	let handleClickSideBar = () => {
		set_store_value(sideBarVisible, $sideBarVisible = !$sideBarVisible, $sideBarVisible);
	};

	const isFullScreen = () => {
		return (document.fullscreenElement && document.fullscreenElement !== null || document.webkitFullscreenElement && document.webkitFullscreenElement !== null || document.mozFullScreenElement && document.mozFullScreenElement !== null || document.msFullscreenElement && document.msFullscreenElement !== null) !== undefined;
	};

	const exitHandler = () => {
		if (!document.fullscreenElement && !document.webkitIsFullScreen && !document.mozFullScreen && !document.msFullscreenElement) {
			set_store_value(fullScreen, $fullScreen = set_store_value(sideBarVisible, $sideBarVisible = !isFullScreen(), $sideBarVisible), $fullScreen);
		}
	};

	const setFullScreenMode = (el, mode) => {
		if (!mode) {
			if (el.requestFullscreen) {
				el.requestFullscreen().catch(() => {
					
				});

				document.addEventListener("fullscreenchange", exitHandler, false);
			} else if (el.webkitRequestFullscreen) {
				el.webkitRequestFullscreen();
				document.addEventListener("webkitfullscreenchange", exitHandler, false);
			} else if (el.mozRequestFullScreen) {
				el.mozRequestFullScreen();
				document.addEventListener("mozfullscreenchange", exitHandler, false);
			} else if (root.msRequestFullscreen) {
				el.msRequestFullscreen();
				document.addEventListener("MSFullscreenChange", exitHandler, false);
			}
		} else {
			if (document.exitFullscreen) {
				document.exitFullscreen().catch(() => {
					
				});
			} else if (document.webkitExitFullscreen) {
				document.webkitExitFullscreen();
			} else if (document.mozCancelFullScreen) {
				document.mozCancelFullScreen();
			} else if (document.msExitFullscreen) {
				document.msExitFullscreen();
			}
		}

		set_store_value(sideBarVisible, $sideBarVisible = set_store_value(fullScreen, $fullScreen = mode, $fullScreen), $sideBarVisible);
	};

	const handleClickFullScreen = () => {
		setFullScreenMode(document.querySelector("#routify-app"), isFullScreen());
	};

	return [$siteMode, handleClickSideBar, handleClickFullScreen];
}

class Screen extends SvelteComponent {
	constructor(options) {
		super();
		if (!document_1$2.getElementById("svelte-17xnhew-style")) add_css$L();
		init(this, options, instance$W, create_fragment$W, safe_not_equal, {});
	}
}

/* src/components/settings/group/Environment.svelte generated by Svelte v3.31.0 */

function add_css$M() {
	var style = element("style");
	style.id = "svelte-14h7pxd-style";
	style.textContent = ".icon-container.svelte-14h7pxd{width:10px;height:10px}.button-dark.svelte-14h7pxd{width:2.5em;height:2.5em;padding:0.2em 0.2em 0.8em 0.8em;display:block;font-family:sans-serif;font-weight:400;cursor:pointer;color:red;line-height:1.3;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;margin-right:5px;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;-webkit-box-shadow:2px 2px 3px rgb(0, 0, 0), -0.5px -0.5px 3px #ffffff61;-moz-box-shadow:2px 2px 3px rgb(0, 0, 0), -0.5px -0.5px 3px #ffffff61;box-shadow:2px 2px 3px rgb(0, 0, 0), -0.5px -0.5px 3px #ffffff61}.button-dark.svelte-14h7pxd:hover{width:2.5em;height:2.5em;padding:0.2em 0.2em 0.8em 0.8em;display:block;font-family:sans-serif;font-weight:500;cursor:pointer;color:red;line-height:1.3;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;margin-right:5px;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:linear-gradient(rgba(16, 16, 16, 1), rgba(16, 16, 16, 0.08));background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;-webkit-box-shadow:2px 2px 5px rgba(0,0,0),-0.5px -0.5px 3px rgb(34, 34, 34);-moz-box-shadow:2px 2px 5px rgba(0,0,0), -0.5px -0.5px 3px rgb(34, 34, 34);box-shadow:2px 2px 3px rgb(0, 0, 0), -1px -1px 3px #ffffff61}.button-dark.svelte-14h7pxd:active{width:2.5em;height:2.5em;padding:0.2em 0.2em 0.8em 0.8em;display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:red;line-height:1.3;max-width:100%;box-sizing:border-box;margin-right:5px;text-align:left;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-size:.65em auto, 100%;box-shadow:-1px -1px 3px rgba(16, 16, 16, 0.4), 0.5px 0.5px 0.5px rgba(16, 16, 16, 0.04)}.combobox-dark.svelte-14h7pxd{width:10em;height:2.5em;padding:0.2em 0.2em 0.8em 0.8em;margin-right:5px;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:#ccc;line-height:1.3;padding:0.7em 1em 0.7em 1em;box-sizing:border-box;border:0 solid #333;text-align:left;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;-webkit-box-shadow:2px 2px 3px rgb(0, 0, 0), -0.5px -0.5px 3px #ffffff61;-moz-box-shadow:2px 2px 3px rgb(0, 0, 0), -0.5px -0.5px 3px #ffffff61;box-shadow:2px 2px 3px rgb(0, 0, 0), -0.5px -0.5px 3px #ffffff61}.combobox-dark.svelte-14h7pxd:hover{width:10em;height:2.5em;padding:0.2em 0.2em 0.8em 0.8em;margin-right:5px;font-family:sans-serif;font-weight:500;cursor:pointer;color:#fff;line-height:1.3;padding:0.7em 1em 0.7em 1em;box-sizing:border-box;border:0 solid #333;text-align:left;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:linear-gradient(rgba(16, 16, 16, 1), rgba(16, 16, 16, 0.2));background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;-webkit-box-shadow:5px 5px 20px -5px rgba(0,0,0,0.75), -5px -5px 20px rgba(255, 255, 255, 0.954);-moz-box-shadow:5px 5px 20px -5px rgba(0,0,0,0.75), -5px -5px 20px rgba(255, 255, 255, 0.954);box-shadow:2px 2px 3px rgb(0, 0, 0), -1px -1px 3px #ffffff61}.combobox-dark.svelte-14h7pxd:focus{width:10em;height:2.5em;padding:0.2em 0.2em 0.8em 0.8em;margin-right:5px;font-size:medium;font-family:sans-serif;font-weight:500;cursor:pointer;line-height:1.3;padding:0.7em 1em 0.7em 1em;box-sizing:border-box;border:0 solid #333;text-align:left;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;-webkit-box-shadow:5px 5px 20px -5px rgba(0,0,0,0.75), -5px -5px 20px rgba(255, 255, 255, 0.954);-moz-box-shadow:5px 5px 20px -5px rgba(0,0,0,0.75), -5px -5px 20px rgba(255, 255, 255, 0.954);box-shadow:2px 2px 3px rgb(0, 0, 0), -1px -1px 3px #ffffff61}.light-mode.svelte-14h7pxd{fill:rgb(133, 130, 130);enable-background:new 0 0 512 512;padding-bottom:3px;width:15px}.dark-mode.svelte-14h7pxd{fill:rgb(133, 130, 130);enable-background:new 0 0 512 512;padding-bottom:3px;width:15px}.button-light.svelte-14h7pxd{width:2.5em;height:2.5em;display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:black;line-height:1.3;padding:0.7em 1em 0.7em 1em;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-moz-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-webkit-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0)}.button-light.svelte-14h7pxd:active{width:2.5em;height:2.5em;display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:black;line-height:1.3;padding:0.7em 1em 0.7em 1em;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-moz-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-webkit-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0)\n  }.button-light.svelte-14h7pxd:disabled{width:2.5em;height:2.5em;display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:#888;line-height:1.3;padding:0.7em 1em 0.7em 1em;width:8em;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-moz-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-webkit-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0)\n  }";
	append(document.head, style);
}

function get_each_context$f(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[25] = list[i];
	return child_ctx;
}

// (492:37) 
function create_if_block_11(ctx) {
	let svg;
	let g;
	let path0;
	let path1;
	let path2;

	return {
		c() {
			svg = svg_element("svg");
			g = svg_element("g");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M23.3,94.7v280.5c0,46.8,77.5,82.1,180.3,82.1c9.8,0,19.6-0.3,29.1-1c6.7-0.5,11.8-6.3,11.4-13.1\n          c-0.5-6.7-6.3-11.7-13.1-11.4c-9,0.6-18.2,1-27.4,1c-91.8,0-155.8-30.4-155.8-57.6v-51c30.7,24.1,87.7,39.6,155.8,39.6\n          c6.2,0,12.5-0.1,18.6-0.4c6.8-0.3,12-6,11.7-12.8c-0.3-6.8-6-12-12.8-11.7c-5.8,0.3-11.7,0.4-17.5,0.4\n          c-91.8,0-155.8-30.4-155.8-57.6v-50.9c30.7,24.1,87.7,39.6,155.8,39.6c102.8,0,180.3-35.3,180.3-82.1V94.7\n          c0-46.8-77.5-82.1-180.3-82.1C100.8,12.5,23.3,47.9,23.3,94.7z M203.6,245.8c-91.8,0-155.8-30.4-155.8-57.6v-51\n          c30.7,24.1,87.7,39.6,155.8,39.6c68.1,0,125.1-15.5,155.8-39.6v51C359.5,215.5,295.5,245.8,203.6,245.8z M359.5,94.7\n          c0,27.3-64,57.6-155.8,57.6S47.8,121.9,47.8,94.7S111.8,37,203.6,37S359.5,67.4,359.5,94.7z");
			attr(path1, "d", "M371.7,265.5c-64.5,0-117,52.5-117,117s52.5,117,117,117c64.5,0,117-52.5,117-117S436.2,265.5,371.7,265.5z M371.7,475\n          c-51,0-92.5-41.5-92.5-92.5s41.5-92.5,92.5-92.5s92.5,41.5,92.5,92.5S422.7,475,371.7,475z");
			attr(path2, "d", "M380,327c-4.7-4.3-11.8-4.3-16.5,0l-32.6,29.8c-5,4.6-5.4,12.3-0.8,17.3c4.6,5,12.3,5.4,17.3,0.8l12.1-11.1V427\n          c0,6.8,5.5,12.3,12.3,12.3S384,433.8,384,427v-63.2l12.1,11.1c2.3,2.1,5.3,3.2,8.3,3.2c3.3,0,6.6-1.3,9.1-4\n          c4.6-5,4.2-12.7-0.8-17.3L380,327z");
			attr(svg, "version", "1.1");
			attr(svg, "id", "Artwork");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "x", "0px");
			attr(svg, "y", "0px");
			attr(svg, "viewBox", "0 0 512 512");
			set_style(svg, "enable-background", "new 0 0 512 512");
			set_style(svg, "width", "20px");
			set_style(svg, "margin-left", "5px");
			set_style(svg, "margin-right", "5px");
			attr(svg, "enable-background", "new 0 0 512 512");
			attr(svg, "xml:space", "preserve");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, g);
			append(g, path0);
			append(g, path1);
			append(g, path2);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (465:4) {#if $siteMode === 'dark' }
function create_if_block_10(ctx) {
	let svg;
	let g;
	let path0;
	let path1;
	let path2;

	return {
		c() {
			svg = svg_element("svg");
			g = svg_element("g");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M23.3,94.7v280.5c0,46.8,77.5,82.1,180.3,82.1c9.8,0,19.6-0.3,29.1-1c6.7-0.5,11.8-6.3,11.4-13.1\n          c-0.5-6.7-6.3-11.7-13.1-11.4c-9,0.6-18.2,1-27.4,1c-91.8,0-155.8-30.4-155.8-57.6v-51c30.7,24.1,87.7,39.6,155.8,39.6\n          c6.2,0,12.5-0.1,18.6-0.4c6.8-0.3,12-6,11.7-12.8c-0.3-6.8-6-12-12.8-11.7c-5.8,0.3-11.7,0.4-17.5,0.4\n          c-91.8,0-155.8-30.4-155.8-57.6v-50.9c30.7,24.1,87.7,39.6,155.8,39.6c102.8,0,180.3-35.3,180.3-82.1V94.7\n          c0-46.8-77.5-82.1-180.3-82.1C100.8,12.5,23.3,47.9,23.3,94.7z M203.6,245.8c-91.8,0-155.8-30.4-155.8-57.6v-51\n          c30.7,24.1,87.7,39.6,155.8,39.6c68.1,0,125.1-15.5,155.8-39.6v51C359.5,215.5,295.5,245.8,203.6,245.8z M359.5,94.7\n          c0,27.3-64,57.6-155.8,57.6S47.8,121.9,47.8,94.7S111.8,37,203.6,37S359.5,67.4,359.5,94.7z");
			attr(path1, "d", "M371.7,265.5c-64.5,0-117,52.5-117,117s52.5,117,117,117c64.5,0,117-52.5,117-117S436.2,265.5,371.7,265.5z M371.7,475\n          c-51,0-92.5-41.5-92.5-92.5s41.5-92.5,92.5-92.5s92.5,41.5,92.5,92.5S422.7,475,371.7,475z");
			attr(path2, "d", "M380,327c-4.7-4.3-11.8-4.3-16.5,0l-32.6,29.8c-5,4.6-5.4,12.3-0.8,17.3c4.6,5,12.3,5.4,17.3,0.8l12.1-11.1V427\n          c0,6.8,5.5,12.3,12.3,12.3S384,433.8,384,427v-63.2l12.1,11.1c2.3,2.1,5.3,3.2,8.3,3.2c3.3,0,6.6-1.3,9.1-4\n          c4.6-5,4.2-12.7-0.8-17.3L380,327z");
			attr(svg, "version", "1.1");
			attr(svg, "id", "Artwork");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "x", "0px");
			attr(svg, "y", "0px");
			attr(svg, "viewBox", "0 0 512 512");
			set_style(svg, "enable-background", "new 0 0 512 512");
			set_style(svg, "width", "20px");
			attr(svg, "class", "light-mode svelte-14h7pxd");
			attr(svg, "enable-background", "new 0 0 512 512");
			attr(svg, "xml:space", "preserve");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, g);
			append(g, path0);
			append(g, path1);
			append(g, path2);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (520:2) {#each $loadEnvironmentOptions as loadEnvironmentOption }
function create_each_block$f(ctx) {
	let option;
	let t0_value = /*loadEnvironmentOption*/ ctx[25].text + "";
	let t0;
	let t1;
	let option_disabled_value;
	let option_value_value;

	return {
		c() {
			option = element("option");
			t0 = text$1(t0_value);
			t1 = space();
			option.disabled = option_disabled_value = /*loadEnvironmentOption*/ ctx[25].disabled;
			option.__value = option_value_value = /*loadEnvironmentOption*/ ctx[25];
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t0);
			append(option, t1);
		},
		p(ctx, dirty) {
			if (dirty & /*$loadEnvironmentOptions*/ 2 && t0_value !== (t0_value = /*loadEnvironmentOption*/ ctx[25].text + "")) set_data(t0, t0_value);

			if (dirty & /*$loadEnvironmentOptions*/ 2 && option_disabled_value !== (option_disabled_value = /*loadEnvironmentOption*/ ctx[25].disabled)) {
				option.disabled = option_disabled_value;
			}

			if (dirty & /*$loadEnvironmentOptions*/ 2 && option_value_value !== (option_value_value = /*loadEnvironmentOption*/ ctx[25])) {
				option.__value = option_value_value;
				option.value = option.__value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (557:37) 
function create_if_block_9(ctx) {
	let svg;
	let g;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			g = svg_element("g");
			path = svg_element("path");
			attr(path, "id", "XMLID_9_");
			attr(path, "d", "M466.5,0h-381L0,83.6v382.8C0,491.6,20.4,512,45.5,512h420.9c25.1,0,45.5-20.4,45.5-45.5V45.5\n            C512,20.4,491.6,0,466.5,0z M392.1,29.7v60.4H151.5V29.7H392.1z M91.1,481.3v-30.7h330.8v29.7H91.1V481.3z M482.3,465.5\n            c0,8.4-6.5,14.9-14.9,14.9h-15.8V420H61.3v60.4H46.5c-8.4,0-14.9-6.5-14.9-14.9V95.7l67.8-66h22.3v90.1h301.1V29.7h45.5\n            c8.4,0,14.9,6.5,14.9,14.9v420.9H482.3z M256.5,150.5c-57.6,0-105,47.4-105,105s47.4,105,105,105s105-47.4,105-105\n            S314.1,150.5,256.5,150.5z M256.5,330.8c-41.8,0-75.3-33.5-75.3-75.3s33.5-75.3,75.3-75.3s75.3,33.5,75.3,75.3\n            S298.3,330.8,256.5,330.8z");
			attr(svg, "version", "1.1");
			attr(svg, "id", "Layer_1");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "x", "0px");
			attr(svg, "y", "0px");
			set_style(svg, "enable-background", "new 0 0 512 512");
			set_style(svg, "width", "15px");
			attr(svg, "viewBox", "0 0 512 512");
			attr(svg, "xml:space", "preserve");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, g);
			append(g, path);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (537:4) {#if $siteMode === 'dark' }
function create_if_block_8(ctx) {
	let svg;
	let g;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			g = svg_element("g");
			path = svg_element("path");
			attr(path, "id", "XMLID_9_");
			attr(path, "d", "M466.5,0h-381L0,83.6v382.8C0,491.6,20.4,512,45.5,512h420.9c25.1,0,45.5-20.4,45.5-45.5V45.5\n            C512,20.4,491.6,0,466.5,0z M392.1,29.7v60.4H151.5V29.7H392.1z M91.1,481.3v-30.7h330.8v29.7H91.1V481.3z M482.3,465.5\n            c0,8.4-6.5,14.9-14.9,14.9h-15.8V420H61.3v60.4H46.5c-8.4,0-14.9-6.5-14.9-14.9V95.7l67.8-66h22.3v90.1h301.1V29.7h45.5\n            c8.4,0,14.9,6.5,14.9,14.9v420.9H482.3z M256.5,150.5c-57.6,0-105,47.4-105,105s47.4,105,105,105s105-47.4,105-105\n            S314.1,150.5,256.5,150.5z M256.5,330.8c-41.8,0-75.3-33.5-75.3-75.3s33.5-75.3,75.3-75.3s75.3,33.5,75.3,75.3\n            S298.3,330.8,256.5,330.8z");
			attr(g, "id", "XMLID_1_");
			attr(svg, "version", "1.1");
			attr(svg, "id", "Layer_1");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "x", "0px");
			attr(svg, "y", "0px");
			attr(svg, "viewBox", "0 0 512 512");
			set_style(svg, "enable-background", "new 0 0 512 512");
			set_style(svg, "width", "15px");
			attr(svg, "class", "light-mode svelte-14h7pxd");
			attr(svg, "xml:space", "preserve");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, g);
			append(g, path);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (610:37) 
function create_if_block_7(ctx) {
	let svg;
	let g;
	let path;
	let polygon;

	return {
		c() {
			svg = svg_element("svg");
			g = svg_element("g");
			path = svg_element("path");
			polygon = svg_element("polygon");
			attr(path, "d", "M317.667,214.42l5.667-86.42h20.951V38h-98.384V0H132.669v38H34.285v90h20.951l20,305h140.571\n            c23.578,24.635,56.766,40,93.478,40c71.368,0,129.43-58.062,129.43-129.43C438.715,275.019,385.143,218.755,317.667,214.42z\n            M162.669,30h53.232v8h-53.232V30z M64.285,68h250v30h-250V68z M103.334,403L85.301,128H293.27l-5.77,87.985\n            c-61.031,10.388-107.645,63.642-107.645,127.586c0,21.411,5.231,41.622,14.475,59.43H103.334z M309.285,443\n            c-54.826,0-99.43-44.604-99.43-99.43s44.604-99.429,99.43-99.429s99.43,44.604,99.43,99.429S364.111,443,309.285,443z");
			attr(polygon, "points", "342.248,289.395 309.285,322.358 276.322,289.395 255.109,310.608 288.072,343.571 255.109,376.533\n            276.322,397.746 309.285,364.783 342.248,397.746 363.461,376.533 330.498,343.571 363.461,310.608 \t");
			attr(svg, "version", "1.1");
			attr(svg, "id", "Layer_1");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "x", "0px");
			attr(svg, "y", "0px");
			attr(svg, "viewBox", "0 0 512 512");
			set_style(svg, "enable-background", "new 0 0 512 512");
			set_style(svg, "width", "19px");
			attr(svg, "xml:space", "preserve");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, g);
			append(g, path);
			append(g, polygon);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (589:4) {#if $siteMode === 'dark' }
function create_if_block_6(ctx) {
	let svg;
	let g;
	let path;
	let polygon;

	return {
		c() {
			svg = svg_element("svg");
			g = svg_element("g");
			path = svg_element("path");
			polygon = svg_element("polygon");
			attr(path, "d", "M317.667,214.42l5.667-86.42h20.951V38h-98.384V0H132.669v38H34.285v90h20.951l20,305h140.571\n            c23.578,24.635,56.766,40,93.478,40c71.368,0,129.43-58.062,129.43-129.43C438.715,275.019,385.143,218.755,317.667,214.42z\n            M162.669,30h53.232v8h-53.232V30z M64.285,68h250v30h-250V68z M103.334,403L85.301,128H293.27l-5.77,87.985\n            c-61.031,10.388-107.645,63.642-107.645,127.586c0,21.411,5.231,41.622,14.475,59.43H103.334z M309.285,443\n            c-54.826,0-99.43-44.604-99.43-99.43s44.604-99.429,99.43-99.429s99.43,44.604,99.43,99.429S364.111,443,309.285,443z");
			attr(polygon, "points", "342.248,289.395 309.285,322.358 276.322,289.395 255.109,310.608 288.072,343.571 255.109,376.533\n            276.322,397.746 309.285,364.783 342.248,397.746 363.461,376.533 330.498,343.571 363.461,310.608 \t");
			attr(svg, "version", "1.1");
			attr(svg, "id", "Layer_1");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "x", "0px");
			attr(svg, "y", "0px");
			attr(svg, "viewBox", "0 0 512 512");
			attr(svg, "class", "light-mode svelte-14h7pxd");
			set_style(svg, "enable-background", "new 0 0 512 512");
			set_style(svg, "width", "19px");
			attr(svg, "xml:space", "preserve");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, g);
			append(g, path);
			append(g, polygon);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (675:37) 
function create_if_block_5$2(ctx) {
	let svg;
	let g;
	let path0;
	let path1;

	return {
		c() {
			svg = svg_element("svg");
			g = svg_element("g");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M266.052,350.322c-5.167-4.324-12.869-3.655-17.198,1.507l-8.104,9.654v-151.01\n            c0-6.739-5.461-12.205-12.205-12.205c-6.744,0-12.205,5.466-12.205,12.205v151.016l-8.099-9.654\n            c-4.329-5.156-12.02-5.842-17.198-1.507c-5.162,4.335-5.836,12.037-1.501,17.198l29.659,35.343\n            c0.098,0.114,0.223,0.196,0.326,0.31c0.354,0.397,0.745,0.767,1.153,1.104c0.239,0.207,0.468,0.413,0.718,0.598\n            c0.451,0.326,0.93,0.604,1.43,0.865c0.245,0.136,0.479,0.283,0.734,0.402c0.571,0.256,1.175,0.441,1.784,0.604\n            c0.212,0.054,0.408,0.141,0.626,0.19c0.832,0.179,1.692,0.283,2.573,0.283c0.887,0,1.746-0.103,2.578-0.283\n            c0.218-0.049,0.413-0.136,0.626-0.19c0.609-0.169,1.213-0.348,1.784-0.604c0.256-0.12,0.49-0.267,0.734-0.402\n            c0.495-0.261,0.979-0.544,1.43-0.865c0.25-0.185,0.479-0.392,0.718-0.598c0.408-0.343,0.794-0.707,1.153-1.104\n            c0.103-0.114,0.228-0.19,0.326-0.31l29.659-35.343C271.888,362.364,271.214,354.662,266.052,350.322z");
			attr(path1, "d", "M339.36,105.412c-4.525,0-9.051,0.337-13.538,0.984c-17.497-18.275-39.52-31.128-64.23-37.388\n            c-0.326-0.087-0.653-0.158-0.979-0.218l-15.936-3.013c-19.499-24.383-49.011-38.71-80.52-38.71\n            c-54.179,0-98.735,42.006-102.798,95.167C24.661,136.083,0,171.018,0,211.196c0,52.503,42.724,95.227,95.238,95.227\n            c13.549,0,26.809-2.861,38.987-8.349c14.99,14.462,33.026,25.031,52.607,31.275v-34.696c-13.957-6.113-26.575-15.219-36.937-27.38\n            c-3.193-3.747-7.762-5.722-12.396-5.722c-3.013,0-6.059,0.832-8.757,2.567c-9.975,6.38-21.566,9.747-33.51,9.747\n            c-34.565,0-62.685-28.115-62.685-62.674c0-28.881,20.456-54.538,48.636-61.026c7.68-1.762,12.994-8.779,12.608-16.654\n            l-0.109-1.741c-0.038-0.533-0.087-1.071-0.087-1.61c0-38.9,31.65-70.545,70.55-70.545c23.524,0,45.422,11.672,58.579,31.22\n            c3.024,4.498,8.088,7.19,13.5,7.19c0.022,0,0.049,0,0.076,0l3.671-0.016l14.082,2.654c20.989,5.428,39.406,17.133,53.27,33.88\n            c4.03,4.873,10.497,6.967,16.6,5.379c5.069-1.311,10.258-1.969,15.42-1.969c34.402,0,62.392,27.989,62.392,62.392\n            s-27.989,62.381-62.392,62.381c-5.162,0-10.351-0.658-15.414-1.969c-6.113-1.588-12.581,0.517-16.6,5.374\n            c-10.182,12.287-22.969,21.593-37.089,27.94v35.055c20.93-6.842,40.042-18.634,55.565-34.832\n            c4.493,0.653,9.018,0.984,13.543,0.984c52.351,0,94.944-42.588,94.944-94.933C434.304,148,391.711,105.412,339.36,105.412z");
			attr(svg, "version", "1.1");
			attr(svg, "id", "Capa_1");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "x", "0px");
			attr(svg, "y", "0px");
			attr(svg, "viewBox", "0 0 512 512");
			attr(svg, "class", "light-mode svelte-14h7pxd");
			set_style(svg, "enable-background", "new 0 0 512 512");
			set_style(svg, "width", "24px");
			attr(svg, "xml:space", "preserve");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, g);
			append(g, path0);
			append(g, path1);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (640:4) {#if $siteMode === 'dark' }
function create_if_block_4$3(ctx) {
	let svg;
	let g;
	let path0;
	let path1;

	return {
		c() {
			svg = svg_element("svg");
			g = svg_element("g");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M266.052,350.322c-5.167-4.324-12.869-3.655-17.198,1.507l-8.104,9.654v-151.01\n          c0-6.739-5.461-12.205-12.205-12.205c-6.744,0-12.205,5.466-12.205,12.205v151.016l-8.099-9.654\n          c-4.329-5.156-12.02-5.842-17.198-1.507c-5.162,4.335-5.836,12.037-1.501,17.198l29.659,35.343\n          c0.098,0.114,0.223,0.196,0.326,0.31c0.354,0.397,0.745,0.767,1.153,1.104c0.239,0.207,0.468,0.413,0.718,0.598\n          c0.451,0.326,0.93,0.604,1.43,0.865c0.245,0.136,0.479,0.283,0.734,0.402c0.571,0.256,1.175,0.441,1.784,0.604\n          c0.212,0.054,0.408,0.141,0.626,0.19c0.832,0.179,1.692,0.283,2.573,0.283c0.887,0,1.746-0.103,2.578-0.283\n          c0.218-0.049,0.413-0.136,0.626-0.19c0.609-0.169,1.213-0.348,1.784-0.604c0.256-0.12,0.49-0.267,0.734-0.402\n          c0.495-0.261,0.979-0.544,1.43-0.865c0.25-0.185,0.479-0.392,0.718-0.598c0.408-0.343,0.794-0.707,1.153-1.104\n          c0.103-0.114,0.228-0.19,0.326-0.31l29.659-35.343C271.888,362.364,271.214,354.662,266.052,350.322z");
			attr(path1, "d", "M339.36,105.412c-4.525,0-9.051,0.337-13.538,0.984c-17.497-18.275-39.52-31.128-64.23-37.388\n          c-0.326-0.087-0.653-0.158-0.979-0.218l-15.936-3.013c-19.499-24.383-49.011-38.71-80.52-38.71\n          c-54.179,0-98.735,42.006-102.798,95.167C24.661,136.083,0,171.018,0,211.196c0,52.503,42.724,95.227,95.238,95.227\n          c13.549,0,26.809-2.861,38.987-8.349c14.99,14.462,33.026,25.031,52.607,31.275v-34.696c-13.957-6.113-26.575-15.219-36.937-27.38\n          c-3.193-3.747-7.762-5.722-12.396-5.722c-3.013,0-6.059,0.832-8.757,2.567c-9.975,6.38-21.566,9.747-33.51,9.747\n          c-34.565,0-62.685-28.115-62.685-62.674c0-28.881,20.456-54.538,48.636-61.026c7.68-1.762,12.994-8.779,12.608-16.654\n          l-0.109-1.741c-0.038-0.533-0.087-1.071-0.087-1.61c0-38.9,31.65-70.545,70.55-70.545c23.524,0,45.422,11.672,58.579,31.22\n          c3.024,4.498,8.088,7.19,13.5,7.19c0.022,0,0.049,0,0.076,0l3.671-0.016l14.082,2.654c20.989,5.428,39.406,17.133,53.27,33.88\n          c4.03,4.873,10.497,6.967,16.6,5.379c5.069-1.311,10.258-1.969,15.42-1.969c34.402,0,62.392,27.989,62.392,62.392\n          s-27.989,62.381-62.392,62.381c-5.162,0-10.351-0.658-15.414-1.969c-6.113-1.588-12.581,0.517-16.6,5.374\n          c-10.182,12.287-22.969,21.593-37.089,27.94v35.055c20.93-6.842,40.042-18.634,55.565-34.832\n          c4.493,0.653,9.018,0.984,13.543,0.984c52.351,0,94.944-42.588,94.944-94.933C434.304,148,391.711,105.412,339.36,105.412z");
			attr(svg, "version", "1.1");
			attr(svg, "id", "Capa_1");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "x", "0px");
			attr(svg, "y", "0px");
			attr(svg, "viewBox", "0 0 512 512");
			attr(svg, "class", "light-mode svelte-14h7pxd");
			set_style(svg, "enable-background", "new 0 0 512 512");
			set_style(svg, "width", "24px");
			attr(svg, "xml:space", "preserve");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, g);
			append(g, path0);
			append(g, path1);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (754:37) 
function create_if_block_3$3(ctx) {
	let svg;
	let g1;
	let g0;
	let path0;
	let path1;

	return {
		c() {
			svg = svg_element("svg");
			g1 = svg_element("g");
			g0 = svg_element("g");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M50.283,44.999l-5.453-6.498c-0.016-0.019-0.038-0.032-0.055-0.051c-0.086-0.095-0.178-0.18-0.278-0.259\n              c-0.012-0.01-0.022-0.021-0.036-0.029c-0.377-0.286-0.841-0.463-1.351-0.463c-0.511,0-0.974,0.177-1.351,0.463\n              c-0.013,0.009-0.023,0.019-0.037,0.029c-0.099,0.079-0.192,0.164-0.276,0.259c-0.017,0.019-0.039,0.032-0.056,0.051l-5.453,6.498\n              c-0.797,0.948-0.673,2.364,0.276,3.162c0.95,0.795,2.366,0.672,3.162-0.277l1.49-1.774v27.765c0,1.239,1.004,2.244,2.244,2.244\n              c1.239,0,2.243-1.005,2.243-2.244V46.108l1.49,1.775c0.443,0.528,1.08,0.801,1.721,0.801c0.508,0,1.021-0.172,1.44-0.523\n              C50.956,47.362,51.08,45.947,50.283,44.999z");
			attr(path1, "d", "M62.393,18.133c-0.832,0-1.664,0.062-2.489,0.181c-3.216-3.36-7.267-5.723-11.81-6.874\n              c-0.059-0.016-0.119-0.029-0.18-0.04l-2.93-0.554c-3.584-4.482-9.01-7.117-14.803-7.117c-9.962,0-18.153,7.723-18.9,17.496\n              C4.534,23.771,0,30.194,0,37.582c0,9.653,7.854,17.507,17.509,17.507c2.491,0,4.93-0.525,7.169-1.535\n              c3.032,2.925,6.745,4.978,10.766,6.062v-6.255c-3.007-1.095-5.712-2.921-7.884-5.47c-0.587-0.69-1.427-1.053-2.279-1.053\n              c-0.554,0-1.114,0.153-1.611,0.473c-1.834,1.173-3.964,1.792-6.161,1.792c-6.355,0-11.525-5.169-11.525-11.523\n              c0-5.31,3.761-10.027,8.943-11.219c1.412-0.325,2.389-1.615,2.318-3.063l-0.02-0.32c-0.006-0.098-0.015-0.197-0.015-0.297\n              c0-7.152,5.819-12.97,12.971-12.97c4.325,0,8.351,2.146,10.77,5.74c0.557,0.827,1.486,1.322,2.482,1.322c0.004,0,0.008,0,0.014,0\n              l0.675-0.003l2.589,0.488c3.858,0.998,7.245,3.15,9.794,6.229c0.741,0.896,1.931,1.281,3.052,0.989\n              c0.933-0.241,1.887-0.362,2.836-0.362c6.324,0,11.471,5.146,11.471,11.471c0,6.325-5.146,11.468-11.471,11.468\n              c-0.949,0-1.903-0.121-2.834-0.361c-1.125-0.292-2.313,0.095-3.053,0.988c-1.605,1.938-3.564,3.474-5.726,4.613v6.59\n              c3.419-1.297,6.542-3.332,9.123-6.025c0.825,0.12,1.657,0.182,2.489,0.182c9.625,0,17.455-7.83,17.455-17.455\n              C79.848,25.963,72.016,18.133,62.393,18.133z");
			attr(svg, "version", "1.1");
			attr(svg, "id", "Capa_1");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "x", "0px");
			attr(svg, "y", "0px");
			attr(svg, "viewBox", "0 0 512 512");
			set_style(svg, "enable-background", "new 0 0 512 512");
			set_style(svg, "width", "130px");
			attr(svg, "xml:space", "preserve");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, g1);
			append(g1, g0);
			append(g0, path0);
			append(g0, path1);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (721:4) {#if $siteMode === 'dark' }
function create_if_block_2$5(ctx) {
	let svg;
	let g;
	let path0;
	let path1;

	return {
		c() {
			svg = svg_element("svg");
			g = svg_element("g");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M50.283,44.999l-5.453-6.498c-0.016-0.019-0.038-0.032-0.055-0.051c-0.086-0.095-0.178-0.18-0.278-0.259\n            c-0.012-0.01-0.022-0.021-0.036-0.029c-0.377-0.286-0.841-0.463-1.351-0.463c-0.511,0-0.974,0.177-1.351,0.463\n            c-0.013,0.009-0.023,0.019-0.037,0.029c-0.099,0.079-0.192,0.164-0.276,0.259c-0.017,0.019-0.039,0.032-0.056,0.051l-5.453,6.498\n            c-0.797,0.948-0.673,2.364,0.276,3.162c0.95,0.795,2.366,0.672,3.162-0.277l1.49-1.774v27.765c0,1.239,1.004,2.244,2.244,2.244\n            c1.239,0,2.243-1.005,2.243-2.244V46.108l1.49,1.775c0.443,0.528,1.08,0.801,1.721,0.801c0.508,0,1.021-0.172,1.44-0.523\n            C50.956,47.362,51.08,45.947,50.283,44.999z");
			attr(path1, "d", "M62.393,18.133c-0.832,0-1.664,0.062-2.489,0.181c-3.216-3.36-7.267-5.723-11.81-6.874\n            c-0.059-0.016-0.119-0.029-0.18-0.04l-2.93-0.554c-3.584-4.482-9.01-7.117-14.803-7.117c-9.962,0-18.153,7.723-18.9,17.496\n            C4.534,23.771,0,30.194,0,37.582c0,9.653,7.854,17.507,17.509,17.507c2.491,0,4.93-0.525,7.169-1.535\n            c3.032,2.925,6.745,4.978,10.766,6.062v-6.255c-3.007-1.095-5.712-2.921-7.884-5.47c-0.587-0.69-1.427-1.053-2.279-1.053\n            c-0.554,0-1.114,0.153-1.611,0.473c-1.834,1.173-3.964,1.792-6.161,1.792c-6.355,0-11.525-5.169-11.525-11.523\n            c0-5.31,3.761-10.027,8.943-11.219c1.412-0.325,2.389-1.615,2.318-3.063l-0.02-0.32c-0.006-0.098-0.015-0.197-0.015-0.297\n            c0-7.152,5.819-12.97,12.971-12.97c4.325,0,8.351,2.146,10.77,5.74c0.557,0.827,1.486,1.322,2.482,1.322c0.004,0,0.008,0,0.014,0\n            l0.675-0.003l2.589,0.488c3.858,0.998,7.245,3.15,9.794,6.229c0.741,0.896,1.931,1.281,3.052,0.989\n            c0.933-0.241,1.887-0.362,2.836-0.362c6.324,0,11.471,5.146,11.471,11.471c0,6.325-5.146,11.468-11.471,11.468\n            c-0.949,0-1.903-0.121-2.834-0.361c-1.125-0.292-2.313,0.095-3.053,0.988c-1.605,1.938-3.564,3.474-5.726,4.613v6.59\n            c3.419-1.297,6.542-3.332,9.123-6.025c0.825,0.12,1.657,0.182,2.489,0.182c9.625,0,17.455-7.83,17.455-17.455\n            C79.848,25.963,72.016,18.133,62.393,18.133z");
			attr(svg, "version", "1.1");
			attr(svg, "id", "Capa_1");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "x", "0px");
			attr(svg, "y", "0px");
			attr(svg, "viewBox", "0 0 512 512");
			attr(svg, "class", "light-mode svelte-14h7pxd");
			set_style(svg, "enable-background", "new 0 0 512 512");
			set_style(svg, "width", "130px");
			attr(svg, "xml:space", "preserve");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, g);
			append(g, path0);
			append(g, path1);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (824:37) 
function create_if_block_1$f(ctx) {
	let svg;
	let g;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			g = svg_element("g");
			path = svg_element("path");
			attr(path, "d", "M404.9,0c45.1,0,81.5,37.1,81.5,82.8c0,45.7-36.5,82.8-81.5,82.8c-24.2,0-46-10.7-60.9-27.7l-160.9,88.1\n            c3.6,9.3,5.5,19.5,5.5,30.1c0,13.9-3.3,26.9-9.3,38.4l153.8,95.4c13.8-25.8,40.7-43.4,71.7-43.4c45.1,0,81.5,37.1,81.5,82.8\n            c0,45.7-36.5,82.8-81.5,82.8s-81.5-37.1-81.5-82.8l0.1-3.5L156.3,322.1c-13.7,10.5-30.7,16.7-49.1,16.7\n            c-45.1,0-81.5-37.1-81.5-82.8s36.5-82.8,81.5-82.8c21.8,0,41.6,8.7,56.3,22.9l163.4-89.4c-2.2-7.5-3.4-15.5-3.4-23.8\n            C323.4,37.1,359.8,0,404.9,0z M404.9,382.1c-25.4,0-46.1,21-46.1,47.1c0,26,20.7,47.1,46.1,47.1s46.1-21,46.1-47.1\n            C451,403.1,430.3,382.1,404.9,382.1z M107.1,208.9c-25.4,0-46.1,21-46.1,47.1s20.7,47.1,46.1,47.1s46.1-21,46.1-47.1\n            S132.5,208.9,107.1,208.9z M404.9,35.7c-25.4,0-46.1,21-46.1,47.1c0,26,20.7,47.1,46.1,47.1s46.1-21,46.1-47.1\n            C451,56.8,430.3,35.7,404.9,35.7z");
			attr(svg, "version", "1.1");
			attr(svg, "id", "Layer_1");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "x", "0px");
			attr(svg, "y", "0px");
			attr(svg, "viewBox", "0 0 512 512");
			set_style(svg, "enable-background", "new 0 0 512 512");
			set_style(svg, "width", "15px");
			attr(svg, "class", "light-mode svelte-14h7pxd");
			attr(svg, "xml:space", "preserve");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, g);
			append(g, path);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (799:4) {#if $siteMode === 'dark' }
function create_if_block$p(ctx) {
	let svg;
	let g;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			g = svg_element("g");
			path = svg_element("path");
			attr(path, "class", "st0");
			attr(path, "d", "M404.9,0c45.1,0,81.5,37.1,81.5,82.8c0,45.7-36.5,82.8-81.5,82.8c-24.2,0-46-10.7-60.9-27.7l-160.9,88.1\n            c3.6,9.3,5.5,19.5,5.5,30.1c0,13.9-3.3,26.9-9.3,38.4l153.8,95.4c13.8-25.8,40.7-43.4,71.7-43.4c45.1,0,81.5,37.1,81.5,82.8\n            c0,45.7-36.5,82.8-81.5,82.8s-81.5-37.1-81.5-82.8l0.1-3.5L156.3,322.1c-13.7,10.5-30.7,16.7-49.1,16.7\n            c-45.1,0-81.5-37.1-81.5-82.8s36.5-82.8,81.5-82.8c21.8,0,41.6,8.7,56.3,22.9l163.4-89.4c-2.2-7.5-3.4-15.5-3.4-23.8\n            C323.4,37.1,359.8,0,404.9,0z M404.9,382.1c-25.4,0-46.1,21-46.1,47.1c0,26,20.7,47.1,46.1,47.1s46.1-21,46.1-47.1\n            C451,403.1,430.3,382.1,404.9,382.1z M107.1,208.9c-25.4,0-46.1,21-46.1,47.1s20.7,47.1,46.1,47.1s46.1-21,46.1-47.1\n            S132.5,208.9,107.1,208.9z M404.9,35.7c-25.4,0-46.1,21-46.1,47.1c0,26,20.7,47.1,46.1,47.1s46.1-21,46.1-47.1\n            C451,56.8,430.3,35.7,404.9,35.7z");
			attr(svg, "version", "1.1");
			attr(svg, "id", "Layer_1");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "x", "0px");
			attr(svg, "y", "0px");
			attr(svg, "viewBox", "0 0 512 512");
			attr(svg, "class", "dark-mode svelte-14h7pxd");
			set_style(svg, "enable-background", "new 0 0 512 512");
			attr(svg, "xml:space", "preserve");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, g);
			append(g, path);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function create_fragment$X(ctx) {
	let select;
	let div0;
	let t0;
	let select_style_value;
	let select_cursor_value;
	let t1;
	let button0;
	let div1;
	let button0_class_value;
	let button0_style_value;
	let t2;
	let button1;
	let div2;
	let button1_class_value;
	let button1_style_value;
	let t3;
	let button2;
	let div3;
	let button2_class_value;
	let t4;
	let button3;
	let div4;
	let button3_class_value;
	let button3_style_value;
	let t5;
	let button4;
	let div5;
	let button4_class_value;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (/*$siteMode*/ ctx[4] === "dark") return create_if_block_10;
		if (/*$siteMode*/ ctx[4] === "light") return create_if_block_11;
	}

	let current_block_type = select_block_type(ctx);
	let if_block0 = current_block_type && current_block_type(ctx);
	let each_value = /*$loadEnvironmentOptions*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$f(get_each_context$f(ctx, each_value, i));
	}

	function select_block_type_1(ctx, dirty) {
		if (/*$siteMode*/ ctx[4] === "dark") return create_if_block_8;
		if (/*$siteMode*/ ctx[4] === "light") return create_if_block_9;
	}

	let current_block_type_1 = select_block_type_1(ctx);
	let if_block1 = current_block_type_1 && current_block_type_1(ctx);

	function select_block_type_2(ctx, dirty) {
		if (/*$siteMode*/ ctx[4] === "dark") return create_if_block_6;
		if (/*$siteMode*/ ctx[4] === "light") return create_if_block_7;
	}

	let current_block_type_2 = select_block_type_2(ctx);
	let if_block2 = current_block_type_2 && current_block_type_2(ctx);

	function select_block_type_3(ctx, dirty) {
		if (/*$siteMode*/ ctx[4] === "dark") return create_if_block_4$3;
		if (/*$siteMode*/ ctx[4] === "light") return create_if_block_5$2;
	}

	let current_block_type_3 = select_block_type_3(ctx);
	let if_block3 = current_block_type_3 && current_block_type_3(ctx);

	function select_block_type_4(ctx, dirty) {
		if (/*$siteMode*/ ctx[4] === "dark") return create_if_block_2$5;
		if (/*$siteMode*/ ctx[4] === "light") return create_if_block_3$3;
	}

	let current_block_type_4 = select_block_type_4(ctx);
	let if_block4 = current_block_type_4 && current_block_type_4(ctx);

	function select_block_type_5(ctx, dirty) {
		if (/*$siteMode*/ ctx[4] === "dark") return create_if_block$p;
		if (/*$siteMode*/ ctx[4] === "light") return create_if_block_1$f;
	}

	let current_block_type_5 = select_block_type_5(ctx);
	let if_block5 = current_block_type_5 && current_block_type_5(ctx);

	return {
		c() {
			select = element("select");
			div0 = element("div");
			if (if_block0) if_block0.c();
			t0 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			button0 = element("button");
			div1 = element("div");
			if (if_block1) if_block1.c();
			t2 = space();
			button1 = element("button");
			div2 = element("div");
			if (if_block2) if_block2.c();
			t3 = space();
			button2 = element("button");
			div3 = element("div");
			if (if_block3) if_block3.c();
			t4 = space();
			button3 = element("button");
			div4 = element("div");
			if (if_block4) if_block4.c();
			t5 = space();
			button4 = element("button");
			div5 = element("div");
			if (if_block5) if_block5.c();
			attr(div0, "class", "icon-container svelte-14h7pxd");
			set_style(div0, "z-index", "1000");
			attr(select, "class", "combobox-dark svelte-14h7pxd");
			attr(select, "title", "load environment");

			attr(select, "style", select_style_value = "" + ((/*$isActive*/ ctx[3]("/playground")
			? `visibility:visible;`
			: `visibility:collapse`) + "; ! important;"));

			attr(select, "cursor", select_cursor_value = /*func*/ ctx[11]);
			if (/*$selectedLoadEnvironmentOption*/ ctx[0] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[12].call(select));
			attr(div1, "class", "icon-container svelte-14h7pxd");

			attr(button0, "class", button0_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[4] === "dark"
			? "button-dark"
			: "button-light") + " svelte-14h7pxd"));

			attr(button0, "title", "save environment");

			attr(button0, "style", button0_style_value = "" + ((/*$isActive*/ ctx[3]("/playground")
			? `visibility:visible;`
			: `visibility:collapse`) + "; margin-left: 2px;"));

			attr(div2, "class", "icon-container svelte-14h7pxd");

			attr(button1, "class", button1_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[4] === "dark"
			? "button-dark"
			: "button-light") + " svelte-14h7pxd"));

			attr(button1, "title", "clear environment");

			attr(button1, "style", button1_style_value = /*$isActive*/ ctx[3]("/playground")
			? `visibility:visible;`
			: `visibility:collapse`);

			attr(div3, "class", "icon-container svelte-14h7pxd");

			attr(button2, "class", button2_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[4] === "dark"
			? "button-dark"
			: "button-light") + " svelte-14h7pxd"));

			attr(button2, "title", "download environment");
			set_style(button2, "padding", "0.2em 0.4em 0.8em 0.6em ! important");
			attr(div4, "class", "icon-container svelte-14h7pxd");

			attr(button3, "class", button3_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[4] === "dark"
			? "button-dark"
			: "button-light") + " svelte-14h7pxd"));

			attr(button3, "title", "upload environment");

			attr(button3, "style", button3_style_value = "" + ((/*$isActive*/ ctx[3]("/playground")
			? `visibility:visible;`
			: `visibility:collapse`) + "; padding: 0.2em 0.4em 0.8em 0.6em ! important;"));

			attr(div5, "class", "icon-container svelte-14h7pxd");

			attr(button4, "class", button4_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[4] === "dark"
			? "button-dark"
			: "button-light") + " svelte-14h7pxd"));

			attr(button4, "title", "share environment");
			set_style(button4, "padding", "0.25em 0.3em 0.75em 0.7em");
		},
		m(target, anchor) {
			insert(target, select, anchor);
			append(select, div0);
			if (if_block0) if_block0.m(div0, null);
			append(div0, t0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(select, null);
			}

			select_option(select, /*$selectedLoadEnvironmentOption*/ ctx[0]);
			insert(target, t1, anchor);
			insert(target, button0, anchor);
			append(button0, div1);
			if (if_block1) if_block1.m(div1, null);
			insert(target, t2, anchor);
			insert(target, button1, anchor);
			append(button1, div2);
			if (if_block2) if_block2.m(div2, null);
			insert(target, t3, anchor);
			insert(target, button2, anchor);
			append(button2, div3);
			if (if_block3) if_block3.m(div3, null);
			insert(target, t4, anchor);
			insert(target, button3, anchor);
			append(button3, div4);
			if (if_block4) if_block4.m(div4, null);
			insert(target, t5, anchor);
			insert(target, button4, anchor);
			append(button4, div5);
			if (if_block5) if_block5.m(div5, null);

			if (!mounted) {
				dispose = [
					listen(select, "change", /*select_change_handler*/ ctx[12]),
					listen(select, "change", /*change_handler*/ ctx[13]),
					listen(select, "click", /*click_handler*/ ctx[14]),
					listen(button0, "click", /*click_handler_1*/ ctx[15]),
					listen(button1, "click", /*click_handler_2*/ ctx[16]),
					listen(button2, "click", /*click_handler_3*/ ctx[17]),
					listen(button3, "click", /*click_handler_4*/ ctx[18]),
					listen(button4, "click", /*handleClick*/ ctx[5])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
				if (if_block0) if_block0.d(1);
				if_block0 = current_block_type && current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(div0, t0);
				}
			}

			if (dirty & /*$loadEnvironmentOptions*/ 2) {
				each_value = /*$loadEnvironmentOptions*/ ctx[1];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$f(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$f(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(select, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*$isActive*/ 8 && select_style_value !== (select_style_value = "" + ((/*$isActive*/ ctx[3]("/playground")
			? `visibility:visible;`
			: `visibility:collapse`) + "; ! important;"))) {
				attr(select, "style", select_style_value);
			}

			if (dirty & /*$isLoadEnvironmentOptionsDisabled*/ 4 && select_cursor_value !== (select_cursor_value = /*func*/ ctx[11])) {
				attr(select, "cursor", select_cursor_value);
			}

			if (dirty & /*$selectedLoadEnvironmentOption, $loadEnvironmentOptions*/ 3) {
				select_option(select, /*$selectedLoadEnvironmentOption*/ ctx[0]);
			}

			if (current_block_type_1 !== (current_block_type_1 = select_block_type_1(ctx))) {
				if (if_block1) if_block1.d(1);
				if_block1 = current_block_type_1 && current_block_type_1(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(div1, null);
				}
			}

			if (dirty & /*$siteMode*/ 16 && button0_class_value !== (button0_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[4] === "dark"
			? "button-dark"
			: "button-light") + " svelte-14h7pxd"))) {
				attr(button0, "class", button0_class_value);
			}

			if (dirty & /*$isActive*/ 8 && button0_style_value !== (button0_style_value = "" + ((/*$isActive*/ ctx[3]("/playground")
			? `visibility:visible;`
			: `visibility:collapse`) + "; margin-left: 2px;"))) {
				attr(button0, "style", button0_style_value);
			}

			if (current_block_type_2 !== (current_block_type_2 = select_block_type_2(ctx))) {
				if (if_block2) if_block2.d(1);
				if_block2 = current_block_type_2 && current_block_type_2(ctx);

				if (if_block2) {
					if_block2.c();
					if_block2.m(div2, null);
				}
			}

			if (dirty & /*$siteMode*/ 16 && button1_class_value !== (button1_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[4] === "dark"
			? "button-dark"
			: "button-light") + " svelte-14h7pxd"))) {
				attr(button1, "class", button1_class_value);
			}

			if (dirty & /*$isActive*/ 8 && button1_style_value !== (button1_style_value = /*$isActive*/ ctx[3]("/playground")
			? `visibility:visible;`
			: `visibility:collapse`)) {
				attr(button1, "style", button1_style_value);
			}

			if (current_block_type_3 !== (current_block_type_3 = select_block_type_3(ctx))) {
				if (if_block3) if_block3.d(1);
				if_block3 = current_block_type_3 && current_block_type_3(ctx);

				if (if_block3) {
					if_block3.c();
					if_block3.m(div3, null);
				}
			}

			if (dirty & /*$siteMode*/ 16 && button2_class_value !== (button2_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[4] === "dark"
			? "button-dark"
			: "button-light") + " svelte-14h7pxd"))) {
				attr(button2, "class", button2_class_value);
			}

			if (current_block_type_4 !== (current_block_type_4 = select_block_type_4(ctx))) {
				if (if_block4) if_block4.d(1);
				if_block4 = current_block_type_4 && current_block_type_4(ctx);

				if (if_block4) {
					if_block4.c();
					if_block4.m(div4, null);
				}
			}

			if (dirty & /*$siteMode*/ 16 && button3_class_value !== (button3_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[4] === "dark"
			? "button-dark"
			: "button-light") + " svelte-14h7pxd"))) {
				attr(button3, "class", button3_class_value);
			}

			if (dirty & /*$isActive*/ 8 && button3_style_value !== (button3_style_value = "" + ((/*$isActive*/ ctx[3]("/playground")
			? `visibility:visible;`
			: `visibility:collapse`) + "; padding: 0.2em 0.4em 0.8em 0.6em ! important;"))) {
				attr(button3, "style", button3_style_value);
			}

			if (current_block_type_5 !== (current_block_type_5 = select_block_type_5(ctx))) {
				if (if_block5) if_block5.d(1);
				if_block5 = current_block_type_5 && current_block_type_5(ctx);

				if (if_block5) {
					if_block5.c();
					if_block5.m(div5, null);
				}
			}

			if (dirty & /*$siteMode*/ 16 && button4_class_value !== (button4_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[4] === "dark"
			? "button-dark"
			: "button-light") + " svelte-14h7pxd"))) {
				attr(button4, "class", button4_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(select);

			if (if_block0) {
				if_block0.d();
			}

			destroy_each(each_blocks, detaching);
			if (detaching) detach(t1);
			if (detaching) detach(button0);

			if (if_block1) {
				if_block1.d();
			}

			if (detaching) detach(t2);
			if (detaching) detach(button1);

			if (if_block2) {
				if_block2.d();
			}

			if (detaching) detach(t3);
			if (detaching) detach(button2);

			if (if_block3) {
				if_block3.d();
			}

			if (detaching) detach(t4);
			if (detaching) detach(button3);

			if (if_block4) {
				if_block4.d();
			}

			if (detaching) detach(t5);
			if (detaching) detach(button4);

			if (if_block5) {
				if_block5.d();
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$X($$self, $$props, $$invalidate) {
	let $items;
	let $isUploadOverlayVisible;
	let $isSaveOverlayVisible;
	let $isDeleteOverlayVisible;
	let $selectedLoadEnvironmentOption;
	let $loadEnvironmentOptions;
	let $isLoadEnvironmentOptionsDisabled;
	let $isActive;
	let $siteMode;
	component_subscribe($$self, items, $$value => $$invalidate(20, $items = $$value));
	component_subscribe($$self, isUploadOverlayVisible, $$value => $$invalidate(21, $isUploadOverlayVisible = $$value));
	component_subscribe($$self, isSaveOverlayVisible, $$value => $$invalidate(22, $isSaveOverlayVisible = $$value));
	component_subscribe($$self, isDeleteOverlayVisible, $$value => $$invalidate(23, $isDeleteOverlayVisible = $$value));
	component_subscribe($$self, selectedLoadEnvironmentOption, $$value => $$invalidate(0, $selectedLoadEnvironmentOption = $$value));
	component_subscribe($$self, loadEnvironmentOptions, $$value => $$invalidate(1, $loadEnvironmentOptions = $$value));
	component_subscribe($$self, isLoadEnvironmentOptionsDisabled, $$value => $$invalidate(2, $isLoadEnvironmentOptionsDisabled = $$value));
	component_subscribe($$self, isActive, $$value => $$invalidate(3, $isActive = $$value));
	component_subscribe($$self, siteMode, $$value => $$invalidate(4, $siteMode = $$value));
	let engine;

	let handleClick = () => {
		window.localStorage["tutorial-" + new Date(Date.now()).toISOString()] = JSON.stringify($items);
	};

	function resetEnvironment() {
		set_store_value(isUploadOverlayVisible, $isUploadOverlayVisible = false, $isUploadOverlayVisible);
		set_store_value(isSaveOverlayVisible, $isSaveOverlayVisible = false, $isSaveOverlayVisible);
		set_store_value(isDeleteOverlayVisible, $isDeleteOverlayVisible = true, $isDeleteOverlayVisible);
	}

	function storeEnvironment() {
		set_store_value(isUploadOverlayVisible, $isUploadOverlayVisible = false, $isUploadOverlayVisible);
		set_store_value(isSaveOverlayVisible, $isSaveOverlayVisible = true, $isSaveOverlayVisible);
		set_store_value(isDeleteOverlayVisible, $isDeleteOverlayVisible = false, $isDeleteOverlayVisible);

		// Add to playground history, e.g.
		// Key  playground-2020-03-02T15:48:31.080Z,
		// Value: [{"2":{"fixed":false,"resizable":true,"draggable":true,"min":{"w":1,"h":1},"max":{}, ...]
		loadEnvironmentSnapshotEntries();
	}

	function loadEnvironment() {
		// Retrieve item, hydrate JSON into grid-items
		let json = window.localStorage.getItem($selectedLoadEnvironmentOption.content);

		set_store_value(items, $items = JSON.parse(json).map(item => hydrateJSONcomponent(item)), $items);

		// .map(item => assignNewID(item))
		// Reset UI
		set_store_value(selectedLoadEnvironmentOption, $selectedLoadEnvironmentOption = $loadEnvironmentOptions[0], $selectedLoadEnvironmentOption);

		set_store_value(isLoadEnvironmentOptionsDisabled, $isLoadEnvironmentOptionsDisabled = true, $isLoadEnvironmentOptionsDisabled);
	}

	function uploadEnvironment() {
		set_store_value(isUploadOverlayVisible, $isUploadOverlayVisible = true, $isUploadOverlayVisible);
		set_store_value(isSaveOverlayVisible, $isSaveOverlayVisible = false, $isSaveOverlayVisible);
		set_store_value(isDeleteOverlayVisible, $isDeleteOverlayVisible = false, $isDeleteOverlayVisible);
	}

	function downloadEnvironment() {
		let timestamp = new Date(Date.now()).toISOString();

		// Create blob from current playround state and filtered content from editor widgets
		const blob = toBlob($items.reduce(
			(acc, val) => {
				if (val.data && val.data.content) acc.push({
					path: `${val.data.type}` + `.txt`, // if 'val' is an editor type (liveCode, grammar or model), `data.content` if defined
					data: val.data.content
				});

				return acc;
			},
			[
				{
					path: `playground.json`,
					data: localStorage.getItem("playground")
				}
			]
		));

		// Trigger a browser file download
		downloadBlob(blob, "sema-" + `${timestamp}` + ".zip");
	}

	onMount(async () => {
		engine = new Engine$1();
	});

	onDestroy(() => {
		engine = null;
	});

	const func = () => $isLoadEnvironmentOptionsDisabled
	? "not-allowed"
	: "pointer";

	function select_change_handler() {
		$selectedLoadEnvironmentOption = select_value(this);
		selectedLoadEnvironmentOption.set($selectedLoadEnvironmentOption);
	}

	const change_handler = () => loadEnvironment();
	const click_handler = () => set_store_value(loadEnvironmentOptions, $loadEnvironmentOptions[0].disabled = true, $loadEnvironmentOptions);
	const click_handler_1 = () => storeEnvironment();
	const click_handler_2 = () => resetEnvironment();
	const click_handler_3 = () => downloadEnvironment();
	const click_handler_4 = () => uploadEnvironment();

	return [
		$selectedLoadEnvironmentOption,
		$loadEnvironmentOptions,
		$isLoadEnvironmentOptionsDisabled,
		$isActive,
		$siteMode,
		handleClick,
		resetEnvironment,
		storeEnvironment,
		loadEnvironment,
		uploadEnvironment,
		downloadEnvironment,
		func,
		select_change_handler,
		change_handler,
		click_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3,
		click_handler_4
	];
}

class Environment extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-14h7pxd-style")) add_css$M();
		init(this, options, instance$X, create_fragment$X, safe_not_equal, {});
	}
}

/* src/components/settings/group/Mouse.svelte generated by Svelte v3.31.0 */

const { document: document_1$3 } = globals;

function add_css$N() {
	var style = element("style");
	style.id = "svelte-1dgtmt0-style";
	style.textContent = ".button-dark.svelte-1dgtmt0{width:2.5em;height:2.5em;display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:red;line-height:1.3;padding:0.25em 1em 0.75em 0.8em;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;margin-right:5px;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;-webkit-box-shadow:2px 2px 3px rgb(0, 0, 0), -0.5px -0.5px 3px #ffffff61;-moz-box-shadow:2px 2px 3px rgb(0, 0, 0), -0.5px -0.5px 3px #ffffff61;box-shadow:2px 2px 3px rgb(0, 0, 0), -0.5px -0.5px 3px #ffffff61}.button-dark.svelte-1dgtmt0:hover{width:2.5em;height:2.5em;font-size:medium;display:block;font-family:sans-serif;font-weight:500;cursor:pointer;color:red;line-height:1.3;padding:0.25em 1em 0.75em 0.8em;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;margin-right:5px;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:linear-gradient(rgba(16, 16, 16, 1), rgba(16, 16, 16, 0.08));background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;-webkit-box-shadow:2px 2px 5px rgba(0,0,0),-0.5px -0.5px 3px rgb(34, 34, 34);-moz-box-shadow:2px 2px 5px rgba(0,0,0), -0.5px -0.5px 3px rgb(34, 34, 34);box-shadow:2px 2px 3px rgb(0, 0, 0), -1px -1px 3px #ffffff61}.button-dark.svelte-1dgtmt0:active{width:2.5em;height:2.5em;display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:red;line-height:1.3;padding:0.25em 1em 0.75em 0.8em;max-width:100%;box-sizing:border-box;margin-right:5px;text-align:left;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-size:.65em auto, 100%;box-shadow:-1px -1px 3px rgba(16, 16, 16, 0.4), 0.5px 0.5px 0.5px rgba(16, 16, 16, 0.04)}.button-light.svelte-1dgtmt0{width:2.5em;height:2.5em;display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:black;line-height:1.3;padding:0.7em 1em 0.7em 1em;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-moz-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-webkit-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0)}.button-light.svelte-1dgtmt0:active{width:2.5em;height:2.5em;display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:black;line-height:1.3;padding:0.7em 1em 0.7em 1em;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-moz-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-webkit-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0)\n  }.button-light.svelte-1dgtmt0:disabled{width:2.5em;height:2.5em;display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:#888;line-height:1.3;padding:0.7em 1em 0.7em 1em;max-width:100%;box-sizing:border-box;border:0 solid #333;text-align:left;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-moz-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0);-webkit-box-shadow:2px 2px 3px #ffffff61, -1px -1px 3px  rgb(0, 0, 0)\n  }path.svelte-1dgtmt0{transform:translate(-3px, -5px)\n  }.mouse-outputText.svelte-1dgtmt0{padding-top:0.1em;width:10em}.mouse.svelte-1dgtmt0{padding-top:3px;enable-background:new 0 0 512 512;width:16px}.mouse-on.svelte-1dgtmt0{fill:#0050A0}.mouse-off.svelte-1dgtmt0{fill:rgb(133, 130, 130)}";
	append(document_1$3.head, style);
}

// (373:6) {:else}
function create_else_block$a(ctx) {
	let svg;
	let g;
	let path;
	let svg_class_value;

	return {
		c() {
			svg = svg_element("svg");
			g = svg_element("g");
			path = svg_element("path");
			attr(path, "d", "M409.6,0v34.1H221.9c-14.1,0-25.6,11.5-25.6,25.6v42.7h-33.5c-52.2,0.1-94.5,42.3-94.5,94.5v170.6\n                c0,79.6,64.8,144.5,144.5,144.5h1.2c79.6,0,144.5-64.8,144.5-144.5V196.9c-0.1-52.2-42.3-94.5-94.5-94.5h-33.5V68.3h187.7\n                c14.1,0,25.6-11.5,25.6-25.6V0L409.6,0z M162.8,136.5h33.5v93.9h-93.9v-33.5C102.4,163.6,129.5,136.6,162.8,136.5z M213.9,477.9\n                h-1.2c-60.9-0.1-110.3-49.4-110.3-110.3v-103h221.9v103C324.2,428.4,274.8,477.8,213.9,477.9z M324.3,196.9v33.5h-93.9v-93.9h33.5\n                C297.2,136.6,324.2,163.6,324.3,196.9z");
			attr(path, "class", "svelte-1dgtmt0");
			attr(svg, "version", "1.1");
			attr(svg, "id", "Layer_1");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "x", "0px");
			attr(svg, "y", "0px");
			attr(svg, "viewBox", "5 0 512 512");
			attr(svg, "class", svg_class_value = "mouse " + (/*$mouseActivated*/ ctx[1] ? `mouse-on` : `mouse-off`) + " svelte-1dgtmt0");
			attr(svg, "xml:space", "preserve");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, g);
			append(g, path);
		},
		p(ctx, dirty) {
			if (dirty & /*$mouseActivated*/ 2 && svg_class_value !== (svg_class_value = "mouse " + (/*$mouseActivated*/ ctx[1] ? `mouse-on` : `mouse-off`) + " svelte-1dgtmt0")) {
				attr(svg, "class", svg_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (359:6) {#if $mouseActivated }
function create_if_block$q(ctx) {
	let svg;
	let g;
	let path;
	let svg_class_value;

	return {
		c() {
			svg = svg_element("svg");
			g = svg_element("g");
			path = svg_element("path");
			attr(path, "d", "M409.6,0v34.1H221.9c-14.1,0-25.6,11.5-25.6,25.6v42.7h-33.5c-52.2,0.1-94.5,42.3-94.5,94.5v170.6\n              c0,79.6,64.8,144.5,144.5,144.5h1.2c79.6,0,144.5-64.8,144.5-144.5V196.9c-0.1-52.2-42.3-94.5-94.5-94.5h-33.5V68.3h187.7\n              c14.1,0,25.6-11.5,25.6-25.6V0L409.6,0z M162.8,136.5h33.5v93.9h-93.9v-33.5C102.4,163.6,129.5,136.6,162.8,136.5z M213.9,477.9\n              h-1.2c-60.9-0.1-110.3-49.4-110.3-110.3v-103h221.9v103C324.2,428.4,274.8,477.8,213.9,477.9z M324.3,196.9v33.5h-93.9v-93.9h33.5\n              C297.2,136.6,324.2,163.6,324.3,196.9z");
			attr(path, "class", "svelte-1dgtmt0");
			attr(svg, "version", "1.1");
			attr(svg, "id", "Layer_1");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "x", "0px");
			attr(svg, "y", "0px");
			attr(svg, "viewBox", "5 0 512 512");
			attr(svg, "class", svg_class_value = "mouse " + (/*$mouseActivated*/ ctx[1] ? `mouse-on` : `mouse-off`) + " svelte-1dgtmt0");
			attr(svg, "xml:space", "preserve");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, g);
			append(g, path);
		},
		p(ctx, dirty) {
			if (dirty & /*$mouseActivated*/ 2 && svg_class_value !== (svg_class_value = "mouse " + (/*$mouseActivated*/ ctx[1] ? `mouse-on` : `mouse-off`) + " svelte-1dgtmt0")) {
				attr(svg, "class", svg_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function create_fragment$Y(ctx) {
	let div1;
	let button;
	let div0;
	let button_class_value;
	let t;
	let span;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (/*$mouseActivated*/ ctx[1]) return create_if_block$q;
		return create_else_block$a;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			div1 = element("div");
			button = element("button");
			div0 = element("div");
			if_block.c();
			t = space();
			span = element("span");
			attr(div0, "class", "icon-container");

			attr(button, "class", button_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[2] === "dark"
			? "button-dark"
			: "button-light") + " svelte-1dgtmt0"));

			attr(button, "title", "Mouse data");
			attr(span, "class", "mouse-outputText svelte-1dgtmt0");
			set_style(div1, "width", "9em");
			set_style(div1, "display", "flex");
			set_style(div1, "margin-left", "2px");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, button);
			append(button, div0);
			if_block.m(div0, null);
			append(div1, t);
			append(div1, span);
			/*span_binding*/ ctx[4](span);

			if (!mounted) {
				dispose = listen(button, "click", /*handleClick*/ ctx[3]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div0, null);
				}
			}

			if (dirty & /*$siteMode*/ 4 && button_class_value !== (button_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[2] === "dark"
			? "button-dark"
			: "button-light") + " svelte-1dgtmt0"))) {
				attr(button, "class", button_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div1);
			if_block.d();
			/*span_binding*/ ctx[4](null);
			mounted = false;
			dispose();
		}
	};
}

const id$1 = "mxy", ttype = "mouseXY", blockSize = 2;

function instance$Y($$self, $$props, $$invalidate) {
	let $mouseActivated;
	let $siteMode;
	component_subscribe($$self, mouseActivated, $$value => $$invalidate(1, $mouseActivated = $$value));
	component_subscribe($$self, siteMode, $$value => $$invalidate(2, $siteMode = $$value));
	let engine, outputText;

	const onMouseMove = e => {
		const x = e.pageX / window.innerWidth;
		const y = e.pageY / window.innerHeight;

		if (outputText) {
			$$invalidate(0, outputText.innerText = `X:${parseFloat(x).toFixed(5)} Y:${parseFloat(y).toFixed(5)}`, outputText);
		}

		if (engine) {
			engine.pushDataToSharedBuffer(id$1, [x, y]);
		}
	};

	const deactivateMouse = e => {
		set_store_value(mouseActivated, $mouseActivated = false, $mouseActivated);

		// $isMouseOverlayVisible = false;
		if (outputText) $$invalidate(0, outputText.innerText = ``, outputText);

		document.removeEventListener("mousemove", onMouseMove, true);
	}; // document.removeEventListener( "keydown", onKeyDown)
	// document.removeEventListener( "keydown", onKeyUp)

	const handleClick = () => {
		// if(engine){
		try {
			set_store_value(mouseActivated, $mouseActivated = !$mouseActivated, $mouseActivated);

			if ($mouseActivated) {
				// if(outputText)
				//   outputText.innerText = `Press ALT \n+ click-drag`;
				// $mouseTrailCaptureActivated = true;
				document.addEventListener("mousemove", onMouseMove, true);

				let sab = engine.createSharedBuffer(id$1, ttype, blockSize);
			} else // document.addEventListener("keydown", onKeyDown );
			// Subscribe Left `Alt`-key UP event to unsubscribe mouse move
			// document.addEventListener("keyup", onKeyUp);
			{
				deactivateMouse(); // Subscribe Left `Alt`-key down event to subscribe mouse move
			}
		} catch(err) {
			console.error("ERROR: Failed to create new channel for mouse data: ", err);
		}
	}; // }
	// else throw new Error('ERROR: Engine not initialized. Please press Start Engine first.')

	onMount(async () => {
		if (!engine) engine = new Engine$1();
	});

	onDestroy(() => {
		deactivateMouse();
		engine = null;
	});

	function span_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			outputText = $$value;
			$$invalidate(0, outputText);
		});
	}

	return [outputText, $mouseActivated, $siteMode, handleClick, span_binding];
}

class Mouse extends SvelteComponent {
	constructor(options) {
		super();
		if (!document_1$3.getElementById("svelte-1dgtmt0-style")) add_css$N();
		init(this, options, instance$Y, create_fragment$Y, safe_not_equal, {});
	}
}

/* src/components/settings/Settings.svelte generated by Svelte v3.31.0 */

function add_css$O() {
	var style = element("style");
	style.id = "svelte-zlftu6-style";
	style.textContent = ".settings-container.svelte-zlftu6{width:100%;display:flex;flex-direction:row;align-self:flex-end;justify-content:space-between;border-bottom:1px solid #080808;margin-left:0.5em}.screen-container.svelte-zlftu6{width:7.5em;display:inline-flex;justify-content:space-between}.environment-container.svelte-zlftu6{width:auto;display:inline-flex;justify-content:space-between}.engine-container.svelte-zlftu6{width:12.5em;display:inline-flex;justify-content:space-between}.mouse-container.svelte-zlftu6{width:10em}";
	append(document.head, style);
}

function create_fragment$Z(ctx) {
	let div8;
	let div0;
	let screen;
	let t0;
	let sitemode;
	let t1;
	let div1;
	let t2;
	let div2;
	let environment;
	let t3;
	let div3;
	let t4;
	let div4;
	let engine;
	let t5;
	let div5;
	let t6;
	let div6;
	let mouse;
	let t7;
	let div7;
	let current;
	screen = new Screen({});
	sitemode = new SiteMode({});
	environment = new Environment({});
	engine = new Engine_1({});
	mouse = new Mouse({});

	return {
		c() {
			div8 = element("div");
			div0 = element("div");
			create_component(screen.$$.fragment);
			t0 = space();
			create_component(sitemode.$$.fragment);
			t1 = space();
			div1 = element("div");
			t2 = space();
			div2 = element("div");
			create_component(environment.$$.fragment);
			t3 = space();
			div3 = element("div");
			t4 = space();
			div4 = element("div");
			create_component(engine.$$.fragment);
			t5 = space();
			div5 = element("div");
			t6 = space();
			div6 = element("div");
			create_component(mouse.$$.fragment);
			t7 = space();
			div7 = element("div");
			attr(div0, "class", "screen-container svelte-zlftu6");
			set_style(div1, "width", "5px");
			attr(div2, "class", "environment-container svelte-zlftu6");
			set_style(div3, "width", "5px");
			attr(div4, "class", "engine-container svelte-zlftu6");
			set_style(div5, "width", "5px");
			attr(div6, "class", "mouse-container svelte-zlftu6");
			set_style(div7, "width", "5px");
			attr(div8, "class", "settings-container svelte-zlftu6");
		},
		m(target, anchor) {
			insert(target, div8, anchor);
			append(div8, div0);
			mount_component(screen, div0, null);
			append(div0, t0);
			mount_component(sitemode, div0, null);
			append(div8, t1);
			append(div8, div1);
			append(div8, t2);
			append(div8, div2);
			mount_component(environment, div2, null);
			append(div8, t3);
			append(div8, div3);
			append(div8, t4);
			append(div8, div4);
			mount_component(engine, div4, null);
			append(div8, t5);
			append(div8, div5);
			append(div8, t6);
			append(div8, div6);
			mount_component(mouse, div6, null);
			append(div8, t7);
			append(div8, div7);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(screen.$$.fragment, local);
			transition_in(sitemode.$$.fragment, local);
			transition_in(environment.$$.fragment, local);
			transition_in(engine.$$.fragment, local);
			transition_in(mouse.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(screen.$$.fragment, local);
			transition_out(sitemode.$$.fragment, local);
			transition_out(environment.$$.fragment, local);
			transition_out(engine.$$.fragment, local);
			transition_out(mouse.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div8);
			destroy_component(screen);
			destroy_component(sitemode);
			destroy_component(environment);
			destroy_component(engine);
			destroy_component(mouse);
		}
	};
}

class Settings extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-zlftu6-style")) add_css$O();
		init(this, options, null, create_fragment$Z, safe_not_equal, {});
	}
}

function getRowsCount$1(items, cols) {
  return Math.max(
    ...items.map((val) => {
      const item = val[cols];
      return (item && item.y) + (item && item.h);
    }),
    1,
  );
}

const getColumn = (containerWidth, columns) => {
  try {
    let [_, cols] = columns
      .slice()
      .reverse()
      .find((value) => {
        const [width, cols] = value;
        return containerWidth <= width;
      });
    return cols;
  } catch {
    return columns[columns.length - 1];
  }
};

function getContainerHeight(items, yPerPx, cols) {
  return getRowsCount$1(items, cols) * yPerPx;
}

const makeMatrix$1 = (rows, cols) => Array.from(Array(rows), () => new Array(cols)); // make 2d array

function findCloseBlocks$1(items, matrix, curObject) {
  const { h, x, y } = curObject;

  const w = Math.min(matrix[0].length, curObject.w);
  const tempR = matrix.slice(y, y + h);

  let result = [];
  for (var i = 0; i < tempR.length; i++) {
    let tempA = tempR[i].slice(x, x + w);
    result = [...result, ...tempA.map((val) => val.id && val.id !== curObject.id && val.id).filter(Boolean)];
  }

  return [...new Set(result)];
}

function makeMatrixFromItemsIgnore$1(items, ignoreList, _row, _col) {
  let matrix = makeMatrix$1(_row, _col);
  for (var i = 0; i < items.length; i++) {
    const value = items[i][_col];
    const id = items[i].id;
    const { x, y, h } = value;
    const w = Math.min(_col, value.w);

    if (ignoreList.indexOf(id) === -1) {
      for (var j = y; j < y + h; j++) {
        const row = matrix[j];
        if (row) {
          for (var k = x; k < x + w; k++) {
            row[k] = { ...value, id };
          }
        }
      }
    }
  }
  return matrix;
}

function findItemsById$1(closeBlocks, items) {
  return items.filter((value) => closeBlocks.indexOf(value.id) !== -1);
}

function getItemById(id, items) {
  return items.find((value) => value.id === id);
}

function findFreeSpaceForItem$1(matrix, item) {
  const cols = matrix[0].length;
  const w = Math.min(cols, item.w);
  let xNtime = cols - w;
  let getMatrixRows = matrix.length;

  for (var i = 0; i < getMatrixRows; i++) {
    const row = matrix[i];
    for (var j = 0; j < xNtime + 1; j++) {
      const sliceA = row.slice(j, j + w);
      const empty = sliceA.every((val) => val === undefined);
      if (empty) {
        const isEmpty = matrix.slice(i, i + item.h).every((a) => a.slice(j, j + w).every((n) => n === undefined));

        if (isEmpty) {
          return { y: i, x: j };
        }
      }
    }
  }

  return {
    y: getMatrixRows,
    x: 0,
  };
}

const getItem$1 = (item, col) => {
  return { ...item[col], id: item.id };
};

const updateItem$1 = (elements, active, position, col) => {
  return elements.map((value) => {
    if (value.id === active.id) {
      return { ...value, [col]: { ...value[col], ...position } };
    }
    return value;
  });
};

function moveItemsAroundItem(active, items, cols, original) {
  // Get current item from the breakpoint
  const activeItem = getItem$1(active, cols);
  const ids = items.map((value) => value.id).filter((value) => value !== activeItem.id);

  const els = items.filter((value) => value.id !== activeItem.id);

  // Update items
  let newItems = updateItem$1(items, active, activeItem, cols);

  let matrix = makeMatrixFromItemsIgnore$1(newItems, ids, getRowsCount$1(newItems, cols), cols);
  let tempItems = newItems;

  // Exclude resolved elements ids in array
  let exclude = [];

  els.forEach((item) => {
    // Find position for element
    let position = findFreeSpaceForItem$1(matrix, item[cols]);
    // Exclude item
    exclude.push(item.id);

    tempItems = updateItem$1(tempItems, item, position, cols);

    // Recreate ids of elements
    let getIgnoreItems = ids.filter((value) => exclude.indexOf(value) === -1);

    // Update matrix for next iteration
    matrix = makeMatrixFromItemsIgnore$1(tempItems, getIgnoreItems, getRowsCount$1(tempItems, cols), cols);
  });

  // Return result
  return tempItems;
}

function moveItem$1(active, items, cols, original) {
  // Get current item from the breakpoint
  const item = getItem$1(active, cols);

  // Create matrix from the items expect the active
  let matrix = makeMatrixFromItemsIgnore$1(items, [item.id], getRowsCount$1(items, cols), cols);
  // Getting the ids of items under active Array<String>
  const closeBlocks = findCloseBlocks$1(items, matrix, item);
  // Getting the objects of items under active Array<Object>
  let closeObj = findItemsById$1(closeBlocks, items);
  // Getting whenever of these items is fixed
  const fixed = closeObj.find((value) => value[cols].fixed);

  // If found fixed, reset the active to its original position
  if (fixed) return items;

  // Update items
  items = updateItem$1(items, active, item, cols);

  // Create matrix of items expect close elements
  matrix = makeMatrixFromItemsIgnore$1(items, closeBlocks, getRowsCount$1(items, cols), cols);

  // Create temp vars
  let tempItems = items;
  let tempCloseBlocks = closeBlocks;

  // Exclude resolved elements ids in array
  let exclude = [];

  // Iterate over close elements under active item
  closeObj.forEach((item) => {
    // Find position for element
    let position = findFreeSpaceForItem$1(matrix, item[cols]);
    // Exclude item
    exclude.push(item.id);

    // Assign the position to the element in the column
    tempItems = updateItem$1(tempItems, item, position, cols);

    // Recreate ids of elements
    let getIgnoreItems = tempCloseBlocks.filter((value) => exclude.indexOf(value) === -1);

    // Update matrix for next iteration
    matrix = makeMatrixFromItemsIgnore$1(tempItems, getIgnoreItems, getRowsCount$1(tempItems, cols), cols);
  });

  // Return result
  return tempItems;
}

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root$1 = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root$1.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

var lodash_throttle = throttle;

/* node_modules/svelte-grid/src/MoveResize/index.svelte generated by Svelte v3.31.0 */

const { document: document_1$4 } = globals;

function add_css$P() {
	var style = element("style");
	style.id = "svelte-1y3sywa-style";
	style.textContent = ".svlt-grid-item.svelte-1y3sywa{touch-action:none;position:absolute;will-change:auto;backface-visibility:hidden;-webkit-backface-visibility:hidden}.svlt-grid-resizer.svelte-1y3sywa{user-select:none;width:20px;height:20px;position:absolute;right:0;bottom:0;cursor:se-resize}.svlt-grid-resizer.svelte-1y3sywa::after{content:\"\";position:absolute;right:3px;bottom:3px;width:5px;height:5px;border-right:2px solid rgba(0, 0, 0, 0.4);border-bottom:2px solid rgba(0, 0, 0, 0.4)}.svlt-grid-active.svelte-1y3sywa{z-index:3;cursor:grabbing;position:fixed;opacity:0.5;backface-visibility:hidden;-webkit-backface-visibility:hidden;-moz-backface-visibility:hidden;-o-backface-visibility:hidden;-ms-backface-visibility:hidden;user-select:none}.shadow-active.svelte-1y3sywa{z-index:2;transition:all 0.2s}.svlt-grid-shadow.svelte-1y3sywa{position:absolute;background:red;will-change:transform;background:pink;backface-visibility:hidden;-webkit-backface-visibility:hidden}";
	append(document_1$4.head, style);
}

const get_default_slot_changes$1 = dirty => ({});

const get_default_slot_context$1 = ctx => ({
	movePointerDown: /*pointerdown*/ ctx[18],
	resizePointerDown: /*resizePointerDown*/ ctx[19]
});

// (68:2) {#if resizable && !item.customResizer}
function create_if_block_1$g(ctx) {
	let div;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			attr(div, "class", "svlt-grid-resizer svelte-1y3sywa");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (!mounted) {
				dispose = listen(div, "pointerdown", /*resizePointerDown*/ ctx[19]);
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			dispose();
		}
	};
}

// (73:0) {#if active || trans}
function create_if_block$r(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			attr(div, "class", "svlt-grid-shadow shadow-active svelte-1y3sywa");
			set_style(div, "width", /*shadow*/ ctx[12].w * /*xPerPx*/ ctx[6] - /*gapX*/ ctx[8] * 2 + "px");
			set_style(div, "height", /*shadow*/ ctx[12].h * /*yPerPx*/ ctx[7] - /*gapY*/ ctx[9] * 2 + "px");
			set_style(div, "transform", "translate(" + (/*shadow*/ ctx[12].x * /*xPerPx*/ ctx[6] + /*gapX*/ ctx[8]) + "px, " + (/*shadow*/ ctx[12].y * /*yPerPx*/ ctx[7] + /*gapY*/ ctx[9]) + "px)");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			/*div_binding*/ ctx[29](div);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*shadow, xPerPx, gapX*/ 4416) {
				set_style(div, "width", /*shadow*/ ctx[12].w * /*xPerPx*/ ctx[6] - /*gapX*/ ctx[8] * 2 + "px");
			}

			if (dirty[0] & /*shadow, yPerPx, gapY*/ 4736) {
				set_style(div, "height", /*shadow*/ ctx[12].h * /*yPerPx*/ ctx[7] - /*gapY*/ ctx[9] * 2 + "px");
			}

			if (dirty[0] & /*shadow, xPerPx, gapX, yPerPx, gapY*/ 5056) {
				set_style(div, "transform", "translate(" + (/*shadow*/ ctx[12].x * /*xPerPx*/ ctx[6] + /*gapX*/ ctx[8]) + "px, " + (/*shadow*/ ctx[12].y * /*yPerPx*/ ctx[7] + /*gapY*/ ctx[9]) + "px)");
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			/*div_binding*/ ctx[29](null);
		}
	};
}

function create_fragment$_(ctx) {
	let div;
	let t0;
	let div_draggable_value;
	let div_style_value;
	let t1;
	let if_block1_anchor;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[28].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[27], get_default_slot_context$1);
	let if_block0 = /*resizable*/ ctx[4] && !/*item*/ ctx[10].customResizer && create_if_block_1$g(ctx);
	let if_block1 = (/*active*/ ctx[13] || /*trans*/ ctx[16]) && create_if_block$r(ctx);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
			attr(div, "draggable", div_draggable_value = false);
			attr(div, "class", "svlt-grid-item svelte-1y3sywa");

			attr(div, "style", div_style_value = "width: " + (/*active*/ ctx[13]
			? /*newSize*/ ctx[15].width
			: /*width*/ ctx[0]) + "px; height:" + (/*active*/ ctx[13]
			? /*newSize*/ ctx[15].height
			: /*height*/ ctx[1]) + "px; \n  " + (/*active*/ ctx[13]
			? `transform: translate(${/*cordDiff*/ ctx[14].x}px, ${/*cordDiff*/ ctx[14].y}px);top:${/*rect*/ ctx[17].top}px;left:${/*rect*/ ctx[17].left}px;`
			: /*trans*/ ctx[16]
				? `transform: translate(${/*cordDiff*/ ctx[14].x}px, ${/*cordDiff*/ ctx[14].y}px); position:absolute; transition: width 0.2s, height 0.2s;`
				: `transition: transform 0.2s, opacity 0.2s; transform: translate(${/*left*/ ctx[2]}px, ${/*top*/ ctx[3]}px); `) + " ");

			toggle_class(div, "svlt-grid-active", /*active*/ ctx[13] || /*trans*/ ctx[16] && /*rect*/ ctx[17]);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			append(div, t0);
			if (if_block0) if_block0.m(div, null);
			insert(target, t1, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = listen(div, "pointerdown", function () {
					if (is_function(/*item*/ ctx[10] && /*item*/ ctx[10].customDragger
					? null
					: /*draggable*/ ctx[5] && /*pointerdown*/ ctx[18])) (/*item*/ ctx[10] && /*item*/ ctx[10].customDragger
					? null
					: /*draggable*/ ctx[5] && /*pointerdown*/ ctx[18]).apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (default_slot) {
				if (default_slot.p && dirty[0] & /*$$scope*/ 134217728) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[27], dirty, get_default_slot_changes$1, get_default_slot_context$1);
				}
			}

			if (/*resizable*/ ctx[4] && !/*item*/ ctx[10].customResizer) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1$g(ctx);
					if_block0.c();
					if_block0.m(div, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (!current || dirty[0] & /*active, newSize, width, height, cordDiff, rect, trans, left, top*/ 253967 && div_style_value !== (div_style_value = "width: " + (/*active*/ ctx[13]
			? /*newSize*/ ctx[15].width
			: /*width*/ ctx[0]) + "px; height:" + (/*active*/ ctx[13]
			? /*newSize*/ ctx[15].height
			: /*height*/ ctx[1]) + "px; \n  " + (/*active*/ ctx[13]
			? `transform: translate(${/*cordDiff*/ ctx[14].x}px, ${/*cordDiff*/ ctx[14].y}px);top:${/*rect*/ ctx[17].top}px;left:${/*rect*/ ctx[17].left}px;`
			: /*trans*/ ctx[16]
				? `transform: translate(${/*cordDiff*/ ctx[14].x}px, ${/*cordDiff*/ ctx[14].y}px); position:absolute; transition: width 0.2s, height 0.2s;`
				: `transition: transform 0.2s, opacity 0.2s; transform: translate(${/*left*/ ctx[2]}px, ${/*top*/ ctx[3]}px); `) + " ")) {
				attr(div, "style", div_style_value);
			}

			if (dirty[0] & /*active, trans, rect*/ 204800) {
				toggle_class(div, "svlt-grid-active", /*active*/ ctx[13] || /*trans*/ ctx[16] && /*rect*/ ctx[17]);
			}

			if (/*active*/ ctx[13] || /*trans*/ ctx[16]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$r(ctx);
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (detaching) detach(t1);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
			mounted = false;
			dispose();
		}
	};
}

function instance$Z($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	const dispatch = createEventDispatcher();
	let { sensor } = $$props;
	let { width } = $$props;
	let { height } = $$props;
	let { left } = $$props;
	let { top } = $$props;
	let { resizable } = $$props;
	let { draggable } = $$props;
	let { id } = $$props;
	let { container } = $$props;
	let { xPerPx } = $$props;
	let { yPerPx } = $$props;
	let { gapX } = $$props;
	let { gapY } = $$props;
	let { item } = $$props;
	let { max } = $$props;
	let { min } = $$props;
	let { cols } = $$props;
	let { nativeContainer } = $$props;
	let shadowElement;
	let shadow = {};
	let active = false;
	let initX, initY;
	let capturePos = { x: 0, y: 0 };
	let cordDiff = { x: 0, y: 0 };
	let newSize = { width, height };
	let trans = false;
	let anima;

	const inActivate = () => {
		const shadowBound = shadowElement.getBoundingClientRect();
		const xdragBound = rect.left + cordDiff.x;
		const ydragBound = rect.top + cordDiff.y;
		$$invalidate(14, cordDiff.x = shadow.x * xPerPx + gapX - (shadowBound.x - xdragBound), cordDiff);
		$$invalidate(14, cordDiff.y = shadow.y * yPerPx + gapY - (shadowBound.y - ydragBound), cordDiff);
		$$invalidate(13, active = false);
		$$invalidate(16, trans = true);
		clearTimeout(anima);

		anima = setTimeout(
			() => {
				$$invalidate(16, trans = false);
			},
			100
		);

		dispatch("pointerup", { id });
	};

	let repaint = cb => {
		dispatch("repaint", { id, shadow, onUpdate: cb });
	};

	// Autoscroll
	let _scrollTop = 0;

	let containerFrame;
	let rect;
	let scrollElement;

	const getContainerFrame = element => {
		if (element === document.documentElement || !element) {
			const { height, top, right, bottom, left } = nativeContainer.getBoundingClientRect();

			return {
				top: Math.max(0, top),
				bottom: Math.min(window.innerHeight, bottom)
			};
		}

		return element.getBoundingClientRect();
	};

	const getScroller = element => !element ? document.documentElement : element;

	const pointerdown = ({ clientX, clientY, target }) => {
		initX = clientX;
		initY = clientY;
		capturePos = { x: left, y: top };

		$$invalidate(12, shadow = {
			x: item.x,
			y: item.y,
			w: item.w,
			h: item.h
		});

		$$invalidate(15, newSize = { width, height });
		containerFrame = getContainerFrame(container);
		scrollElement = getScroller(container);
		$$invalidate(14, cordDiff = { x: 0, y: 0 });
		$$invalidate(17, rect = target.closest(".svlt-grid-item").getBoundingClientRect());
		$$invalidate(13, active = true);
		$$invalidate(16, trans = false);
		_scrollTop = scrollElement.scrollTop;
		window.addEventListener("pointermove", pointermove);
		window.addEventListener("pointerup", pointerup);
	};

	let sign = { x: 0, y: 0 };
	let vel = { x: 0, y: 0 };
	let intervalId = 0;

	const stopAutoscroll = () => {
		clearInterval(intervalId);
		intervalId = false;
		sign = { x: 0, y: 0 };
		vel = { x: 0, y: 0 };
	};

	const update = () => {
		const _newScrollTop = scrollElement.scrollTop - _scrollTop;
		const boundX = capturePos.x + cordDiff.x;
		const boundY = capturePos.y + (cordDiff.y + _newScrollTop);
		let gridX = Math.round(boundX / xPerPx);
		let gridY = Math.round(boundY / yPerPx);
		$$invalidate(12, shadow.x = Math.max(Math.min(gridX, cols - shadow.w), 0), shadow);
		$$invalidate(12, shadow.y = Math.max(gridY, 0), shadow);

		if (max.y) {
			$$invalidate(12, shadow.y = Math.min(shadow.y, max.y), shadow);
		}

		repaint();
	};

	const pointermove = event => {
		event.preventDefault();
		event.stopPropagation();
		event.stopImmediatePropagation();
		const { clientX, clientY } = event;
		$$invalidate(14, cordDiff = { x: clientX - initX, y: clientY - initY });
		const Y_SENSOR = sensor;
		let velocityTop = Math.max(0, (containerFrame.top + Y_SENSOR - clientY) / Y_SENSOR);
		let velocityBottom = Math.max(0, (clientY - (containerFrame.bottom - Y_SENSOR)) / Y_SENSOR);
		const topSensor = velocityTop > 0 && velocityBottom === 0;
		const bottomSensor = velocityBottom > 0 && velocityTop === 0;
		sign.y = topSensor ? -1 : bottomSensor ? 1 : 0;
		vel.y = sign.y === -1 ? velocityTop : velocityBottom;

		if (vel.y > 0) {
			if (!intervalId) {
				// Start scrolling
				// TODO Use requestAnimationFrame
				intervalId = setInterval(
					() => {
						scrollElement.scrollTop += 2 * (vel.y + Math.sign(vel.y)) * sign.y;
						update();
					},
					10
				);
			}
		} else if (intervalId) {
			stopAutoscroll();
		} else {
			update();
		}
	};

	const pointerup = e => {
		stopAutoscroll();
		window.removeEventListener("pointerdown", pointerdown);
		window.removeEventListener("pointermove", pointermove);
		window.removeEventListener("pointerup", pointerup);
		repaint(inActivate);
	};

	// Resize
	let resizeInitPos = { x: 0, y: 0 };

	let initSize = { width: 0, height: 0 };

	const resizePointerDown = e => {
		e.stopPropagation();
		const { pageX, pageY } = e;
		resizeInitPos = { x: pageX, y: pageY };
		initSize = { width, height };
		$$invalidate(14, cordDiff = { x: 0, y: 0 });
		$$invalidate(17, rect = e.target.closest(".svlt-grid-item").getBoundingClientRect());
		$$invalidate(15, newSize = { width, height });
		$$invalidate(13, active = true);
		$$invalidate(16, trans = false);

		$$invalidate(12, shadow = {
			x: item.x,
			y: item.y,
			w: item.w,
			h: item.h
		});

		containerFrame = getContainerFrame(container);
		scrollElement = getScroller(container);
		window.addEventListener("pointermove", resizePointerMove);
		window.addEventListener("pointerup", resizePointerUp);
	};

	const resizePointerMove = ({ pageX, pageY }) => {
		$$invalidate(15, newSize.width = initSize.width + pageX - resizeInitPos.x, newSize);
		$$invalidate(15, newSize.height = initSize.height + pageY - resizeInitPos.y, newSize);

		// Get max col number
		let maxWidth = cols - shadow.x;

		maxWidth = Math.min(max.w, maxWidth) || maxWidth;

		// Limit bound
		$$invalidate(15, newSize.width = Math.max(Math.min(newSize.width, maxWidth * xPerPx - gapX * 2), min.w * xPerPx - gapX * 2), newSize);

		$$invalidate(15, newSize.height = Math.max(newSize.height, min.h * yPerPx - gapY * 2), newSize);

		if (max.h) {
			$$invalidate(15, newSize.height = Math.min(newSize.height, max.h * yPerPx - gapY * 2), newSize);
		}

		// Limit col & row
		$$invalidate(12, shadow.w = Math.round((newSize.width + gapX * 2) / xPerPx), shadow);

		$$invalidate(12, shadow.h = Math.round((newSize.height + gapY * 2) / yPerPx), shadow);
		repaint();
	};

	const resizePointerUp = e => {
		e.stopPropagation();
		repaint(inActivate);
		window.removeEventListener("pointermove", resizePointerMove);
		window.removeEventListener("pointerup", resizePointerUp);
	};

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			shadowElement = $$value;
			$$invalidate(11, shadowElement);
		});
	}

	$$self.$$set = $$props => {
		if ("sensor" in $$props) $$invalidate(20, sensor = $$props.sensor);
		if ("width" in $$props) $$invalidate(0, width = $$props.width);
		if ("height" in $$props) $$invalidate(1, height = $$props.height);
		if ("left" in $$props) $$invalidate(2, left = $$props.left);
		if ("top" in $$props) $$invalidate(3, top = $$props.top);
		if ("resizable" in $$props) $$invalidate(4, resizable = $$props.resizable);
		if ("draggable" in $$props) $$invalidate(5, draggable = $$props.draggable);
		if ("id" in $$props) $$invalidate(21, id = $$props.id);
		if ("container" in $$props) $$invalidate(22, container = $$props.container);
		if ("xPerPx" in $$props) $$invalidate(6, xPerPx = $$props.xPerPx);
		if ("yPerPx" in $$props) $$invalidate(7, yPerPx = $$props.yPerPx);
		if ("gapX" in $$props) $$invalidate(8, gapX = $$props.gapX);
		if ("gapY" in $$props) $$invalidate(9, gapY = $$props.gapY);
		if ("item" in $$props) $$invalidate(10, item = $$props.item);
		if ("max" in $$props) $$invalidate(23, max = $$props.max);
		if ("min" in $$props) $$invalidate(24, min = $$props.min);
		if ("cols" in $$props) $$invalidate(25, cols = $$props.cols);
		if ("nativeContainer" in $$props) $$invalidate(26, nativeContainer = $$props.nativeContainer);
		if ("$$scope" in $$props) $$invalidate(27, $$scope = $$props.$$scope);
	};

	return [
		width,
		height,
		left,
		top,
		resizable,
		draggable,
		xPerPx,
		yPerPx,
		gapX,
		gapY,
		item,
		shadowElement,
		shadow,
		active,
		cordDiff,
		newSize,
		trans,
		rect,
		pointerdown,
		resizePointerDown,
		sensor,
		id,
		container,
		max,
		min,
		cols,
		nativeContainer,
		$$scope,
		slots,
		div_binding
	];
}

class MoveResize extends SvelteComponent {
	constructor(options) {
		super();
		if (!document_1$4.getElementById("svelte-1y3sywa-style")) add_css$P();

		init(
			this,
			options,
			instance$Z,
			create_fragment$_,
			safe_not_equal,
			{
				sensor: 20,
				width: 0,
				height: 1,
				left: 2,
				top: 3,
				resizable: 4,
				draggable: 5,
				id: 21,
				container: 22,
				xPerPx: 6,
				yPerPx: 7,
				gapX: 8,
				gapY: 9,
				item: 10,
				max: 23,
				min: 24,
				cols: 25,
				nativeContainer: 26
			},
			[-1, -1]
		);
	}
}

/* node_modules/svelte-grid/src/index.svelte generated by Svelte v3.31.0 */

function add_css$Q() {
	var style = element("style");
	style.id = "svelte-xmewc1-style";
	style.textContent = ".svlt-grid-container.svelte-xmewc1{position:relative}";
	append(document.head, style);
}

function get_each_context$g(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[27] = list[i];
	child_ctx[29] = i;
	return child_ctx;
}

const get_default_slot_changes$2 = dirty => ({
	movePointerDown: dirty[1] & /*movePointerDown*/ 1,
	resizePointerDown: dirty[0] & /*resizePointerDown*/ 1073741824,
	dataItem: dirty[0] & /*items*/ 1,
	item: dirty[0] & /*items, getComputedCols*/ 17,
	index: dirty[0] & /*items*/ 1
});

const get_default_slot_context$2 = ctx => ({
	movePointerDown: /*movePointerDown*/ ctx[31],
	resizePointerDown: /*resizePointerDown*/ ctx[30],
	dataItem: /*item*/ ctx[27],
	item: /*item*/ ctx[27][/*getComputedCols*/ ctx[4]],
	index: /*i*/ ctx[29]
});

// (7:2) {#if xPerPx || !fastStart}
function create_if_block$s(ctx) {
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_1_anchor;
	let current;
	let each_value = /*items*/ ctx[0];
	const get_key = ctx => /*item*/ ctx[27].id;

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$g(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$g(key, child_ctx));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*items, getComputedCols, xPerPx, yPerPx, gapX, gapY, sensor, scroller, container, handleRepaint, pointerup, $$scope, resizePointerDown*/ 1075846653 | dirty[1] & /*movePointerDown*/ 1) {
				const each_value = /*items*/ ctx[0];
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$g, each_1_anchor, get_each_context$g);
				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d(detaching);
			}

			if (detaching) detach(each_1_anchor);
		}
	};
}

// (32:8) {#if item[getComputedCols]}
function create_if_block_1$h(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[19].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[21], get_default_slot_context$2);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[0] & /*$$scope, resizePointerDown, items, getComputedCols*/ 1075838993 | dirty[1] & /*movePointerDown*/ 1) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[21], dirty, get_default_slot_changes$2, get_default_slot_context$2);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (9:6) <MoveResize         on:repaint={handleRepaint}         on:pointerup={pointerup}         id={item.id}         resizable={item[getComputedCols] && item[getComputedCols].resizable}         draggable={item[getComputedCols] && item[getComputedCols].draggable}         {xPerPx}         {yPerPx}         width={Math.min(getComputedCols, item[getComputedCols] && item[getComputedCols].w) * xPerPx - gapX * 2}         height={(item[getComputedCols] && item[getComputedCols].h) * yPerPx - gapY * 2}         top={(item[getComputedCols] && item[getComputedCols].y) * yPerPx + gapY}         left={(item[getComputedCols] && item[getComputedCols].x) * xPerPx + gapX}         item={item[getComputedCols]}         min={item[getComputedCols] && item[getComputedCols].min}         max={item[getComputedCols] && item[getComputedCols].max}         cols={getComputedCols}         {gapX}         {gapY}         {sensor}         container={scroller}         nativeContainer={container}         let:resizePointerDown         let:movePointerDown>
function create_default_slot$p(ctx) {
	let t;
	let current;
	let if_block = /*item*/ ctx[27][/*getComputedCols*/ ctx[4]] && create_if_block_1$h(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			t = space();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*item*/ ctx[27][/*getComputedCols*/ ctx[4]]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*items, getComputedCols*/ 17) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1$h(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t);
		}
	};
}

// (8:4) {#each items as item, i (item.id)}
function create_each_block$g(key_1, ctx) {
	let first;
	let moveresize;
	let current;

	moveresize = new MoveResize({
			props: {
				id: /*item*/ ctx[27].id,
				resizable: /*item*/ ctx[27][/*getComputedCols*/ ctx[4]] && /*item*/ ctx[27][/*getComputedCols*/ ctx[4]].resizable,
				draggable: /*item*/ ctx[27][/*getComputedCols*/ ctx[4]] && /*item*/ ctx[27][/*getComputedCols*/ ctx[4]].draggable,
				xPerPx: /*xPerPx*/ ctx[6],
				yPerPx: /*yPerPx*/ ctx[10],
				width: Math.min(/*getComputedCols*/ ctx[4], /*item*/ ctx[27][/*getComputedCols*/ ctx[4]] && /*item*/ ctx[27][/*getComputedCols*/ ctx[4]].w) * /*xPerPx*/ ctx[6] - /*gapX*/ ctx[7] * 2,
				height: (/*item*/ ctx[27][/*getComputedCols*/ ctx[4]] && /*item*/ ctx[27][/*getComputedCols*/ ctx[4]].h) * /*yPerPx*/ ctx[10] - /*gapY*/ ctx[8] * 2,
				top: (/*item*/ ctx[27][/*getComputedCols*/ ctx[4]] && /*item*/ ctx[27][/*getComputedCols*/ ctx[4]].y) * /*yPerPx*/ ctx[10] + /*gapY*/ ctx[8],
				left: (/*item*/ ctx[27][/*getComputedCols*/ ctx[4]] && /*item*/ ctx[27][/*getComputedCols*/ ctx[4]].x) * /*xPerPx*/ ctx[6] + /*gapX*/ ctx[7],
				item: /*item*/ ctx[27][/*getComputedCols*/ ctx[4]],
				min: /*item*/ ctx[27][/*getComputedCols*/ ctx[4]] && /*item*/ ctx[27][/*getComputedCols*/ ctx[4]].min,
				max: /*item*/ ctx[27][/*getComputedCols*/ ctx[4]] && /*item*/ ctx[27][/*getComputedCols*/ ctx[4]].max,
				cols: /*getComputedCols*/ ctx[4],
				gapX: /*gapX*/ ctx[7],
				gapY: /*gapY*/ ctx[8],
				sensor: /*sensor*/ ctx[3],
				container: /*scroller*/ ctx[2],
				nativeContainer: /*container*/ ctx[5],
				$$slots: {
					default: [
						create_default_slot$p,
						({ resizePointerDown, movePointerDown }) => ({
							30: resizePointerDown,
							31: movePointerDown
						}),
						({ resizePointerDown, movePointerDown }) => [resizePointerDown ? 1073741824 : 0, movePointerDown ? 1 : 0]
					]
				},
				$$scope: { ctx }
			}
		});

	moveresize.$on("repaint", /*handleRepaint*/ ctx[12]);
	moveresize.$on("pointerup", /*pointerup*/ ctx[11]);

	return {
		key: key_1,
		first: null,
		c() {
			first = empty();
			create_component(moveresize.$$.fragment);
			this.first = first;
		},
		m(target, anchor) {
			insert(target, first, anchor);
			mount_component(moveresize, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const moveresize_changes = {};
			if (dirty[0] & /*items*/ 1) moveresize_changes.id = /*item*/ ctx[27].id;
			if (dirty[0] & /*items, getComputedCols*/ 17) moveresize_changes.resizable = /*item*/ ctx[27][/*getComputedCols*/ ctx[4]] && /*item*/ ctx[27][/*getComputedCols*/ ctx[4]].resizable;
			if (dirty[0] & /*items, getComputedCols*/ 17) moveresize_changes.draggable = /*item*/ ctx[27][/*getComputedCols*/ ctx[4]] && /*item*/ ctx[27][/*getComputedCols*/ ctx[4]].draggable;
			if (dirty[0] & /*xPerPx*/ 64) moveresize_changes.xPerPx = /*xPerPx*/ ctx[6];
			if (dirty[0] & /*getComputedCols, items, xPerPx, gapX*/ 209) moveresize_changes.width = Math.min(/*getComputedCols*/ ctx[4], /*item*/ ctx[27][/*getComputedCols*/ ctx[4]] && /*item*/ ctx[27][/*getComputedCols*/ ctx[4]].w) * /*xPerPx*/ ctx[6] - /*gapX*/ ctx[7] * 2;
			if (dirty[0] & /*items, getComputedCols, gapY*/ 273) moveresize_changes.height = (/*item*/ ctx[27][/*getComputedCols*/ ctx[4]] && /*item*/ ctx[27][/*getComputedCols*/ ctx[4]].h) * /*yPerPx*/ ctx[10] - /*gapY*/ ctx[8] * 2;
			if (dirty[0] & /*items, getComputedCols, gapY*/ 273) moveresize_changes.top = (/*item*/ ctx[27][/*getComputedCols*/ ctx[4]] && /*item*/ ctx[27][/*getComputedCols*/ ctx[4]].y) * /*yPerPx*/ ctx[10] + /*gapY*/ ctx[8];
			if (dirty[0] & /*items, getComputedCols, xPerPx, gapX*/ 209) moveresize_changes.left = (/*item*/ ctx[27][/*getComputedCols*/ ctx[4]] && /*item*/ ctx[27][/*getComputedCols*/ ctx[4]].x) * /*xPerPx*/ ctx[6] + /*gapX*/ ctx[7];
			if (dirty[0] & /*items, getComputedCols*/ 17) moveresize_changes.item = /*item*/ ctx[27][/*getComputedCols*/ ctx[4]];
			if (dirty[0] & /*items, getComputedCols*/ 17) moveresize_changes.min = /*item*/ ctx[27][/*getComputedCols*/ ctx[4]] && /*item*/ ctx[27][/*getComputedCols*/ ctx[4]].min;
			if (dirty[0] & /*items, getComputedCols*/ 17) moveresize_changes.max = /*item*/ ctx[27][/*getComputedCols*/ ctx[4]] && /*item*/ ctx[27][/*getComputedCols*/ ctx[4]].max;
			if (dirty[0] & /*getComputedCols*/ 16) moveresize_changes.cols = /*getComputedCols*/ ctx[4];
			if (dirty[0] & /*gapX*/ 128) moveresize_changes.gapX = /*gapX*/ ctx[7];
			if (dirty[0] & /*gapY*/ 256) moveresize_changes.gapY = /*gapY*/ ctx[8];
			if (dirty[0] & /*sensor*/ 8) moveresize_changes.sensor = /*sensor*/ ctx[3];
			if (dirty[0] & /*scroller*/ 4) moveresize_changes.container = /*scroller*/ ctx[2];
			if (dirty[0] & /*container*/ 32) moveresize_changes.nativeContainer = /*container*/ ctx[5];

			if (dirty[0] & /*$$scope, resizePointerDown, items, getComputedCols*/ 1075838993 | dirty[1] & /*movePointerDown*/ 1) {
				moveresize_changes.$$scope = { dirty, ctx };
			}

			moveresize.$set(moveresize_changes);
		},
		i(local) {
			if (current) return;
			transition_in(moveresize.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(moveresize.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(first);
			destroy_component(moveresize, detaching);
		}
	};
}

function create_fragment$$(ctx) {
	let div;
	let current;
	let if_block = (/*xPerPx*/ ctx[6] || !/*fastStart*/ ctx[1]) && create_if_block$s(ctx);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			attr(div, "class", "svlt-grid-container svelte-xmewc1");
			set_style(div, "height", /*containerHeight*/ ctx[9] + "px");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			/*div_binding*/ ctx[20](div);
			current = true;
		},
		p(ctx, dirty) {
			if (/*xPerPx*/ ctx[6] || !/*fastStart*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*xPerPx, fastStart*/ 66) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$s(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (!current || dirty[0] & /*containerHeight*/ 512) {
				set_style(div, "height", /*containerHeight*/ ctx[9] + "px");
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			/*div_binding*/ ctx[20](null);
		}
	};
}

function instance$_($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	const dispatch = createEventDispatcher();
	let { fillSpace = false } = $$props;
	let { items } = $$props;
	let { rowHeight } = $$props;
	let { cols } = $$props;
	let { gap = [10, 10] } = $$props;
	let { fastStart = false } = $$props;
	let { throttleUpdate = 100 } = $$props;
	let { throttleResize = 100 } = $$props;
	let { scroller } = $$props;
	let { sensor = 20 } = $$props;
	let getComputedCols;
	let container;
	let xPerPx = 0;
	let yPerPx = rowHeight;
	let containerWidth;

	const pointerup = ev => {
		dispatch("pointerup", { id: ev.detail.id, cols: getComputedCols });
	};

	const onResize = lodash_throttle(
		() => {
			dispatch("resize", {
				cols: getComputedCols,
				xPerPx,
				yPerPx,
				width: containerWidth
			});
		},
		throttleResize
	);

	onMount(() => {
		const sizeObserver = new ResizeObserver(entries => {
				let width = entries[0].contentRect.width;
				if (width === containerWidth) return;
				$$invalidate(4, getComputedCols = getColumn(width, cols));
				$$invalidate(6, xPerPx = width / getComputedCols);

				if (!containerWidth) {
					dispatch("mount", {
						cols: getComputedCols,
						xPerPx,
						yPerPx, // same as rowHeight
						
					});
				} else {
					onResize();
				}

				containerWidth = width;
			});

		sizeObserver.observe(container);
		return () => sizeObserver.disconnect();
	});

	const updateMatrix = ({ detail }) => {
		let activeItem = getItemById(detail.id, items);

		if (activeItem) {
			activeItem = {
				...activeItem,
				[getComputedCols]: {
					...activeItem[getComputedCols],
					...detail.shadow
				}
			};

			if (fillSpace) {
				$$invalidate(0, items = moveItemsAroundItem(activeItem, items, getComputedCols, getItemById(detail.id, items)));
			} else {
				$$invalidate(0, items = moveItem$1(activeItem, items, getComputedCols, getItemById(detail.id, items)));
			}

			if (detail.onUpdate) detail.onUpdate();

			dispatch("change", {
				unsafeItem: activeItem,
				id: activeItem.id,
				cols: getComputedCols
			});
		}
	};

	const handleRepaint = lodash_throttle(updateMatrix, throttleUpdate);

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			container = $$value;
			$$invalidate(5, container);
		});
	}

	$$self.$$set = $$props => {
		if ("fillSpace" in $$props) $$invalidate(13, fillSpace = $$props.fillSpace);
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
		if ("rowHeight" in $$props) $$invalidate(14, rowHeight = $$props.rowHeight);
		if ("cols" in $$props) $$invalidate(15, cols = $$props.cols);
		if ("gap" in $$props) $$invalidate(16, gap = $$props.gap);
		if ("fastStart" in $$props) $$invalidate(1, fastStart = $$props.fastStart);
		if ("throttleUpdate" in $$props) $$invalidate(17, throttleUpdate = $$props.throttleUpdate);
		if ("throttleResize" in $$props) $$invalidate(18, throttleResize = $$props.throttleResize);
		if ("scroller" in $$props) $$invalidate(2, scroller = $$props.scroller);
		if ("sensor" in $$props) $$invalidate(3, sensor = $$props.sensor);
		if ("$$scope" in $$props) $$invalidate(21, $$scope = $$props.$$scope);
	};

	let gapX;
	let gapY;
	let containerHeight;

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*gap*/ 65536) {
			 $$invalidate(7, [gapX, gapY] = gap, gapX, ($$invalidate(8, gapY), $$invalidate(16, gap)));
		}

		if ($$self.$$.dirty[0] & /*items, getComputedCols*/ 17) {
			 $$invalidate(9, containerHeight = getContainerHeight(items, yPerPx, getComputedCols));
		}
	};

	return [
		items,
		fastStart,
		scroller,
		sensor,
		getComputedCols,
		container,
		xPerPx,
		gapX,
		gapY,
		containerHeight,
		yPerPx,
		pointerup,
		handleRepaint,
		fillSpace,
		rowHeight,
		cols,
		gap,
		throttleUpdate,
		throttleResize,
		slots,
		div_binding,
		$$scope
	];
}

class Src extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-xmewc1-style")) add_css$Q();

		init(
			this,
			options,
			instance$_,
			create_fragment$$,
			safe_not_equal,
			{
				fillSpace: 13,
				items: 0,
				rowHeight: 14,
				cols: 15,
				gap: 16,
				fastStart: 1,
				throttleUpdate: 17,
				throttleResize: 18,
				scroller: 2,
				sensor: 3
			},
			[-1, -1]
		);
	}
}

/* src/pages/playground/index.svelte generated by Svelte v3.31.0 */

const { document: document_1$5 } = globals;

function add_css$R() {
	var style = element("style");
	style.id = "svelte-bkvrlg-style";
	style.textContent = ".container.svelte-bkvrlg{height:100%;width:100%;display:grid;grid-template-columns:auto 1fr;grid-template-rows:auto 1fr;grid-template-areas:\"sidebar settings\"\n      \"sidebar layout\"}.sidebar-container.svelte-bkvrlg{background:#151515;grid-area:sidebar;height:100%}.sidebar-container-light.svelte-bkvrlg{background:white;grid-area:sidebar;height:100%}.settings-container.svelte-bkvrlg{background:#151515;grid-area:settings;height:100%;width:auto}.settings-container-light.svelte-bkvrlg{background:white;grid-area:settings;height:100%;width:auto}.dashboard-container.svelte-bkvrlg{grid-area:layout;width:100%;z-index:0}.dashboard-container-dark.svelte-bkvrlg{background:#212121}.dashboard-container-light.svelte-bkvrlg{background:#d1d1d1}.upload-overlay-container.svelte-bkvrlg{grid-area:layout;z-index:1000;background-color:rgba(16,12,12,0.8);visibility:hidden;width:100%;font-size:16px}.mouse-overlay-container.svelte-bkvrlg{grid-area:layout;z-index:1000;background-color:rgba(16,12,12,0.8);visibility:visible;width:100%;font-size:16px;visibility:hidden}body{margin:0}.svlt-grid-resizer{z-index:1500}.svlt-grid-resizer::after{border-color:white !important}.svlt-grid-container{height:auto !important}.svlt-grid-transition > .svlt-grid-item{transition:transform 0.2s}.svlt-grid-shadow{background:rgba(25, 25, 25, 0.6) !important;border:solid 3.5em rgba(#151515, .5);border-radius:4px;border-bottom-right-radius:3px;transition:transform 0.2s}.svlt-grid-item{display:grid;grid-template-columns:auto 1fr auto;grid-template-rows:auto 1fr}.chrome.svelte-bkvrlg{grid-row:1/1;grid-column:1/3;display:grid;position:relative;padding:0.2em 0.1em 0.1em 0.1em;z-index:1500}.move.svelte-bkvrlg{text-shadow:1px 1px 1px #000000;font-size:1.2em;position:absolute;padding:0em 0.3em ;cursor:move;color:lightgray;grid-column:1/1}.item-header-type.svelte-bkvrlg{grid-column:2/2}.close.svelte-bkvrlg{grid-column:3/2;position:absolute;top:0;right:0;padding:0.1em 0.3em 0.1em 0.1em;cursor:pointer;text-shadow:1px 1px 1px #000000}.close-overlay.svelte-bkvrlg{position:absolute;right:0;padding:0.1em 0.3em 0.1em 0.1em;cursor:pointer;text-shadow:1px 1px 1px #000000}.content.svelte-bkvrlg{grid-row:2/2;grid-column:1/3;width:100%;height:100%;border-radius:0px;border-top-left-radius:0px;border-bottom-right-radius:0px;overflow-y:hidden}.scrollable.svelte-bkvrlg{flex:1 1 auto;margin:0 0 0.5em 0;overflow-y:auto}path.svelte-bkvrlg{fill:white}";
	append(document_1$5.head, style);
}

// (549:35) 
function create_if_block_2$6(ctx) {
	let save;
	let current;
	save = new Save({});

	return {
		c() {
			create_component(save.$$.fragment);
		},
		m(target, anchor) {
			mount_component(save, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(save.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(save.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(save, detaching);
		}
	};
}

// (547:37) 
function create_if_block_1$i(ctx) {
	let delete_1;
	let current;
	delete_1 = new Delete({});

	return {
		c() {
			create_component(delete_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(delete_1, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(delete_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(delete_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(delete_1, detaching);
		}
	};
}

// (545:2) {#if $isUploadOverlayVisible }
function create_if_block$t(ctx) {
	let upload;
	let current;
	upload = new Upload({});

	return {
		c() {
			create_component(upload.$$.fragment);
		},
		m(target, anchor) {
			mount_component(upload, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(upload.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(upload.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(upload, detaching);
		}
	};
}

// (568:4) <Grid       bind:items={ $items }       { cols }       { rowHeight }       { gap }       fastStart={ $fastStart }       on:adjust={ onAdjust }       on:mount={ onChildMount }       let:item       let:dataItem       scroller={ container }       fillSpace={ fillFree }       >
function create_default_slot$q(ctx) {
	let div2;
	let div0;
	let t0;
	let div1;
	let span0;
	let t1_value = /*dataItem*/ ctx[39].data.type + "";
	let t1;
	let t2;
	let span1;
	let t4;
	let div3;
	let switch_instance;
	let current;
	let mounted;
	let dispose;

	function click_handler_1() {
		return /*click_handler_1*/ ctx[18](/*dataItem*/ ctx[39]);
	}

	const switch_instance_spread_levels = [{ class: "component" }, /*dataItem*/ ctx[39].data];

	function change_handler(...args) {
		return /*change_handler*/ ctx[19](/*dataItem*/ ctx[39], ...args);
	}

	var switch_value = /*dataItem*/ ctx[39].data.component;

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props());
		switch_instance.$on("change", change_handler);
	}

	return {
		c() {
			div2 = element("div");
			div0 = element("div");

			div0.innerHTML = `<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 489.9 489.9" style="enable-background:new 0 0 489.9 489.9;" xml:space="preserve" width="16px"><g><g><path d="M406.2,173.55c-4.8,4.8-4.8,12.5,0,17.3l41.8,41.8H333.3v-63.9c0-6.8-5.5-12.3-12.3-12.3h-63.9V41.85l41.8,41.8
                    c2.4,2.4,5.5,3.6,8.7,3.6s6.3-1.2,8.7-3.6c4.8-4.8,4.8-12.5,0-17.3l-62.7-62.7c-2.3-2.3-5.4-3.6-8.7-3.6s-6.4,1.3-8.7,3.6
                    l-62.7,62.7c-4.8,4.8-4.8,12.5,0,17.3s12.5,4.8,17.3,0l41.8-41.8v114.7h-63.9c-6.8,0-12.3,5.5-12.3,12.3v63.9H41.8l41.8-41.8
                    c4.8-4.8,4.8-12.5,0-17.3s-12.5-4.8-17.3,0l-62.7,62.7c-4.8,4.8-4.8,12.5,0,17.3l62.7,62.7c2.4,2.4,5.5,3.6,8.7,3.6
                    s6.3-1.2,8.7-3.6c4.8-4.8,4.8-12.5,0-17.3l-41.8-41.8h114.7v63.9c0,6.8,5.5,12.3,12.3,12.3h63.9v114.7l-41.9-41.9
                    c-4.8-4.8-12.5-4.8-17.3,0s-4.8,12.5,0,17.3l62.7,62.7c2.3,2.3,5.4,3.6,8.7,3.6s6.4-1.3,8.7-3.6l62.7-62.7
                    c4.8-4.8,4.8-12.5,0-17.3s-12.5-4.8-17.3,0l-41.8,41.8v-114.7h63.9c6.8,0,12.3-5.5,12.3-12.3v-63.9h114.7l-42,41.8
                    c-4.8,4.8-4.8,12.5,0,17.3c2.4,2.4,5.5,3.6,8.7,3.6s6.3-1.2,8.7-3.6l62.7-62.7c2.3-2.3,3.6-5.4,3.6-8.7s-1.3-6.4-3.6-8.7
                    l-62.7-62.7C418.7,168.75,411,168.75,406.2,173.55z M308.8,308.85H181v-127.8h127.8L308.8,308.85L308.8,308.85z" class="svelte-bkvrlg"></path></g></g></svg>`;

			t0 = space();
			div1 = element("div");
			span0 = element("span");
			t1 = text$1(t1_value);
			t2 = space();
			span1 = element("span");
			span1.textContent = "";
			t4 = space();
			div3 = element("div");
			if (switch_instance) create_component(switch_instance.$$.fragment);
			attr(div0, "class", "move svelte-bkvrlg");
			attr(div1, "class", "item-header-type svelte-bkvrlg");
			attr(span1, "class", "close svelte-bkvrlg");
			attr(div2, "class", "chrome svelte-bkvrlg");
			set_style(div2, "background", "rgba(25, 25, 25, 0.6)");
			attr(div3, "class", "content svelte-bkvrlg");

			set_style(div3, "background", /*item*/ ctx[38].fixed
			? "#bka"
			: /*dataItem*/ ctx[39].data.background);
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div0);
			append(div2, t0);
			append(div2, div1);
			append(div1, span0);
			append(span0, t1);
			append(div2, t2);
			append(div2, span1);
			insert(target, t4, anchor);
			insert(target, div3, anchor);

			if (switch_instance) {
				mount_component(switch_instance, div3, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen(span1, "click", click_handler_1),
					listen(div3, "pointerdown", pointerdown_handler)
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if ((!current || dirty[1] & /*dataItem*/ 256) && t1_value !== (t1_value = /*dataItem*/ ctx[39].data.type + "")) set_data(t1, t1_value);

			const switch_instance_changes = (dirty[1] & /*dataItem*/ 256)
			? get_spread_update(switch_instance_spread_levels, [
					switch_instance_spread_levels[0],
					get_spread_object(/*dataItem*/ ctx[39].data)
				])
			: {};

			if (switch_value !== (switch_value = /*dataItem*/ ctx[39].data.component)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props());
					switch_instance.$on("change", change_handler);
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, div3, null);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}

			if (!current || dirty[1] & /*item, dataItem*/ 384) {
				set_style(div3, "background", /*item*/ ctx[38].fixed
				? "#bka"
				: /*dataItem*/ ctx[39].data.background);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div2);
			if (detaching) detach(t4);
			if (detaching) detach(div3);
			if (switch_instance) destroy_component(switch_instance);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$10(ctx) {
	let t0;
	let div5;
	let div0;
	let sidebar;
	let div0_class_value;
	let div0_style_value;
	let t1;
	let div1;
	let span;
	let t3;
	let current_block_type_index;
	let if_block;
	let t4;
	let div2;
	let t5;
	let div3;
	let settings;
	let div3_class_value;
	let t6;
	let div4;
	let grid_1;
	let updating_items;
	let div4_class_value;
	let current;
	let mounted;
	let dispose;
	sidebar = new Sidebar({});
	const if_block_creators = [create_if_block$t, create_if_block_1$i, create_if_block_2$6];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*$isUploadOverlayVisible*/ ctx[2]) return 0;
		if (/*$isDeleteOverlayVisible*/ ctx[4]) return 1;
		if (/*$isSaveOverlayVisible*/ ctx[3]) return 2;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	settings = new Settings({});

	function grid_1_items_binding(value) {
		/*grid_1_items_binding*/ ctx[20].call(null, value);
	}

	let grid_1_props = {
		cols: /*cols*/ ctx[10],
		rowHeight,
		gap: /*gap*/ ctx[11],
		fastStart: /*$fastStart*/ ctx[8],
		scroller: /*container*/ ctx[0],
		fillSpace: /*fillFree*/ ctx[9],
		$$slots: {
			default: [
				create_default_slot$q,
				({ item, dataItem }) => ({ 38: item, 39: dataItem }),
				({ item, dataItem }) => [0, (item ? 128 : 0) | (dataItem ? 256 : 0)]
			]
		},
		$$scope: { ctx }
	};

	if (/*$items*/ ctx[1] !== void 0) {
		grid_1_props.items = /*$items*/ ctx[1];
	}

	grid_1 = new Src({ props: grid_1_props });
	binding_callbacks.push(() => bind(grid_1, "items", grid_1_items_binding));
	grid_1.$on("adjust", /*onAdjust*/ ctx[15]);
	grid_1.$on("mount", /*onChildMount*/ ctx[16]);

	return {
		c() {
			t0 = space();
			div5 = element("div");
			div0 = element("div");
			create_component(sidebar.$$.fragment);
			t1 = space();
			div1 = element("div");
			span = element("span");
			span.textContent = "";
			t3 = space();
			if (if_block) if_block.c();
			t4 = space();
			div2 = element("div");
			t5 = space();
			div3 = element("div");
			create_component(settings.$$.fragment);
			t6 = space();
			div4 = element("div");
			create_component(grid_1.$$.fragment);
			document_1$5.title = "Sema  Playground";

			attr(div0, "class", div0_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[5] === "dark"
			? "sidebar-container"
			: "sidebar-container-light") + " svelte-bkvrlg"));

			attr(div0, "style", div0_style_value = /*$sideBarVisible*/ ctx[6]
			? "width: auto; visibility: visible;"
			: "width: 0px; visibility: hidden;");

			attr(span, "class", "close-overlay svelte-bkvrlg");
			attr(div1, "class", "upload-overlay-container svelte-bkvrlg");

			set_style(div1, "visibility", /*$isUploadOverlayVisible*/ ctx[2] || /*$isDeleteOverlayVisible*/ ctx[4] || /*$isSaveOverlayVisible*/ ctx[3]
			? "visible"
			: "hidden");

			attr(div2, "class", "mouse-overlay-container svelte-bkvrlg");
			set_style(div2, "visibility", /*$isMouseOverlayVisible*/ ctx[7] ? "visible" : "hidden");

			attr(div3, "class", div3_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[5] === "dark"
			? "settings-container"
			: "settings-container-light") + " svelte-bkvrlg"));

			attr(div4, "class", div4_class_value = "dashboard-container " + (/*$siteMode*/ ctx[5] === "dark"
			? "dashboard-container-dark"
			: "dashboard-container-light") + "  scrollable" + " svelte-bkvrlg");

			attr(div5, "class", "container svelte-bkvrlg");
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, div5, anchor);
			append(div5, div0);
			mount_component(sidebar, div0, null);
			append(div5, t1);
			append(div5, div1);
			append(div1, span);
			append(div1, t3);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(div1, null);
			}

			append(div5, t4);
			append(div5, div2);
			append(div5, t5);
			append(div5, div3);
			mount_component(settings, div3, null);
			append(div5, t6);
			append(div5, div4);
			mount_component(grid_1, div4, null);
			/*div4_binding*/ ctx[21](div4);
			current = true;

			if (!mounted) {
				dispose = listen(span, "click", /*click_handler*/ ctx[17]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (!current || dirty[0] & /*$siteMode*/ 32 && div0_class_value !== (div0_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[5] === "dark"
			? "sidebar-container"
			: "sidebar-container-light") + " svelte-bkvrlg"))) {
				attr(div0, "class", div0_class_value);
			}

			if (!current || dirty[0] & /*$sideBarVisible*/ 64 && div0_style_value !== (div0_style_value = /*$sideBarVisible*/ ctx[6]
			? "width: auto; visibility: visible;"
			: "width: 0px; visibility: hidden;")) {
				attr(div0, "style", div0_style_value);
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index !== previous_block_index) {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(div1, null);
				} else {
					if_block = null;
				}
			}

			if (!current || dirty[0] & /*$isUploadOverlayVisible, $isDeleteOverlayVisible, $isSaveOverlayVisible*/ 28) {
				set_style(div1, "visibility", /*$isUploadOverlayVisible*/ ctx[2] || /*$isDeleteOverlayVisible*/ ctx[4] || /*$isSaveOverlayVisible*/ ctx[3]
				? "visible"
				: "hidden");
			}

			if (!current || dirty[0] & /*$isMouseOverlayVisible*/ 128) {
				set_style(div2, "visibility", /*$isMouseOverlayVisible*/ ctx[7] ? "visible" : "hidden");
			}

			if (!current || dirty[0] & /*$siteMode*/ 32 && div3_class_value !== (div3_class_value = "" + (null_to_empty(/*$siteMode*/ ctx[5] === "dark"
			? "settings-container"
			: "settings-container-light") + " svelte-bkvrlg"))) {
				attr(div3, "class", div3_class_value);
			}

			const grid_1_changes = {};
			if (dirty[0] & /*$fastStart*/ 256) grid_1_changes.fastStart = /*$fastStart*/ ctx[8];
			if (dirty[0] & /*container*/ 1) grid_1_changes.scroller = /*container*/ ctx[0];

			if (dirty[1] & /*$$scope, item, dataItem*/ 896) {
				grid_1_changes.$$scope = { dirty, ctx };
			}

			if (!updating_items && dirty[0] & /*$items*/ 2) {
				updating_items = true;
				grid_1_changes.items = /*$items*/ ctx[1];
				add_flush_callback(() => updating_items = false);
			}

			grid_1.$set(grid_1_changes);

			if (!current || dirty[0] & /*$siteMode*/ 32 && div4_class_value !== (div4_class_value = "dashboard-container " + (/*$siteMode*/ ctx[5] === "dark"
			? "dashboard-container-dark"
			: "dashboard-container-light") + "  scrollable" + " svelte-bkvrlg")) {
				attr(div4, "class", div4_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(sidebar.$$.fragment, local);
			transition_in(if_block);
			transition_in(settings.$$.fragment, local);
			transition_in(grid_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(sidebar.$$.fragment, local);
			transition_out(if_block);
			transition_out(settings.$$.fragment, local);
			transition_out(grid_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(div5);
			destroy_component(sidebar);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}

			destroy_component(settings);
			destroy_component(grid_1);
			/*div4_binding*/ ctx[21](null);
			mounted = false;
			dispose();
		}
	};
}

let rowHeight = 100;
const pointerdown_handler = e => e.stopPropagation();

function instance$$($$self, $$props, $$invalidate) {
	let $focusedItem;
	let $focusedItemProperties;
	let $items;
	let $isUploadOverlayVisible;
	let $isSaveOverlayVisible;
	let $isDeleteOverlayVisible;
	let $siteMode;
	let $sideBarVisible;
	let $isMouseOverlayVisible;
	let $fastStart;
	component_subscribe($$self, focusedItem, $$value => $$invalidate(25, $focusedItem = $$value));
	component_subscribe($$self, focusedItemProperties, $$value => $$invalidate(26, $focusedItemProperties = $$value));
	component_subscribe($$self, items, $$value => $$invalidate(1, $items = $$value));
	component_subscribe($$self, isUploadOverlayVisible, $$value => $$invalidate(2, $isUploadOverlayVisible = $$value));
	component_subscribe($$self, isSaveOverlayVisible, $$value => $$invalidate(3, $isSaveOverlayVisible = $$value));
	component_subscribe($$self, isDeleteOverlayVisible, $$value => $$invalidate(4, $isDeleteOverlayVisible = $$value));
	component_subscribe($$self, siteMode, $$value => $$invalidate(5, $siteMode = $$value));
	component_subscribe($$self, sideBarVisible, $$value => $$invalidate(6, $sideBarVisible = $$value));
	component_subscribe($$self, isMouseOverlayVisible, $$value => $$invalidate(7, $isMouseOverlayVisible = $$value));
	component_subscribe($$self, fastStart, $$value => $$invalidate(8, $fastStart = $$value));
	let fillFree = true;
	let messaging = new PubSub();
	let controller = new Controller(); // this will return the previously created Singleton instance
	let engine = controller.engine;

	// Playground dashboard configuration
	let cols = [[2880, 12], [1600, 12], [1280, 8], [1024, 6], [800, 3], [500, 2]]; // over this rez is failling

	let gap = [2, 2];

	// Subscription tokens for messaging topic subscriptions
	// must be kept for unsubscribe on each route component onMount/onDestroy
	// (or navigations between tutorial/playground)
	let addSubscriptionToken;
	let unsubscribeItemsChangeCallback;

	// const unsubscribePlaygroundItemsCallback = items.subscribe(value => {
	//   console.log('Playground items changed');
	//   // await populateStoresWithFetchedProps(newItem);
	// });
	const setFocused = item => {
		if (item) {
			try {
				let itemProperties = [];

				if (item.data.type === "liveCodeEditor" || item.data.type === "grammarEditor" || item.data.type === "modelEditor") {
					itemProperties = [{ lineNumbers: item.data.lineNumbers }, { theme: item.data.theme }];

					// Order in item properties determines final order in interface
					// if( item.type === "liveCodeEditor" || item.type === "grammarEditor" ){
					//   itemProperties.push({ debug: true });
					// }
					if (item.data.type === "liveCodeEditor") {
						itemProperties.push({ grammar: item.data.grammar });
					}

					if (item.data.type === "modelEditor") {
						itemProperties.push({ restart: true });
						itemProperties.push({ visor: true });
					}
				} else if (item.data.type === "analyser") {
					itemProperties.push({ mode: item.data.mode });
				} else if (item.data.type === "visualiser") {
					itemProperties.push({ channelID: item.data.channelID });
				}

				item.data.hasFocus = true;
				set_store_value(focusedItem, $focusedItem = item, $focusedItem);
				set_store_value(focusedItemProperties, $focusedItemProperties = itemProperties, $focusedItemProperties);

				// set unfocused items through the rest of the list
				set_store_value(
					items,
					$items = $items.map(i => i === item
					? { ...i, ["hasFocus"]: true }
					: { ...i, ["hasFocus"]: false }),
					$items
				);
			} catch(error) {
				console.error("Error Playground.setFocused: setting item focuses"); // $items = $items.map(i => i === item ? { ...i, [e.detail.prop]: e.detail.value } : i)
			}

			
		} else console.error("Error Playground.setFocused: setting item focuses: empty item");
	};

	function setLayoutResponsiveness(item) {
		if (item && items && cols) {
			try {
				return {
					...item,
					...cols.reduce(
						(acc, obj) => {
							let col = obj[1]; // for each col config, get number of cols
							let findOutPosition = gridHelp.findSpace(item, $items, col);

							if (!acc[col]) {
								acc[col] = { ...item[col], ...findOutPosition };
							}

							return acc;
						},
						{}
					)
				};
			} catch(err) {
				console.error("Error setting layout responsiveness when adding new item");
			}
		} else throw new Error("Error setting layout responsiveness when adding new item");
	}

	async function addItem(e) {
		if (e.type) {
			try {
				let item = await createNewItem(e.type, e.data);
				await updateItemPropsWithFetchedValues(item);
				await populateCommonStoresWithFetchedProps(item);
				updateItemPropsWithCommonStoreValues(item);
				setFocused(item);
				const newItem = setLayoutResponsiveness(item);
				set_store_value(items, $items = [...$items, ...[newItem]], $items);
			} catch(error) {
				console.error("Error on routes/Playground.addItem", error); // console.log("DEBUG:playground:addItem:", newItem);
			}
		} else console.error("Error on routes/Playground.addItem: undefined parameters");
	}

	const update = (e, dataItem) => {
		try {
			if (e && e.detail && dataItem) {
				if (e.detail.prop === "content") {
					switch (dataItem.data.type) {
						case "liveCodeEditor":
							localStorage.liveCodeEditorValue = e.detail.value;
							break;
						case "grammarEditor":
							localStorage.grammarEditorValue = e.detail.value;
							break;
						case "modelEditor":
							localStorage.modelEditorValue = e.detail.value;
							break;
						default:
							break;
					}

					// Content update from CodeMirror update with 'content' prop and value
					dataItem.data[e.detail.prop] = e.detail.value;

					// Update item and items collection by filtering out version with old value and concating update version
					set_store_value(items, $items = [...$items.filter(i => i !== dataItem), ...[dataItem]], $items);
				} else if (e.detail.prop === "hasFocus") {
					setFocused(dataItem);
				}
			}
		} catch(error) {
			console.log(`Erro updating component: ${dataItem}`, error);
		}
	};

	const remove = item => {
		if (!engine) engine = new Engine$1();

		if (item.data.type === "analyser") {
			engine.removeAnalyser({ id: item.id });
		} // messaging.publish('remove-engine-analyser', { id: item.id }); // notify audio engine to remove associated analyser

		// console.log("DEBUG:dashboard:remove:", item);
		messaging.publish("plaground-item-deletion", item.data.type);

		remove.bind(null, item); // remove dashboard item binding
		delete item.component;
		set_store_value(items, $items = $items.filter(i => i.id !== item.id), $items);
	}; // console.log("DEBUG:dashboard:remove:");
	// console.log($items);

	const onClickCloseOverlay = () => {
		set_store_value(isUploadOverlayVisible, $isUploadOverlayVisible = set_store_value(isSaveOverlayVisible, $isSaveOverlayVisible = set_store_value(isDeleteOverlayVisible, $isDeleteOverlayVisible = false, $isDeleteOverlayVisible), $isSaveOverlayVisible), $isUploadOverlayVisible);
	};

	const onAdjust = e => {
		// console.log("DEBUG:dashboard:onAdjust:", e.detail);
		items.set($items); // call a re-render
	};

	const onChildMount = e => {
		// console.log("DEBUG:dashboard:onChildMount:", e.detail);
		items.set($items); // call a re-render
	};

	let container;

	onMount(async () => {
		console.log("Playground mount: ");

		// No need to create re-initialise controller again here
		if (!controller.initializing && !controller.samplesLoaded) // controller.init('http://localhost:5000/sema-engine');
		await controller.init(document.location.origin + "/sema-engine");

		console.log("Playground index: onMount ");

		// Sequentially fetch data from individual items' properties into language design workflow stores
		for (const item of $items) await updateItemPropsWithFetchedValues(item);

		for (const item of $items) await populateCommonStoresWithFetchedProps(item);
		for (const item of $items) updateItemPropsWithCommonStoreValues(item);
		addSubscriptionToken = messaging.subscribe("playground-add", e => addItem(e));

		unsubscribeItemsChangeCallback = items.subscribe(value => {
			
		}); //console.log('Playground items changed: ', value );
	});

	onDestroy(() => {
		if (controller) {
			controller.stop();
		}

		messaging.unsubscribe(addSubscriptionToken);

		// messaging.unsubscribe(resetSubscriptionToken);
		// unsubscribeItemsChangeCallback();
		resetStores();
	});

	const click_handler = () => onClickCloseOverlay();
	const click_handler_1 = dataItem => remove(dataItem);
	const change_handler = (dataItem, e) => update(e, dataItem);

	function grid_1_items_binding(value) {
		$items = value;
		items.set($items);
	}

	function div4_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			container = $$value;
			$$invalidate(0, container);
		});
	}

	return [
		container,
		$items,
		$isUploadOverlayVisible,
		$isSaveOverlayVisible,
		$isDeleteOverlayVisible,
		$siteMode,
		$sideBarVisible,
		$isMouseOverlayVisible,
		$fastStart,
		fillFree,
		cols,
		gap,
		update,
		remove,
		onClickCloseOverlay,
		onAdjust,
		onChildMount,
		click_handler,
		click_handler_1,
		change_handler,
		grid_1_items_binding,
		div4_binding
	];
}

class Playground extends SvelteComponent {
	constructor(options) {
		super();
		if (!document_1$5.getElementById("svelte-bkvrlg-style")) add_css$R();
		init(this, options, instance$$, create_fragment$10, safe_not_equal, {}, [-1, -1]);
	}
}

/* src/pages/samples/index.svelte generated by Svelte v3.31.0 */

function create_fragment$11(ctx) {
	let t;

	return {
		c() {
			t = text$1("samples list");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

class Samples extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, null, create_fragment$11, safe_not_equal, {});
	}
}

let liveCode = "";
let modelCode = "";
let grammarCode = "";

/*******                                        ********/
/*******     Tutorial Language Design Stores    ********/
/*******                                        ********/
/*******                                        ********/
/*******                                        ********/
/*******                                        ********/
/*******                                        ********/
/*******                                        ********/
/*******                                        ********/
/*******                                        ********/
/*******                                        ********/
/*******     Tutorial Dashboard Items Stores    ********/
/*******                                        ********/



const originalItems = [
	{
		...gridHelp.item({ x: 0, y: 0, w: 6, h: 7, id: id() }),
		...{
			type: "liveCodeEditor",
			name: "hello-world",
			background: "#151515",
			lineNumbers: true,
			hasFocus: false,
			background: "#151515",
			theme: "icecoder",
			component: LiveCodeEditor,
			data: liveCode,
			grammarSource: "/languages/default/grammar.ne",
		},
	},

	{
		...gridHelp.item({ x: 6, y: 0, w: 3, h: 2, id: id() }),
		...{
			name: "hello world",
			type: "analyser",
			lineNumbers: true,
			hasFocus: false,
			theme: "monokai",
			background: "#f0f0f0",
			component: Analyser,
			mode: "both",
		},
	},

	{
		...gridHelp.item({ x: 9, y: 0, w: 18, h: 3, id: id() }),
		...{
			name: "hello world",
			type: "modelEditor",
			lineNumbers: true,
			hasFocus: false,
			theme: "monokai",
			background: "#f0f0f0",
			component: ModelEditor,
			data: modelCode,
		},
	},

	{
		...gridHelp.item({ x: 6, y: 2, w: 3, h: 5, id: id() }),
		...{
			name: "hello world",
			type: "liveCodeParseOutput",
			lineNumbers: false,
			hasFocus: false,
			theme: "shadowfox",
			background: "#ebdeff",
			component: LiveCodeParseOutput,
			data: "",
		},
	},

	{
		...gridHelp.item({ x: 9, y: 3, w: 15, h: 3, id: id() }),
		...{
			name: "hello world",
			type: "grammarEditor",
			lineNumbers: true,
			hasFocus: false,
			theme: "monokai",
			background: "#AAAAAA",
			component: GrammarEditor,
			data: grammarCode,
		},
	},

	{
		...gridHelp.item({ x: 7, y: 7, w: 4, h: 30, id: id() }),
		...{
			name: "hello world",
			type: "storeInspector",
			lineNumbers: true,
			hasFocus: false,
			theme: "monokai",
			background: "#f0f0f0",
			component: StoreInspector,
			data: "",
		},
	},

	{
		...gridHelp.item({ x: 9, y: 6, w: 18, h: 1, id: id() }),
		...{
			name: "hello world",
			type: "grammarCompileOutput",
			lineNumbers: true,
			hasFocus: false,
			theme: "monokai",
			background: "#d1d5ff",
			component: GrammarCompileOutput,
			data: "",
		},
	},
];

const testItems$1 = [
	{
		...gridHelp.item({ x: 7, y: 0, w: 2, h: 1, id: id() }),
		...{
			type: "liveCodeEditor",
			name: "hello-world",
			background: "#151515",
			lineNumbers: true,
			hasFocus: false,
			background: "#151515",
			theme: "icecoder",
			component: LiveCodeEditor,
			data: "#lc-1",
			grammarSource: "/languages/default/grammar.ne"
		},
	},

	{
		...gridHelp.item({ x: 10, y: 2, w: 2, h: 1, id: id() }),
		...{
			name: "hello world",
			type: "grammarEditor",
			lineNumbers: true,
			hasFocus: false,
			theme: "monokai",
			background: "#AAAAAA",
			component: GrammarEditor,
			data: "#g-1",
		},
	},

	{
		...gridHelp.item({ x: 0, y: 4, w: 3, h: 1, id: id() }),
		...{
			name: "hello world",
			type: "modelEditor",
			lineNumbers: true,
			hasFocus: false,
			theme: "monokai",
			background: "#f0f0f0",
			component: ModelEditor,
			data: "//m-1\nsema.env.saveLocal('1')",
		},
	},

	{
		...gridHelp.item({ x: 0, y: 8, w: 1, h: 1, id: id() }),
		...{
			name: "hello world",
			type: "analyser",
			lineNumbers: true,
			hasFocus: false,
			theme: "monokai",
			background: "#f0f0f0",
			component: Analyser,
			mode: "spectrogram",
			data: "1",
		},
	},
];

// Store for tutorial options in Sidebar component
let tutorialOptions = [
	{
		id: 1,
		text: `Tutorial 1`,
		sections: [
			{
				slug: "basics",
				title: "Basics",
				chapter_dir: "01-basics",
				section_dir: "01-introduction",
			},
			{
				slug: "layout",
				title: "Layout",
				chapter_dir: "01-basics",
				section_dir: "02-layout",
			},
			{
				slug: "editors",
				title: "Editors",
				chapter_dir: "01-basics",
				section_dir: "03-editors",
			},
			{
				slug: "widgets",
				title: "Widgets",
				chapter_dir: "01-basics",
				section_dir: "04-widgets",
			},
		],
	},
];

function hydrateJSONcomponent$1 (item){
	if (
		item !== "undefined" &&
		item.data !== "undefined" &&
		item.data.type !== "undefined"
	) {
		switch (item.data.type) {
			case 'liveCodeEditor':
				item.data.component = LiveCodeEditor;
				break
			case 'grammarEditor':
				item.data.component = GrammarEditor;
				break
			case 'modelEditor':
				item.data.component = ModelEditor;
				break
			case 'liveCodeParseOutput':
				item.data.component = LiveCodeParseOutput;
				break
			case 'grammarCompileOutput':
				item.data.component = GrammarCompileOutput;
				break
			case 'storeInspector':
				item.data.component = StoreInspector;
				break
			case 'analyser':
				item.data.component = Analyser;
				break
			case 'console':
				item.data.component = Console;
				break
			case 'dspCode':
				item.data.component = DSPCode;
				break
		}
		if (item.id !== "undefined") {
			item.id = id();
			item.data.name = item.name + item.id;
		}
		return item;
	} else throw Error("hydrateJSONcomponent: undefined item");
	// } else {
	// 	createNewItem();
	// }
}


let tutorials = writable(tutorialOptions);
// export let tutorials = writable([]);

// Store for SELECTED tutorial options in Sidebar component
let selected = writable({});
// export let selected = storable("selectedTutorial", {}, false) ;

let items$1 = writable(testItems$1); // localStorageWrapper
// export let items = storable("tutorial", testItems, true); // localStorageWrapper

/* src/pages/tutorial/[chapter]/[section]/index.svelte generated by Svelte v3.31.0 */

const { document: document_1$6 } = globals;

function add_css$S() {
	var style = element("style");
	style.id = "svelte-1ilt945-style";
	style.textContent = "code{border-radius:4px;font-size:100%;background-color:white;color:black;padding:2px 4px 2px 4px;border:1px solid #CCCCCC}pre code{display:block;border-radius:4px;font-size:90%;background-color:white;color:black;padding:5px;border:1px solid #CCCCCC;margin:0px 0px 0px 0px}.markdown-section-container{overflow:auto;border-radius:5px;background:#999}";
	append(document_1$6.head, style);
}

// (165:0) {:catch error}
function create_catch_block$1(ctx) {
	let p;
	let t_value = /*error*/ ctx[9].message + "";
	let t;

	return {
		c() {
			p = element("p");
			t = text$1(t_value);
			set_style(p, "color", "red");
		},
		m(target, anchor) {
			insert(target, p, anchor);
			append(p, t);
		},
		p(ctx, dirty) {
			if (dirty & /*promise*/ 2 && t_value !== (t_value = /*error*/ ctx[9].message + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (163:0) {:then number}
function create_then_block$1(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			attr(div, "class", "markdown-output");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			div.innerHTML = /*markdown*/ ctx[0];
		},
		p(ctx, dirty) {
			if (dirty & /*markdown*/ 1) div.innerHTML = /*markdown*/ ctx[0];		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (161:16)   <p>...waiting</p> {:then number}
function create_pending_block$1(ctx) {
	let p;

	return {
		c() {
			p = element("p");
			p.textContent = "...waiting";
		},
		m(target, anchor) {
			insert(target, p, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

function create_fragment$12(ctx) {
	let div;
	let promise_1;

	let info = {
		ctx,
		current: null,
		token: null,
		hasCatch: true,
		pending: create_pending_block$1,
		then: create_then_block$1,
		catch: create_catch_block$1,
		value: 8,
		error: 9
	};

	handle_promise(promise_1 = /*promise*/ ctx[1], info);

	return {
		c() {
			div = element("div");
			info.block.c();
			attr(div, "class", "markdown-section-container");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			info.block.m(div, info.anchor = null);
			info.mount = () => div;
			info.anchor = null;
		},
		p(new_ctx, [dirty]) {
			ctx = new_ctx;
			info.ctx = ctx;

			if (dirty & /*promise*/ 2 && promise_1 !== (promise_1 = /*promise*/ ctx[1]) && handle_promise(promise_1, info)) ; else {
				const child_ctx = ctx.slice();
				child_ctx[8] = child_ctx[9] = info.resolved;
				info.block.p(child_ctx, dirty);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			info.block.d();
			info.token = null;
			info = null;
		}
	};
}

function instance$10($$self, $$props, $$invalidate) {
	let $params;
	let $items;
	component_subscribe($$self, params, $$value => $$invalidate(3, $params = $$value));
	component_subscribe($$self, items$1, $$value => $$invalidate(5, $items = $$value));
	let { section } = $$props; // we are grabbing this export variable value from Routify's file structure variable mechanism [chapter]/[section]
	let renderer = new marked.Renderer();

	renderer.link = function (href, title, text) {
		let link = marked.Renderer.prototype.link.apply(this, arguments);
		return link.replace("<a", "<a target='_blank'");
	};

	marked.setOptions({ renderer });
	let markdown;

	let fetchMarkdown = async (chapter, section) => {
		if (chapter !== undefined && section !== undefined) {
			let res, text;

			try {
				res = await fetch(document.location.origin + `/tutorial/${chapter}/${section}/index.md`);
				text = await res.text();
				let json = await fetch(document.location.origin + `/tutorial/${$params.chapter}/${$params.section}/layout.json`).then(r => r.json());
				set_store_value(items$1, $items = json.map(item => hydrateJSONcomponent$1(item)), $items);

				for (const item of $items) {
					await updateItemPropsWithFetchedValues(item);
					await populateCommonStoresWithFetchedProps(item);
					updateItemPropsWithCommonStoreValues(item);
				}
			} catch(error) {
				console.error("Error loading tutorial environment", error);
			}

			// await tick();
			if (res.ok) {
				$$invalidate(0, markdown = marked(text));

				// console.log(markdown);
				let codeID = 0;

				while (markdown.indexOf("<pre><code>") > -1) {
					$$invalidate(0, markdown = markdown.replace("<pre><code>", `<pre style="margin-top:-25px">
              <button style="font-size:70%; text-align: center; float: right; z-index: 1000; top: 30px; position: relative;" type="button" onclick="copyCode('code${codeID}')">copy</button>
              <code style="-moz-user-select: text; -html-user-select: text; -webkit-user-select: text; -ms-user-select: text; user-select: text; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word;" id='code${codeID++}'>`));
				} // markdown = markdown.replace(
				//   "<pre><code>",

				//   `<pre><code style="-moz-user-select: text; -khtml-user-select: text; -webkit-user-select: text; -ms-user-select: text; user-select: text; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word;" id='code${codeID++}'>`
				// );
				
			} else {
				console.error("Error on markdown conversion", error); // markdown="test";
				
			}
		}
	};

	onMount(async () => {
		console.log("tutorial - chapter section");
		for (const item of $items) await populateCommonStoresWithFetchedProps(item);
		console.log(`DEBUG:tutorial/${$params.chapter}/${$params.section}/ index`);
	}); // promise = fetchMarkdown($selected.chapter_dir, $selected.section_dir); // Reactive statement, var 'promise' reacts to 'section' changes

	onDestroy(() => {
		set_store_value(items$1, $items = [], $items);
		resetStores();
	}); // console.log("DEBUG:routes/tutorial/_layout:onDestroy")

	$$self.$$set = $$props => {
		if ("section" in $$props) $$invalidate(2, section = $$props.section);
	};

	let promise;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$params*/ 8) {
			 $$invalidate(1, promise = fetchMarkdown($params.chapter, $params.section)); // Reactive statement, var 'promise' reacts to 'section' changes
		}
	};

	return [markdown, promise, section, $params];
}

class U5Bsectionu5D extends SvelteComponent {
	constructor(options) {
		super();
		if (!document_1$6.getElementById("svelte-1ilt945-style")) add_css$S();
		init(this, options, instance$10, create_fragment$12, safe_not_equal, { section: 2 });
	}
}

/* src/pages/tutorial/index.svelte generated by Svelte v3.31.0 */

const { document: document_1$7 } = globals;

function add_css$T() {
	var style = element("style");
	style.id = "svelte-1egnf73-style";
	style.textContent = ".markdown-index-container{overflow:auto;border-radius:5px;background:#999}.markdown-output{padding:0em 0.6em 0em 0.5em}";
	append(document_1$7.head, style);
}

// (91:0) {:catch error}
function create_catch_block$2(ctx) {
	let p;
	let t_value = /*error*/ ctx[6].message + "";
	let t;

	return {
		c() {
			p = element("p");
			t = text$1(t_value);
			set_style(p, "color", "red");
		},
		m(target, anchor) {
			insert(target, p, anchor);
			append(p, t);
		},
		p(ctx, dirty) {
			if (dirty & /*promise*/ 1 && t_value !== (t_value = /*error*/ ctx[6].message + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (89:0) {:then number}
function create_then_block$2(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			attr(div, "class", "markdown-output");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			div.innerHTML = /*markdown*/ ctx[1];
		},
		p(ctx, dirty) {
			if (dirty & /*markdown*/ 2) div.innerHTML = /*markdown*/ ctx[1];		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (87:16)   <p>...waiting</p> {:then number}
function create_pending_block$2(ctx) {
	let p;

	return {
		c() {
			p = element("p");
			p.textContent = "...waiting";
		},
		m(target, anchor) {
			insert(target, p, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

function create_fragment$13(ctx) {
	let div;
	let promise_1;

	let info = {
		ctx,
		current: null,
		token: null,
		hasCatch: true,
		pending: create_pending_block$2,
		then: create_then_block$2,
		catch: create_catch_block$2,
		value: 5,
		error: 6
	};

	handle_promise(promise_1 = /*promise*/ ctx[0], info);

	return {
		c() {
			div = element("div");
			info.block.c();
			attr(div, "class", "markdown-index-container");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			info.block.m(div, info.anchor = null);
			info.mount = () => div;
			info.anchor = null;
		},
		p(new_ctx, [dirty]) {
			ctx = new_ctx;
			info.ctx = ctx;

			if (dirty & /*promise*/ 1 && promise_1 !== (promise_1 = /*promise*/ ctx[0]) && handle_promise(promise_1, info)) ; else {
				const child_ctx = ctx.slice();
				child_ctx[5] = child_ctx[6] = info.resolved;
				info.block.p(child_ctx, dirty);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			info.block.d();
			info.token = null;
			info = null;
		}
	};
}

function instance$11($$self, $$props, $$invalidate) {
	let $selected;
	component_subscribe($$self, selected, $$value => $$invalidate(2, $selected = $$value));
	let controller = new Controller(); // this will return the previously created Singleton instance

	// export let section; // we are grabbing this export variable value from Routify's file structure variable mechanism [chapter]/[section]
	let promise;

	let markdown;

	let fetchMarkdown = async (chapter, section) => {
		if (chapter != undefined && section != undefined) {
			// There is a call with undefined value when navigating to Playground
			const res = await fetch(document.location.origin + `/tutorial/${chapter}/${section}/index.md`);

			const text = await res.text();

			// console.log(`DEBUG:[/${chapter}]/[${section}]:fetchMarkdown: `, text);
			// await tick();
			if (res.ok) {
				marked.setOptions({ renderer: new marked.Renderer() });
				$$invalidate(1, markdown = marked(text));
			} else {
				throw new Error(text);
			}
		}
	};

	onMount(async () => {
		console.log("tutorial - index");
		localStorage.setItem("tutorial-reloaded", true);

		if (!controller.samplesLoaded) // controller.init('http://localhost:5000/sema-engine');
		controller.init(document.location.origin + "/sema-engine");

		$$invalidate(0, promise = fetchMarkdown($selected.chapter_dir, $selected.section_dir)); // Reactive statement, var 'promise' reacts to 'section' changes
	}); // console.log(`index:url:${$params.chapter}:params:${$params.section}}`);
	// console.log($url())

	onDestroy(() => {
		if (controller) {
			controller.stop();
		}
	});

	return [promise, markdown];
}

class Tutorial extends SvelteComponent {
	constructor(options) {
		super();
		if (!document_1$7.getElementById("svelte-1egnf73-style")) add_css$T();
		init(this, options, instance$11, create_fragment$13, safe_not_equal, {});
	}
}

/* src/pages/tutorial/_layout.svelte generated by Svelte v3.31.0 */

const { document: document_1$8 } = globals;

function add_css$U() {
	var style = element("style");
	style.id = "svelte-1wnzjyo-style";
	style.textContent = ".container{width:100%;height:100%;display:grid;grid-template-columns:auto 1fr;grid-template-rows:auto 1fr;grid-template-areas:\"sidebar settings\"\n  \t\t\"sidebar layout\";overflow:hidden}.container-dark{background:#151515}.container-light{background:#151515}.tutorial-sidebar-container{grid-area:sidebar;height:100%;min-width:15em;max-width:22em;padding-left:0.1em;padding-right:0.2em}.settings-container{grid-area:settings;height:100%;width:auto}.settings-container-light{background:white;grid-area:settings;height:100%;width:auto}.tutorial-navigator{display:grid;grid-template-columns:auto auto auto;width:100%;padding-right:0.3em;margin-bottom:0.05em}.chrome{grid-row:1/1;grid-column:1/3;display:grid;position:relative;padding:0.2em 0.1em 0.1em 0.1em;z-index:1500}.item-header-type{grid-column:2/2}.content{grid-row:2/2;grid-column:1/3;width:100%;height:100%;border-radius:0px;border-top-left-radius:0px;border-bottom-right-radius:0px;overflow-y:hidden}.markdown-container{height:calc(100vh - 86px);padding-left:0.1em;padding-right:0.1em;border-radius:5px;overflow-y:scroll}.tutorial-dashboard-container{grid-area:layout;height:100%;overflow:hidden;margin-left:0.2em}.combobox-dark{border:0}.mouse-overlay-container{grid-area:layout;z-index:1000;background-color:rgba(16,12,12,0.8);visibility:visible;width:100%;display:flex;justify-content:center;align-items:center;font-size:16px;visibility:hidden}.combobox-dark select{width:100%;height:2.5em;display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:#fff;line-height:1.3;padding:0.7em 1em 0.7em 1em;max-width:100%;box-sizing:border-box;border:0 solid #333;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;-webkit-box-shadow:5px 5px 20px -5px rgba(0,0,0,0.75), -5px -5px 20px rgba(255, 255, 255, 0.954);-moz-box-shadow:5px 5px 20px -5px rgba(0,0,0,0.75), -5px -5px 20px rgba(255, 255, 255, 0.954);box-shadow:-1px -1px 3px #ffffff61, 2px 2px 3px rgb(0, 0, 0) }.combobox-dark select optgroup{color:black}.button-dark{width:2.5em;height:2.5em;padding:0.7em 1em 0.7em 1em;display:block;font-size:medium;font-family:sans-serif;font-weight:400;cursor:pointer;color:#fff;line-height:1.3;max-width:100%;box-sizing:border-box;border:0 solid #333;border-radius:.6em;-moz-appearance:none;-webkit-appearance:none;appearance:none;background-color:rgba(16, 16, 16, 0.04);background-repeat:no-repeat, repeat;background-position:right .7em top 50%, 0 0;background-size:.65em auto, 100%;-webkit-box-shadow:2px 2px 5px rgba(0,0,0),-1px -1px 1px rgb(34, 34, 34);-moz-box-shadow:2px 2px 5px rgba(0,0,0), -1px -1px 1px rgb(34, 34, 34);box-shadow:2px 2px 3px rgb(0, 0, 0), -1px -1px 3px #ffffff61}.left{grid-column:1}.middle{margin-left:4px;margin-right:4px;grid-column:2}.right{grid-column:3}";
	append(document_1$8.head, style);
}

const get_default_slot_changes$3 = dirty => ({ scoped: dirty & /*$selected*/ 4 });
const get_default_slot_context$3 = ctx => ({ scoped: /*$selected*/ ctx[2] });

function get_each_context$h(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[23] = list[i];
	child_ctx[25] = i;
	return child_ctx;
}

function get_each_context_1$4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[26] = list[i];
	child_ctx[25] = i;
	return child_ctx;
}

// (154:10) {#if $tutorials !== undefined}
function create_if_block$u(ctx) {
	let each_1_anchor;
	let each_value = /*$tutorials*/ ctx[3];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$h(get_each_context$h(ctx, each_value, i));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*$tutorials, undefined*/ 8) {
				each_value = /*$tutorials*/ ctx[3];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$h(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$h(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (157:16) {#if chapter.sections !== undefined}
function create_if_block_1$j(ctx) {
	let each_1_anchor;
	let each_value_1 = /*chapter*/ ctx[23].sections;
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*$tutorials*/ 8) {
				each_value_1 = /*chapter*/ ctx[23].sections;
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$4(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1$4(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (158:18) {#each chapter.sections as section, i}
function create_each_block_1$4(ctx) {
	let option;
	let t_value = /*section*/ ctx[26].title + "";
	let t;
	let option_value_value;

	return {
		c() {
			option = element("option");
			t = text$1(t_value);
			option.__value = option_value_value = /*section*/ ctx[26];
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(ctx, dirty) {
			if (dirty & /*$tutorials*/ 8 && t_value !== (t_value = /*section*/ ctx[26].title + "")) set_data(t, t_value);

			if (dirty & /*$tutorials*/ 8 && option_value_value !== (option_value_value = /*section*/ ctx[26])) {
				option.__value = option_value_value;
				option.value = option.__value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (155:12) {#each $tutorials as chapter, i}
function create_each_block$h(ctx) {
	let optgroup;
	let optgroup_label_value;
	let if_block = /*chapter*/ ctx[23].sections !== undefined && create_if_block_1$j(ctx);

	return {
		c() {
			optgroup = element("optgroup");
			if (if_block) if_block.c();
			attr(optgroup, "label", optgroup_label_value = "" + (/*i*/ ctx[25] + 1 + ". " + /*chapter*/ ctx[23].title));
		},
		m(target, anchor) {
			insert(target, optgroup, anchor);
			if (if_block) if_block.m(optgroup, null);
		},
		p(ctx, dirty) {
			if (/*chapter*/ ctx[23].sections !== undefined) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$j(ctx);
					if_block.c();
					if_block.m(optgroup, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*$tutorials*/ 8 && optgroup_label_value !== (optgroup_label_value = "" + (/*i*/ ctx[25] + 1 + ". " + /*chapter*/ ctx[23].title))) {
				attr(optgroup, "label", optgroup_label_value);
			}
		},
		d(detaching) {
			if (detaching) detach(optgroup);
			if (if_block) if_block.d();
		}
	};
}

// (191:4) <Grid       bind:items={ $items }       { cols }       { rowHeight }       { gap }       fastStart={ false }       on:adjust={ onAdjust }       on:mount={ onChildMount }       let:item       let:dataItem       scroller={ container }     >
function create_default_slot$r(ctx) {
	let div1;
	let div0;
	let span;
	let t0_value = /*dataItem*/ ctx[22].data.type + "";
	let t0;
	let t1;
	let div2;
	let switch_instance;
	let current;
	let mounted;
	let dispose;
	const switch_instance_spread_levels = [{ class: "component" }, /*dataItem*/ ctx[22].data];

	function change_handler_1(...args) {
		return /*change_handler_1*/ ctx[16](/*dataItem*/ ctx[22], ...args);
	}

	var switch_value = /*dataItem*/ ctx[22].data.component;

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props());
		switch_instance.$on("change", change_handler_1);
	}

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			span = element("span");
			t0 = text$1(t0_value);
			t1 = space();
			div2 = element("div");
			if (switch_instance) create_component(switch_instance.$$.fragment);
			attr(div0, "class", "item-header-type");
			attr(div1, "class", "chrome");
			set_style(div1, "background", "rgba(25, 25, 25, 0.6)");
			attr(div2, "class", "content");

			set_style(div2, "background", /*item*/ ctx[21].fixed
			? "#bka"
			: /*dataItem*/ ctx[22].data.background);
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			append(div0, span);
			append(span, t0);
			insert(target, t1, anchor);
			insert(target, div2, anchor);

			if (switch_instance) {
				mount_component(switch_instance, div2, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen(div2, "pointerdown", pointerdown_handler$1);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if ((!current || dirty & /*dataItem*/ 4194304) && t0_value !== (t0_value = /*dataItem*/ ctx[22].data.type + "")) set_data(t0, t0_value);

			const switch_instance_changes = (dirty & /*dataItem*/ 4194304)
			? get_spread_update(switch_instance_spread_levels, [
					switch_instance_spread_levels[0],
					get_spread_object(/*dataItem*/ ctx[22].data)
				])
			: {};

			if (switch_value !== (switch_value = /*dataItem*/ ctx[22].data.component)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props());
					switch_instance.$on("change", change_handler_1);
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, div2, null);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}

			if (!current || dirty & /*item, dataItem*/ 6291456) {
				set_style(div2, "background", /*item*/ ctx[21].fixed
				? "#bka"
				: /*dataItem*/ ctx[22].data.background);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (detaching) detach(t1);
			if (detaching) detach(div2);
			if (switch_instance) destroy_component(switch_instance);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$14(ctx) {
	let t0;
	let div7;
	let div3;
	let div1;
	let button0;
	let t2;
	let div0;
	let select;
	let t3;
	let button1;
	let t5;
	let div2;
	let t6;
	let div4;
	let settings;
	let div4_class_value;
	let t7;
	let div5;
	let t8;
	let div6;
	let grid;
	let updating_items;
	let current;
	let mounted;
	let dispose;
	let if_block = /*$tutorials*/ ctx[3] !== undefined && create_if_block$u(ctx);
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[18], get_default_slot_context$3);
	settings = new Settings({});

	function grid_items_binding(value) {
		/*grid_items_binding*/ ctx[17].call(null, value);
	}

	let grid_props = {
		cols: /*cols*/ ctx[6],
		rowHeight: rowHeight$1,
		gap: /*gap*/ ctx[7],
		fastStart: false,
		scroller: /*container*/ ctx[0],
		$$slots: {
			default: [
				create_default_slot$r,
				({ item, dataItem }) => ({ 21: item, 22: dataItem }),
				({ item, dataItem }) => (item ? 2097152 : 0) | (dataItem ? 4194304 : 0)
			]
		},
		$$scope: { ctx }
	};

	if (/*$items*/ ctx[1] !== void 0) {
		grid_props.items = /*$items*/ ctx[1];
	}

	grid = new Src({ props: grid_props });
	binding_callbacks.push(() => bind(grid, "items", grid_items_binding));
	grid.$on("adjust", /*onAdjust*/ ctx[10]);
	grid.$on("mount", /*onChildMount*/ ctx[11]);

	return {
		c() {
			t0 = space();
			div7 = element("div");
			div3 = element("div");
			div1 = element("div");
			button0 = element("button");
			button0.textContent = "";
			t2 = space();
			div0 = element("div");
			select = element("select");
			if (if_block) if_block.c();
			t3 = space();
			button1 = element("button");
			button1.textContent = "";
			t5 = space();
			div2 = element("div");
			if (default_slot) default_slot.c();
			t6 = space();
			div4 = element("div");
			create_component(settings.$$.fragment);
			t7 = space();
			div5 = element("div");
			t8 = space();
			div6 = element("div");
			create_component(grid.$$.fragment);
			document_1$8.title = "Sema  Tutorial";
			attr(button0, "class", "button-dark left");
			if (/*$selected*/ ctx[2] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[13].call(select));
			attr(div0, "class", "combobox-dark middle");
			attr(button1, "class", "button-dark right");
			attr(div1, "class", "tutorial-navigator");
			attr(div2, "class", "markdown-container");
			attr(div3, "class", "tutorial-sidebar-container");

			attr(div4, "class", div4_class_value = /*$siteMode*/ ctx[4] === "dark"
			? "settings-container"
			: "settings-container-light");

			attr(div5, "class", "mouse-overlay-container");
			set_style(div5, "visibility", /*$isMouseOverlayVisible*/ ctx[5] ? "visible" : "hidden");
			attr(div6, "class", "tutorial-dashboard-container");
			attr(div7, "class", "container");
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, div7, anchor);
			append(div7, div3);
			append(div3, div1);
			append(div1, button0);
			append(div1, t2);
			append(div1, div0);
			append(div0, select);
			if (if_block) if_block.m(select, null);
			select_option(select, /*$selected*/ ctx[2]);
			append(div1, t3);
			append(div1, button1);
			append(div3, t5);
			append(div3, div2);

			if (default_slot) {
				default_slot.m(div2, null);
			}

			/*div3_binding*/ ctx[15](div3);
			append(div7, t6);
			append(div7, div4);
			mount_component(settings, div4, null);
			append(div7, t7);
			append(div7, div5);
			append(div7, t8);
			append(div7, div6);
			mount_component(grid, div6, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(select, "change", /*select_change_handler*/ ctx[13]),
					listen(select, "change", /*change_handler*/ ctx[14])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (/*$tutorials*/ ctx[3] !== undefined) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$u(ctx);
					if_block.c();
					if_block.m(select, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*$selected, $tutorials*/ 12) {
				select_option(select, /*$selected*/ ctx[2]);
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope, $selected*/ 262148) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[18], dirty, get_default_slot_changes$3, get_default_slot_context$3);
				}
			}

			if (!current || dirty & /*$siteMode*/ 16 && div4_class_value !== (div4_class_value = /*$siteMode*/ ctx[4] === "dark"
			? "settings-container"
			: "settings-container-light")) {
				attr(div4, "class", div4_class_value);
			}

			if (!current || dirty & /*$isMouseOverlayVisible*/ 32) {
				set_style(div5, "visibility", /*$isMouseOverlayVisible*/ ctx[5] ? "visible" : "hidden");
			}

			const grid_changes = {};
			if (dirty & /*container*/ 1) grid_changes.scroller = /*container*/ ctx[0];

			if (dirty & /*$$scope, item, dataItem*/ 6553600) {
				grid_changes.$$scope = { dirty, ctx };
			}

			if (!updating_items && dirty & /*$items*/ 2) {
				updating_items = true;
				grid_changes.items = /*$items*/ ctx[1];
				add_flush_callback(() => updating_items = false);
			}

			grid.$set(grid_changes);
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(settings.$$.fragment, local);
			transition_in(grid.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			transition_out(settings.$$.fragment, local);
			transition_out(grid.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(div7);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
			/*div3_binding*/ ctx[15](null);
			destroy_component(settings);
			destroy_component(grid);
			mounted = false;
			run_all(dispose);
		}
	};
}

let rowHeight$1 = 100;
const pointerdown_handler$1 = e => e.stopPropagation();

function instance$12($$self, $$props, $$invalidate) {
	let $items;
	let $selected;
	let $goto;
	let $tutorials;
	let $siteMode;
	let $isMouseOverlayVisible;
	component_subscribe($$self, items$1, $$value => $$invalidate(1, $items = $$value));
	component_subscribe($$self, selected, $$value => $$invalidate(2, $selected = $$value));
	component_subscribe($$self, goto, $$value => $$invalidate(19, $goto = $$value));
	component_subscribe($$self, tutorials, $$value => $$invalidate(3, $tutorials = $$value));
	component_subscribe($$self, siteMode, $$value => $$invalidate(4, $siteMode = $$value));
	component_subscribe($$self, isMouseOverlayVisible, $$value => $$invalidate(5, $isMouseOverlayVisible = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	let controller = new Controller(); // this will return the previously created Singleton instance
	let container;

	// Tutorial dashboard configuration
	let cols = [
		// [2880, 13]
		[1600, 8],
		[1440, 6],
		[1280, 3]
	]; // [1024, 2],
	// [800, 1],
	// [500, 1]

	let gap = [2, 2];

	let handleSelect = e => {
		try {
			// await tick();
			set_store_value(items$1, $items = [], $items); // refresh items to call onDestroy on each (learner need to terminate workers)

			localStorage.setItem("last-session-tutorial-url", `/tutorial/${$selected.chapter_dir}/${$selected.section_dir}/`);
			$goto(`/tutorial/${$selected.chapter_dir}/${$selected.section_dir}/`);
		} catch(error) {
			console.error("Error Selecting and loading tutorial environment", error);
		}
	};

	const update = (e, dataItem) => {
		try {
			if (e !== undefined && e.detail !== undefined && dataItem !== undefined) {
				if (e.detail.prop === "content") {
					// Content update from CodeMirror update with 'content' prop and value
					dataItem.data[e.detail.prop] = e.detail.value;

					// Update item and items collection by filtering out version with old value and concating update version
					set_store_value(items$1, $items = [...$items.filter(i => i !== dataItem), ...[dataItem]], $items);
				} else if (e.detail.prop === "hasFocus") {
					
				} // Currently, NO focused item feedback on tutorial
				// setFocused(dataItem);
			}
		} catch(error) {
			console.error("Error updating item", error);
		}
	};

	const onAdjust = e => {
		
	}; // console.log("DEBUG:dashboard:onAdjust:", e.detail);
	// $items = $items; // call a re-render

	const onChildMount = e => {
		
	}; // console.log("DEBUG:dashboard:onChildMount:"ii, e.detail);
	// $items = $items; // call a re-render

	onMount(async () => {
		console.log("DEBUG:routes/tutorial/_layout:onMount");

		if (!controller.samplesLoaded) {
			controller.init(document.location.origin + "/sema-engine");
			$goto(localStorage.getItem("last-session-tutorial-url"));
		}

		if ($items.length === 0 && localStorage["last-session-tutorial-url"]) {
			let sessionTutorialURL = document.location.origin + localStorage.getItem("last-session-tutorial-url") + "layout.json";
			let json = await fetch(sessionTutorialURL).then(r => r.json());
			set_store_value(items$1, $items = json.map(item => hydrateJSONcomponent$1(item)), $items);
		}

		for (const item of $items) {
			await updateItemPropsWithFetchedValues(item);
			await populateCommonStoresWithFetchedProps(item);
			updateItemPropsWithCommonStoreValues(item);
		}
	});

	onDestroy(() => {
		set_store_value(items$1, $items = [], $items);

		if (controller) {
			controller.stop();
		}
	}); // console.log("DEBUG:routes/tutorial/_layout:onDestroy")

	function select_change_handler() {
		$selected = select_value(this);
		selected.set($selected);
	}

	const change_handler = e => handleSelect();

	function div3_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			container = $$value;
			$$invalidate(0, container);
		});
	}

	const change_handler_1 = (dataItem, e) => update(e, dataItem);

	function grid_items_binding(value) {
		$items = value;
		items$1.set($items);
	}

	$$self.$$set = $$props => {
		if ("$$scope" in $$props) $$invalidate(18, $$scope = $$props.$$scope);
	};

	return [
		container,
		$items,
		$selected,
		$tutorials,
		$siteMode,
		$isMouseOverlayVisible,
		cols,
		gap,
		handleSelect,
		update,
		onAdjust,
		onChildMount,
		slots,
		select_change_handler,
		change_handler,
		div3_binding,
		change_handler_1,
		grid_items_binding,
		$$scope
	];
}

class Layout$4 extends SvelteComponent {
	constructor(options) {
		super();
		if (!document_1$8.getElementById("svelte-1wnzjyo-style")) add_css$U();
		init(this, options, instance$12, create_fragment$14, safe_not_equal, {});
	}
}

/* src/pages/_navigation.svelte generated by Svelte v3.31.0 */

function add_css$V() {
	var style = element("style");
	style.id = "svelte-1uzzr70-style";
	style.textContent = "[aria-current].svelte-1uzzr70{box-shadow:0 0.15em #ccc}.container-logo.svelte-1uzzr70{font-weight:bold;display:inline-block}.container-links.svelte-1uzzr70{display:flex;justify-content:space-evenly}.container-logo-svg.svelte-1uzzr70{font-weight:bold;display:inline-block}a.svelte-1uzzr70{padding:0.5em 0em 0.35em 0em}a.svelte-1uzzr70:hover{text-decoration:none}";
	append(document.head, style);
}

function get_each_context$i(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[10] = list[i][0];
	child_ctx[11] = list[i][1];
	return child_ctx;
}

// (538:6) {:else}
function create_else_block_1$2(ctx) {
	let div;
	let a;
	let t0_value = /*name*/ ctx[11] + "";
	let t0;
	let a_aria_current_value;
	let a_href_value;
	let t1;

	return {
		c() {
			div = element("div");
			a = element("a");
			t0 = text$1(t0_value);
			t1 = space();
			set_style(a, "color", /*$siteMode*/ ctx[2] === "dark" ? "white" : "black");

			attr(a, "aria-current", a_aria_current_value = /*$isActive*/ ctx[1](/*path*/ ctx[10])
			? "page"
			: undefined);

			attr(a, "href", a_href_value = /*path*/ ctx[10]);
			attr(a, "class", "svelte-1uzzr70");
			toggle_class(a, "active", /*$isActive*/ ctx[1](/*path*/ ctx[10]));
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, a);
			append(a, t0);
			append(div, t1);
		},
		p(ctx, dirty) {
			if (dirty & /*$siteMode*/ 4) {
				set_style(a, "color", /*$siteMode*/ ctx[2] === "dark" ? "white" : "black");
			}

			if (dirty & /*$isActive*/ 2 && a_aria_current_value !== (a_aria_current_value = /*$isActive*/ ctx[1](/*path*/ ctx[10])
			? "page"
			: undefined)) {
				attr(a, "aria-current", a_aria_current_value);
			}

			if (dirty & /*$isActive, links*/ 66) {
				toggle_class(a, "active", /*$isActive*/ ctx[1](/*path*/ ctx[10]));
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (531:6) {#if path==`tutorial`}
function create_if_block_1$k(ctx) {
	let div;
	let a;
	let t0;
	let a_aria_current_value;
	let a_href_value;
	let t1;

	return {
		c() {
			div = element("div");
			a = element("a");
			t0 = text$1("Tutorial");
			t1 = space();
			set_style(a, "color", /*$siteMode*/ ctx[2] === "dark" ? "white" : "black");

			attr(a, "aria-current", a_aria_current_value = /*$isActive*/ ctx[1](/*path*/ ctx[10])
			? "page"
			: undefined);

			attr(a, "href", a_href_value = /*$url*/ ctx[3]("/tutorial/:chapter/:section/", /*persistentParams*/ ctx[0]));
			attr(a, "class", "svelte-1uzzr70");
			toggle_class(a, "active", /*$isActive*/ ctx[1](/*path*/ ctx[10]));
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, a);
			append(a, t0);
			append(div, t1);
		},
		p(ctx, dirty) {
			if (dirty & /*$siteMode*/ 4) {
				set_style(a, "color", /*$siteMode*/ ctx[2] === "dark" ? "white" : "black");
			}

			if (dirty & /*$isActive*/ 2 && a_aria_current_value !== (a_aria_current_value = /*$isActive*/ ctx[1](/*path*/ ctx[10])
			? "page"
			: undefined)) {
				attr(a, "aria-current", a_aria_current_value);
			}

			if (dirty & /*$url, persistentParams*/ 9 && a_href_value !== (a_href_value = /*$url*/ ctx[3]("/tutorial/:chapter/:section/", /*persistentParams*/ ctx[0]))) {
				attr(a, "href", a_href_value);
			}

			if (dirty & /*$isActive, links*/ 66) {
				toggle_class(a, "active", /*$isActive*/ ctx[1](/*path*/ ctx[10]));
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (530:2) {#each links as [path, name]}
function create_each_block$i(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*path*/ ctx[10] == `tutorial`) return create_if_block_1$k;
		return create_else_block_1$2;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if_block.p(ctx, dirty);
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (562:2) {:else}
function create_else_block$b(ctx) {
	let a;
	let t;

	return {
		c() {
			a = element("a");
			t = text$1("login");
			attr(a, "href", "/login");
			set_style(a, "color", /*$siteMode*/ ctx[2] === "dark" ? "white" : "black");
			attr(a, "class", "svelte-1uzzr70");
		},
		m(target, anchor) {
			insert(target, a, anchor);
			append(a, t);
		},
		p(ctx, dirty) {
			if (dirty & /*$siteMode*/ 4) {
				set_style(a, "color", /*$siteMode*/ ctx[2] === "dark" ? "white" : "black");
			}
		},
		d(detaching) {
			if (detaching) detach(a);
		}
	};
}

// (552:2) {#if $username}
function create_if_block$v(ctx) {
	let a0;
	let t0;
	let t1;
	let img;
	let img_src_value;
	let img_alt_value;
	let t2;
	let a1;
	let t3;
	let mounted;
	let dispose;

	return {
		c() {
			a0 = element("a");
			t0 = text$1("admin");
			t1 = space();
			img = element("img");
			t2 = space();
			a1 = element("a");
			t3 = text$1("signout");
			attr(a0, "href", "/admin");
			set_style(a0, "color", /*$siteMode*/ ctx[2] === "dark" ? "white" : "black");
			attr(a0, "class", "svelte-1uzzr70");
			if (img.src !== (img_src_value = /*$avatar_url*/ ctx[5])) attr(img, "src", img_src_value);
			attr(img, "alt", img_alt_value = "profile - " + /*$username*/ ctx[4]);
			attr(a1, "href", "#signout");
			set_style(a1, "color", /*$siteMode*/ ctx[2] === "dark" ? "white" : "black");
			attr(a1, "class", "svelte-1uzzr70");
		},
		m(target, anchor) {
			insert(target, a0, anchor);
			append(a0, t0);
			insert(target, t1, anchor);
			insert(target, img, anchor);
			insert(target, t2, anchor);
			insert(target, a1, anchor);
			append(a1, t3);

			if (!mounted) {
				dispose = listen(a1, "click", /*click_handler*/ ctx[9]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*$siteMode*/ 4) {
				set_style(a0, "color", /*$siteMode*/ ctx[2] === "dark" ? "white" : "black");
			}

			if (dirty & /*$avatar_url*/ 32 && img.src !== (img_src_value = /*$avatar_url*/ ctx[5])) {
				attr(img, "src", img_src_value);
			}

			if (dirty & /*$username*/ 16 && img_alt_value !== (img_alt_value = "profile - " + /*$username*/ ctx[4])) {
				attr(img, "alt", img_alt_value);
			}

			if (dirty & /*$siteMode*/ 4) {
				set_style(a1, "color", /*$siteMode*/ ctx[2] === "dark" ? "white" : "black");
			}
		},
		d(detaching) {
			if (detaching) detach(a0);
			if (detaching) detach(t1);
			if (detaching) detach(img);
			if (detaching) detach(t2);
			if (detaching) detach(a1);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$15(ctx) {
	let nav;
	let div1;
	let div0;
	let svg;
	let sodipodi_namedview;
	let g13;
	let g12;
	let path0;
	let path0_class_value;
	let path1;
	let path1_class_value;
	let path2;
	let path2_class_value;
	let path3;
	let path3_class_value;
	let path4;
	let path4_class_value;
	let g0;
	let path5;
	let path5_class_value;
	let path6;
	let path6_class_value;
	let path7;
	let path7_class_value;
	let path8;
	let path8_class_value;
	let path9;
	let path9_class_value;
	let g1;
	let path10;
	let path10_class_value;
	let path11;
	let path11_class_value;
	let path12;
	let path12_class_value;
	let path13;
	let path13_class_value;
	let path14;
	let path14_class_value;
	let g2;
	let path15;
	let path15_class_value;
	let path16;
	let path16_class_value;
	let path17;
	let path17_class_value;
	let g3;
	let path18;
	let path18_class_value;
	let path19;
	let path19_class_value;
	let g4;
	let path20;
	let path20_class_value;
	let path21;
	let path21_class_value;
	let g5;
	let path22;
	let path22_class_value;
	let path23;
	let path23_class_value;
	let g6;
	let path24;
	let path24_class_value;
	let path25;
	let path25_class_value;
	let g7;
	let path26;
	let path26_class_value;
	let path27;
	let path27_class_value;
	let g8;
	let path28;
	let path28_class_value;
	let path29;
	let path29_class_value;
	let g9;
	let path30;
	let path30_class_value;
	let path31;
	let path31_class_value;
	let g10;
	let path32;
	let path32_class_value;
	let path33;
	let path33_class_value;
	let g11;
	let path34;
	let path34_class_value;
	let path35;
	let path35_class_value;
	let metadata;
	let rdf_RDF;
	let cc_Work;
	let dc_format;
	let t0;
	let dc_type;
	let cc_license;
	let dc_publisher;
	let cc_Agent;
	let dc_title;
	let t1;
	let cc_License;
	let cc_permits0;
	let cc_permits1;
	let cc_permits2;
	let t2;
	let a;
	let t3;
	let a_href_value;
	let t4;
	let div2;
	let t5;
	let div3;
	let each_value = /*links*/ ctx[6];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$i(get_each_context$i(ctx, each_value, i));
	}

	function select_block_type_1(ctx, dirty) {
		if (/*$username*/ ctx[4]) return create_if_block$v;
		return create_else_block$b;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			nav = element("nav");
			div1 = element("div");
			div0 = element("div");
			svg = svg_element("svg");
			sodipodi_namedview = svg_element("sodipodi:namedview");
			g13 = svg_element("g");
			g12 = svg_element("g");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			path3 = svg_element("path");
			path4 = svg_element("path");
			g0 = svg_element("g");
			path5 = svg_element("path");
			path6 = svg_element("path");
			path7 = svg_element("path");
			path8 = svg_element("path");
			path9 = svg_element("path");
			g1 = svg_element("g");
			path10 = svg_element("path");
			path11 = svg_element("path");
			path12 = svg_element("path");
			path13 = svg_element("path");
			path14 = svg_element("path");
			g2 = svg_element("g");
			path15 = svg_element("path");
			path16 = svg_element("path");
			path17 = svg_element("path");
			g3 = svg_element("g");
			path18 = svg_element("path");
			path19 = svg_element("path");
			g4 = svg_element("g");
			path20 = svg_element("path");
			path21 = svg_element("path");
			g5 = svg_element("g");
			path22 = svg_element("path");
			path23 = svg_element("path");
			g6 = svg_element("g");
			path24 = svg_element("path");
			path25 = svg_element("path");
			g7 = svg_element("g");
			path26 = svg_element("path");
			path27 = svg_element("path");
			g8 = svg_element("g");
			path28 = svg_element("path");
			path29 = svg_element("path");
			g9 = svg_element("g");
			path30 = svg_element("path");
			path31 = svg_element("path");
			g10 = svg_element("g");
			path32 = svg_element("path");
			path33 = svg_element("path");
			g11 = svg_element("g");
			path34 = svg_element("path");
			path35 = svg_element("path");
			metadata = svg_element("metadata");
			rdf_RDF = svg_element("rdf:RDF");
			cc_Work = svg_element("cc:Work");
			dc_format = svg_element("dc:format");
			t0 = text$1("image/svg+xml");
			dc_type = svg_element("dc:type");
			cc_license = svg_element("cc:license");
			dc_publisher = svg_element("dc:publisher");
			cc_Agent = svg_element("cc:Agent");
			dc_title = svg_element("dc:title");
			t1 = text$1("Openclipart");
			cc_License = svg_element("cc:License");
			cc_permits0 = svg_element("cc:permits");
			cc_permits1 = svg_element("cc:permits");
			cc_permits2 = svg_element("cc:permits");
			t2 = space();
			a = element("a");
			t3 = text$1("sema");
			t4 = space();
			div2 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t5 = space();
			div3 = element("div");
			if_block.c();
			attr(sodipodi_namedview, "id", "base");
			attr(sodipodi_namedview, "fit-margin-left", "0");
			attr(sodipodi_namedview, "inkscape:showpageshadow", "false");
			attr(sodipodi_namedview, "inkscape:zoom", "0.32091642");
			attr(sodipodi_namedview, "borderopacity", "1.0");
			attr(sodipodi_namedview, "inkscape:current-layer", "layer1");
			attr(sodipodi_namedview, "inkscape:cx", "145.05777");
			attr(sodipodi_namedview, "inkscape:cy", "-369.87653");
			attr(sodipodi_namedview, "inkscape:window-maximized", "1");
			attr(sodipodi_namedview, "showgrid", "false");
			attr(sodipodi_namedview, "fit-margin-right", "0");
			attr(sodipodi_namedview, "showguides", "true");
			attr(sodipodi_namedview, "bordercolor", "#666666");
			attr(sodipodi_namedview, "inkscape:window-x", "0");
			attr(sodipodi_namedview, "inkscape:guide-bbox", "true");
			attr(sodipodi_namedview, "inkscape:window-y", "654");
			attr(sodipodi_namedview, "fit-margin-bottom", "0");
			attr(sodipodi_namedview, "inkscape:window-width", "1680");
			attr(sodipodi_namedview, "inkscape:pageopacity", "0.0");
			attr(sodipodi_namedview, "inkscape:pageshadow", "2");
			attr(sodipodi_namedview, "pagecolor", "#ffffff");
			attr(sodipodi_namedview, "inkscape:document-units", "px");
			attr(sodipodi_namedview, "inkscape:window-height", "1026");
			attr(sodipodi_namedview, "showborder", "false");
			attr(sodipodi_namedview, "fit-margin-top", "0");
			attr(path0, "id", "path4912");
			attr(path0, "sodipodi:nodetypes", "sssssssssssssscsssssssssssssscscs");
			attr(path0, "inkscape:connector-curvature", "0");

			attr(path0, "class", path0_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			attr(path0, "d", "m-4879.2 2526.8c28.931-26.554 34.045-73.521 6.7362-103.15-22.385-24.288-61.908-28.559-86.795-5.5254-20.32 18.807-23.873 51.956-4.5097 72.785 15.749 16.938 43.453 19.885 60.824 3.6611 14.068-13.138 16.5-36.211 2.9553-50.645-10.921-11.638-30.063-13.638-42.01-2.3709-9.5888 9.0427-11.225 24.862-1.8897 34.709 7.4578 7.8667 20.477 9.2007 28.56 1.4956 6.4251-6.1245 7.507-16.794 1.1744-23.4-5.0075-5.2238-13.712-6.0964-19.086-0.9146-4.2268 4.0756-4.927 11.144-0.7059 15.494 3.3012 3.4021 9.0128 3.9611 12.517 0.5389 2.7241-2.6598 3.1673-7.252 0.407-10.059-2.1329-2.1691-5.8044-2.5189-7.8963-0.2069 1.997-1.738 5.0383-1.4474 6.8043 0.3481 2.2861 2.3251 1.9189 6.1284-0.3372 8.3314-2.9016 2.8344-7.6326 2.3713-10.366-0.4463-3.4958-3.6032-2.9158-9.4571 0.5846-12.832 4.4507-4.2914 11.659-3.5688 15.807 0.7575 5.2443 5.4712 4.3487 14.307-0.9728 19.379-6.6948 6.3814-17.477 5.2765-23.653-1.2385-7.732-8.1558-6.3762-21.257 1.5649-28.746 9.8944-9.3309 25.748-7.675 34.792 1.9633 11.218 11.954 9.2037 31.063-2.4472 41.944-14.387 13.436-37.333 10.996-50.375-3.0324-16.039-17.25-13.094-44.705 3.735-60.28 20.611-19.077 53.344-15.539 71.883 4.5762 22.617 24.541 18.382 63.439-5.5788 85.43-1.9553 1.7948-4.5226 3.813-6.7213 5.3658 1.7499 1.8673 3.4068 3.9086 4.9153 6.1209 1.2189 1.7866 2.2945 3.6485 3.2408 5.5593 2.3899-1.7475 4.6718-3.6184 6.8421-5.6111z");
			attr(path1, "id", "path4916");
			attr(path1, "d", "m-5349.6 2631c-5.0428-20.848-26.139-35.708-47.521-30.49-17.526 4.2776-30.016 22.039-25.587 40.022 3.6165 14.684 18.52 25.146 33.595 21.398 12.259-3.0483 20.992-15.512 17.83-28.103-2.5604-10.197-12.945-17.459-23.424-14.802-8.4492 2.1432-14.466 10.763-12.239 19.452 1.7872 6.9735 8.9146 11.938 16.09 10.079 5.7313-1.485 9.8108-7.3545 8.2653-13.255-1.2285-4.69-6.0417-8.0276-10.873-6.7475-3.821 1.0119-6.5389 4.9419-5.4828 8.8802 0.8304 3.0974 4.0234 5.3008 7.2188 4.4334 2.498-0.6807 4.2757-3.2604 3.5663-5.8398-0.5506-2.0056-2.6285-3.4312-4.6997-2.8545-1.6007 0.445-2.7382 2.1086-2.1869 3.719-0.3027-1.4137 0.64-2.7906 1.9652-3.1596 1.7158-0.4781 3.4361 0.7025 3.8927 2.3638 0.5876 2.136-0.8842 4.2744-2.9536 4.8364-2.6458 0.7204-5.2908-1.1064-5.9785-3.6715-0.8745-3.2619 1.377-6.5161 4.5409-7.3547 4.0013-1.0601 7.988 1.704 9.0052 5.5883 1.2801 4.8867-2.0987 9.7484-6.8454 10.978-5.9419 1.5395-11.845-2.5725-13.326-8.3477-1.8437-7.1957 3.1388-14.335 10.137-16.11 8.6787-2.2011 17.279 3.8134 19.4 12.259 2.6183 10.428-4.6143 20.75-14.767 23.275-12.485 3.1041-24.828-5.5608-27.823-17.722-3.6688-14.894 6.6758-29.604 21.191-33.146 17.709-4.3219 35.18 7.9855 39.356 25.252 0.3409 1.4092 0.6271 3.1697 0.7877 4.631 1.3559-0.3399 2.769-0.595 4.2249-0.731 1.176-0.11 2.3503-0.1323 3.5139-0.079-0.2036-1.6043-0.4945-3.1899-0.873-4.7538z");
			attr(path1, "sodipodi:nodetypes", "sssssssssssssscsssssssssssssscscs");

			attr(path1, "class", path1_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			attr(path1, "inkscape:connector-curvature", "0");
			attr(path2, "id", "path4920");
			attr(path2, "sodipodi:nodetypes", "sssssssssssssscsssssssssssssscscs");
			attr(path2, "inkscape:connector-curvature", "0");

			attr(path2, "class", path2_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			attr(path2, "d", "m-4657.5 2644.3c5.8673 21.76 28.432 36.791 50.749 30.725 18.292-4.9726 30.925-23.97 25.78-42.738-4.2007-15.324-20.142-25.906-35.873-21.556-12.793 3.5369-21.624 16.867-17.959 30.006 2.9683 10.64 14.074 17.984 25.009 14.906 8.816-2.4821 14.9-11.701 12.323-20.766-2.0679-7.2757-9.6908-12.295-17.176-10.146-5.9795 1.7163-10.104 7.9934-8.3188 14.149 1.419 4.8925 6.566 8.2665 11.606 6.7897 3.9853-1.1678 6.7329-5.3698 5.5158-9.4775-0.9571-3.2309-4.3711-5.4577-7.7036-4.4592-2.6063 0.7807-4.4021 3.5415-3.5866 6.2317 0.6342 2.0909 2.8552 3.5317 5.0152 2.8688 1.6686-0.5126 2.8183-2.2895 2.1945-3.9665 0.3565 1.4769-0.5957 2.949-1.9777 3.373-1.7889 0.5495-3.6286-0.6442-4.1535-2.3763-0.6758-2.2277 0.8116-4.5142 2.9703-5.1609 2.7596-0.8276 5.5876 1.0175 6.38 3.6932 1.0081 3.402-1.2676 6.8819-4.5681 7.8492-4.174 1.223-8.4367-1.5712-9.6117-5.6232-1.4783-5.098 1.9373-10.296 6.8894-11.718 6.1994-1.7793 12.513 2.3778 14.225 8.4036 2.1339 7.5074-2.9045 15.143-10.206 17.198-9.0562 2.5499-18.254-3.5326-20.713-12.345-3.0359-10.882 4.2783-21.922 14.873-24.851 13.029-3.6023 26.231 5.1609 29.71 17.853 4.2608 15.544-6.2019 31.278-21.351 35.396-18.482 5.0241-37.171-7.4249-42.03-25.446-0.3963-1.4708-0.7458-3.3119-0.9541-4.8427-1.4151 0.3938-2.892 0.7008-4.4178 0.8838-1.2326 0.145-2.465 0.203-3.6885 0.1789 0.2577 1.6795 0.607 3.3367 1.047 4.9694z");
			attr(path3, "id", "path4922");
			attr(path3, "sodipodi:nodetypes", "sssssssssssssscsssssssssssssscscs");
			attr(path3, "inkscape:connector-curvature", "0");

			attr(path3, "class", path3_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			attr(path3, "d", "m-4938.5 2875.9c-80.161-114.31-62.018-281.3 55.45-363.31 96.285-67.225 236.78-51.847 305.59 47.151 56.18 80.831 43.185 198.65-39.97 256.17-67.623 46.779-166.07 35.833-213.99-33.776-38.804-56.37-29.616-138.34 28.446-178.11 46.814-32.061 114.81-24.375 147.68 23.876 26.381 38.727 19.975 94.904-19.967 121.96-31.907 21.614-78.131 16.295-100.31-16.636-17.629-26.176-13.23-64.048 13.806-82.146 21.38-14.311 52.269-10.688 66.968 11.412 11.56 17.381 8.5898 42.458-9.3914 54.338-14.062 9.2901-34.321 6.8653-43.873-7.6947-7.4253-11.319-5.4554-27.601 6.2748-35.24 9.0625-5.901 22.079-4.3088 27.576 5.318-5.6068-7.5597-16.387-8.8784-23.892-3.9911-9.7151 6.326-11.346 19.811-5.1969 29.185 7.9105 12.058 24.689 14.067 36.335 6.3728 14.892-9.8385 17.352-30.607 7.7779-45.002-12.173-18.303-37.756-21.303-55.463-9.4508-22.392 14.988-26.035 46.354-11.434 68.033 18.368 27.273 56.651 31.679 83.076 13.778 33.08-22.409 38.386-68.935 16.537-101.01-27.222-39.961-83.534-46.327-122.31-19.774-48.087 32.933-55.697 100.82-23.559 147.51 39.685 57.65 121.22 66.715 177.23 27.973 68.869-47.641 79.632-145.22 33.104-212.16-56.986-81.989-173.35-94.726-253.09-39.05-97.287 67.925-112.31 206.22-45.924 300.9 5.4183 7.7264 12.789 16.695 19.237 23.768-7.4941 5.1586-14.816 10.968-21.745 17.496-5.5964 5.2728-10.755 10.914-15.501 16.826-6.9633-7.8941-13.455-16.136-19.47-24.712z");
			attr(path4, "id", "path4926");
			attr(path4, "d", "m-5210.6 2748.7c-83.601-3.5091-156.45-72.986-152.67-158.76 3.0955-70.309 61.606-131.56 133.78-128.23 58.932 2.72 110.26 51.832 107.33 112.36-2.3806 49.222-43.462 92.08-94.043 89.516-40.961-2.0752-76.618-36.315-74.383-78.432 1.802-33.958 30.234-63.51 65.169-61.569 28.04 1.5577 52.436 25.075 50.758 53.94-1.3411 23.058-20.714 43.114-44.465 41.668-18.879-1.1494-35.296-17.042-34.057-36.501 0.9806-15.388 13.96-28.766 29.831-27.707 12.483 0.8324 23.333 11.383 22.434 24.268-0.7033 10.076-9.2388 18.833-19.647 18.072-8.0914-0.5911-15.121-7.4612-14.482-15.826 0.4942-6.4625 5.9946-12.076 12.578-11.184-5.64-0.087-10.195 4.5622-10.605 9.9144-0.5298 6.9276 5.2922 12.617 11.994 13.107 8.6201 0.6296 15.689-6.6221 16.272-14.967 0.7448-10.671-8.2413-19.409-18.579-20.098-13.145-0.8766-23.894 10.203-24.706 22.947-1.0269 16.116 12.57 29.278 28.206 30.23 19.67 1.1975 35.715-15.413 36.826-34.51 1.3904-23.906-18.815-43.383-42.037-44.673-28.933-1.6075-52.481 22.868-53.973 50.992-1.8511 34.881 27.68 63.238 61.604 64.957 41.892 2.1225 75.915-33.372 77.886-74.138 2.4245-50.129-40.083-90.803-88.89-93.056-59.776-2.759-108.23 47.968-110.8 106.2-3.1276 71.042 57.203 128.58 126.44 131.49 5.6508 0.2371 12.604 0 18.319-0.4931-0.2762 5.4456-0.18 11.046 0.4018 16.722 0.4697 4.5843 1.2746 9.0946 2.3584 13.507-6.2934 0.437-12.58 0.523-18.853 0.2598z");
			attr(path4, "sodipodi:nodetypes", "sssssssssssssscsssssssssssssscscs");

			attr(path4, "class", path4_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			attr(path4, "inkscape:connector-curvature", "0");
			attr(path5, "id", "path4930");
			attr(path5, "inkscape:connector-curvature", "0");

			attr(path5, "class", path5_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			attr(path5, "d", "m1100 252.1c-38.582-5.0193-71.655-28.564-88.698-63.144-13.064-26.507-15.479-57.006-6.7207-84.88 3.4376-10.94 7.5514-19.486 14.247-29.596 6.1465-9.2808 11.637-15.576 19.717-22.605 12.521-10.893 25.403-18.105 41.405-23.181 19.708-6.252 41.942-6.9335 61.744-1.8924 9.1446 2.3281 18.849 6.0402 26.659 10.198 6.7541 3.5957 17.813 11.197 14.27 9.8081-3.7223-1.4589-13.367-3.9653-19.48-5.0623-10.763-1.9314-27.667-2.3031-37.837-0.83196-28.658 4.1454-52.123 15.814-71.818 35.715-31.192 31.516-43.548 77.168-31.048 114.71 8.0684 24.235 25.64 42.29 48.587 49.924 17.279 5.7486 35.216 4.6663 51.146-3.0861 17.77-8.6479 30.052-24.393 34.071-43.68 1.044-5.01 1.1472-15.932 0.2003-21.208-2.0065-11.181-6.9794-20.781-15.161-29.269-10.973-11.384-24.569-17.144-40.559-17.184-3.4463-0.008-6.8524 0.13881-7.569 0.32717-1.2043 0.31652-1.3277 0.21087-1.6288-1.3939-0.6188-3.2984 0.1393-16.572 1.1676-20.443 3.2487-12.229 8.3824-20.963 17.303-29.438 11.958-11.361 27.245-17.312 44.47-17.312 26.745 0 51.255 15.462 64.354 40.596 13.607 26.109 13.1 58.996-1.3683 88.767-17.246 35.486-49.965 58.974-89.345 64.139-6.7396 0.88387-21.387 0.89435-28.107 0.0201v0.00002z");
			attr(path6, "id", "path4932");
			attr(path6, "inkscape:connector-curvature", "0");

			attr(path6, "class", path6_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			attr(path6, "d", "m1140 173.74c-18.736-2.3106-34.722-13.517-43.08-30.199-1.9142-3.8208-3.9735-9.6041-4.5847-12.876l-0.3923-2.0999 1.7357-0.28711c3.2107-0.5311 12.421-0.3036 16.499 0.40756 20.2 3.5226 36.747 17.773 43.077 37.099 1.8297 5.5857 2.0524 7.261 1.0179 7.6579-1.3815 0.53013-10.795 0.72609-14.273 0.29712z");
			attr(g0, "id", "g4928");
			set_style(g0, "fill", "#000000");
			attr(g0, "transform", "matrix(-.013055 .099846 .099846 .013055 -5221.8 2466.8)");
			attr(path7, "id", "path4940");
			attr(path7, "sodipodi:nodetypes", "sssssssssssssscsssssssssssssscscs");

			attr(path7, "class", path7_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			attr(path7, "inkscape:connector-curvature", "0");
			attr(path7, "d", "m-5539.7 3053.6c-21.276 8.9965-33.387 34.008-24.111 55.821 7.6039 17.879 28.658 28.053 46.997 20.208 14.973-6.4054 23.491-24.07 16.878-39.436-5.3781-12.496-20.146-19.602-32.976-14.045-10.39 4.4997-16.296 16.803-11.643 27.476 3.7513 8.6051 13.962 13.495 22.806 9.6139 7.0991-3.1161 11.131-11.557 7.9052-18.857-2.5778-5.8318-9.5272-9.1428-15.528-6.4709-4.7698 2.1243-7.4768 7.8215-5.2757 12.732 1.7424 3.8834 6.3929 6.0867 10.39 4.2862 3.1472-1.4233 4.9313-5.2008 3.4552-8.4438-1.1568-2.5371-4.2108-3.9754-6.8325-2.7612-2.0347 0.9357-3.1878 3.3924-2.213 5.4926 0.7528 1.6236 2.7183 2.5422 4.334 1.6741-1.4496 0.5688-3.0774-0.1928-3.6968-1.5473-0.8075-1.74 0.1477-3.7744 1.8278-4.5512 2.1679-0.9974 4.6971 0.1936 5.6607 2.2818 1.2252 2.6867-0.2528 5.8158-2.8615 6.9929-3.3137 1.4986-7.1649-0.326-8.6028-3.5549-1.8249-4.0672 0.4169-8.7861 4.367-10.545 4.9699-2.2132 10.726 0.5293 12.86 5.3586 2.6728 6.0465-0.6669 13.038-6.5484 15.617-7.3247 3.2151-15.781-0.8345-18.888-7.9624-3.8539-8.8396 1.0376-19.029 9.6415-22.756 10.626-4.6022 22.857 1.283 27.311 11.632 5.4774 12.726-1.5769 27.355-13.978 32.66-15.188 6.4973-32.625-1.9293-38.922-16.736-7.6828-18.065 2.3479-38.78 19.968-46.231 1.438-0.6082 3.2587-1.2199 4.7841-1.6453-0.5984-1.3814-1.1154-2.8383-1.5143-4.3621-0.322-1.2308-0.5503-2.4748-0.697-3.7205-1.6693 0.496-3.303 1.0822-4.8995 1.7572z");
			attr(path8, "id", "path4942");
			attr(path8, "d", "m-4660.7 3028.9c-28.931-26.554-34.045-73.521-6.7362-103.15 22.385-24.288 61.908-28.559 86.795-5.5254 20.32 18.807 23.873 51.956 4.5097 72.785-15.749 16.938-43.453 19.885-60.824 3.6611-14.068-13.138-16.5-36.211-2.9553-50.645 10.921-11.638 30.063-13.638 42.01-2.3709 9.5888 9.0427 11.225 24.862 1.8897 34.709-7.4578 7.8667-20.477 9.2007-28.56 1.4956-6.4251-6.1245-7.507-16.794-1.1744-23.4 5.0075-5.2238 13.712-6.0964 19.086-0.9146 4.2268 4.0756 4.927 11.144 0.7059 15.494-3.3012 3.4021-9.0128 3.9611-12.517 0.5389-2.7241-2.6598-3.1673-7.252-0.407-10.059 2.1329-2.1691 5.8044-2.5189 7.8963-0.2069-1.997-1.738-5.0383-1.4474-6.8043 0.3481-2.2861 2.3251-1.9189 6.1284 0.3372 8.3314 2.9016 2.8344 7.6326 2.3713 10.366-0.4463 3.4958-3.6032 2.9158-9.4571-0.5846-12.832-4.4507-4.2914-11.659-3.5688-15.807 0.7575-5.2443 5.4712-4.3487 14.307 0.9728 19.379 6.6948 6.3814 17.477 5.2765 23.653-1.2385 7.732-8.1558 6.3762-21.257-1.5649-28.746-9.8944-9.3309-25.748-7.675-34.792 1.9633-11.218 11.954-9.2037 31.063 2.4472 41.944 14.387 13.436 37.333 10.996 50.375-3.0324 16.039-17.25 13.094-44.705-3.735-60.28-20.611-19.077-53.344-15.539-71.883 4.5762-22.617 24.541-18.382 63.439 5.5788 85.43 1.9553 1.7948 4.5226 3.813 6.7213 5.3658-1.7499 1.8673-3.4068 3.9086-4.9153 6.1209-1.2189 1.7866-2.2945 3.6485-3.2408 5.5593-2.3899-1.7475-4.6718-3.6184-6.8421-5.6111z");
			attr(path8, "sodipodi:nodetypes", "sssssssssssssscsssssssssssssscscs");

			attr(path8, "class", path8_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			attr(path8, "inkscape:connector-curvature", "0");
			attr(path9, "id", "path4944");
			attr(path9, "d", "m-5405.7 2930.8c-28.962 96.118-131.39 160.1-229.96 130.18-80.794-24.525-134.56-110.76-109.21-193.65 20.702-67.682 93.058-112.71 162.53-91.296 56.498 17.418 94.08 77.919 76.046 135.94-14.604 46.988-65.012 78.238-113.3 63.104-38.93-12.201-64.814-54.042-52.16-94.067 10.157-32.125 44.75-53.479 77.798-42.936 26.399 8.4215 43.943 36.908 35.193 64.081-6.9551 21.599-30.312 35.95-52.559 28.717-17.591-5.7198-29.277-24.786-23.323-42.917 4.6829-14.26 20.175-23.73 34.882-18.85 11.501 3.8167 19.137 16.343 15.156 28.213-3.0956 9.2281-13.172 15.353-22.704 12.121-7.3637-2.4979-12.25-10.562-9.254-17.947-1.7792 6.5291 2.2679 13.207 8.3661 15.276 7.8936 2.6781 16.24-2.3955 18.803-10.038 3.2977-9.8309-3.0263-20.205-12.552-23.366-12.18-4.0415-25.011 3.8011-28.889 15.611-4.9311 15.016 4.7466 30.807 19.316 35.544 18.425 5.9902 37.769-5.895 43.529-23.783 7.2466-22.505-7.2831-46.097-29.146-53.072-27.37-8.7313-56.02 8.954-64.432 35.56-10.48 33.149 10.957 67.801 43.198 77.906 39.988 12.534 81.736-13.347 93.831-52.263 14.936-48.056-16.19-98.162-62.981-112.59-57.539-17.739-117.46 19.557-134.61 75.612-20.999 68.652 23.533 140.07 90.446 160.38 81.635 24.78 166.47-28.21 190.45-107.81 1.9575-6.497 3.7489-14.649 4.8796-21.437 6.2467 1.9418 12.784 3.4971 19.554 4.5102 5.4675 0.8184 10.949 1.2257 16.4 1.2791-1.3658 7.4445-3.1367 14.777-5.3097 21.989z");
			attr(path9, "sodipodi:nodetypes", "sssssssssssssscsssssssssssssscscs");

			attr(path9, "class", path9_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			attr(path9, "inkscape:connector-curvature", "0");
			attr(path10, "id", "path4948");
			attr(path10, "d", "m1100 252.1c-38.582-5.0193-71.655-28.564-88.698-63.144-13.064-26.507-15.479-57.006-6.7207-84.88 3.4376-10.94 7.5514-19.486 14.247-29.596 6.1465-9.2808 11.637-15.576 19.717-22.605 12.521-10.893 25.403-18.105 41.405-23.181 19.708-6.252 41.942-6.9335 61.744-1.8924 9.1446 2.3281 18.849 6.0402 26.659 10.198 6.7541 3.5957 17.813 11.197 14.27 9.8081-3.7223-1.4589-13.367-3.9653-19.48-5.0623-10.763-1.9314-27.667-2.3031-37.837-0.83196-28.658 4.1454-52.123 15.814-71.818 35.715-31.192 31.516-43.548 77.168-31.048 114.71 8.0684 24.235 25.64 42.29 48.587 49.924 17.279 5.7486 35.216 4.6663 51.146-3.0861 17.77-8.6479 30.052-24.393 34.071-43.68 1.044-5.01 1.1472-15.932 0.2003-21.208-2.0065-11.181-6.9794-20.781-15.161-29.269-10.973-11.384-24.569-17.144-40.559-17.184-3.4463-0.008-6.8524 0.13881-7.569 0.32717-1.2043 0.31652-1.3277 0.21087-1.6288-1.3939-0.6188-3.2984 0.1393-16.572 1.1676-20.443 3.2487-12.229 8.3824-20.963 17.303-29.438 11.958-11.361 27.245-17.312 44.47-17.312 26.745 0 51.255 15.462 64.354 40.596 13.607 26.109 13.1 58.996-1.3683 88.767-17.246 35.486-49.965 58.974-89.345 64.139-6.7396 0.88387-21.387 0.89435-28.107 0.0201v0.00002z");

			attr(path10, "class", path10_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			attr(path10, "inkscape:connector-curvature", "0");
			attr(path11, "id", "path4950");
			attr(path11, "d", "m1140 173.74c-18.736-2.3106-34.722-13.517-43.08-30.199-1.9142-3.8208-3.9735-9.6041-4.5847-12.876l-0.3923-2.0999 1.7357-0.28711c3.2107-0.5311 12.421-0.3036 16.499 0.40756 20.2 3.5226 36.747 17.773 43.077 37.099 1.8297 5.5857 2.0524 7.261 1.0179 7.6579-1.3815 0.53013-10.795 0.72609-14.273 0.29712z");

			attr(path11, "class", path11_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			attr(path11, "inkscape:connector-curvature", "0");
			attr(g1, "id", "g4946");
			attr(g1, "transform", "matrix(.083095 .056876 .056876 -.083095 -5706.3 2844)");
			attr(path12, "id", "path4952");
			attr(path12, "d", "m-5168.8 2961.6c-13.099-4.1108-21.688-18.218-17.442-31.65 3.4802-11.01 15.356-18.228 26.652-14.631 9.2231 2.9368 15.268 12.902 12.231 22.369-2.47 7.6987-10.802 12.744-18.709 10.187-6.4028-2.0705-10.597-9.0125-8.4524-15.592 1.7294-5.3044 7.4915-8.7786 12.945-6.9856 4.3771 1.4391 7.2432 6.2032 5.7498 10.706-1.1929 3.5969-5.1158 5.9514-8.818 4.7124-2.9427-0.985-4.8687-4.2014-3.8448-7.2323 0.8096-2.3967 3.4352-3.9649 5.9053-3.1222 1.9427 0.6627 3.2134 2.7959 2.5231 4.7994-0.54 1.5669-2.2648 2.5916-3.8819 2.0285-1.257-0.4377-2.0789-1.8254-1.6218-3.1236 0.353-1.0032 1.4634-1.6587 2.4687-1.2374-0.89-0.2537-1.8097 0.2894-2.1021 1.1201-0.3785 1.0753 0.3022 2.2245 1.3434 2.587 1.3392 0.4664 2.7677-0.3821 3.2149-1.6799 0.5718-1.6593-0.4808-3.4262-2.0897-3.9749-2.0457-0.6979-4.2202 0.6009-4.8908 2.5858-0.8479 2.5102 0.7471 5.174 3.1843 5.9897 3.0662 1.0262 6.3151-0.9238 7.3031-3.9027 1.2368-3.7292-1.1369-7.6748-4.7621-8.8667-4.5165-1.485-9.2888 1.3923-10.721 5.7855-1.7766 5.4488 1.6975 11.198 7.0002 12.913 6.5481 2.1176 13.449-2.0605 15.495-8.4366 2.5157-7.8407-2.4908-16.094-10.129-18.526-9.3552-2.9788-19.191 2.9993-22.073 12.118-3.5163 11.125 3.5975 22.808 14.446 26.213 0.8853 0.2779 1.9973 0.536 2.9239 0.7008-0.2753 0.8513-0.4983 1.7428-0.6474 2.667-0.1205 0.7464-0.1847 1.4953-0.2005 2.2406-1.0159-0.1983-2.0158-0.4521-2.9987-0.7605z");

			attr(path12, "class", path12_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			attr(path12, "sodipodi:nodetypes", "sssssssssssssscsssssssssssssscscs");
			attr(path12, "inkscape:connector-curvature", "0");
			attr(path13, "id", "path4954");
			attr(path13, "sodipodi:nodetypes", "sssssssssssssscsssssssssssssscscs");

			attr(path13, "class", path13_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			attr(path13, "inkscape:connector-curvature", "0");
			attr(path13, "d", "m-5276.3 2925.8c-20.171 13.512-49.135 9.7375-62.958-10.99-11.33-16.989-8.1344-41.358 9.3321-52.953 14.261-9.467 34.696-6.7703 44.388 7.9003 7.8816 11.93 5.6131 29.006-6.6667 37.078-9.9443 6.5369-24.161 4.635-30.859-5.607-5.4001-8.2578-3.8113-20.05 4.6994-25.586 6.8307-4.4426 16.574-3.1203 21.129 3.9243 3.6392 5.6275 2.5428 13.644-3.2648 17.377-4.6163 2.9676-11.184 2.0623-14.23-2.7053-2.4087-3.7701-1.6641-9.127 2.2326-11.6 3.0647-1.9453 7.4134-1.3357 9.412 1.8345 1.5628 2.4793 1.0661 5.9924-1.5008 7.5988-1.9954 1.249-4.8188 0.846-6.1031-1.2217-0.9924-1.5975-0.6671-3.8545 1.0269-4.7744-1.3351 0.9465-1.6044 2.816-0.7826 4.1389 1.0637 1.7125 3.4021 2.0463 5.0547 1.0118 2.1258-1.3304 2.5373-4.2398 1.2429-6.2932-1.6552-2.6256-5.2569-3.1304-7.795-1.5194-3.2272 2.0484-3.8438 6.485-1.8491 9.6073 2.5227 3.9486 7.9621 4.6984 11.785 2.2406 4.8098-3.092 5.7179-9.7314 2.7039-14.392-3.7731-5.8343-11.842-6.9295-17.499-3.25-7.0484 4.5841-8.3643 14.351-3.8919 21.19 5.5469 8.4824 17.322 10.058 25.557 4.6437 10.17-6.6853 12.049-20.827 5.5214-30.708-8.027-12.15-24.951-14.384-36.762-6.5431-14.466 9.6027-17.112 29.785-7.7289 43.855 11.448 17.166 35.435 20.292 52.141 9.1015 1.3634-0.9133 2.9505-2.1609 4.2037-3.2561 0.8689 1.3221 1.8516 2.6166 2.9609 3.8454 0.8959 0.9925 1.8576 1.9104 2.8677 2.7573-1.3982 1.1813-2.8552 2.2793-4.3686 3.2932z");
			attr(path14, "id", "path4956");
			attr(path14, "sodipodi:nodetypes", "sssssssssssssscsssssssssssssscscs");

			attr(path14, "class", path14_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			attr(path14, "inkscape:connector-curvature", "0");
			attr(path14, "d", "m-4840.4 2949.7c-55.946-169.8-241.22-279.04-415.34-221.27-142.72 47.348-234.51 203.32-185.59 349.74 39.944 119.55 170.81 196.42 293.53 155.12 99.79-33.586 163.94-143.01 129.19-245.49-28.143-82.988-119.31-136.32-204.58-107.18-68.751 23.499-112.92 99.169-88.57 169.85 19.547 56.729 82.11 93.169 140.46 72.892 46.614-16.198 76.549-67.712 59.732-115.69-13.367-38.136-55.605-62.62-94.881-48.728-31.058 10.985-50.992 45.463-39.565 77.47 8.9876 25.174 37 41.326 62.96 31.967 20.302-7.3195 33.326-29.969 25.695-50.92-5.9318-16.288-24.152-26.733-40.973-20.542-12.996 4.7829-21.328 19.361-15.656 32.374-3.4658-11.543 3.4347-23.616 14.198-27.578 13.931-5.1273 29.021 3.5236 33.934 17.013 6.3192 17.352-4.4665 36.11-21.281 42.172-21.5 7.7513-44.7-5.6263-52.144-26.475-9.4642-26.508 7.0452-55.063 32.768-64.161 32.529-11.505 67.509 8.7719 78.58 40.356 13.928 39.735-10.864 82.4-49.47 95.814-48.329 16.793-100.14-13.386-116.33-60.369-20.17-58.537 16.414-121.21 73.353-140.67 70.62-24.138 146.13 20.034 169.43 88.765 28.783 84.873-24.346 175.5-106.99 203.32-101.63 34.205-210.02-29.46-243.1-128.47-40.516-121.27 35.507-250.44 153.71-289.66 144.21-47.841 297.65 42.63 343.99 183.26 3.7813 11.477 7.3428 25.91 9.6651 37.943 11.033-3.7421 22.601-6.8089 34.606-8.9217 9.697-1.7065 19.438-2.6816 29.138-3.0255-2.7705-13.191-6.2584-26.165-10.456-38.905z");
			attr(path15, "id", "path4960");
			attr(path15, "inkscape:connector-curvature", "0");

			attr(path15, "class", path15_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			attr(path15, "d", "m1100 252.1c-38.582-5.0193-71.655-28.564-88.698-63.144-13.064-26.507-15.479-57.006-6.7207-84.88 3.4376-10.94 7.5514-19.486 14.247-29.596 6.1465-9.2808 11.637-15.576 19.717-22.605 12.521-10.893 25.403-18.105 41.405-23.181 19.708-6.252 41.942-6.9335 61.744-1.8924 9.1446 2.3281 18.849 6.0402 26.659 10.198 6.7541 3.5957 17.813 11.197 14.27 9.8081-3.7223-1.4589-13.367-3.9653-19.48-5.0623-10.763-1.9314-27.667-2.3031-37.837-0.83196-28.658 4.1454-52.123 15.814-71.818 35.715-31.192 31.516-43.548 77.168-31.048 114.71 8.0684 24.235 25.64 42.29 48.587 49.924 17.279 5.7486 35.216 4.6663 51.146-3.0861 17.77-8.6479 30.052-24.393 34.071-43.68 1.044-5.01 1.1472-15.932 0.2003-21.208-2.0065-11.181-6.9794-20.781-15.161-29.269-10.973-11.384-24.569-17.144-40.559-17.184-3.4463-0.008-6.8524 0.13881-7.569 0.32717-1.2043 0.31652-1.3277 0.21087-1.6288-1.3939-0.6188-3.2984 0.1393-16.572 1.1676-20.443 3.2487-12.229 8.3824-20.963 17.303-29.438 11.958-11.361 27.245-17.312 44.47-17.312 26.745 0 51.255 15.462 64.354 40.596 13.607 26.109 13.1 58.996-1.3683 88.767-17.246 35.486-49.965 58.974-89.345 64.139-6.7396 0.88387-21.387 0.89435-28.107 0.0201v0.00002z");
			attr(path16, "id", "path4962");
			attr(path16, "inkscape:connector-curvature", "0");

			attr(path16, "class", path16_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			attr(path16, "d", "m1140 173.74c-18.736-2.3106-34.722-13.517-43.08-30.199-1.9142-3.8208-3.9735-9.6041-4.5847-12.876l-0.3923-2.0999 1.7357-0.28711c3.2107-0.5311 12.421-0.3036 16.499 0.40756 20.2 3.5226 36.747 17.773 43.077 37.099 1.8297 5.5857 2.0524 7.261 1.0179 7.6579-1.3815 0.53013-10.795 0.72609-14.273 0.29712z");
			attr(g2, "id", "g4958");
			attr(g2, "transform", "matrix(-.047197 -.088950 .088950 -.047197 -5163.1 3130.4)");
			attr(path17, "id", "path4964");

			attr(path17, "class", path17_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			attr(path17, "d", "m-4602.8 3332.3c64.66-123.74 25.016-286.96-102.1-353.05-104.19-54.171-241.51-20.703-296.89 86.381-45.224 87.434-17.06 202.57 72.853 248.82 73.118 37.615 169.32 13.994 207.8-61.241 31.166-60.926 11.425-141.01-51.303-172.91-50.576-25.72-117-9.2809-143.33 42.825-21.136 41.821-7.4993 96.693 35.614 118.34 34.44 17.294 79.584 6.0256 97.305-29.504 14.086-28.241 4.813-65.222-24.342-79.661-23.055-11.418-53.214-3.8197-64.923 20-9.2088 18.734-3.0112 43.214 16.359 52.661 15.148 7.388 34.922 2.3566 42.504-13.319 5.895-12.186 1.83-28.076-10.792-34.128-9.7512-4.6761-22.451-1.4093-26.653 8.8491 4.579-8.2229 15.097-10.929 23.173-7.0559 10.454 5.0127 13.82 18.172 8.9378 28.265-6.28 12.982-22.656 17.15-35.202 11.031-16.042-7.8242-21.175-28.099-13.548-43.614 9.6968-19.727 34.675-26.02 53.769-16.564 24.146 11.958 31.826 42.586 20.161 65.976-14.676 29.425-52.064 38.758-80.588 24.435-35.707-17.93-47.001-63.375-29.496-98.011 21.81-43.154 76.821-56.768 118.71-35.467 51.952 26.419 68.301 92.748 42.489 143.21-31.874 62.31-111.55 81.872-172.1 50.72-74.466-38.308-97.791-133.66-60.337-206.08 45.872-88.687 159.6-116.41 245.89-71.541 105.27 54.735 138.11 189.92 84.556 292.4-4.3706 8.3638-10.516 18.213-15.992 26.062 8.0998 4.1434 16.113 8.9535 23.83 14.528 6.233 4.5024 12.08 9.4276 17.552 14.674 5.8809-8.7305 11.249-17.744 16.101-27.028z");
			attr(path17, "sodipodi:nodetypes", "sssssssssssssscsssssssssssssscscs");
			attr(path17, "inkscape:connector-curvature", "0");
			attr(path18, "id", "path4968");

			attr(path18, "class", path18_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			attr(path18, "inkscape:connector-curvature", "0");
			attr(path18, "d", "m1100 252.1c-38.582-5.0193-71.655-28.564-88.698-63.144-13.064-26.507-15.479-57.006-6.7207-84.88 3.4376-10.94 7.5514-19.486 14.247-29.596 6.1465-9.2808 11.637-15.576 19.717-22.605 12.521-10.893 25.403-18.105 41.405-23.181 19.708-6.252 41.942-6.9335 61.744-1.8924 9.1446 2.3281 18.849 6.0402 26.659 10.198 6.7541 3.5957 17.813 11.197 14.27 9.8081-3.7223-1.4589-13.367-3.9653-19.48-5.0623-10.763-1.9314-27.667-2.3031-37.837-0.83196-28.658 4.1454-52.123 15.814-71.818 35.715-31.192 31.516-43.548 77.168-31.048 114.71 8.0684 24.235 25.64 42.29 48.587 49.924 17.279 5.7486 35.216 4.6663 51.146-3.0861 17.77-8.6479 30.052-24.393 34.071-43.68 1.044-5.01 1.1472-15.932 0.2003-21.208-2.0065-11.181-6.9794-20.781-15.161-29.269-10.973-11.384-24.569-17.144-40.559-17.184-3.4463-0.008-6.8524 0.13881-7.569 0.32717-1.2043 0.31652-1.3277 0.21087-1.6288-1.3939-0.6188-3.2984 0.1393-16.572 1.1676-20.443 3.2487-12.229 8.3824-20.963 17.303-29.438 11.958-11.361 27.245-17.312 44.47-17.312 26.745 0 51.255 15.462 64.354 40.596 13.607 26.109 13.1 58.996-1.3683 88.767-17.246 35.486-49.965 58.974-89.345 64.139-6.7396 0.88387-21.387 0.89435-28.107 0.0201v0.00002z");
			attr(path19, "id", "path4970");

			attr(path19, "class", path19_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			attr(path19, "inkscape:connector-curvature", "0");
			attr(path19, "d", "m1140 173.74c-18.736-2.3106-34.722-13.517-43.08-30.199-1.9142-3.8208-3.9735-9.6041-4.5847-12.876l-0.3923-2.0999 1.7357-0.28711c3.2107-0.5311 12.421-0.3036 16.499 0.40756 20.2 3.5226 36.747 17.773 43.077 37.099 1.8297 5.5857 2.0524 7.261 1.0179 7.6579-1.3815 0.53013-10.795 0.72609-14.273 0.29712z");
			attr(g3, "id", "g4966");
			attr(g3, "transform", "matrix(-.014112 .010669 .010669 .014112 -5294.4 2874.1)");
			attr(path20, "id", "path4974");

			attr(path20, "class", path20_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			attr(path20, "d", "m1100 252.1c-38.582-5.0193-71.655-28.564-88.698-63.144-13.064-26.507-15.479-57.006-6.7207-84.88 3.4376-10.94 7.5514-19.486 14.247-29.596 6.1465-9.2808 11.637-15.576 19.717-22.605 12.521-10.893 25.403-18.105 41.405-23.181 19.708-6.252 41.942-6.9335 61.744-1.8924 9.1446 2.3281 18.849 6.0402 26.659 10.198 6.7541 3.5957 17.813 11.197 14.27 9.8081-3.7223-1.4589-13.367-3.9653-19.48-5.0623-10.763-1.9314-27.667-2.3031-37.837-0.83196-28.658 4.1454-52.123 15.814-71.818 35.715-31.192 31.516-43.548 77.168-31.048 114.71 8.0684 24.235 25.64 42.29 48.587 49.924 17.279 5.7486 35.216 4.6663 51.146-3.0861 17.77-8.6479 30.052-24.393 34.071-43.68 1.044-5.01 1.1472-15.932 0.2003-21.208-2.0065-11.181-6.9794-20.781-15.161-29.269-10.973-11.384-24.569-17.144-40.559-17.184-3.4463-0.008-6.8524 0.13881-7.569 0.32717-1.2043 0.31652-1.3277 0.21087-1.6288-1.3939-0.6188-3.2984 0.1393-16.572 1.1676-20.443 3.2487-12.229 8.3824-20.963 17.303-29.438 11.958-11.361 27.245-17.312 44.47-17.312 26.745 0 51.255 15.462 64.354 40.596 13.607 26.109 13.1 58.996-1.3683 88.767-17.246 35.486-49.965 58.974-89.345 64.139-6.7396 0.88387-21.387 0.89435-28.107 0.0201v0.00002z");
			set_style(path20, "fill", "#000000");
			attr(path20, "inkscape:connector-curvature", "0");
			attr(path21, "id", "path4976");
			attr(path21, "d", "m1140 173.74c-18.736-2.3106-34.722-13.517-43.08-30.199-1.9142-3.8208-3.9735-9.6041-4.5847-12.876l-0.3923-2.0999 1.7357-0.28711c3.2107-0.5311 12.421-0.3036 16.499 0.40756 20.2 3.5226 36.747 17.773 43.077 37.099 1.8297 5.5857 2.0524 7.261 1.0179 7.6579-1.3815 0.53013-10.795 0.72609-14.273 0.29712z");

			attr(path21, "class", path21_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			set_style(path21, "fill", "#000000");
			attr(path21, "inkscape:connector-curvature", "0");
			attr(g4, "id", "g4972");
			set_style(g4, "fill", "#000000");
			attr(g4, "transform", "matrix(-.015818 .0079232 -.0079232 -.015818 -5507.7 3092.4)");
			attr(path22, "id", "path4980");
			attr(path22, "inkscape:connector-curvature", "0");

			attr(path22, "class", path22_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			attr(path22, "d", "m1100 252.1c-38.582-5.0193-71.655-28.564-88.698-63.144-13.064-26.507-15.479-57.006-6.7207-84.88 3.4376-10.94 7.5514-19.486 14.247-29.596 6.1465-9.2808 11.637-15.576 19.717-22.605 12.521-10.893 25.403-18.105 41.405-23.181 19.708-6.252 41.942-6.9335 61.744-1.8924 9.1446 2.3281 18.849 6.0402 26.659 10.198 6.7541 3.5957 17.813 11.197 14.27 9.8081-3.7223-1.4589-13.367-3.9653-19.48-5.0623-10.763-1.9314-27.667-2.3031-37.837-0.83196-28.658 4.1454-52.123 15.814-71.818 35.715-31.192 31.516-43.548 77.168-31.048 114.71 8.0684 24.235 25.64 42.29 48.587 49.924 17.279 5.7486 35.216 4.6663 51.146-3.0861 17.77-8.6479 30.052-24.393 34.071-43.68 1.044-5.01 1.1472-15.932 0.2003-21.208-2.0065-11.181-6.9794-20.781-15.161-29.269-10.973-11.384-24.569-17.144-40.559-17.184-3.4463-0.008-6.8524 0.13881-7.569 0.32717-1.2043 0.31652-1.3277 0.21087-1.6288-1.3939-0.6188-3.2984 0.1393-16.572 1.1676-20.443 3.2487-12.229 8.3824-20.963 17.303-29.438 11.958-11.361 27.245-17.312 44.47-17.312 26.745 0 51.255 15.462 64.354 40.596 13.607 26.109 13.1 58.996-1.3683 88.767-17.246 35.486-49.965 58.974-89.345 64.139-6.7396 0.88387-21.387 0.89435-28.107 0.0201v0.00002z");
			attr(path23, "id", "path4982");
			attr(path23, "inkscape:connector-curvature", "0");

			attr(path23, "class", path23_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			attr(path23, "d", "m1140 173.74c-18.736-2.3106-34.722-13.517-43.08-30.199-1.9142-3.8208-3.9735-9.6041-4.5847-12.876l-0.3923-2.0999 1.7357-0.28711c3.2107-0.5311 12.421-0.3036 16.499 0.40756 20.2 3.5226 36.747 17.773 43.077 37.099 1.8297 5.5857 2.0524 7.261 1.0179 7.6579-1.3815 0.53013-10.795 0.72609-14.273 0.29712z");
			attr(g5, "id", "g4978");
			set_style(g5, "fill", "#000000");
			attr(g5, "transform", "matrix(-.0070262 -.016236 .016236 -.0070262 -5387.5 2655.3)");
			attr(path24, "id", "path4986");

			attr(path24, "class", path24_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			attr(path24, "d", "m1100 252.1c-38.582-5.0193-71.655-28.564-88.698-63.144-13.064-26.507-15.479-57.006-6.7207-84.88 3.4376-10.94 7.5514-19.486 14.247-29.596 6.1465-9.2808 11.637-15.576 19.717-22.605 12.521-10.893 25.403-18.105 41.405-23.181 19.708-6.252 41.942-6.9335 61.744-1.8924 9.1446 2.3281 18.849 6.0402 26.659 10.198 6.7541 3.5957 17.813 11.197 14.27 9.8081-3.7223-1.4589-13.367-3.9653-19.48-5.0623-10.763-1.9314-27.667-2.3031-37.837-0.83196-28.658 4.1454-52.123 15.814-71.818 35.715-31.192 31.516-43.548 77.168-31.048 114.71 8.0684 24.235 25.64 42.29 48.587 49.924 17.279 5.7486 35.216 4.6663 51.146-3.0861 17.77-8.6479 30.052-24.393 34.071-43.68 1.044-5.01 1.1472-15.932 0.2003-21.208-2.0065-11.181-6.9794-20.781-15.161-29.269-10.973-11.384-24.569-17.144-40.559-17.184-3.4463-0.008-6.8524 0.13881-7.569 0.32717-1.2043 0.31652-1.3277 0.21087-1.6288-1.3939-0.6188-3.2984 0.1393-16.572 1.1676-20.443 3.2487-12.229 8.3824-20.963 17.303-29.438 11.958-11.361 27.245-17.312 44.47-17.312 26.745 0 51.255 15.462 64.354 40.596 13.607 26.109 13.1 58.996-1.3683 88.767-17.246 35.486-49.965 58.974-89.345 64.139-6.7396 0.88387-21.387 0.89435-28.107 0.0201v0.00002z");
			attr(path24, "inkscape:connector-curvature", "0");
			attr(path25, "id", "path4988");
			attr(path25, "d", "m1140 173.74c-18.736-2.3106-34.722-13.517-43.08-30.199-1.9142-3.8208-3.9735-9.6041-4.5847-12.876l-0.3923-2.0999 1.7357-0.28711c3.2107-0.5311 12.421-0.3036 16.499 0.40756 20.2 3.5226 36.747 17.773 43.077 37.099 1.8297 5.5857 2.0524 7.261 1.0179 7.6579-1.3815 0.53013-10.795 0.72609-14.273 0.29712z");

			attr(path25, "class", path25_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			attr(path25, "inkscape:connector-curvature", "0");
			attr(g6, "id", "g4984");
			set_style(g6, "fill", "#000000");
			attr(g6, "transform", "matrix(.013851 -.015717 .015717 .013851 -4944.7 2476.4)");
			attr(path26, "id", "path4992");

			attr(path26, "class", path26_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			attr(path26, "inkscape:connector-curvature", "0");
			attr(path26, "d", "m1100 252.1c-38.582-5.0193-71.655-28.564-88.698-63.144-13.064-26.507-15.479-57.006-6.7207-84.88 3.4376-10.94 7.5514-19.486 14.247-29.596 6.1465-9.2808 11.637-15.576 19.717-22.605 12.521-10.893 25.403-18.105 41.405-23.181 19.708-6.252 41.942-6.9335 61.744-1.8924 9.1446 2.3281 18.849 6.0402 26.659 10.198 6.7541 3.5957 17.813 11.197 14.27 9.8081-3.7223-1.4589-13.367-3.9653-19.48-5.0623-10.763-1.9314-27.667-2.3031-37.837-0.83196-28.658 4.1454-52.123 15.814-71.818 35.715-31.192 31.516-43.548 77.168-31.048 114.71 8.0684 24.235 25.64 42.29 48.587 49.924 17.279 5.7486 35.216 4.6663 51.146-3.0861 17.77-8.6479 30.052-24.393 34.071-43.68 1.044-5.01 1.1472-15.932 0.2003-21.208-2.0065-11.181-6.9794-20.781-15.161-29.269-10.973-11.384-24.569-17.144-40.559-17.184-3.4463-0.008-6.8524 0.13881-7.569 0.32717-1.2043 0.31652-1.3277 0.21087-1.6288-1.3939-0.6188-3.2984 0.1393-16.572 1.1676-20.443 3.2487-12.229 8.3824-20.963 17.303-29.438 11.958-11.361 27.245-17.312 44.47-17.312 26.745 0 51.255 15.462 64.354 40.596 13.607 26.109 13.1 58.996-1.3683 88.767-17.246 35.486-49.965 58.974-89.345 64.139-6.7396 0.88387-21.387 0.89435-28.107 0.0201v0.00002z");
			attr(path27, "id", "path4994");
			attr(path27, "inkscape:connector-curvature", "0");

			attr(path27, "class", path27_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			attr(path27, "d", "m1140 173.74c-18.736-2.3106-34.722-13.517-43.08-30.199-1.9142-3.8208-3.9735-9.6041-4.5847-12.876l-0.3923-2.0999 1.7357-0.28711c3.2107-0.5311 12.421-0.3036 16.499 0.40756 20.2 3.5226 36.747 17.773 43.077 37.099 1.8297 5.5857 2.0524 7.261 1.0179 7.6579-1.3815 0.53013-10.795 0.72609-14.273 0.29712z");
			attr(g7, "id", "g4990");
			set_style(g7, "fill", "#000000");
			attr(g7, "transform", "matrix(-.039369 -.092681 -.092681 .039369 -4667.5 2782.9)");
			attr(path28, "id", "path4998");

			attr(path28, "class", path28_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			attr(path28, "d", "m1100 252.1c-38.582-5.0193-71.655-28.564-88.698-63.144-13.064-26.507-15.479-57.006-6.7207-84.88 3.4376-10.94 7.5514-19.486 14.247-29.596 6.1465-9.2808 11.637-15.576 19.717-22.605 12.521-10.893 25.403-18.105 41.405-23.181 19.708-6.252 41.942-6.9335 61.744-1.8924 9.1446 2.3281 18.849 6.0402 26.659 10.198 6.7541 3.5957 17.813 11.197 14.27 9.8081-3.7223-1.4589-13.367-3.9653-19.48-5.0623-10.763-1.9314-27.667-2.3031-37.837-0.83196-28.658 4.1454-52.123 15.814-71.818 35.715-31.192 31.516-43.548 77.168-31.048 114.71 8.0684 24.235 25.64 42.29 48.587 49.924 17.279 5.7486 35.216 4.6663 51.146-3.0861 17.77-8.6479 30.052-24.393 34.071-43.68 1.044-5.01 1.1472-15.932 0.2003-21.208-2.0065-11.181-6.9794-20.781-15.161-29.269-10.973-11.384-24.569-17.144-40.559-17.184-3.4463-0.008-6.8524 0.13881-7.569 0.32717-1.2043 0.31652-1.3277 0.21087-1.6288-1.3939-0.6188-3.2984 0.1393-16.572 1.1676-20.443 3.2487-12.229 8.3824-20.963 17.303-29.438 11.958-11.361 27.245-17.312 44.47-17.312 26.745 0 51.255 15.462 64.354 40.596 13.607 26.109 13.1 58.996-1.3683 88.767-17.246 35.486-49.965 58.974-89.345 64.139-6.7396 0.88387-21.387 0.89435-28.107 0.0201v0.00002z");
			attr(path28, "inkscape:connector-curvature", "0");
			attr(path29, "id", "path5000");

			attr(path29, "class", path29_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			attr(path29, "d", "m1140 173.74c-18.736-2.3106-34.722-13.517-43.08-30.199-1.9142-3.8208-3.9735-9.6041-4.5847-12.876l-0.3923-2.0999 1.7357-0.28711c3.2107-0.5311 12.421-0.3036 16.499 0.40756 20.2 3.5226 36.747 17.773 43.077 37.099 1.8297 5.5857 2.0524 7.261 1.0179 7.6579-1.3815 0.53013-10.795 0.72609-14.273 0.29712z");
			attr(path29, "inkscape:connector-curvature", "0");
			attr(g8, "id", "g4996");
			set_style(g8, "fill", "#000000");
			attr(g8, "transform", "matrix(.0060549 .019502 -.019502 .0060549 -4616.2 2615)");
			attr(path30, "id", "path5004");

			attr(path30, "class", path30_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			attr(path30, "d", "m1100 252.1c-38.582-5.0193-71.655-28.564-88.698-63.144-13.064-26.507-15.479-57.006-6.7207-84.88 3.4376-10.94 7.5514-19.486 14.247-29.596 6.1465-9.2808 11.637-15.576 19.717-22.605 12.521-10.893 25.403-18.105 41.405-23.181 19.708-6.252 41.942-6.9335 61.744-1.8924 9.1446 2.3281 18.849 6.0402 26.659 10.198 6.7541 3.5957 17.813 11.197 14.27 9.8081-3.7223-1.4589-13.367-3.9653-19.48-5.0623-10.763-1.9314-27.667-2.3031-37.837-0.83196-28.658 4.1454-52.123 15.814-71.818 35.715-31.192 31.516-43.548 77.168-31.048 114.71 8.0684 24.235 25.64 42.29 48.587 49.924 17.279 5.7486 35.216 4.6663 51.146-3.0861 17.77-8.6479 30.052-24.393 34.071-43.68 1.044-5.01 1.1472-15.932 0.2003-21.208-2.0065-11.181-6.9794-20.781-15.161-29.269-10.973-11.384-24.569-17.144-40.559-17.184-3.4463-0.008-6.8524 0.13881-7.569 0.32717-1.2043 0.31652-1.3277 0.21087-1.6288-1.3939-0.6188-3.2984 0.1393-16.572 1.1676-20.443 3.2487-12.229 8.3824-20.963 17.303-29.438 11.958-11.361 27.245-17.312 44.47-17.312 26.745 0 51.255 15.462 64.354 40.596 13.607 26.109 13.1 58.996-1.3683 88.767-17.246 35.486-49.965 58.974-89.345 64.139-6.7396 0.88387-21.387 0.89435-28.107 0.0201v0.00002z");
			attr(path30, "inkscape:connector-curvature", "0");
			attr(path31, "id", "path5006");

			attr(path31, "class", path31_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			attr(path31, "d", "m1140 173.74c-18.736-2.3106-34.722-13.517-43.08-30.199-1.9142-3.8208-3.9735-9.6041-4.5847-12.876l-0.3923-2.0999 1.7357-0.28711c3.2107-0.5311 12.421-0.3036 16.499 0.40756 20.2 3.5226 36.747 17.773 43.077 37.099 1.8297 5.5857 2.0524 7.261 1.0179 7.6579-1.3815 0.53013-10.795 0.72609-14.273 0.29712z");
			attr(path31, "inkscape:connector-curvature", "0");
			attr(g9, "id", "g5002");
			set_style(g9, "fill", "#000000");
			attr(g9, "transform", "matrix(.040611 -.092143 .092143 .040611 -4897.8 3267.7)");
			attr(path32, "id", "path5010");

			attr(path32, "class", path32_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			attr(path32, "d", "m1100 252.1c-38.582-5.0193-71.655-28.564-88.698-63.144-13.064-26.507-15.479-57.006-6.7207-84.88 3.4376-10.94 7.5514-19.486 14.247-29.596 6.1465-9.2808 11.637-15.576 19.717-22.605 12.521-10.893 25.403-18.105 41.405-23.181 19.708-6.252 41.942-6.9335 61.744-1.8924 9.1446 2.3281 18.849 6.0402 26.659 10.198 6.7541 3.5957 17.813 11.197 14.27 9.8081-3.7223-1.4589-13.367-3.9653-19.48-5.0623-10.763-1.9314-27.667-2.3031-37.837-0.83196-28.658 4.1454-52.123 15.814-71.818 35.715-31.192 31.516-43.548 77.168-31.048 114.71 8.0684 24.235 25.64 42.29 48.587 49.924 17.279 5.7486 35.216 4.6663 51.146-3.0861 17.77-8.6479 30.052-24.393 34.071-43.68 1.044-5.01 1.1472-15.932 0.2003-21.208-2.0065-11.181-6.9794-20.781-15.161-29.269-10.973-11.384-24.569-17.144-40.559-17.184-3.4463-0.008-6.8524 0.13881-7.569 0.32717-1.2043 0.31652-1.3277 0.21087-1.6288-1.3939-0.6188-3.2984 0.1393-16.572 1.1676-20.443 3.2487-12.229 8.3824-20.963 17.303-29.438 11.958-11.361 27.245-17.312 44.47-17.312 26.745 0 51.255 15.462 64.354 40.596 13.607 26.109 13.1 58.996-1.3683 88.767-17.246 35.486-49.965 58.974-89.345 64.139-6.7396 0.88387-21.387 0.89435-28.107 0.0201v0.00002z");
			attr(path32, "inkscape:connector-curvature", "0");
			attr(path33, "id", "path5012");
			attr(path33, "d", "m1140 173.74c-18.736-2.3106-34.722-13.517-43.08-30.199-1.9142-3.8208-3.9735-9.6041-4.5847-12.876l-0.3923-2.0999 1.7357-0.28711c3.2107-0.5311 12.421-0.3036 16.499 0.40756 20.2 3.5226 36.747 17.773 43.077 37.099 1.8297 5.5857 2.0524 7.261 1.0179 7.6579-1.3815 0.53013-10.795 0.72609-14.273 0.29712z");

			attr(path33, "class", path33_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			attr(path33, "inkscape:connector-curvature", "0");
			attr(g10, "id", "g5008");
			set_style(g10, "fill", "#000000");
			attr(g10, "transform", "matrix(-.012081 .00090683 .00090683 .012081 -5150.2 2931.4)");
			attr(path34, "id", "path5016");
			attr(path34, "inkscape:connector-curvature", "0");

			attr(path34, "class", path34_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			attr(path34, "d", "m1100 252.1c-38.582-5.0193-71.655-28.564-88.698-63.144-13.064-26.507-15.479-57.006-6.7207-84.88 3.4376-10.94 7.5514-19.486 14.247-29.596 6.1465-9.2808 11.637-15.576 19.717-22.605 12.521-10.893 25.403-18.105 41.405-23.181 19.708-6.252 41.942-6.9335 61.744-1.8924 9.1446 2.3281 18.849 6.0402 26.659 10.198 6.7541 3.5957 17.813 11.197 14.27 9.8081-3.7223-1.4589-13.367-3.9653-19.48-5.0623-10.763-1.9314-27.667-2.3031-37.837-0.83196-28.658 4.1454-52.123 15.814-71.818 35.715-31.192 31.516-43.548 77.168-31.048 114.71 8.0684 24.235 25.64 42.29 48.587 49.924 17.279 5.7486 35.216 4.6663 51.146-3.0861 17.77-8.6479 30.052-24.393 34.071-43.68 1.044-5.01 1.1472-15.932 0.2003-21.208-2.0065-11.181-6.9794-20.781-15.161-29.269-10.973-11.384-24.569-17.144-40.559-17.184-3.4463-0.008-6.8524 0.13881-7.569 0.32717-1.2043 0.31652-1.3277 0.21087-1.6288-1.3939-0.6188-3.2984 0.1393-16.572 1.1676-20.443 3.2487-12.229 8.3824-20.963 17.303-29.438 11.958-11.361 27.245-17.312 44.47-17.312 26.745 0 51.255 15.462 64.354 40.596 13.607 26.109 13.1 58.996-1.3683 88.767-17.246 35.486-49.965 58.974-89.345 64.139-6.7396 0.88387-21.387 0.89435-28.107 0.0201v0.00002z");
			attr(path35, "id", "path5018");
			attr(path35, "inkscape:connector-curvature", "0");

			attr(path35, "class", path35_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"));

			attr(path35, "d", "m1140 173.74c-18.736-2.3106-34.722-13.517-43.08-30.199-1.9142-3.8208-3.9735-9.6041-4.5847-12.876l-0.3923-2.0999 1.7357-0.28711c3.2107-0.5311 12.421-0.3036 16.499 0.40756 20.2 3.5226 36.747 17.773 43.077 37.099 1.8297 5.5857 2.0524 7.261 1.0179 7.6579-1.3815 0.53013-10.795 0.72609-14.273 0.29712z");
			attr(g11, "id", "g5014");
			set_style(g11, "fill", "#000000");
			attr(g11, "transform", "matrix(-.014158 -.015441 -.015441 .014158 -4594.9 2978)");
			attr(g12, "id", "g5848");
			attr(g12, "transform", "matrix(.41395 0 0 .41395 -6675.3 1897.4)");
			attr(g13, "id", "layer1");
			attr(g13, "inkscape:label", "Layer 1");
			attr(g13, "inkscape:groupmode", "layer");
			attr(g13, "transform", "translate(9056 -2892.1)");
			attr(dc_type, "rdf:resource", "http://purl.org/dc/dcmitype/StillImage");
			attr(cc_license, "rdf:resource", "http://creativecommons.org/licenses/publicdomain/");
			attr(cc_Agent, "rdf:about", "http://openclipart.org/");
			attr(cc_permits0, "rdf:resource", "http://creativecommons.org/ns#Reproduction");
			attr(cc_permits1, "rdf:resource", "http://creativecommons.org/ns#Distribution");
			attr(cc_permits2, "rdf:resource", "http://creativecommons.org/ns#DerivativeWorks");
			attr(cc_License, "rdf:about", "http://creativecommons.org/licenses/publicdomain/");
			attr(svg, "xmlns:inkscape", "http://www.inkscape.org/namespaces/inkscape");
			attr(svg, "xmlns:rdf", "http://www.w3.org/1999/02/22-rdf-syntax-ns#");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:sodipodi", "http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd");
			attr(svg, "xmlns:ns1", "http://sozi.baierouge.fr");
			attr(svg, "xmlns:cc", "http://creativecommons.org/ns#");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "xmlns:dc", "http://purl.org/dc/elements/1.1/");
			attr(svg, "id", "svg2");
			attr(svg, "viewBox", "0 0 500 395.89");
			attr(svg, "version", "1.1");
			set_style(svg, "margin-top", "auto");
			attr(svg, "inkscape:version", "0.48.3.1 r9886");
			attr(svg, "class", "spiral-logo");
			attr(svg, "width", "25");
			attr(div0, "class", "container-logo-svg svelte-1uzzr70");
			set_style(div0, "visibility", /*$isActive*/ ctx[1](`/index`) ? `hidden` : `visible`);
			attr(a, "href", a_href_value = /*$url*/ ctx[3]("/index"));
			set_style(a, "visibility", /*$isActive*/ ctx[1](`/index`) ? `hidden` : `visible`);
			set_style(a, "color", /*$siteMode*/ ctx[2] === "dark" ? "white" : "black");
			set_style(a, "font-size", "xx-large");
			set_style(a, "text-decoration", "none");
			set_style(a, "padding", "0px 0px 0px 0px");
			attr(a, "class", "svelte-1uzzr70");
			attr(div1, "class", "container-logo svelte-1uzzr70");
			attr(div2, "class", "container-links svelte-1uzzr70");
		},
		m(target, anchor) {
			insert(target, nav, anchor);
			append(nav, div1);
			append(div1, div0);
			append(div0, svg);
			append(svg, sodipodi_namedview);
			append(svg, g13);
			append(g13, g12);
			append(g12, path0);
			append(g12, path1);
			append(g12, path2);
			append(g12, path3);
			append(g12, path4);
			append(g12, g0);
			append(g0, path5);
			append(g0, path6);
			append(g12, path7);
			append(g12, path8);
			append(g12, path9);
			append(g12, g1);
			append(g1, path10);
			append(g1, path11);
			append(g12, path12);
			append(g12, path13);
			append(g12, path14);
			append(g12, g2);
			append(g2, path15);
			append(g2, path16);
			append(g12, path17);
			append(g12, g3);
			append(g3, path18);
			append(g3, path19);
			append(g12, g4);
			append(g4, path20);
			append(g4, path21);
			append(g12, g5);
			append(g5, path22);
			append(g5, path23);
			append(g12, g6);
			append(g6, path24);
			append(g6, path25);
			append(g12, g7);
			append(g7, path26);
			append(g7, path27);
			append(g12, g8);
			append(g8, path28);
			append(g8, path29);
			append(g12, g9);
			append(g9, path30);
			append(g9, path31);
			append(g12, g10);
			append(g10, path32);
			append(g10, path33);
			append(g12, g11);
			append(g11, path34);
			append(g11, path35);
			append(svg, metadata);
			append(metadata, rdf_RDF);
			append(rdf_RDF, cc_Work);
			append(cc_Work, dc_format);
			append(dc_format, t0);
			append(cc_Work, dc_type);
			append(cc_Work, cc_license);
			append(cc_Work, dc_publisher);
			append(dc_publisher, cc_Agent);
			append(cc_Agent, dc_title);
			append(dc_title, t1);
			append(rdf_RDF, cc_License);
			append(cc_License, cc_permits0);
			append(cc_License, cc_permits1);
			append(cc_License, cc_permits2);
			append(div1, t2);
			append(div1, a);
			append(a, t3);
			append(nav, t4);
			append(nav, div2);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div2, null);
			}

			append(nav, t5);
			append(nav, div3);
			if_block.m(div3, null);
		},
		p(ctx, [dirty]) {
			if (dirty & /*$siteMode*/ 4 && path0_class_value !== (path0_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path0, "class", path0_class_value);
			}

			if (dirty & /*$siteMode*/ 4 && path1_class_value !== (path1_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path1, "class", path1_class_value);
			}

			if (dirty & /*$siteMode*/ 4 && path2_class_value !== (path2_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path2, "class", path2_class_value);
			}

			if (dirty & /*$siteMode*/ 4 && path3_class_value !== (path3_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path3, "class", path3_class_value);
			}

			if (dirty & /*$siteMode*/ 4 && path4_class_value !== (path4_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path4, "class", path4_class_value);
			}

			if (dirty & /*$siteMode*/ 4 && path5_class_value !== (path5_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path5, "class", path5_class_value);
			}

			if (dirty & /*$siteMode*/ 4 && path6_class_value !== (path6_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path6, "class", path6_class_value);
			}

			if (dirty & /*$siteMode*/ 4 && path7_class_value !== (path7_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path7, "class", path7_class_value);
			}

			if (dirty & /*$siteMode*/ 4 && path8_class_value !== (path8_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path8, "class", path8_class_value);
			}

			if (dirty & /*$siteMode*/ 4 && path9_class_value !== (path9_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path9, "class", path9_class_value);
			}

			if (dirty & /*$siteMode*/ 4 && path10_class_value !== (path10_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path10, "class", path10_class_value);
			}

			if (dirty & /*$siteMode*/ 4 && path11_class_value !== (path11_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path11, "class", path11_class_value);
			}

			if (dirty & /*$siteMode*/ 4 && path12_class_value !== (path12_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path12, "class", path12_class_value);
			}

			if (dirty & /*$siteMode*/ 4 && path13_class_value !== (path13_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path13, "class", path13_class_value);
			}

			if (dirty & /*$siteMode*/ 4 && path14_class_value !== (path14_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path14, "class", path14_class_value);
			}

			if (dirty & /*$siteMode*/ 4 && path15_class_value !== (path15_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path15, "class", path15_class_value);
			}

			if (dirty & /*$siteMode*/ 4 && path16_class_value !== (path16_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path16, "class", path16_class_value);
			}

			if (dirty & /*$siteMode*/ 4 && path17_class_value !== (path17_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path17, "class", path17_class_value);
			}

			if (dirty & /*$siteMode*/ 4 && path18_class_value !== (path18_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path18, "class", path18_class_value);
			}

			if (dirty & /*$siteMode*/ 4 && path19_class_value !== (path19_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path19, "class", path19_class_value);
			}

			if (dirty & /*$siteMode*/ 4 && path20_class_value !== (path20_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path20, "class", path20_class_value);
			}

			if (dirty & /*$siteMode*/ 4 && path21_class_value !== (path21_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path21, "class", path21_class_value);
			}

			if (dirty & /*$siteMode*/ 4 && path22_class_value !== (path22_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path22, "class", path22_class_value);
			}

			if (dirty & /*$siteMode*/ 4 && path23_class_value !== (path23_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path23, "class", path23_class_value);
			}

			if (dirty & /*$siteMode*/ 4 && path24_class_value !== (path24_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path24, "class", path24_class_value);
			}

			if (dirty & /*$siteMode*/ 4 && path25_class_value !== (path25_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path25, "class", path25_class_value);
			}

			if (dirty & /*$siteMode*/ 4 && path26_class_value !== (path26_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path26, "class", path26_class_value);
			}

			if (dirty & /*$siteMode*/ 4 && path27_class_value !== (path27_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path27, "class", path27_class_value);
			}

			if (dirty & /*$siteMode*/ 4 && path28_class_value !== (path28_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path28, "class", path28_class_value);
			}

			if (dirty & /*$siteMode*/ 4 && path29_class_value !== (path29_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path29, "class", path29_class_value);
			}

			if (dirty & /*$siteMode*/ 4 && path30_class_value !== (path30_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path30, "class", path30_class_value);
			}

			if (dirty & /*$siteMode*/ 4 && path31_class_value !== (path31_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path31, "class", path31_class_value);
			}

			if (dirty & /*$siteMode*/ 4 && path32_class_value !== (path32_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path32, "class", path32_class_value);
			}

			if (dirty & /*$siteMode*/ 4 && path33_class_value !== (path33_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path33, "class", path33_class_value);
			}

			if (dirty & /*$siteMode*/ 4 && path34_class_value !== (path34_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path34, "class", path34_class_value);
			}

			if (dirty & /*$siteMode*/ 4 && path35_class_value !== (path35_class_value = "" + ((/*$siteMode*/ ctx[2] === "dark"
			? "path-dark"
			: "path-light") + ";"))) {
				attr(path35, "class", path35_class_value);
			}

			if (dirty & /*$isActive*/ 2) {
				set_style(div0, "visibility", /*$isActive*/ ctx[1](`/index`) ? `hidden` : `visible`);
			}

			if (dirty & /*$url*/ 8 && a_href_value !== (a_href_value = /*$url*/ ctx[3]("/index"))) {
				attr(a, "href", a_href_value);
			}

			if (dirty & /*$isActive*/ 2) {
				set_style(a, "visibility", /*$isActive*/ ctx[1](`/index`) ? `hidden` : `visible`);
			}

			if (dirty & /*$siteMode*/ 4) {
				set_style(a, "color", /*$siteMode*/ ctx[2] === "dark" ? "white" : "black");
			}

			if (dirty & /*$siteMode, $isActive, links, undefined, $url, persistentParams*/ 79) {
				each_value = /*links*/ ctx[6];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$i(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$i(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div2, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div3, null);
				}
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(nav);
			destroy_each(each_blocks, detaching);
			if_block.d();
		}
	};
}

function instance$13($$self, $$props, $$invalidate) {
	let $params;
	let $isActive;
	let $siteMode;
	let $url;
	let $username;
	let $avatar_url;
	component_subscribe($$self, params, $$value => $$invalidate(8, $params = $$value));
	component_subscribe($$self, isActive, $$value => $$invalidate(1, $isActive = $$value));
	component_subscribe($$self, siteMode, $$value => $$invalidate(2, $siteMode = $$value));
	component_subscribe($$self, url, $$value => $$invalidate(3, $url = $$value));
	component_subscribe($$self, username, $$value => $$invalidate(4, $username = $$value));
	component_subscribe($$self, avatar_url, $$value => $$invalidate(5, $avatar_url = $$value));
	let controller = new Controller(); // this will return the previously created Singleton instance

	// const { user, signout } = authStore
	const links = [
		["/playground", "playground"],
		["/tutorial", "tutorial"],
		["/docs", "reference"],
		["/about", "about"]
	];

	let persistentParams = {
		chapter: "01-basics",
		section: "01-introduction"
	};

	const click_handler = () => signOut();

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$params, controller*/ 384) {
			// update url parameters only when navigating tutorials
			 if ($params.chapter && $params.section) {
				// console.log(`navigation:url:${$url}:params:${$params}}`);
				console.log(`navigation:url:${$params.chapter}:params:${$params.section}}`);

				$$invalidate(0, persistentParams = $params);

				if (!controller) {
					$$invalidate(7, controller = new Controller());
				}

				// does an async hush
				controller.stop();
			}
		}
	};

	return [
		persistentParams,
		$isActive,
		$siteMode,
		$url,
		$username,
		$avatar_url,
		links,
		controller,
		$params,
		click_handler
	];
}

class Navigation extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1uzzr70-style")) add_css$V();
		init(this, options, instance$13, create_fragment$15, safe_not_equal, {});
	}
}

/* src/pages/_layout.svelte generated by Svelte v3.31.0 */

const { document: document_1$9 } = globals;

function add_css$W() {
	var style = element("style");
	style.id = "svelte-ni42rv-style";
	style.textContent = ".app-dark.svelte-ni42rv{background-color:#151515;color:white}.app-light.svelte-ni42rv{background-color:white;color:black}";
	append(document_1$9.head, style);
}

function create_fragment$16(ctx) {
	let div;
	let header;
	let navigation;
	let t0;
	let main;
	let t1;
	let footer;
	let div_class_value;
	let current;
	navigation = new Navigation({});
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	return {
		c() {
			div = element("div");
			header = element("header");
			create_component(navigation.$$.fragment);
			t0 = space();
			main = element("main");
			if (default_slot) default_slot.c();
			t1 = space();
			footer = element("footer");

			attr(div, "class", div_class_value = "app " + (/*$siteMode*/ ctx[0] === "dark"
			? "app-dark"
			: "app-light") + " svelte-ni42rv");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, header);
			mount_component(navigation, header, null);
			append(div, t0);
			append(div, main);

			if (default_slot) {
				default_slot.m(main, null);
			}

			append(div, t1);
			append(div, footer);
			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			if (!current || dirty & /*$siteMode*/ 1 && div_class_value !== (div_class_value = "app " + (/*$siteMode*/ ctx[0] === "dark"
			? "app-dark"
			: "app-light") + " svelte-ni42rv")) {
				attr(div, "class", div_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(navigation.$$.fragment, local);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(navigation.$$.fragment, local);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(navigation);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$14($$self, $$props, $$invalidate) {
	let $engineStatus;
	let $sidebarLiveCodeOptions;
	let $ready;
	let $tutorials;
	let $selected;
	let $params;
	let $items;
	let $links;
	let $chosenDocs;
	let $siteMode;
	component_subscribe($$self, engineStatus, $$value => $$invalidate(6, $engineStatus = $$value));
	component_subscribe($$self, sidebarLiveCodeOptions, $$value => $$invalidate(7, $sidebarLiveCodeOptions = $$value));
	component_subscribe($$self, ready, $$value => $$invalidate(8, $ready = $$value));
	component_subscribe($$self, tutorials, $$value => $$invalidate(9, $tutorials = $$value));
	component_subscribe($$self, selected, $$value => $$invalidate(10, $selected = $$value));
	component_subscribe($$self, params, $$value => $$invalidate(2, $params = $$value));
	component_subscribe($$self, items$1, $$value => $$invalidate(11, $items = $$value));
	component_subscribe($$self, links, $$value => $$invalidate(12, $links = $$value));
	component_subscribe($$self, chosenDocs, $$value => $$invalidate(13, $chosenDocs = $$value));
	component_subscribe($$self, siteMode, $$value => $$invalidate(0, $siteMode = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	let controller = new Controller(); // this will return the previously created Singleton instance
	let engine = controller.engine;

	/**
 * Loads language options from language service and set grammar and default code sources
*/
	let loadSidebarLiveCodeOptions = () => {
		fetch(document.location.origin + `/languages/languages.json`).then(r => r.json()).then(json => {
			// console.log("DEBUG:_layout:loadPlayground");
			// console.log(json)
			set_store_value(
				sidebarLiveCodeOptions,
				$sidebarLiveCodeOptions = $sidebarLiveCodeOptions.concat(json.map(language => ({
					id: 1,
					disabled: false,
					text: language.name,
					content: {
						grammar: `/languages/${language.name}/grammar.ne`,
						livecode: `/languages/${language.name}/code.sem`
					}
				}))),
				$sidebarLiveCodeOptions
			);

			$ready();
		}).catch(() => new Error("Fetching languages.json failed"));

		
	};

	/**
   * Fetches Tutorial table of contents and sets default tutorial (Basics/Introduction)
  */
	let fetchAndLoadDefaultTutorial = () => {
		fetch(document.location.origin + `/tutorial/tutorial.json`).then(r => r.json()).then(json => {
			set_store_value(tutorials, $tutorials = json, $tutorials);
			set_store_value(selected, $selected = $tutorials[0].sections[0], $selected);
			$ready();
		}).catch(() => new Error("Fetching tutorial.json failed"));
	};

	/**
 * Fetches and sets the contents of the default tutorial (Basics/Introduction)
*/
	let fetchAndLoadDefaultTutorialItems = async () => {
		if ($params.chapter_dir !== undefined && params.section_dir !== undefined) {
			fetch(document.location.origin + `/tutorial/${$params.chapter_dir}/${$params.section_dir}/layout.json`).then(r => r.json()).then(json => {
				set_store_value(items$1, $items = json.map(item => hydrateJSONcomponent$1(item)), $items);
				$ready();
			}).catch(() => new Error("Fetching default tutorial items failed"));
		} else {
			let json = await fetch(document.location.origin + `/tutorial/01-basics/01-introduction/layout.json`).then(r => r.json());
			set_store_value(items$1, $items = json.map(item => hydrateJSONcomponent$1(item)), $items);

			for (const item of $items) {
				await updateItemPropsWithFetchedValues(item);
				await populateCommonStoresWithFetchedProps(item);
				updateItemPropsWithCommonStoreValues(item);
			}
		}
	};

	let fetchAndLoadDocsNavLinks = async () => {
		const res1 = await fetch(document.location.origin + `/docs/docsnew.json`);
		const json = await res1.json();

		if (res1.ok) {
			let tmpLinks = json;
			let tmpChosenDocs = tmpLinks[0].path;

			for (let i = 0; i < tmpLinks.length; i++) {
				let currentHeadings = [];

				if (tmpLinks[i].file != undefined) {
					// There is a call with undefined value when navigating to Playground
					const res = await fetch(document.location.origin + `/docs/${tmpLinks[i].file}.md`);

					const text = await res.text();

					if (res.ok) {
						//get tokens from the marked lexer
						let tokens = marked.lexer(text);

						//loop through them
						for (let i = 0; i < tokens.length; i++) {
							if (tokens[i].type == "heading" && tokens[i].depth == 1) {
								let heading = tokens[i].text;

								currentHeadings.push({
									heading,
									route: heading.replace(/\s+/g, "-").toLowerCase(),
									active: false
								});
							}
						}

						tmpLinks[i].subs = currentHeadings;
					} else {
						throw new Error(text);
					}
				}
			}

			console.log("tmpLinks", tmpLinks);
			set_store_value(links, $links = tmpLinks, $links);
			set_store_value(chosenDocs, $chosenDocs = tmpChosenDocs, $chosenDocs);
		}
	};

	onMount(async () => {
		console.log("DEBUG:routes/_layout:onMount");

		// console.log($params);
		// If application loads from index page, entry is through here
		// otherwise, it loads first from playground/index or tutorial/_layout
		// so no need to re-initialise controller here
		if (!controller.initializing && !controller.samplesLoaded) await controller.init(document.location.origin + "/sema-engine");
	});

	$$self.$$set = $$props => {
		if ("$$scope" in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*engine*/ 2) {
			 document.addEventListener("keydown", e => {
				if (e.code === "Period" && (e.ctrlKey || e.metaKey)) {
					if (!engine && !engine.isHushed) $$invalidate(1, engine = new Engine());
					engine.hush();
					set_store_value(engineStatus, $engineStatus = "paused", $engineStatus);
				}
			});
		}

		if ($$self.$$.dirty & /*$params*/ 4) {
			// update url parameters only when navigating tutorials
			 if ($params.chapter && $params.section) ;
		}
	};

	 loadSidebarLiveCodeOptions();
	 loadEnvironmentSnapshotEntries();
	 fetchAndLoadDefaultTutorial();
	 fetchAndLoadDefaultTutorialItems();
	 fetchAndLoadDocsNavLinks(); //preload nav links for documentation (reference)
	return [$siteMode, engine, $params, $$scope, slots];
}

class Layout$5 extends SvelteComponent {
	constructor(options) {
		super();
		if (!document_1$9.getElementById("svelte-ni42rv-style")) add_css$W();
		init(this, options, instance$14, create_fragment$16, safe_not_equal, {});
	}
}

//tree
const _tree = {
  "name": "_layout",
  "filepath": "/_layout.svelte",
  "root": true,
  "ownMeta": {},
  "absolutePath": "/Users/francisco/Documents/dev/MIMIC/sema/src/pages/_layout.svelte",
  "children": [
    {
      "isFile": true,
      "isDir": false,
      "file": "_fallback.svelte",
      "filepath": "/_fallback.svelte",
      "name": "_fallback",
      "ext": "svelte",
      "badExt": false,
      "absolutePath": "/Users/francisco/Documents/dev/MIMIC/sema/src/pages/_fallback.svelte",
      "importPath": "../src/pages/_fallback.svelte",
      "isLayout": false,
      "isReset": false,
      "isIndex": false,
      "isFallback": true,
      "isPage": false,
      "ownMeta": {},
      "meta": {
        "recursive": true,
        "preload": false,
        "prerender": true
      },
      "path": "/_fallback",
      "id": "__fallback",
      "component": () => Fallback
    },
    {
      "isFile": false,
      "isDir": true,
      "file": "about",
      "filepath": "/about",
      "name": "about",
      "ext": "",
      "badExt": false,
      "absolutePath": "/Users/francisco/Documents/dev/MIMIC/sema/src/pages/about",
      "children": [
        {
          "isFile": true,
          "isDir": false,
          "file": "index.svelte",
          "filepath": "/about/index.svelte",
          "name": "index",
          "ext": "svelte",
          "badExt": false,
          "absolutePath": "/Users/francisco/Documents/dev/MIMIC/sema/src/pages/about/index.svelte",
          "importPath": "../src/pages/about/index.svelte",
          "isLayout": false,
          "isReset": false,
          "isIndex": true,
          "isFallback": false,
          "isPage": true,
          "ownMeta": {},
          "meta": {
            "recursive": true,
            "preload": false,
            "prerender": true
          },
          "path": "/about/index",
          "id": "_about_index",
          "component": () => About
        }
      ],
      "isLayout": false,
      "isReset": false,
      "isIndex": false,
      "isFallback": false,
      "isPage": false,
      "ownMeta": {},
      "meta": {
        "recursive": true,
        "preload": false,
        "prerender": true
      },
      "path": "/about"
    },
    {
      "isFile": true,
      "isDir": true,
      "file": "_layout.svelte",
      "filepath": "/admin/_layout.svelte",
      "name": "_layout",
      "ext": "svelte",
      "badExt": false,
      "absolutePath": "/Users/francisco/Documents/dev/MIMIC/sema/src/pages/admin/_layout.svelte",
      "children": [
        {
          "isFile": true,
          "isDir": false,
          "file": "index.svelte",
          "filepath": "/admin/index.svelte",
          "name": "index",
          "ext": "svelte",
          "badExt": false,
          "absolutePath": "/Users/francisco/Documents/dev/MIMIC/sema/src/pages/admin/index.svelte",
          "importPath": "../src/pages/admin/index.svelte",
          "isLayout": false,
          "isReset": false,
          "isIndex": true,
          "isFallback": false,
          "isPage": true,
          "ownMeta": {},
          "meta": {
            "recursive": true,
            "preload": false,
            "prerender": true
          },
          "path": "/admin/index",
          "id": "_admin_index",
          "component": () => Admin
        }
      ],
      "isLayout": true,
      "isReset": false,
      "isIndex": false,
      "isFallback": false,
      "isPage": false,
      "importPath": "../src/pages/admin/_layout.svelte",
      "ownMeta": {},
      "meta": {
        "recursive": true,
        "preload": false,
        "prerender": true
      },
      "path": "/admin",
      "id": "_admin__layout",
      "component": () => Layout
    },
    {
      "isFile": true,
      "isDir": true,
      "file": "_layout.svelte",
      "filepath": "/docs/_layout.svelte",
      "name": "_layout",
      "ext": "svelte",
      "badExt": false,
      "absolutePath": "/Users/francisco/Documents/dev/MIMIC/sema/src/pages/docs/_layout.svelte",
      "children": [
        {
          "isFile": true,
          "isDir": true,
          "file": "_layout.svelte",
          "filepath": "/docs/[docId]/_layout.svelte",
          "name": "_layout",
          "ext": "svelte",
          "badExt": false,
          "absolutePath": "/Users/francisco/Documents/dev/MIMIC/sema/src/pages/docs/[docId]/_layout.svelte",
          "children": [
            {
              "isFile": true,
              "isDir": false,
              "file": "index.svelte",
              "filepath": "/docs/[docId]/index.svelte",
              "name": "index",
              "ext": "svelte",
              "badExt": false,
              "absolutePath": "/Users/francisco/Documents/dev/MIMIC/sema/src/pages/docs/[docId]/index.svelte",
              "importPath": "../src/pages/docs/[docId]/index.svelte",
              "isLayout": false,
              "isReset": false,
              "isIndex": true,
              "isFallback": false,
              "isPage": true,
              "ownMeta": {},
              "meta": {
                "recursive": true,
                "preload": false,
                "prerender": true
              },
              "path": "/docs/:docId/index",
              "id": "_docs__docId_index",
              "component": () => U5BdocIdu5D
            }
          ],
          "isLayout": true,
          "isReset": false,
          "isIndex": false,
          "isFallback": false,
          "isPage": false,
          "importPath": "../src/pages/docs/[docId]/_layout.svelte",
          "ownMeta": {},
          "meta": {
            "recursive": true,
            "preload": false,
            "prerender": true
          },
          "path": "/docs/:docId",
          "id": "_docs__docId__layout",
          "component": () => Layout$1
        },
        {
          "isFile": true,
          "isDir": false,
          "file": "CollapsibleSection.svelte",
          "filepath": "/docs/CollapsibleSection.svelte",
          "name": "CollapsibleSection",
          "ext": "svelte",
          "badExt": false,
          "absolutePath": "/Users/francisco/Documents/dev/MIMIC/sema/src/pages/docs/CollapsibleSection.svelte",
          "importPath": "../src/pages/docs/CollapsibleSection.svelte",
          "isLayout": false,
          "isReset": false,
          "isIndex": false,
          "isFallback": false,
          "isPage": true,
          "ownMeta": {},
          "meta": {
            "recursive": true,
            "preload": false,
            "prerender": true
          },
          "path": "/docs/CollapsibleSection",
          "id": "_docs_CollapsibleSection",
          "component": () => CollapsibleSection
        },
        {
          "isFile": true,
          "isDir": false,
          "file": "index.svelte",
          "filepath": "/docs/index.svelte",
          "name": "index",
          "ext": "svelte",
          "badExt": false,
          "absolutePath": "/Users/francisco/Documents/dev/MIMIC/sema/src/pages/docs/index.svelte",
          "importPath": "../src/pages/docs/index.svelte",
          "isLayout": false,
          "isReset": false,
          "isIndex": true,
          "isFallback": false,
          "isPage": true,
          "ownMeta": {},
          "meta": {
            "recursive": true,
            "preload": false,
            "prerender": true
          },
          "path": "/docs/index",
          "id": "_docs_index",
          "component": () => Docs
        },
        {
          "isFile": true,
          "isDir": false,
          "file": "sidebar-menu.svelte",
          "filepath": "/docs/sidebar-menu.svelte",
          "name": "sidebar-menu",
          "ext": "svelte",
          "badExt": false,
          "absolutePath": "/Users/francisco/Documents/dev/MIMIC/sema/src/pages/docs/sidebar-menu.svelte",
          "importPath": "../src/pages/docs/sidebar-menu.svelte",
          "isLayout": false,
          "isReset": false,
          "isIndex": false,
          "isFallback": false,
          "isPage": true,
          "ownMeta": {},
          "meta": {
            "recursive": true,
            "preload": false,
            "prerender": true
          },
          "path": "/docs/sidebar-menu",
          "id": "_docs_sidebarMenu",
          "component": () => Sidebar_menu
        }
      ],
      "isLayout": true,
      "isReset": false,
      "isIndex": false,
      "isFallback": false,
      "isPage": false,
      "importPath": "../src/pages/docs/_layout.svelte",
      "ownMeta": {},
      "meta": {
        "recursive": true,
        "preload": false,
        "prerender": true
      },
      "path": "/docs",
      "id": "_docs__layout",
      "component": () => Layout$2
    },
    {
      "isFile": true,
      "isDir": false,
      "file": "index.svelte",
      "filepath": "/index.svelte",
      "name": "index",
      "ext": "svelte",
      "badExt": false,
      "absolutePath": "/Users/francisco/Documents/dev/MIMIC/sema/src/pages/index.svelte",
      "importPath": "../src/pages/index.svelte",
      "isLayout": false,
      "isReset": false,
      "isIndex": true,
      "isFallback": false,
      "isPage": true,
      "ownMeta": {},
      "meta": {
        "recursive": true,
        "preload": false,
        "prerender": true
      },
      "path": "/index",
      "id": "_index",
      "component": () => Pages
    },
    {
      "isFile": true,
      "isDir": true,
      "file": "_layout.svelte",
      "filepath": "/login/_layout.svelte",
      "name": "_layout",
      "ext": "svelte",
      "badExt": false,
      "absolutePath": "/Users/francisco/Documents/dev/MIMIC/sema/src/pages/login/_layout.svelte",
      "children": [
        {
          "isFile": true,
          "isDir": false,
          "file": "index.svelte",
          "filepath": "/login/index.svelte",
          "name": "index",
          "ext": "svelte",
          "badExt": false,
          "absolutePath": "/Users/francisco/Documents/dev/MIMIC/sema/src/pages/login/index.svelte",
          "importPath": "../src/pages/login/index.svelte",
          "isLayout": false,
          "isReset": false,
          "isIndex": true,
          "isFallback": false,
          "isPage": true,
          "ownMeta": {},
          "meta": {
            "recursive": true,
            "preload": false,
            "prerender": true
          },
          "path": "/login/index",
          "id": "_login_index",
          "component": () => Login
        }
      ],
      "isLayout": true,
      "isReset": false,
      "isIndex": false,
      "isFallback": false,
      "isPage": false,
      "importPath": "../src/pages/login/_layout.svelte",
      "ownMeta": {},
      "meta": {
        "recursive": true,
        "preload": false,
        "prerender": true
      },
      "path": "/login",
      "id": "_login__layout",
      "component": () => Layout$3
    },
    {
      "isFile": false,
      "isDir": true,
      "file": "playground",
      "filepath": "/playground",
      "name": "playground",
      "ext": "",
      "badExt": false,
      "absolutePath": "/Users/francisco/Documents/dev/MIMIC/sema/src/pages/playground",
      "children": [
        {
          "isFile": true,
          "isDir": false,
          "file": "index.svelte",
          "filepath": "/playground/index.svelte",
          "name": "index",
          "ext": "svelte",
          "badExt": false,
          "absolutePath": "/Users/francisco/Documents/dev/MIMIC/sema/src/pages/playground/index.svelte",
          "importPath": "../src/pages/playground/index.svelte",
          "isLayout": false,
          "isReset": false,
          "isIndex": true,
          "isFallback": false,
          "isPage": true,
          "ownMeta": {},
          "meta": {
            "recursive": true,
            "preload": false,
            "prerender": true
          },
          "path": "/playground/index",
          "id": "_playground_index",
          "component": () => Playground
        }
      ],
      "isLayout": false,
      "isReset": false,
      "isIndex": false,
      "isFallback": false,
      "isPage": false,
      "ownMeta": {},
      "meta": {
        "recursive": true,
        "preload": false,
        "prerender": true
      },
      "path": "/playground"
    },
    {
      "isFile": false,
      "isDir": true,
      "file": "samples",
      "filepath": "/samples",
      "name": "samples",
      "ext": "",
      "badExt": false,
      "absolutePath": "/Users/francisco/Documents/dev/MIMIC/sema/src/pages/samples",
      "children": [
        {
          "isFile": true,
          "isDir": false,
          "file": "index.svelte",
          "filepath": "/samples/index.svelte",
          "name": "index",
          "ext": "svelte",
          "badExt": false,
          "absolutePath": "/Users/francisco/Documents/dev/MIMIC/sema/src/pages/samples/index.svelte",
          "importPath": "../src/pages/samples/index.svelte",
          "isLayout": false,
          "isReset": false,
          "isIndex": true,
          "isFallback": false,
          "isPage": true,
          "ownMeta": {},
          "meta": {
            "recursive": true,
            "preload": false,
            "prerender": true
          },
          "path": "/samples/index",
          "id": "_samples_index",
          "component": () => Samples
        }
      ],
      "isLayout": false,
      "isReset": false,
      "isIndex": false,
      "isFallback": false,
      "isPage": false,
      "ownMeta": {},
      "meta": {
        "recursive": true,
        "preload": false,
        "prerender": true
      },
      "path": "/samples"
    },
    {
      "isFile": true,
      "isDir": true,
      "file": "_layout.svelte",
      "filepath": "/tutorial/_layout.svelte",
      "name": "_layout",
      "ext": "svelte",
      "badExt": false,
      "absolutePath": "/Users/francisco/Documents/dev/MIMIC/sema/src/pages/tutorial/_layout.svelte",
      "children": [
        {
          "isFile": false,
          "isDir": true,
          "file": "[chapter]",
          "filepath": "/tutorial/[chapter]",
          "name": "[chapter]",
          "ext": "",
          "badExt": false,
          "absolutePath": "/Users/francisco/Documents/dev/MIMIC/sema/src/pages/tutorial/[chapter]",
          "children": [
            {
              "isFile": false,
              "isDir": true,
              "file": "[section]",
              "filepath": "/tutorial/[chapter]/[section]",
              "name": "[section]",
              "ext": "",
              "badExt": false,
              "absolutePath": "/Users/francisco/Documents/dev/MIMIC/sema/src/pages/tutorial/[chapter]/[section]",
              "children": [
                {
                  "isFile": true,
                  "isDir": false,
                  "file": "index.svelte",
                  "filepath": "/tutorial/[chapter]/[section]/index.svelte",
                  "name": "index",
                  "ext": "svelte",
                  "badExt": false,
                  "absolutePath": "/Users/francisco/Documents/dev/MIMIC/sema/src/pages/tutorial/[chapter]/[section]/index.svelte",
                  "importPath": "../src/pages/tutorial/[chapter]/[section]/index.svelte",
                  "isLayout": false,
                  "isReset": false,
                  "isIndex": true,
                  "isFallback": false,
                  "isPage": true,
                  "ownMeta": {},
                  "meta": {
                    "recursive": true,
                    "preload": false,
                    "prerender": true
                  },
                  "path": "/tutorial/:chapter/:section/index",
                  "id": "_tutorial__chapter__section_index",
                  "component": () => U5Bsectionu5D
                }
              ],
              "isLayout": false,
              "isReset": false,
              "isIndex": false,
              "isFallback": false,
              "isPage": false,
              "ownMeta": {},
              "meta": {
                "recursive": true,
                "preload": false,
                "prerender": true
              },
              "path": "/tutorial/:chapter/:section"
            }
          ],
          "isLayout": false,
          "isReset": false,
          "isIndex": false,
          "isFallback": false,
          "isPage": false,
          "ownMeta": {},
          "meta": {
            "recursive": true,
            "preload": false,
            "prerender": true
          },
          "path": "/tutorial/:chapter"
        },
        {
          "isFile": true,
          "isDir": false,
          "file": "index.svelte",
          "filepath": "/tutorial/index.svelte",
          "name": "index",
          "ext": "svelte",
          "badExt": false,
          "absolutePath": "/Users/francisco/Documents/dev/MIMIC/sema/src/pages/tutorial/index.svelte",
          "importPath": "../src/pages/tutorial/index.svelte",
          "isLayout": false,
          "isReset": false,
          "isIndex": true,
          "isFallback": false,
          "isPage": true,
          "ownMeta": {},
          "meta": {
            "recursive": true,
            "preload": false,
            "prerender": true
          },
          "path": "/tutorial/index",
          "id": "_tutorial_index",
          "component": () => Tutorial
        }
      ],
      "isLayout": true,
      "isReset": false,
      "isIndex": false,
      "isFallback": false,
      "isPage": false,
      "importPath": "../src/pages/tutorial/_layout.svelte",
      "ownMeta": {},
      "meta": {
        "recursive": true,
        "preload": false,
        "prerender": true
      },
      "path": "/tutorial",
      "id": "_tutorial__layout",
      "component": () => Layout$4
    }
  ],
  "isLayout": true,
  "isReset": false,
  "isIndex": false,
  "isFallback": false,
  "isPage": false,
  "isFile": true,
  "file": "_layout.svelte",
  "ext": "svelte",
  "badExt": false,
  "importPath": "../src/pages/_layout.svelte",
  "meta": {
    "recursive": true,
    "preload": false,
    "prerender": true
  },
  "path": "/",
  "id": "__layout",
  "component": () => Layout$5
};


const {tree, routes: routes$1} = buildClientTree(_tree);

/* src/App.svelte generated by Svelte v3.31.0 */

const { document: document_1$a } = globals;

function add_css$X() {
	var style = element("style");
	style.id = "svelte-1s743jr-style";
	style.textContent = "body{padding:0;margin:0;overflow:hidden}#routify-app{height:100%;overflow:hidden}.app{display:grid;grid-template-rows:auto 1fr auto;min-height:100vh}.app>main{background-attachment:fixed;background-size:cover}nav{display:grid;grid-template-columns:1fr minmax(max-content, 1fr) 1fr;justify-content:space-evenly}nav :last-child{text-align:right}nav :nth-child(2){text-align:center}nav>*{white-space:nowrap}nav a,nav a:visited{display:inline-block;padding:12px;padding-left:calc(2vw);padding-right:calc(2vw)}nav img[alt^='profile - ']{border-radius:100%;width:32px;vertical-align:middle}footer{position:absolute;bottom:8px;right:16px}header{box-shadow:0 4px 8px rgba(0, 0s, 0, 0.5);border-bottom:1px solid #000}.admin-module{min-height:100%;display:grid;background-color:#ff7700;background-image:url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1600 900'%3E%3Cpolygon fill='%23cc0000' points='957 450 539 900 1396 900'/%3E%3Cpolygon fill='%23aa0000' points='957 450 872.9 900 1396 900'/%3E%3Cpolygon fill='%23d6002b' points='-60 900 398 662 816 900'/%3E%3Cpolygon fill='%23b10022' points='337 900 398 662 816 900'/%3E%3Cpolygon fill='%23d9004b' points='1203 546 1552 900 876 900'/%3E%3Cpolygon fill='%23b2003d' points='1203 546 1552 900 1162 900'/%3E%3Cpolygon fill='%23d3006c' points='641 695 886 900 367 900'/%3E%3Cpolygon fill='%23ac0057' points='587 900 641 695 886 900'/%3E%3Cpolygon fill='%23c4008c' points='1710 900 1401 632 1096 900'/%3E%3Cpolygon fill='%239e0071' points='1710 900 1401 632 1365 900'/%3E%3Cpolygon fill='%23aa00aa' points='1210 900 971 687 725 900'/%3E%3Cpolygon fill='%23880088' points='943 900 1210 900 971 687'/%3E%3C/svg%3E\");background-attachment:fixed;background-size:cover}.admin-module.not-authed{background-color:#808080;background-image:url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1600 900'%3E%3Cpolygon fill='%23666666' points='957 450 539 900 1396 900'/%3E%3Cpolygon fill='%23545454' points='957 450 872.9 900 1396 900'/%3E%3Cpolygon fill='%23636363' points='-60 900 398 662 816 900'/%3E%3Cpolygon fill='%23515151' points='337 900 398 662 816 900'/%3E%3Cpolygon fill='%23606060' points='1203 546 1552 900 876 900'/%3E%3Cpolygon fill='%234e4e4e' points='1203 546 1552 900 1162 900'/%3E%3Cpolygon fill='%235d5d5d' points='641 695 886 900 367 900'/%3E%3Cpolygon fill='%234b4b4b' points='587 900 641 695 886 900'/%3E%3Cpolygon fill='%235a5a5a' points='1710 900 1401 632 1096 900'/%3E%3Cpolygon fill='%23484848' points='1710 900 1401 632 1365 900'/%3E%3Cpolygon fill='%23575757' points='1210 900 971 687 725 900'/%3E%3Cpolygon fill='%23454545' points='943 900 1210 900 971 687'/%3E%3C/svg%3E\")}.card{padding:24px 48px;border-radius:4px;box-shadow:0 4px 16px rgba(0, 0, 0, 0.2)}.button{background:#333;margin-top:32px;padding:16px 24px;outline:none;border:none;box-shadow:none;font-weight:bold}.center-all{min-height:100%;height:100%;width:100%;display:grid}html,body{position:relative;width:100%;height:100%;overflow:hidden}body{margin:0;box-sizing:border-box;font-size:large;user-select:text;font-family:-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Oxygen-Sans, Ubuntu, Cantarell, \"Helvetica Neue\", sans-serif}a{color:#2981fb;text-decoration:none}a:hover{text-decoration:underline}label{display:block}input,button,select{font-family:inherit;font-size:inherit;padding:0.4em;margin:0.25em 0 0.2em 0;box-sizing:border-box;border:1px solid #ccc;border-radius:2px}textarea{letter-spacing:normal;word-spacing:normal;text-transform:none;text-indent:0px;text-shadow:none;display:inline-block;text-align:start;appearance:auto;background-color:rgb(59, 59, 59);-webkit-rtl-ordering:logical;flex-direction:column;resize:none;cursor:text;white-space:pre-wrap;overflow-wrap:break-word;column-count:initial !important;margin:0em}code{border-radius:4px;font-size:100%;background-color:white;color:black;padding:2px 4px 2px 4px;border:1px solid #CCCCCC}pre code{display:block;border-radius:4px;font-size:90%;background-color:white;color:black;padding:5px;border:1px solid #CCCCCC;margin:0px 0px 0px 0px}input:disabled{color:#ccc}input[type=\"range\"]{height:0}button{color:#333;background-color:#f4f4f4;outline:none}button:disabled{color:#999}button:not(:disabled):active{background-color:#ddd}button:focus{border-color:#666}";
	append(document_1$a.head, style);
}

function create_fragment$17(ctx) {
	let router;
	let current;
	router = new Router({ props: { routes: routes$1 } });

	return {
		c() {
			create_component(router.$$.fragment);
		},
		m(target, anchor) {
			mount_component(router, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(router.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(router.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(router, detaching);
		}
	};
}

function instance$15($$self) {
	let messaging = new PubSub();

	// we need to queue our init till after Routify has been initialized
	setTimeout(() => window.routify.inBrowser && init$2());

	// $unsupportedBrowser
	let unsupportedBrowser, controller, engine;

	/**
 * This async IIFE tests the browser in which Sema is loading for WAAPI Audio Worklet support
 * It either succeeds and dynamically imports the sema-engine OR fails graciously
 * * This is invoked even if load happens through Playground or Tutorial via client side routing
 * */
	(async () => {
		// Detect Firefox early otherwise audio engine needs to be initialised for a fail to be detected [Firefox fix]
		// if (/firefox/i.test(navigator.userAgent)){
		//   console.error('Firefox detected: unsupported browser')
		//   unsupportedBrowser = true;
		// }
		// else {
		// Need a dynamic import to prevent the AudioWorkletNode inside the audioEngine module from loading [Safari fix]
		Promise.resolve().then(function () { return index; }).then(module => {
			// Apply in Inversion of Control with constructor injection
			engine = new module.Engine();

			controller = new Controller(engine); // Init need to be deferred to Playground or tutorial after User Action
		}).catch(err => unsupportedBrowser = true);
	})(); // }

	function onMouseMove(e) {
		messaging.publish("mouse-xy", [e.clientX / window.innerWidth, e.clientY / window.innerHeight]);
	}

	document.addEventListener("mousemove", onMouseMove);
	return [];
}

class App extends SvelteComponent {
	constructor(options) {
		super();
		if (!document_1$a.getElementById("svelte-1s743jr-style")) add_css$X();
		init(this, options, instance$15, create_fragment$17, safe_not_equal, {});
	}
}

const app = HMR(App, { target: document.body }, 'routify-app');

/** Service worker. Uncomment to use service worker */

// if ('serviceWorker' in navigator) {
//     import('workbox-window').then(async ({ Workbox }) => {
//         const wb = new Workbox('/sw.js')
//         const registration = await wb.register()
//         wb.addEventListener('installed', () => (console.log('installed service worker')))
//         wb.addEventListener('externalinstalled', () => (console.log('installed service worker')))
//     })
// }

export { commonjsGlobal as a, createCommonjsModule as c };
//# sourceMappingURL=main.js.map
